# coding:utf-8"""create on Feb 23, 2020 by Wayne YUFunction:将高总国内AS互联数据加到Caida库上，通过绘制AS Core Map图，比较国内AS网络地位的变化情况 - - - - -2"""import timeimport csvimport numpy as npimport matplotlib.pyplot as pltdef write_to_csv(res_list, des_path):    """    把给定的List，写到指定路径的文件中    :param res_list:    :param des_path:    :return: None    """    print("write file <%s> ..." % des_path)    csvFile = open(des_path, 'w', newline='', encoding='utf-8')    try:        writer = csv.writer(csvFile, delimiter="|")        for i in res_list:            writer.writerow(i)    except Exception as e:        print(e)    finally:        csvFile.close()    print("write finish!")def compute_polar_args(as_info):    """    根据传入的as_info,计算每个as号的参数angle、radius    angle = longitue of the AS's orgs    radius = 1 - log((All_rel(AS)+1) / (maxinum_all_rel + 1))    :param as_info:    :return new_as_info:    """    new_as_info = []    max_all_rel = 0  # 存储最大的连接数    for item in as_info:        # print(item)        if int(item[1]) > max_all_rel:            max_all_rel = int(item[1])    print("Max Edge Cnt:", max_all_rel)    for item in as_info:        angle = 0.0        radius = 0.0        if float(item[10]) >= 0.0:            angle = float(item[10])        else:            angle = float(item[10]) + 360.0        radius = 1 - np.log((int(item[1]) + 1) / (max_all_rel + 1))        item.append(angle)        item.append(radius)        new_as_info.append(item)        # print(item)    return new_as_infodef draw_polar_map(as_info, open_file, year_str):    """    根据传入的as_info进行绘图    :param as_info:    :param open_file:    :param year_str:    :return None:    """    # #########################关键参数生成##################################    max_radius = 0.0    min_radius = 10000.0    min_index = 0    angle_list = []    radius_list = []    coordinate_dic = {}    temp_list = []    item_cnt = 0    for item in as_info:        # print(item)        if float(item[12]) > max_radius:            max_radius = float(item[12])        if float(item[12]) < min_radius:            min_radius = float(item[12])            min_index = item_cnt        angle = (float(item[11]) / 360.0) * 2 * np.pi        radius = float(float(item[12]))        temp_list.append(angle)        temp_list.append(radius)        angle_list.append(angle)        radius_list.append(radius)        coordinate_dic[item[0]] = temp_list        temp_list = []        item_cnt += 1    # print(coordinate_dic)    # 准备绘图    plt.figure(figsize=(9, 5))    ax = plt.subplot(111, projection='polar')    ax.set_ylim(0.0, max_radius + 2)  # 设置极坐标半径radius的最大刻度    # #########################绘画参数生成##################################    area_list = []    lw_list = []    c_color_list = []    z_order_list = []    max_index = []    cn_index = []    cn_all_as = []  # 存储所有中国AS号    global_all_as = []  # 所有世界所有AS号    index_cnt = 0    for item in radius_list:        if item < max_radius * 0.2:            area_list.append(12)            lw_list.append(0.1)            c_color_list.append([float(200/256), float(100/256), float(100/256)])            z_order_list.append(2)            max_index.append(index_cnt)  # 记录最牛逼的几个点的坐标            if as_info[index_cnt][8] == "CN":                cn_index.append(index_cnt)        elif item < max_radius * 0.4:            area_list.append(8)            lw_list.append(0.1)            c_color_list.append([float(224.0/256), float(200.0/256), float(41.0/256)])            z_order_list.append(2)            if as_info[index_cnt][8] == "CN":                cn_index.append(index_cnt)        elif item < max_radius * 0.6:            area_list.append(3)            lw_list.append(0.1)            c_color_list.append([float(100/256), float(100/256), float(200/256)])            z_order_list.append(2)            if as_info[index_cnt][8] == "CN":                cn_index.append(index_cnt)        else:            area_list.append(2)            lw_list.append(0.1)            c_color_list.append([float(256/256), float(256/256), float(256/256)])            z_order_list.append(1)        # 如果该点为中国，则改变其填充颜色,改变其Marker，并存储        if as_info[index_cnt][8] == "CN":            cn_all_as.append(as_info[index_cnt])  # 存储所有的中国AS号            del c_color_list[-1]            c_color_list.append([float(100.0/256), float(200.0/256), float(100.0/256)])        # 存储实世界所有AS号        global_all_as.append(as_info[index_cnt])        index_cnt += 1    area = area_list    print("CN all AS Length:", len(cn_all_as))    cn_all_as.sort(reverse=True, key=lambda elem: int(elem[1]))    print("Global All AS Length:", len(global_all_as))    global_all_as.sort(reverse=True, key=lambda  elem: int(elem[1]))    # ###########################画线################################    edges_cnt = 0    file_read = open(open_file, 'r', encoding='utf-8')    for line in file_read.readlines():        if line.strip().find("#") == 0:            continue        line = line.strip().split("|")        p1 = coordinate_dic.get(line[0])        p2 = coordinate_dic.get(line[1])        if p1 and p2:            z_order_value = 1            line_width = 0.05            alpha_value = 1            if p1[1] < max_radius * 0.2 and p2[1] < max_radius * 0.2:                line_width = 0.4                line_color = [float(230/256), float(51/256), float(51/256)]                alpha_value = 1                z_order_value = 6            elif p1[1] < max_radius * 0.4 and p2[1] < max_radius * 0.4:                line_width = 0.2                line_color = [float(102/256), float(102/256), float(200/256)]                alpha_value = 0.7                z_order_value = 4            elif p1[1] < max_radius * 0.6 and p2[1] < max_radius * 0.6:                line_width = 0.1                line_color = [float(128/256), float(128/256), float(240/256)]                alpha_value = 0.5                z_order_value = 2            else:                line_width = 0.02                line_color = [float(20/256), float(250/256), float(250/256)]                z_order_value = 1            # print("computing:", p1, p2)            ax.plot([p1[0], p2[0]], [p1[1], p2[1]], linewidth=line_width, alpha=alpha_value, color=line_color, zorder=z_order_value, )            edges_cnt += 1    # ######################## 打点######################################    c = ax.scatter(angle_list, radius_list, c=c_color_list, edgecolors=[0, 0, 0], marker="o", lw=lw_list, s=area, cmap='hsv', alpha=0.9, zorder=7)    # c = ax.scatter(angle_list, radius_list, c=colors, marker='s', s=area, cmap='hsv', alpha=1)    # ########################绘制外围辅助性图标##########################    # 画个内圆    circle_theta = np.arange(0, 2*np.pi, 0.01)    circle_radius = [max_radius + 0.1] * len(circle_theta)    # print(circle_theta)    # print(circle_radius)    ax.plot(circle_theta, circle_radius, color=[1, 1, 1], linewidth=0.2)    # 画个外圆1    circle_theta = np.arange(0, 2*np.pi, 0.01)    circle_radius = [max_radius + 0.3] * len(circle_theta)    # print(circle_theta)    # print(circle_radius)    ax.plot(circle_theta, circle_radius, color=[1, 1, 1], linewidth=0.2)    # 画外圆2    circle_theta = np.arange(0, 2*np.pi, 0.01)    circle_radius = [max_radius + 0.5] * len(circle_theta)    # print(circle_theta)    # print(circle_radius)    ax.plot(circle_theta, circle_radius, color=[1, 1, 1], linewidth=0.2)    # 画外圆3    circle_theta = np.arange(0, 2*np.pi, 0.01)    circle_radius = [max_radius + 0.6] * len(circle_theta)    # print(circle_theta)    # print(circle_radius)    ax.plot(circle_theta, circle_radius, color=[1, 1, 1], linewidth=0.2)    # 填充欧洲（Europe）颜色为#bd87bf，从西经14度至东经49度，即346-49    circle_theta = np.arange(float(346.0/360)*2*np.pi, float(360/360)*2*np.pi, 0.01)    circle_radius = [max_radius + 0.2] * len(circle_theta)    ax.plot(circle_theta, circle_radius, color="#bd87bf", linewidth=3)    circle_theta = np.arange(float(0.0/360)*2*np.pi, float(49/360)*2*np.pi, 0.01)    circle_radius = [max_radius + 0.2] * len(circle_theta)    ax.plot(circle_theta, circle_radius, color="#bd87bf", linewidth=3)    # 填充亚洲（Asia）颜色为#00a895,从东经49度至西经175，即49-185    circle_theta = np.arange(float(49.0/360)*2*np.pi, float(185/360)*2*np.pi, 0.01)    circle_radius = [max_radius + 0.2] * len(circle_theta)    ax.plot(circle_theta, circle_radius, color="#00a895", linewidth=3)    # 填充北美洲（North American）颜色为#669ed8，从西经170度至西经20度，即190-340    circle_theta = np.arange(float(190.0/360) * 2 * np.pi, float(340/360) * 2 * np.pi, 0.01)    circle_radius = [max_radius + 0.2] * len(circle_theta)    ax.plot(circle_theta, circle_radius, color="#669ed8", linewidth=3)    # 填充非洲（Africa）颜色为#b680c3，从西经14度至东经52度，即346-52    circle_theta = np.arange(float(346.0/360) * 2 * np.pi, float(360/360) * 2 * np.pi, 0.01)    circle_radius = [max_radius + 0.4] * len(circle_theta)    ax.plot(circle_theta, circle_radius, color="#f3c828", linewidth=3)    circle_theta = np.arange(float(0.0/360) * 2 * np.pi, float(52/360) * 2 * np.pi, 0.01)    circle_radius = [max_radius + 0.4] * len(circle_theta)    ax.plot(circle_theta, circle_radius, color="#f3c828", linewidth=3)    # 填充大洋洲(Oceana)，颜色为#fec273，从东经110度至东经180度，即110-180    circle_theta = np.arange(float(110/360) * 2 * np.pi, float(180/360) * 2 * np.pi, 0.01)    circle_radius = [max_radius + 0.4] * len(circle_theta)    ax.plot(circle_theta, circle_radius, color="#fec273", linewidth=3)    # 填充南美洲（South American），颜色为#f2c41d，从西经80度至西经40度，即280-320    circle_theta = np.arange(float(280/360) * 2 * np.pi, float(320/360) * 2 * np.pi, 0.01)    circle_radius = [max_radius + 0.4] * len(circle_theta)    ax.plot(circle_theta, circle_radius, color="#f2c41d", linewidth=3)    # 绘制经度刻度    # circle_radius = np.arange(max_radius+0.5, max_radius+0.9, 0.01)    # circle_theta = [0.0] * len(circle_radius)    # ax.plot(circle_theta, circle_radius, color=[0, 0, 0], linewidth=0.8)    # 每隔10度画一个    for tap_zone in range(0, 36, 1):        time_zone_angle = tap_zone * 10        circle_radius = np.arange(max_radius + 0.55, max_radius + 0.8, 0.01)        circle_theta = [float(time_zone_angle / 360)*2*np.pi] * len(circle_radius)        ax.plot(circle_theta, circle_radius, color=[1, 1, 1], linewidth=0.3)    # 每隔90度画一个    for tap_zone in range(0, 4, 1):        time_zone_angle = tap_zone * 90        circle_radius = np.arange(max_radius + 0.55, max_radius + 0.9, 0.01)        circle_theta = [float(time_zone_angle / 360)*2*np.pi] * len(circle_radius)        ax.plot(circle_theta, circle_radius, color=[1, 1, 1], linewidth=1)    # 添加关键城市和地区的文本信息    # 一般字体统一用一个字典控制    font = {'family': 'serif',            'style': 'italic',            'weight': 'normal',            'color': 'white',            'size': 4            }    text_theta = 0.0    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "London, UK", fontdict=font,  ha='left', va='center', rotation=0)    text_theta = float(5.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Paris, FR", fontdict=font, ha='left',  va='bottom', rotation=5)    text_theta = float(9.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Frankfurt, DE", fontdict=font, ha='left',  va='bottom', rotation=9)    text_theta = float(15.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Berlin, DE", fontdict=font, ha='left',  va='bottom', rotation=15)    text_theta = float(27.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Helsinki, FI", fontdict=font, ha='left',  va='bottom', rotation=27)    text_theta = float(39.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Moscow, RU", fontdict=font, ha='left',  va='bottom', rotation=39)    text_theta = float(75.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Bombay, IN", fontdict=font, ha='left',  va='bottom', rotation=75)    text_theta = float(78.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Delhi, IN", fontdict=font, ha='left',  va='bottom', rotation=78)    text_theta = float(100.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Bangkok, TH", fontdict=font, ha='right',  va='bottom', rotation=100)    text_theta = float(102.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Singapore, SG", fontdict=font, ha='right',  va='bottom', rotation=102)    text_theta = float(116.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Beijing, CN", fontdict=font, ha='right',  va='bottom', rotation=116)    text_theta = float(121.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Taiopei, CN", fontdict=font, ha='right',  va='bottom', rotation=121)    text_theta = float(139.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Tokyo, JP", fontdict=font, ha='right',  va='bottom', rotation=139)    text_theta = float(151.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Sydney, AU", fontdict=font, ha='right',  va='bottom', rotation=151)    text_theta = float(201/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Honolulu, US", fontdict=font, ha='right',  va='top', rotation=201)    text_theta = float(238.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "San Jose, US", fontdict=font, ha='right',  va='top', rotation=238)    text_theta = float(242.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "San Diego, US", fontdict=font,  ha='right',  va='top', rotation=242)    text_theta = float(248.0/360)*2*np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Phoenix, US", fontdict=font,  ha='right',  va='top', rotation=248)    text_theta = float(255.0/360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Denver, US", fontdict=font,  ha='right',  va='top', rotation=255)    text_theta = float(263.0/ 360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Houston, US", fontdict=font,  ha='right',  va='top', rotation=263)    text_theta = float(272.0/360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Chicago, US", fontdict=font,  ha='center',  va='top', rotation=272)    text_theta = float(281.0/ 360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Toronto, CA", fontdict=font,  ha='left',  va='top', rotation=281)    text_theta = float(284.0/360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Washington, US", fontdict=font, ha='left',  va='top', rotation=284)    text_theta = float(286.0/360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Ottawa, CA", fontdict=font, ha='left',  va='top', rotation=286)    text_theta = float(289.0/360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Boston, US", fontdict=font, ha='left',  va='top', rotation=289)    text_theta = float(302.0/360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Buenos Aires, AR", fontdict=font, ha='left',  va='top', rotation=302)    text_theta = float(316.0/360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Rio de Janeiro, BR", fontdict=font, ha='left',  va='top', rotation=316)    text_theta = float(351.0/360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "ALges, PT", fontdict=font, ha='left',  va='top', rotation=351)    text_theta = float(354.0/360) * 2 * np.pi    text_radius = max_radius + 1    ax.text(text_theta, text_radius, "Dublin, IE", fontdict=font, ha='left',  va='top', rotation=354)    # 给最牛逼的几个点做标记    # 一般字体统一用一个字典控制    font = {'family': 'serif',            'style': 'italic',            'weight': 'normal',            'color': 'white',            'size': 2            }    for index_item in max_index:        as_string = as_info[index_item][5] + "(AS"+as_info[index_item][0]+")"        # as_string ="AS" + as_info[index_item][0]        ax.text(angle_list[index_item]-0.2, radius_list[index_item]+0.1, as_string, fontdict=font, ha='right', va='center', zorder=8)        # print("Global AS Rank:", as_info[index_item])    print("Global AS Rank(TOP10):")    for item_as in global_all_as[0:10]:        print(item_as)    # 给中国几个牛逼的AS做标记    font = {'family': 'serif',            'style': 'italic',            'weight': 'normal',            'color': 'white',            'size': 2            }    # for index_item in cn_index:    #     as_string = as_info[index_item][5] + "(AS" + as_info[index_item][0] + ")"    #     # ax.text(angle_list[index_item], radius_list[index_item]+0.1, as_string, fontdict=font, ha='right', va='center', zorder=8)    #     print("China AS Rank:", as_info[index_item])    print("China AS Rank(TOP10):")    for item_as in cn_all_as[0:10]:        print(item_as)    # print(as_info[0])  # 测试    print("连通度最高的AS号半径：", radius_list[min_index], "ASN:", as_info[min_index][0], "AS info:", as_info[min_index][5])    # 画出圆心    # ax.scatter(0, 0, c="", edgecolors=[0, 0, 0], marker='o', lw=1, s=0.5, cmap='hsv', alpha=0.8, zorder=5)    # 添加图时间信息    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 12            }    text_theta = float(30/360) * 2 * np.pi    text_radius = 2.5 * max_radius    ax.text(text_theta, text_radius, "Year:", fontdict=font,  ha='center', va='center', rotation=0)    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 24            }    text_theta = float(26/360) * 2 * np.pi    text_radius = (2.5 * max_radius * np.cos(float(30/360) * 2 * np.pi)) / np.cos(float(26/360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta, text_radius, year_str, fontdict=font,  ha='center', va='center', rotation=0)    # 添加图节点和边的信息    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 12            }    text_theta = float(350/360) * 2 * np.pi    text_radius = (2.5 * max_radius * np.cos(float(30/360) * 2 * np.pi)) / np.cos(float(10/360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta, text_radius, "Nodes:", fontdict=font,  ha='center', va='center', rotation=0)    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 24            }    text_theta = float(345/360) * 2 * np.pi    text_radius = (2.5 * max_radius * np.cos(float(30/360) * 2 * np.pi)) / np.cos(float(15/360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta, text_radius, item_cnt, fontdict=font,  ha='center', va='center', rotation=0)    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 12            }    text_theta = float(340/360) * 2 * np.pi    text_radius = (2.5 * max_radius * np.cos(float(30/360) * 2 * np.pi)) / np.cos(float(20/360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta, text_radius, "Edges:", fontdict=font,  ha='center', va='center', rotation=0)    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 24            }    text_theta = float(335/360) * 2 * np.pi    text_radius = (2.5 * max_radius * np.cos(float(30/360) * 2 * np.pi)) / np.cos(float(25/360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta, text_radius, edges_cnt, fontdict=font,  ha='center', va='center', rotation=0)    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 8            }    text_theta = float(332/360) * 2 * np.pi    text_radius = (2.5 * max_radius * np.cos(float(30/360) * 2 * np.pi)) / np.cos(float(28/360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta, text_radius, "(Peering & Transit)", fontdict=font,  ha='center', va='center', rotation=0)    # 添加图标题    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 20            }    text_theta = float(149/360) * 2 * np.pi    text_radius = (2.3 * max_radius * np.cos(float(30/360) * 2 * np.pi)) / np.cos(float(31/360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta, text_radius, "Global AS Core Map", fontdict=font,  ha='center', va='center', rotation=0)    # 计算乘系数    if int(year_str) <= 2010:        multi_apha = 3.4    elif int(year_str) <= 2015:        multi_apha = 3.3    else:        multi_apha = 3.2    # 添加Global AS Rank(TOP10)    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 10            }    text_theta = float(168/360) * 2 * np.pi    text_radius = (multi_apha * max_radius * np.cos(float(30/360) * 2 * np.pi)) / np.cos(float(12 / 360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta, text_radius, "Global AS Rank(TOP10)", fontdict=font, ha='left', va='center', rotation=0)    # 添加全球排名    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 4.5            }    liter_cnt = 1  # 存储循环计数    for item_as in global_all_as[0:10]:        iter_theta = 170 + 1 * liter_cnt        if iter_theta >= 180:            text_theta = float(iter_theta/360) * 2 * np.pi            text_radius = (multi_apha * max_radius * np.cos(float(30 / 360) * 2 * np.pi)) / np.cos(float((180-iter_theta)/360) * 2 * np.pi)  # 根据余弦关系        else:            text_theta = float(iter_theta/360) * 2 * np.pi            text_radius = (multi_apha * max_radius * np.cos(float(30 / 360) * 2 * np.pi)) / np.cos(float((iter_theta-180)/360) * 2 * np.pi)  # 根据余弦关系        if liter_cnt == 10:            text_str = "NO." + str(liter_cnt) + ": AS" + item_as[0] + ", " + item_as[1] + ", " + item_as[6] + ", " + item_as[8]        else:            text_str = "NO.0" + str(liter_cnt) + ": AS" + item_as[0] + ", " + item_as[1] + ", " + item_as[6] + ", " + item_as[8]        ax.text(text_theta, text_radius, text_str, fontdict=font, ha='left', va='center', rotation=0)        liter_cnt += 1    # 添加China AS Rank(TOP10)    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 10            }    text_theta_cn = float(191 / 360) * 2 * np.pi    text_radius_cn = (multi_apha * max_radius * np.cos(float(30 / 360) * 2 * np.pi)) / np.cos(float(11/ 360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta_cn, text_radius_cn, "China AS Rank(TOP10)", fontdict=font, ha='left', va='center', rotation=0)    # 添加中国排名    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'white',            'size': 4.5            }    liter_cnt = 1  # 存储循环计数    for item_as in cn_all_as[0:10]:        iter_theta = 193 + 1 * liter_cnt        if iter_theta >= 180:            text_theta = float(iter_theta / 360) * 2 * np.pi            text_radius = (multi_apha * max_radius * np.cos(float(30 / 360) * 2 * np.pi)) / np.cos(                float((180 - iter_theta) / 360) * 2 * np.pi)  # 根据余弦关系        else:            text_theta = float(iter_theta / 360) * 2 * np.pi            text_radius = (multi_apha * max_radius * np.cos(float(30 / 360) * 2 * np.pi)) / np.cos(                float((iter_theta - 180) / 360) * 2 * np.pi)  # 根据余弦关系        if liter_cnt == 10:            text_str = "NO." + str(liter_cnt) + ": AS" + item_as[0] + ", " + item_as[1] + ", " + item_as[6] + ", " + item_as[8]        else:            text_str = "NO.0" + str(liter_cnt) + ": AS" + item_as[0] + ", " + item_as[1] + ", " + item_as[6] + ", " + item_as[8]        ax.text(text_theta, text_radius, text_str, fontdict=font, ha='left', va='center', rotation=0)        liter_cnt += 1    # 添加中国图例    font = {'family': 'serif',            'style': 'normal',            'weight': 'normal',            'color': 'green',            'size': 4            }    text_theta_cn = float(204 / 360) * 2 * np.pi    text_radius_cn = (multi_apha * max_radius * np.cos(float(30 / 360) * 2 * np.pi)) / np.cos(float(24 / 360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta_cn, text_radius_cn, "China AS Color: Green", fontdict=font, ha='left', va='center',rotation=0)    # 添加CopyRight    font = {'family': 'serif',            'style': 'italic',            'weight': 'normal',            'color': 'white',            'size': 4            }    text_theta_cn = float(207 / 360) * 2 * np.pi    text_radius_cn = (multi_apha * max_radius * np.cos(float(30 / 360) * 2 * np.pi)) / np.cos(float(27 / 360) * 2 * np.pi)  # 根据余弦关系    ax.text(text_theta_cn, text_radius_cn, "CopyRight CAICT 2020, By Wayne YU, http://www.mryu.top/", fontdict=font, ha='left', va='center', rotation=0)    plt.axis('off')    # plt.xticks([])  # 去掉横坐标    # plt.yticks([])  # 去掉纵坐标    save_fig_name = "../000LocalData/as_cn/as_core_map_scatter_intergrate" + year_str + ".jpg"    plt.savefig(save_fig_name, dpi=1080, facecolor='black')    # plt.show()    plt.close()def update_file_in_list(file_in_list):    """    更新file_in_list，补充国内数据，说明地位的变化    :param file_in_list:    :return re_list:    """    file_in_intergrate = "..\\000LocalData\\as_cn\\as_map_intergrate_20200221.csv"  # Gao+Caida整合后的AS网络画像    file_read = open(file_in_intergrate, 'r', encoding='utf-8')    # 构建整合后的AS网络画像字典    as2degree = {}    for line in file_read.readlines():        line = line.strip().split("|")        as2degree[line[0]] = line[1]    # 更新file_in_list 国内部分数据    re_list = []    for item in file_in_list:        if item[8] == "CN":            try:                item[1] = as2degree[item[0]]                re_list.append(item)            except Exception as e:                print("ERROR:", e)    return re_listif __name__ == "__main__":    time_start = time.time()  # 记录启动时间    # file_in = '..\\000LocalData\\as_map\\as_core_map_data_new20200201.csv'  # Caida数据源AS网络画像    file_in = '..\\000LocalData\\as_map_intergrate\\as_map_intergrate_20200221.csv'  # 多数据源AS网络画像    file_read = open(file_in, 'r', encoding='utf-8')    file_in_list = []    new_info = []    asn_temp = ""    for line in file_read.readlines():        line = line.strip().split('|')        if len(line) < 11:            continue        if asn_temp == line[0]:            continue        file_in_list.append(line)        asn_temp = line[0]    # file_in_list = update_file_in_list(file_in_list)    # print(file_in_list)    new_info = compute_polar_args(file_in_list)  # 计算极坐标相关参数    bgp_file = "..\\000LocalData\\as_compare\\as_rel_20200221_integrate.txt"  # 整合之后的互联关系数据    draw_polar_map(new_info, bgp_file, "2020")    time_end = time.time()    print("=>Scripts Finish, Time Consuming:", (time_end - time_start), "S")