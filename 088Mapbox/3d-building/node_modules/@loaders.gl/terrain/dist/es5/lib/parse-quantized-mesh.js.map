{"version":3,"sources":["../../../src/lib/parse-quantized-mesh.ts"],"names":["getMeshAttributes","vertexData","header","bounds","minHeight","maxHeight","minX","minY","maxX","maxY","xScale","yScale","zScale","nCoords","length","positions","Float32Array","texCoords","i","x","y","z","POSITION","value","size","TEXCOORD_0","getTileMesh","arrayBuffer","options","DECODING_STEPS","triangleIndices","originalTriangleIndices","westIndices","northIndices","eastIndices","southIndices","attributes","boundingBox","skirtHeight","newAttributes","newTriangles","triangles","loaderData","vertexCount","mode","indices","loadQuantizedMesh"],"mappings":"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","sourcesContent":["import {getMeshBoundingBox} from '@loaders.gl/schema';\nimport decode, {DECODING_STEPS} from './decode-quantized-mesh';\nimport {addSkirt} from './helpers/skirt';\n\nfunction getMeshAttributes(vertexData, header, bounds) {\n  const {minHeight, maxHeight} = header;\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];\n  const xScale = maxX - minX;\n  const yScale = maxY - minY;\n  const zScale = maxHeight - minHeight;\n\n  const nCoords = vertexData.length / 3;\n  // vec3. x, y defined by bounds, z in meters\n  const positions = new Float32Array(nCoords * 3);\n\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(nCoords * 2);\n\n  // Data is not interleaved; all u, then all v, then all heights\n  for (let i = 0; i < nCoords; i++) {\n    const x = vertexData[i] / 32767;\n    const y = vertexData[i + nCoords] / 32767;\n    const z = vertexData[i + nCoords * 2] / 32767;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = y * yScale + minY;\n    positions[3 * i + 2] = z * zScale + minHeight;\n\n    texCoords[2 * i + 0] = x;\n    texCoords[2 * i + 1] = y;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // TODO: Parse normals if they exist in the file\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\nfunction getTileMesh(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n  const {bounds} = options;\n  // Don't parse edge indices or format extensions\n  const {\n    header,\n    vertexData,\n    triangleIndices: originalTriangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices\n  } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);\n  let triangleIndices = originalTriangleIndices;\n  let attributes = getMeshAttributes(vertexData, header, bounds);\n\n  // Compute bounding box before adding skirt so that z values are not skewed\n  // TODO: Find bounding box from header, instead of doing extra pass over\n  // vertices.\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (options.skirtHeight) {\n    const {attributes: newAttributes, triangles: newTriangles} = addSkirt(\n      attributes,\n      triangleIndices,\n      options.skirtHeight,\n      {\n        westIndices,\n        northIndices,\n        eastIndices,\n        southIndices\n      }\n    );\n    attributes = newAttributes;\n    triangleIndices = newTriangles;\n  }\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      // @ts-ignore\n      vertexCount: triangleIndices.length,\n      boundingBox\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: triangleIndices, size: 1},\n    attributes\n  };\n}\n\nexport default function loadQuantizedMesh(arrayBuffer, options) {\n  return getTileMesh(arrayBuffer, options['quantized-mesh']);\n}\n"],"file":"parse-quantized-mesh.js"}