{"version":3,"sources":["../../src/csv-loader.ts"],"names":["VERSION","DEFAULT_CSV_LOADER_OPTIONS","csv","shape","optimizeMemoryUsage","header","columnPrefix","quoteChar","escapeChar","dynamicTyping","comments","skipEmptyLines","delimitersToGuess","CSVLoader","id","module","name","version","extensions","mimeTypes","category","parse","arrayBuffer","options","parseCSV","TextDecoder","decode","parseText","text","parseInBatches","parseCSVInBatches","csvText","csvOptions","firstRow","readFirstRow","isHeaderRow","Boolean","parseWithHeader","papaparseConfig","download","transformHeader","duplicateColumnTransformer","undefined","error","e","Error","result","Papa","rows","data","headerRow","meta","fields","generateHeader","length","map","row","Array","isArray","asyncIterator","batchSize","asyncQueue","AsyncQueue","isFirstRow","tableBatchBuilder","schema","config","chunkSize","step","results","collapsedRow","flat","join","trim","bytesUsed","cursor","deduceSchema","JSON","stringify","TableBatchBuilder","addRow","batch","getFullBatch","enqueue","complete","getFinalBatch","close","AsyncIteratorStreamer","every","value","preview","observedColumns","Set","col","colName","counter","has","add","count","headers","i","push","columnName","String","index","type","Float32Array","_typecheckCSVLoader"],"mappings":"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","sourcesContent":["import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {Batch} from '@loaders.gl/schema';\ntype Schema = any;\n\nimport {\n  AsyncQueue,\n  TableBatchBuilder,\n  convertToArrayRow,\n  convertToObjectRow\n} from '@loaders.gl/schema';\nimport Papa from './papaparse/papaparse';\nimport AsyncIteratorStreamer from './papaparse/async-iterator-streamer';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type CSVLoaderOptions = LoaderOptions & {\n  csv?: {\n    // loaders.gl options\n    shape?: 'array-row-table' | 'object-row-table' | 'columnar-table';\n    /** optimizes memory usage but increases parsing time. */\n    optimizeMemoryUsage?: boolean;\n    columnPrefix?: string;\n    header?: 'auto';\n\n    // CSV options (papaparse)\n    // delimiter: auto\n    // newline: auto\n    quoteChar?: string;\n    escapeChar?: string;\n    // Convert numbers and boolean values in rows from strings\n    dynamicTyping?: boolean;\n    comments?: boolean;\n    skipEmptyLines?: boolean | 'greedy';\n    // transform: null?\n    delimitersToGuess?: string[];\n    // fastMode: auto\n  };\n};\n\nconst DEFAULT_CSV_LOADER_OPTIONS = {\n  csv: {\n    shape: 'object-row-table',\n    optimizeMemoryUsage: false,\n    // CSV options\n    header: 'auto',\n    columnPrefix: 'column',\n    // delimiter: auto\n    // newline: auto\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: true,\n    // transform: null?\n    delimitersToGuess: [',', '\\t', '|', ';']\n    // fastMode: auto\n  }\n};\n\nexport const CSVLoader = {\n  id: 'csv',\n  module: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv', 'tsv', 'dsv'],\n  mimeTypes: ['text/csv', 'text/tab-separated-values', 'text/dsv'],\n  category: 'table',\n  parse: async (arrayBuffer: ArrayBuffer, options?: CSVLoaderOptions) =>\n    parseCSV(new TextDecoder().decode(arrayBuffer), options),\n  parseText: (text: string, options?: CSVLoaderOptions) => parseCSV(text, options),\n  parseInBatches: parseCSVInBatches,\n  // @ts-ignore\n  // testText: null,\n  options: DEFAULT_CSV_LOADER_OPTIONS as CSVLoaderOptions\n};\n\nasync function parseCSV(csvText: string, options?: CSVLoaderOptions) {\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const firstRow = readFirstRow(csvText);\n  const header: boolean =\n    csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);\n\n  const parseWithHeader = header;\n\n  const papaparseConfig = {\n    // dynamicTyping: true,\n    ...csvOptions,\n    header: parseWithHeader,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,\n    error: (e) => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, papaparseConfig);\n  let {data: rows} = result;\n\n  const headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);\n\n  switch (csvOptions.shape) {\n    case 'object-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? convertToObjectRow(row, headerRow) : row));\n      break;\n    case 'array-row-table':\n      rows = rows.map((row) => (Array.isArray(row) ? row : convertToArrayRow(row, headerRow)));\n      break;\n    default:\n  }\n\n  /*\n  if (!header && shape === 'object-row-table') {\n    // If the dataset has no header, transform the array result into an object shape with an\n    // autogenerated header\n    return result.data.map((row) =>\n      row.reduce((acc, value, i) => {\n        acc[headerRow[i]] = value;\n        return acc;\n      }, {})\n    );\n  }\n  */\n  return rows;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options?: CSVLoaderOptions\n): AsyncIterable<Batch> {\n  // Papaparse does not support standard batch size handling\n  // TODO - investigate papaparse chunks mode\n  options = {...options};\n  if (options.batchSize === 'auto') {\n    options.batchSize = 4000;\n  }\n\n  // Apps can call the parse method directly, we so apply default options here\n  const csvOptions = {...DEFAULT_CSV_LOADER_OPTIONS.csv, ...options?.csv};\n\n  const asyncQueue = new AsyncQueue<Batch>();\n\n  let isFirstRow: boolean = true;\n  let headerRow: string[] | null = null;\n  let tableBatchBuilder: TableBatchBuilder | null = null;\n  let schema: Schema | null = null;\n\n  const config = {\n    // dynamicTyping: true, // Convert numbers and boolean values in rows from strings,\n    ...csvOptions,\n    header: false, // Unfortunately, header detection is not automatic and does not infer shapes\n    download: false, // We handle loading, no need for papaparse to do it for us\n    // chunkSize is set to 5MB explicitly (same as Papaparse default) due to a bug where the\n    // streaming parser gets stuck if skipEmptyLines and a step callback are both supplied.\n    // See https://github.com/mholt/PapaParse/issues/465\n    chunkSize: 1024 * 1024 * 5,\n    // skipEmptyLines is set to a boolean value if supplied. Greedy is set to true\n    // skipEmptyLines is handled manually given two bugs where the streaming parser gets stuck if\n    // both of the skipEmptyLines and step callback options are provided:\n    // - true doesn't work unless chunkSize is set: https://github.com/mholt/PapaParse/issues/465\n    // - greedy doesn't work: https://github.com/mholt/PapaParse/issues/825\n    skipEmptyLines: false,\n\n    // step is called on every row\n    // eslint-disable-next-line complexity\n    step(results) {\n      let row = results.data;\n\n      if (csvOptions.skipEmptyLines) {\n        // Manually reject lines that are empty\n        const collapsedRow = row.flat().join('').trim();\n        if (collapsedRow === '') {\n          return;\n        }\n      }\n      const bytesUsed = results.meta.cursor;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        // Auto detects or can be forced with csvOptions.header\n        const header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);\n        if (header) {\n          headerRow = row.map(duplicateColumnTransformer());\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = generateHeader(csvOptions.columnPrefix, row.length);\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n\n      if (csvOptions.optimizeMemoryUsage) {\n        // A workaround to allocate new strings and don't retain pointers to original strings.\n        // https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        row = JSON.parse(JSON.stringify(row));\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder ||\n        new TableBatchBuilder(schema, {\n          // @ts-expect-error\n          shape: csvOptions.shape || 'array-row-table',\n          ...options\n        });\n\n      try {\n        tableBatchBuilder.addRow(row);\n        // If a batch has been completed, emit it\n        const batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results) {\n      try {\n        const bytesUsed = results.meta.cursor;\n        // Ensure any final (partial) batch gets emitted\n        const batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({bytesUsed});\n        if (batch) {\n          asyncQueue.enqueue(batch);\n        }\n      } catch (error) {\n        asyncQueue.enqueue(error as Error);\n      }\n\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\n/**\n * Checks if a certain row is a header row\n * @param row the row to check\n * @returns true if the row looks like a header\n */\nfunction isHeaderRow(row: string[]): boolean {\n  return row && row.every((value) => typeof value === 'string');\n}\n\n/**\n * Reads, parses, and returns the first row of a CSV text\n * @param csvText the csv text to parse\n * @returns the first row\n */\nfunction readFirstRow(csvText: string): any[] {\n  const result = Papa.parse(csvText, {\n    download: false,\n    dynamicTyping: true,\n    preview: 1\n  });\n  return result.data[0];\n}\n\n/**\n * Creates a transformer that renames duplicate columns. This is needed as Papaparse doesn't handle\n * duplicate header columns and would use the latest occurrence by default.\n * See the header option in https://www.papaparse.com/docs#config\n * @returns a transform function that returns sanitized names for duplicate fields\n */\nfunction duplicateColumnTransformer() {\n  const observedColumns = new Set();\n  return (col) => {\n    let colName = col;\n    let counter = 1;\n    while (observedColumns.has(colName)) {\n      colName = `${col}.${counter}`;\n      counter++;\n    }\n    observedColumns.add(colName);\n    return colName;\n  };\n}\n\n/**\n * Generates the header of a CSV given a prefix and a column count\n * @param columnPrefix the columnPrefix to use\n * @param count the count of column names to generate\n * @returns an array of column names\n */\nfunction generateHeader(columnPrefix: string, count: number = 0): string[] {\n  const headers: string[] = [];\n  for (let i = 0; i < count; i++) {\n    headers.push(`${columnPrefix}${i + 1}`);\n  }\n  return headers;\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n\nexport const _typecheckCSVLoader: LoaderWithParser = CSVLoader;\n"],"file":"csv-loader.js"}