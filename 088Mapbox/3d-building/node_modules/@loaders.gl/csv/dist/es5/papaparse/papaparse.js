"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/* @license
Papa Parse
v5.0.0-beta.0
https://github.com/mholt/PapaParse
License: MIT
*/
var BYTE_ORDER_MARK = "\uFEFF";
var Papa = {
  parse: CsvToJson,
  unparse: JsonToCsv,
  RECORD_SEP: String.fromCharCode(30),
  UNIT_SEP: String.fromCharCode(31),
  BYTE_ORDER_MARK: BYTE_ORDER_MARK,
  BAD_DELIMITERS: ['\r', '\n', '"', BYTE_ORDER_MARK],
  WORKERS_SUPPORTED: false,
  NODE_STREAM_INPUT: 1,
  LocalChunkSize: 1024 * 1024 * 10,
  RemoteChunkSize: 1024 * 1024 * 5,
  DefaultDelimiter: ',',
  Parser: Parser,
  ParserHandle: ParserHandle,
  ChunkStreamer: ChunkStreamer,
  StringStreamer: StringStreamer
};
var _default = Papa;
exports.default = _default;

function CsvToJson(_input, _config, UserDefinedStreamer) {
  _config = _config || {};
  var dynamicTyping = _config.dynamicTyping || false;

  if (isFunction(dynamicTyping)) {
    _config.dynamicTypingFunction = dynamicTyping;
    dynamicTyping = {};
  }

  _config.dynamicTyping = dynamicTyping;
  _config.transform = isFunction(_config.transform) ? _config.transform : false;

  if (_config.worker && Papa.WORKERS_SUPPORTED) {
    var w = newWorker();
    w.userStep = _config.step;
    w.userChunk = _config.chunk;
    w.userComplete = _config.complete;
    w.userError = _config.error;
    _config.step = isFunction(_config.step);
    _config.chunk = isFunction(_config.chunk);
    _config.complete = isFunction(_config.complete);
    _config.error = isFunction(_config.error);
    delete _config.worker;
    w.postMessage({
      input: _input,
      config: _config,
      workerId: w.id
    });
    return;
  }

  var streamer = null;

  if (typeof _input === 'string') {
    streamer = new StringStreamer(_config);
  }

  if (!streamer) {
    streamer = new UserDefinedStreamer(_config);
  }

  return streamer.stream(_input);
}

function JsonToCsv(_input, _config) {
  var _quotes = false;
  var _writeHeader = true;
  var _delimiter = ',';
  var _newline = '\r\n';
  var _quoteChar = '"';

  var _escapedQuote = _quoteChar + _quoteChar;

  var _skipEmptyLines = false;
  var _columns = null;
  unpackConfig();
  var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');
  if (typeof _input === 'string') _input = JSON.parse(_input);

  if (Array.isArray(_input)) {
    if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);else if ((0, _typeof2.default)(_input[0]) === 'object') return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);
  } else if ((0, _typeof2.default)(_input) === 'object') {
    if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);

    if (Array.isArray(_input.data)) {
      if (!_input.fields) _input.fields = _input.meta && _input.meta.fields;
      if (!_input.fields) _input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0]);
      if (!Array.isArray(_input.data[0]) && (0, _typeof2.default)(_input.data[0]) !== 'object') _input.data = [_input.data];
    }

    return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
  }

  throw new Error('Unable to serialize unrecognized input');

  function unpackConfig() {
    if ((0, _typeof2.default)(_config) !== 'object') return;

    if (typeof _config.delimiter === 'string' && !Papa.BAD_DELIMITERS.filter(function (value) {
      return _config.delimiter.indexOf(value) !== -1;
    }).length) {
      _delimiter = _config.delimiter;
    }

    if (typeof _config.quotes === 'boolean' || Array.isArray(_config.quotes)) _quotes = _config.quotes;
    if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string') _skipEmptyLines = _config.skipEmptyLines;
    if (typeof _config.newline === 'string') _newline = _config.newline;
    if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;
    if (typeof _config.header === 'boolean') _writeHeader = _config.header;

    if (Array.isArray(_config.columns)) {
      if (_config.columns.length === 0) throw new Error('Option columns is empty');
      _columns = _config.columns;
    }

    if (_config.escapeChar !== undefined) {
      _escapedQuote = _config.escapeChar + _quoteChar;
    }
  }

  function objectKeys(obj) {
    if ((0, _typeof2.default)(obj) !== 'object') return [];
    var keys = [];

    for (var key in obj) {
      keys.push(key);
    }

    return keys;
  }

  function serialize(fields, data, skipEmptyLines) {
    var csv = '';
    if (typeof fields === 'string') fields = JSON.parse(fields);
    if (typeof data === 'string') data = JSON.parse(data);
    var hasHeader = Array.isArray(fields) && fields.length > 0;
    var dataKeyedByField = !Array.isArray(data[0]);

    if (hasHeader && _writeHeader) {
      for (var i = 0; i < fields.length; i++) {
        if (i > 0) csv += _delimiter;
        csv += safe(fields[i], i);
      }

      if (data.length > 0) csv += _newline;
    }

    for (var row = 0; row < data.length; row++) {
      var maxCol = hasHeader ? fields.length : data[row].length;
      var emptyLine = false;
      var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;

      if (skipEmptyLines && !hasHeader) {
        emptyLine = skipEmptyLines === 'greedy' ? data[row].join('').trim() === '' : data[row].length === 1 && data[row][0].length === 0;
      }

      if (skipEmptyLines === 'greedy' && hasHeader) {
        var line = [];

        for (var c = 0; c < maxCol; c++) {
          var cx = dataKeyedByField ? fields[c] : c;
          line.push(data[row][cx]);
        }

        emptyLine = line.join('').trim() === '';
      }

      if (!emptyLine) {
        for (var col = 0; col < maxCol; col++) {
          if (col > 0 && !nullLine) csv += _delimiter;
          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
          csv += safe(data[row][colIdx], col);
        }

        if (row < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {
          csv += _newline;
        }
      }
    }

    return csv;
  }

  function safe(str, col) {
    if (typeof str === 'undefined' || str === null) return '';
    if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);
    str = str.toString().replace(quoteCharRegex, _escapedQuote);
    var needsQuotes = typeof _quotes === 'boolean' && _quotes || Array.isArray(_quotes) && _quotes[col] || hasAny(str, Papa.BAD_DELIMITERS) || str.indexOf(_delimiter) > -1 || str.charAt(0) === ' ' || str.charAt(str.length - 1) === ' ';
    return needsQuotes ? _quoteChar + str + _quoteChar : str;
  }

  function hasAny(str, substrings) {
    for (var i = 0; i < substrings.length; i++) {
      if (str.indexOf(substrings[i]) > -1) return true;
    }

    return false;
  }
}

function ChunkStreamer(config) {
  this._handle = null;
  this._finished = false;
  this._completed = false;
  this._input = null;
  this._baseIndex = 0;
  this._partialLine = '';
  this._rowCount = 0;
  this._start = 0;
  this._nextChunk = null;
  this.isFirstChunk = true;
  this._completeResults = {
    data: [],
    errors: [],
    meta: {}
  };
  replaceConfig.call(this, config);

  this.parseChunk = function (chunk, isFakeChunk) {
    if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {
      var modifiedChunk = this._config.beforeFirstChunk(chunk);

      if (modifiedChunk !== undefined) chunk = modifiedChunk;
    }

    this.isFirstChunk = false;
    var aggregate = this._partialLine + chunk;
    this._partialLine = '';

    var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

    if (this._handle.paused() || this._handle.aborted()) return;
    var lastIndex = results.meta.cursor;

    if (!this._finished) {
      this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
      this._baseIndex = lastIndex;
    }

    if (results && results.data) this._rowCount += results.data.length;
    var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;

    if (isFunction(this._config.chunk) && !isFakeChunk) {
      this._config.chunk(results, this._handle);

      if (this._handle.paused() || this._handle.aborted()) return;
      results = undefined;
      this._completeResults = undefined;
    }

    if (!this._config.step && !this._config.chunk) {
      this._completeResults.data = this._completeResults.data.concat(results.data);
      this._completeResults.errors = this._completeResults.errors.concat(results.errors);
      this._completeResults.meta = results.meta;
    }

    if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {
      this._config.complete(this._completeResults, this._input);

      this._completed = true;
    }

    if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();
    return results;
  };

  this._sendError = function (error) {
    if (isFunction(this._config.error)) this._config.error(error);
  };

  function replaceConfig(config) {
    var configCopy = copy(config);
    configCopy.chunkSize = parseInt(configCopy.chunkSize);
    if (!config.step && !config.chunk) configCopy.chunkSize = null;
    this._handle = new ParserHandle(configCopy);
    this._handle.streamer = this;
    this._config = configCopy;
  }
}

function StringStreamer(config) {
  config = config || {};
  ChunkStreamer.call(this, config);
  var remaining;

  this.stream = function (s) {
    remaining = s;
    return this._nextChunk();
  };

  this._nextChunk = function () {
    if (this._finished) return;
    var size = this._config.chunkSize;
    var chunk = size ? remaining.substr(0, size) : remaining;
    remaining = size ? remaining.substr(size) : '';
    this._finished = !remaining;
    return this.parseChunk(chunk);
  };
}

StringStreamer.prototype = Object.create(StringStreamer.prototype);
StringStreamer.prototype.constructor = StringStreamer;

function ParserHandle(_config) {
  var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
  var ISO_DATE = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
  var self = this;
  var _stepCounter = 0;
  var _rowCounter = 0;

  var _input;

  var _parser;

  var _paused = false;
  var _aborted = false;

  var _delimiterError;

  var _fields = [];
  var _results = {
    data: [],
    errors: [],
    meta: {}
  };

  if (isFunction(_config.step)) {
    var userStep = _config.step;

    _config.step = function (results) {
      _results = results;
      if (needsHeaderRow()) processResults();else {
          processResults();
          if (!_results.data || _results.data.length === 0) return;
          _stepCounter += results.data.length;
          if (_config.preview && _stepCounter > _config.preview) _parser.abort();else userStep(_results, self);
        }
    };
  }

  this.parse = function (input, baseIndex, ignoreLastRow) {
    var quoteChar = _config.quoteChar || '"';
    if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);
    _delimiterError = false;

    if (!_config.delimiter) {
      var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);
      if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;else {
        _delimiterError = true;
        _config.delimiter = Papa.DefaultDelimiter;
      }
      _results.meta.delimiter = _config.delimiter;
    } else if (isFunction(_config.delimiter)) {
      _config.delimiter = _config.delimiter(input);
      _results.meta.delimiter = _config.delimiter;
    }

    var parserConfig = copy(_config);
    if (_config.preview && _config.header) parserConfig.preview++;
    _input = input;
    _parser = new Parser(parserConfig);
    _results = _parser.parse(_input, baseIndex, ignoreLastRow);
    processResults();
    return _paused ? {
      meta: {
        paused: true
      }
    } : _results || {
      meta: {
        paused: false
      }
    };
  };

  this.paused = function () {
    return _paused;
  };

  this.pause = function () {
    _paused = true;

    _parser.abort();

    _input = _input.substr(_parser.getCharIndex());
  };

  this.resume = function () {
    _paused = false;
    self.streamer.parseChunk(_input, true);
  };

  this.aborted = function () {
    return _aborted;
  };

  this.abort = function () {
    _aborted = true;

    _parser.abort();

    _results.meta.aborted = true;
    if (isFunction(_config.complete)) _config.complete(_results);
    _input = '';
  };

  function testEmptyLine(s) {
    return _config.skipEmptyLines === 'greedy' ? s.join('').trim() === '' : s.length === 1 && s[0].length === 0;
  }

  function processResults() {
    if (_results && _delimiterError) {
      addError('Delimiter', 'UndetectableDelimiter', "Unable to auto-detect delimiting character; defaulted to '" + Papa.DefaultDelimiter + "'");
      _delimiterError = false;
    }

    if (_config.skipEmptyLines) {
      for (var i = 0; i < _results.data.length; i++) {
        if (testEmptyLine(_results.data[i])) _results.data.splice(i--, 1);
      }
    }

    if (needsHeaderRow()) fillHeaderFields();
    return applyHeaderAndDynamicTypingAndTransformation();
  }

  function needsHeaderRow() {
    return _config.header && _fields.length === 0;
  }

  function fillHeaderFields() {
    if (!_results) return;

    function addHeder(header) {
      if (isFunction(_config.transformHeader)) header = _config.transformHeader(header);

      _fields.push(header);
    }

    if (Array.isArray(_results.data[0])) {
      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++) {
        _results.data[i].forEach(addHeder);
      }

      _results.data.splice(0, 1);
    } else _results.data.forEach(addHeder);
  }

  function shouldApplyDynamicTyping(field) {
    if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {
      _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
    }

    return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
  }

  function parseDynamic(field, value) {
    if (shouldApplyDynamicTyping(field)) {
      if (value === 'true' || value === 'TRUE') return true;else if (value === 'false' || value === 'FALSE') return false;else if (FLOAT.test(value)) return parseFloat(value);else if (ISO_DATE.test(value)) return new Date(value);else return value === '' ? null : value;
    }

    return value;
  }

  function applyHeaderAndDynamicTypingAndTransformation() {
    if (!_results || !_results.data || !_config.header && !_config.dynamicTyping && !_config.transform) return _results;

    function processRow(rowSource, i) {
      var row = _config.header ? {} : [];
      var j;

      for (j = 0; j < rowSource.length; j++) {
        var field = j;
        var value = rowSource[j];
        if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];
        if (_config.transform) value = _config.transform(value, field);
        value = parseDynamic(field, value);

        if (field === '__parsed_extra') {
          row[field] = row[field] || [];
          row[field].push(value);
        } else row[field] = value;
      }

      if (_config.header) {
        if (j > _fields.length) addError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);else if (j < _fields.length) addError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);
      }

      return row;
    }

    var incrementBy = 1;

    if (!_results.data[0] || Array.isArray(_results.data[0])) {
      _results.data = _results.data.map(processRow);
      incrementBy = _results.data.length;
    } else _results.data = processRow(_results.data, 0);

    if (_config.header && _results.meta) _results.meta.fields = _fields;
    _rowCounter += incrementBy;
    return _results;
  }

  function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {
    var bestDelim, bestDelta, fieldCountPrevRow;
    delimitersToGuess = delimitersToGuess || [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];

    for (var i = 0; i < delimitersToGuess.length; i++) {
      var delim = delimitersToGuess[i];
      var delta = 0,
          avgFieldCount = 0,
          emptyLinesCount = 0;
      fieldCountPrevRow = undefined;
      var preview = new Parser({
        comments: comments,
        delimiter: delim,
        newline: newline,
        preview: 10
      }).parse(input);

      for (var j = 0; j < preview.data.length; j++) {
        if (skipEmptyLines && testEmptyLine(preview.data[j])) {
          emptyLinesCount++;
          continue;
        }

        var fieldCount = preview.data[j].length;
        avgFieldCount += fieldCount;

        if (typeof fieldCountPrevRow === 'undefined') {
          fieldCountPrevRow = 0;
          continue;
        } else if (fieldCount > 1) {
          delta += Math.abs(fieldCount - fieldCountPrevRow);
          fieldCountPrevRow = fieldCount;
        }
      }

      if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;

      if ((typeof bestDelta === 'undefined' || delta > bestDelta) && avgFieldCount > 1.99) {
        bestDelta = delta;
        bestDelim = delim;
      }
    }

    _config.delimiter = bestDelim;
    return {
      successful: !!bestDelim,
      bestDelimiter: bestDelim
    };
  }

  function guessLineEndings(input, quoteChar) {
    input = input.substr(0, 1024 * 1024);
    var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');
    input = input.replace(re, '');
    var r = input.split('\r');
    var n = input.split('\n');
    var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;
    if (r.length === 1 || nAppearsFirst) return '\n';
    var numWithN = 0;

    for (var i = 0; i < r.length; i++) {
      if (r[i][0] === '\n') numWithN++;
    }

    return numWithN >= r.length / 2 ? '\r\n' : '\r';
  }

  function addError(type, code, msg, row) {
    _results.errors.push({
      type: type,
      code: code,
      message: msg,
      row: row
    });
  }
}

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function Parser(config) {
  config = config || {};
  var delim = config.delimiter;
  var newline = config.newline;
  var comments = config.comments;
  var step = config.step;
  var preview = config.preview;
  var fastMode = config.fastMode;
  var quoteChar;

  if (config.quoteChar === undefined) {
    quoteChar = '"';
  } else {
    quoteChar = config.quoteChar;
  }

  var escapeChar = quoteChar;

  if (config.escapeChar !== undefined) {
    escapeChar = config.escapeChar;
  }

  if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ',';
  if (comments === delim) throw new Error('Comment character same as delimiter');else if (comments === true) comments = '#';else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1) comments = false;
  if (newline !== '\n' && newline !== '\r' && newline !== '\r\n') newline = '\n';
  var cursor = 0;
  var aborted = false;

  this.parse = function (input, baseIndex, ignoreLastRow) {
    if (typeof input !== 'string') throw new Error('Input must be a string');
    var inputLen = input.length,
        delimLen = delim.length,
        newlineLen = newline.length,
        commentsLen = comments.length;
    var stepIsFunction = isFunction(step);
    cursor = 0;
    var data = [],
        errors = [],
        row = [],
        lastCursor = 0;
    if (!input) return returnable();

    if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {
      var rows = input.split(newline);

      for (var i = 0; i < rows.length; i++) {
        row = rows[i];
        cursor += row.length;
        if (i !== rows.length - 1) cursor += newline.length;else if (ignoreLastRow) return returnable();
        if (comments && row.substr(0, commentsLen) === comments) continue;

        if (stepIsFunction) {
          data = [];
          pushRow(row.split(delim));
          doStep();
          if (aborted) return returnable();
        } else pushRow(row.split(delim));

        if (preview && i >= preview) {
          data = data.slice(0, preview);
          return returnable(true);
        }
      }

      return returnable();
    }

    var nextDelim = input.indexOf(delim, cursor);
    var nextNewline = input.indexOf(newline, cursor);
    var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');
    var quoteSearch;

    for (;;) {
      if (input[cursor] === quoteChar) {
        quoteSearch = cursor;
        cursor++;

        for (;;) {
          quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);

          if (quoteSearch === -1) {
            if (!ignoreLastRow) {
              errors.push({
                type: 'Quotes',
                code: 'MissingQuotes',
                message: 'Quoted field unterminated',
                row: data.length,
                index: cursor
              });
            }

            return finish();
          }

          if (quoteSearch === inputLen - 1) {
            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
            return finish(value);
          }

          if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {
            quoteSearch++;
            continue;
          }

          if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {
            continue;
          }

          var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
          var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);

          if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;
            nextDelim = input.indexOf(delim, cursor);
            nextNewline = input.indexOf(newline, cursor);

            if (stepIsFunction) {
              doStep();
              if (aborted) return returnable();
            }

            if (preview && data.length >= preview) return returnable(true);
            break;
          }

          var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);

          if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
            nextDelim = input.indexOf(delim, cursor);

            if (stepIsFunction) {
              doStep();
              if (aborted) return returnable();
            }

            if (preview && data.length >= preview) return returnable(true);
            break;
          }

          errors.push({
            type: 'Quotes',
            code: 'InvalidQuotes',
            message: 'Trailing quote on quoted field is malformed',
            row: data.length,
            index: cursor
          });
          quoteSearch++;
          continue;
        }

        if (stepIsFunction) {
          doStep();
          if (aborted) return returnable();
        }

        if (preview && data.length >= preview) return returnable(true);
        continue;
      }

      if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {
        if (nextNewline === -1) return returnable();
        cursor = nextNewline + newlineLen;
        nextNewline = input.indexOf(newline, cursor);
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }

      if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
        row.push(input.substring(cursor, nextDelim));
        cursor = nextDelim + delimLen;
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }

      if (nextNewline !== -1) {
        row.push(input.substring(cursor, nextNewline));
        saveRow(nextNewline + newlineLen);

        if (stepIsFunction) {
          doStep();
          if (aborted) return returnable();
        }

        if (preview && data.length >= preview) return returnable(true);
        continue;
      }

      break;
    }

    return finish();

    function pushRow(row) {
      data.push(row);
      lastCursor = cursor;
    }

    function extraSpaces(index) {
      var spaceLength = 0;

      if (index !== -1) {
        var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);

        if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {
          spaceLength = textBetweenClosingQuoteAndIndex.length;
        }
      }

      return spaceLength;
    }

    function finish(value) {
      if (ignoreLastRow) return returnable();
      if (typeof value === 'undefined') value = input.substr(cursor);
      row.push(value);
      cursor = inputLen;
      pushRow(row);
      if (stepIsFunction) doStep();
      return returnable();
    }

    function saveRow(newCursor) {
      cursor = newCursor;
      pushRow(row);
      row = [];
      nextNewline = input.indexOf(newline, cursor);
    }

    function returnable(stopped, step) {
      var isStep = step || false;
      return {
        data: isStep ? data[0] : data,
        errors: errors,
        meta: {
          delimiter: delim,
          linebreak: newline,
          aborted: aborted,
          truncated: !!stopped,
          cursor: lastCursor + (baseIndex || 0)
        }
      };
    }

    function doStep() {
      step(returnable(undefined, true));
      data = [];
      errors = [];
    }
  };

  this.abort = function () {
    aborted = true;
  };

  this.getCharIndex = function () {
    return cursor;
  };
}

function notImplemented() {
  throw new Error('Not implemented.');
}

function copy(obj) {
  if ((0, _typeof2.default)(obj) !== 'object' || obj === null) return obj;
  var cpy = Array.isArray(obj) ? [] : {};

  for (var key in obj) {
    cpy[key] = copy(obj[key]);
  }

  return cpy;
}

function isFunction(func) {
  return typeof func === 'function';
}
//# sourceMappingURL=papaparse.js.map