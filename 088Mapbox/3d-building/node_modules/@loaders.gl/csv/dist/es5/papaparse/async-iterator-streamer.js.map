{"version":3,"sources":["../../../src/papaparse/async-iterator-streamer.ts"],"names":["ChunkStreamer","Papa","AsyncIteratorStreamer","config","call","textDecoder","TextDecoder","_config","encoding","stream","asyncIterator","_input","chunk","parseChunk","getStringChunk","_finished","_sendError","_nextChunk","nextChunk","decode","prototype","Object","create","constructor"],"mappings":";;;;;;;;;;;;;;;AAQA;;AACA,IAAOA,aAAP,GAAwBC,kBAAxB,CAAOD,aAAP;;AAEe,SAASE,qBAAT,CAA+BC,MAA/B,EAAuC;AACpDA,EAAAA,MAAM,GAAGA,MAAM,IAAI,EAAnB;AAEAH,EAAAA,aAAa,CAACI,IAAd,CAAmB,IAAnB,EAAyBD,MAAzB;AAEA,OAAKE,WAAL,GAAmB,IAAIC,WAAJ,CAAgB,KAAKC,OAAL,CAAaC,QAA7B,CAAnB;;AAaA,OAAKC,MAAL;AAAA,yEAAc,iBAAgBC,aAAhB;AAAA;;AAAA;AAAA;AAAA;AAAA;AACZ,mBAAKC,MAAL,GAAcD,aAAd;AADY;AAAA;AAAA;AAAA;AAAA,uDAMgBA,aANhB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAMOE,cAAAA,KANP;AAOR,mBAAKC,UAAL,CAAgB,KAAKC,cAAL,CAAoBF,KAApB,CAAhB;;AAPQ;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAsBV,mBAAKG,SAAL,GAAiB,IAAjB;AACA,mBAAKF,UAAL,CAAgB,EAAhB;AAvBU;AAAA;;AAAA;AAAA;AAAA;;AA0BV,mBAAKG,UAAL;;AA1BU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAd;;AAAA;AAAA;AAAA;AAAA;;AA8BA,OAAKC,UAAL,GAAkB,SAASC,SAAT,GAAqB,CAEtC,CAFD;;AAKA,OAAKJ,cAAL,GAAsB,UAAUF,KAAV,EAAiB;AACrC,WAAO,OAAOA,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoC,KAAKP,WAAL,CAAiBc,MAAjB,CAAwBP,KAAxB,EAA+B;AAACH,MAAAA,MAAM,EAAE;AAAT,KAA/B,CAA3C;AACD,GAFD;AAGD;;AAEDP,qBAAqB,CAACkB,SAAtB,GAAkCC,MAAM,CAACC,MAAP,CAActB,aAAa,CAACoB,SAA5B,CAAlC;AACAlB,qBAAqB,CAACkB,SAAtB,CAAgCG,WAAhC,GAA8CrB,qBAA9C","sourcesContent":["// @ts-nocheck\n// A custom papaparse `Streamer` for async iterators\n// Ideally this can be contributed back to papaparse\n// Or papaparse can expose Streamer API so we can extend without forking.\n\n/* eslint-disable no-invalid-this */\n\n// Note: papaparse is not an ES6 module\nimport Papa from './papaparse';\nconst {ChunkStreamer} = Papa;\n\nexport default function AsyncIteratorStreamer(config) {\n  config = config || {};\n\n  ChunkStreamer.call(this, config);\n\n  this.textDecoder = new TextDecoder(this._config.encoding);\n\n  // Implement ChunkStreamer base class methods\n\n  // this.pause = function() {\n  //   ChunkStreamer.prototype.pause.apply(this, arguments);\n  // };\n\n  // this.resume = function() {\n  //   ChunkStreamer.prototype.resume.apply(this, arguments);\n  //   this._input.resume();\n  // };\n\n  this.stream = async function (asyncIterator) {\n    this._input = asyncIterator;\n\n    try {\n      // ES2018 version\n      // TODO - check for pause and abort flags?\n      for await (const chunk of asyncIterator) {\n        this.parseChunk(this.getStringChunk(chunk));\n      }\n\n      // ES5 VERSION\n      // while (true) {\n      //   asyncIterator.next().then(function(value) {\n      //     if (value.done) {\n      //       // finalize iterator?\n      //     }\n      //   }\n      //   const  = await ;\n      //   if (done) return total;\n      //   total += value.length;\n      // }\n\n      this._finished = true;\n      this.parseChunk('');\n    } catch (error) {\n      // Inform ChunkStreamer base class of error\n      this._sendError(error);\n    }\n  };\n\n  this._nextChunk = function nextChunk() {\n    // Left empty, as async iterator automatically pulls next chunk\n  };\n\n  // HELPER METHODS\n  this.getStringChunk = function (chunk) {\n    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {stream: true});\n  };\n}\n\nAsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);\nAsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;\n"],"file":"async-iterator-streamer.js"}