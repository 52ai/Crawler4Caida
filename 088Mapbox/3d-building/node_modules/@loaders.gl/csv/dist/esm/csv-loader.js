import { AsyncQueue, TableBatchBuilder, convertToArrayRow, convertToObjectRow } from '@loaders.gl/schema';
import Papa from './papaparse/papaparse';
import AsyncIteratorStreamer from './papaparse/async-iterator-streamer';
const VERSION = typeof "3.2.6" !== 'undefined' ? "3.2.6" : 'latest';
const DEFAULT_CSV_LOADER_OPTIONS = {
  csv: {
    shape: 'object-row-table',
    optimizeMemoryUsage: false,
    header: 'auto',
    columnPrefix: 'column',
    quoteChar: '"',
    escapeChar: '"',
    dynamicTyping: true,
    comments: false,
    skipEmptyLines: true,
    delimitersToGuess: [',', '\t', '|', ';']
  }
};
export const CSVLoader = {
  id: 'csv',
  module: 'csv',
  name: 'CSV',
  version: VERSION,
  extensions: ['csv', 'tsv', 'dsv'],
  mimeTypes: ['text/csv', 'text/tab-separated-values', 'text/dsv'],
  category: 'table',
  parse: async (arrayBuffer, options) => parseCSV(new TextDecoder().decode(arrayBuffer), options),
  parseText: (text, options) => parseCSV(text, options),
  parseInBatches: parseCSVInBatches,
  options: DEFAULT_CSV_LOADER_OPTIONS
};

async function parseCSV(csvText, options) {
  const csvOptions = { ...DEFAULT_CSV_LOADER_OPTIONS.csv,
    ...(options === null || options === void 0 ? void 0 : options.csv)
  };
  const firstRow = readFirstRow(csvText);
  const header = csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);
  const parseWithHeader = header;
  const papaparseConfig = { ...csvOptions,
    header: parseWithHeader,
    download: false,
    transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,
    error: e => {
      throw new Error(e);
    }
  };
  const result = Papa.parse(csvText, papaparseConfig);
  let {
    data: rows
  } = result;
  const headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);

  switch (csvOptions.shape) {
    case 'object-row-table':
      rows = rows.map(row => Array.isArray(row) ? convertToObjectRow(row, headerRow) : row);
      break;

    case 'array-row-table':
      rows = rows.map(row => Array.isArray(row) ? row : convertToArrayRow(row, headerRow));
      break;

    default:
  }

  return rows;
}

function parseCSVInBatches(asyncIterator, options) {
  var _options;

  options = { ...options
  };

  if (options.batchSize === 'auto') {
    options.batchSize = 4000;
  }

  const csvOptions = { ...DEFAULT_CSV_LOADER_OPTIONS.csv,
    ...((_options = options) === null || _options === void 0 ? void 0 : _options.csv)
  };
  const asyncQueue = new AsyncQueue();
  let isFirstRow = true;
  let headerRow = null;
  let tableBatchBuilder = null;
  let schema = null;
  const config = { ...csvOptions,
    header: false,
    download: false,
    chunkSize: 1024 * 1024 * 5,
    skipEmptyLines: false,

    step(results) {
      let row = results.data;

      if (csvOptions.skipEmptyLines) {
        const collapsedRow = row.flat().join('').trim();

        if (collapsedRow === '') {
          return;
        }
      }

      const bytesUsed = results.meta.cursor;

      if (isFirstRow && !headerRow) {
        const header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);

        if (header) {
          headerRow = row.map(duplicateColumnTransformer());
          return;
        }
      }

      if (isFirstRow) {
        isFirstRow = false;

        if (!headerRow) {
          headerRow = generateHeader(csvOptions.columnPrefix, row.length);
        }

        schema = deduceSchema(row, headerRow);
      }

      if (csvOptions.optimizeMemoryUsage) {
        row = JSON.parse(JSON.stringify(row));
      }

      tableBatchBuilder = tableBatchBuilder || new TableBatchBuilder(schema, {
        shape: csvOptions.shape || 'array-row-table',
        ...options
      });

      try {
        tableBatchBuilder.addRow(row);
        const batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({
          bytesUsed
        });

        if (batch) {
          asyncQueue.enqueue(batch);
        }
      } catch (error) {
        asyncQueue.enqueue(error);
      }
    },

    complete(results) {
      try {
        const bytesUsed = results.meta.cursor;
        const batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({
          bytesUsed
        });

        if (batch) {
          asyncQueue.enqueue(batch);
        }
      } catch (error) {
        asyncQueue.enqueue(error);
      }

      asyncQueue.close();
    }

  };
  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);
  return asyncQueue;
}

function isHeaderRow(row) {
  return row && row.every(value => typeof value === 'string');
}

function readFirstRow(csvText) {
  const result = Papa.parse(csvText, {
    download: false,
    dynamicTyping: true,
    preview: 1
  });
  return result.data[0];
}

function duplicateColumnTransformer() {
  const observedColumns = new Set();
  return col => {
    let colName = col;
    let counter = 1;

    while (observedColumns.has(colName)) {
      colName = "".concat(col, ".").concat(counter);
      counter++;
    }

    observedColumns.add(colName);
    return colName;
  };
}

function generateHeader(columnPrefix, count = 0) {
  const headers = [];

  for (let i = 0; i < count; i++) {
    headers.push("".concat(columnPrefix).concat(i + 1));
  }

  return headers;
}

function deduceSchema(row, headerRow) {
  const schema = headerRow ? {} : [];

  for (let i = 0; i < row.length; i++) {
    const columnName = headerRow && headerRow[i] || i;
    const value = row[i];

    switch (typeof value) {
      case 'number':
      case 'boolean':
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Float32Array
        };
        break;

      case 'string':
      default:
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Array
        };
    }
  }

  return schema;
}

export const _typecheckCSVLoader = CSVLoader;
//# sourceMappingURL=csv-loader.js.map