{"version":3,"sources":["../../../../src/lib/parsers/parse-npy.ts"],"names":["systemIsLittleEndian","a","Uint32Array","b","Uint8Array","buffer","byteOffset","byteLength","LITTLE_ENDIAN_OS","DTYPES","u1","i1","Int8Array","u2","Uint16Array","i2","Int16Array","u4","i4","Int32Array","f4","Float32Array","f8","Float64Array","parseNPY","arrayBuffer","options","view","DataView","parseHeader","header","headerEndOffset","numpyType","descr","ArrayType","slice","console","warn","nArrayElements","shape","reduce","arrayByteLength","BYTES_PER_ELEMENT","data","majorVersion","getUint8","offset","headerLength","getUint32","getUint16","encoding","decoder","TextDecoder","headerArray","headerText","decode","JSON","parse","replace"],"mappings":"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","sourcesContent":["// import type {TextureLevel} from '@loaders.gl/schema';\n\ntype NumpyHeader = {descr: string; shape: number[]};\n\nfunction systemIsLittleEndian() {\n  const a = new Uint32Array([0x12345678]);\n  const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nconst LITTLE_ENDIAN_OS = systemIsLittleEndian();\n\n// The basic string format consists of 3 characters:\n// 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n// 2. a character code giving the basic type of the array\n// 3. an integer providing the number of bytes the type uses.\n// https://numpy.org/doc/stable/reference/arrays.interface.html\n//\n// Here I only include the second and third characters, and check endianness\n// separately\nconst DTYPES: Record<string, any> = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\n\nexport function parseNPY(arrayBuffer: ArrayBuffer, options?: unknown) {\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const view = new DataView(arrayBuffer);\n  const {header, headerEndOffset} = parseHeader(view);\n\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    // eslint-disable-next-line no-console, no-undef\n    console.warn(`Decoding of npy dtype not implemented: ${numpyType}`);\n    return null;\n  }\n\n  const nArrayElements = header.shape?.reduce((a: number, b: number): number => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  // Swap endianness if needed\n  if ((numpyType[0] === '>' && LITTLE_ENDIAN_OS) || (numpyType[0] === '<' && !LITTLE_ENDIAN_OS)) {\n    // eslint-disable-next-line no-console, no-undef\n    console.warn('Data is wrong endianness, byte swapping not yet implemented.');\n  }\n\n  return {\n    data,\n    header\n  };\n}\n\n/**\n * Parse NPY header\n *\n * @param  view\n * @return\n */\nfunction parseHeader(view: DataView): {header: NumpyHeader; headerEndOffset: number} {\n  const majorVersion = view.getUint8(6);\n  // const minorVersion = view.getUint8(7);\n\n  let offset = 8;\n  let headerLength;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(8, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(8, true);\n    offset += 2;\n  }\n\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n\n  const header = JSON.parse(\n    headerText\n      .replace(/'/g, '\"')\n      .replace('False', 'false')\n      .replace('(', '[')\n      .replace(/,*\\),*/g, ']')\n  );\n\n  return {header, headerEndOffset: offset};\n}\n"],"file":"parse-npy.js"}