{"version":3,"sources":["../../../../src/lib/texture-api/load-image-cube.ts"],"names":["GL_TEXTURE_CUBE_MAP_POSITIVE_X","GL_TEXTURE_CUBE_MAP_NEGATIVE_X","GL_TEXTURE_CUBE_MAP_POSITIVE_Y","GL_TEXTURE_CUBE_MAP_NEGATIVE_Y","GL_TEXTURE_CUBE_MAP_POSITIVE_Z","GL_TEXTURE_CUBE_MAP_NEGATIVE_Z","CUBE_FACES","face","direction","axis","sign","getImageCubeUrls","getUrl","options","urls","promises","index","i","promise","then","url","push","length","Promise","all","loadImageTextureCube","ImageLoader","parse"],"mappings":";;;;;;;;;;;;;;;;AACA;;AAEA;;AACA;;;;;;AAGA,IAAMA,8BAA8B,GAAG,MAAvC;AACA,IAAMC,8BAA8B,GAAG,MAAvC;AACA,IAAMC,8BAA8B,GAAG,MAAvC;AACA,IAAMC,8BAA8B,GAAG,MAAvC;AACA,IAAMC,8BAA8B,GAAG,MAAvC;AACA,IAAMC,8BAA8B,GAAG,MAAvC;AAEA,IAAMC,UAAU,GAAG,CACjB;AAACC,EAAAA,IAAI,EAAEP,8BAAP;AAAuCQ,EAAAA,SAAS,EAAE,OAAlD;AAA2DC,EAAAA,IAAI,EAAE,GAAjE;AAAsEC,EAAAA,IAAI,EAAE;AAA5E,CADiB,EAEjB;AAACH,EAAAA,IAAI,EAAEN,8BAAP;AAAuCO,EAAAA,SAAS,EAAE,MAAlD;AAA0DC,EAAAA,IAAI,EAAE,GAAhE;AAAqEC,EAAAA,IAAI,EAAE;AAA3E,CAFiB,EAGjB;AAACH,EAAAA,IAAI,EAAEL,8BAAP;AAAuCM,EAAAA,SAAS,EAAE,KAAlD;AAAyDC,EAAAA,IAAI,EAAE,GAA/D;AAAoEC,EAAAA,IAAI,EAAE;AAA1E,CAHiB,EAIjB;AAACH,EAAAA,IAAI,EAAEJ,8BAAP;AAAuCK,EAAAA,SAAS,EAAE,QAAlD;AAA4DC,EAAAA,IAAI,EAAE,GAAlE;AAAuEC,EAAAA,IAAI,EAAE;AAA7E,CAJiB,EAKjB;AAACH,EAAAA,IAAI,EAAEH,8BAAP;AAAuCI,EAAAA,SAAS,EAAE,OAAlD;AAA2DC,EAAAA,IAAI,EAAE,GAAjE;AAAsEC,EAAAA,IAAI,EAAE;AAA5E,CALiB,EAMjB;AAACH,EAAAA,IAAI,EAAEF,8BAAP;AAAuCG,EAAAA,SAAS,EAAE,MAAlD;AAA0DC,EAAAA,IAAI,EAAE,GAAhE;AAAqEC,EAAAA,IAAI,EAAE;AAA3E,CANiB,CAAnB;;SAoBsBC,gB;;;;;gFAAf,iBAAgCC,MAAhC,EAAgDC,OAAhD;AAAA;;AAAA;AAAA;AAAA;AAAA;AAECC,YAAAA,IAFD,GAE2C,EAF3C;AAGCC,YAAAA,QAHD,GAG4B,EAH5B;AAKDC,YAAAA,KALC,GAKO,CALP;;AAAA,mCAMIC,CANJ;AAOH,kBAAMV,IAAI,GAAGD,UAAU,CAACU,KAAD,CAAvB;AACA,kBAAME,OAAO,GAAG,6BAAaN,MAAb,EAAqBC,OAArB,kCAAkCN,IAAlC;AAAwCS,gBAAAA,KAAK,EAAEA,KAAK;AAApD,kBAAyDG,IAAzD,CAA8D,UAACC,GAAD,EAAS;AACrFN,gBAAAA,IAAI,CAACP,IAAI,CAACA,IAAN,CAAJ,GAAkBa,GAAlB;AACD,eAFe,CAAhB;AAGAL,cAAAA,QAAQ,CAACM,IAAT,CAAcH,OAAd;AAXG;;AAML,iBAASD,CAAT,GAAa,CAAb,EAAgBA,CAAC,GAAGX,UAAU,CAACgB,MAA/B,EAAuC,EAAEL,CAAzC,EAA4C;AAAA,oBAAnCA,CAAmC;AAM3C;;AAZI;AAAA,mBAcCM,OAAO,CAACC,GAAR,CAAYT,QAAZ,CAdD;;AAAA;AAAA,6CAgBED,IAhBF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAqBeW,oB;;;;;oFAAf,kBACLb,MADK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAELC,YAAAA,OAFK,8DAEK,EAFL;AAAA;AAAA,mBAIcF,gBAAgB,CAACC,MAAD,EAASC,OAAT,CAJ9B;;AAAA;AAICC,YAAAA,IAJD;AAAA;AAAA,mBAKS,wBAASA,IAAT,EAAeY,oBAAYC,KAA3B,EAAkCd,OAAlC,CALT;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["// loaders.gl, MIT license\nimport {ImageLoader} from '@loaders.gl/images';\nimport type {GetUrl, UrlOptions} from './texture-api-types';\nimport {getImageUrls} from './load-image';\nimport {deepLoad} from './deep-load';\n\n// Returned map will be have keys corresponding to GL cubemap constants\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;\n\nconst CUBE_FACES = [\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_X, direction: 'right', axis: 'x', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X, direction: 'left', axis: 'x', sign: 'negative'},\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y, direction: 'top', axis: 'y', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, direction: 'bottom', axis: 'y', sign: 'negative'},\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z, direction: 'front', axis: 'z', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, direction: 'back', axis: 'z', sign: 'negative'}\n];\n\nexport type ImageCubeTexture = {\n  GL_TEXTURE_CUBE_MAP_POSITIVE_X: any;\n  GL_TEXTURE_CUBE_MAP_NEGATIVE_X: any;\n  GL_TEXTURE_CUBE_MAP_POSITIVE_Y: any;\n  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: any;\n  GL_TEXTURE_CUBE_MAP_POSITIVE_Z: any;\n  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: any;\n};\n\n// Returns an object with six key-value pairs containing the urls (or url mip arrays)\n// for each cube face\nexport async function getImageCubeUrls(getUrl: GetUrl, options: UrlOptions) {\n  // Calculate URLs\n  const urls: Record<number, string | string[]> = {};\n  const promises: Promise<any>[] = [];\n\n  let index = 0;\n  for (let i = 0; i < CUBE_FACES.length; ++i) {\n    const face = CUBE_FACES[index];\n    const promise = getImageUrls(getUrl, options, {...face, index: index++}).then((url) => {\n      urls[face.face] = url;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return urls;\n}\n\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function loadImageTextureCube(\n  getUrl: GetUrl,\n  options = {}\n): Promise<ImageCubeTexture> {\n  const urls = await getImageCubeUrls(getUrl, options);\n  return (await deepLoad(urls, ImageLoader.parse, options)) as ImageCubeTexture;\n}\n"],"file":"load-image-cube.js"}