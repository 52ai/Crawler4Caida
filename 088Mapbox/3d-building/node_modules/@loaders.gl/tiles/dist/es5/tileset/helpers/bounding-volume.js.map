{"version":3,"sources":["../../../../src/tileset/helpers/bounding-volume.ts"],"names":["defined","x","undefined","scratchScale","Vector3","scratchNorthWest","scratchSouthEast","createBoundingVolume","boundingVolumeHeader","transform","result","box","createBox","region","west","south","east","north","minHeight","maxHeight","northWest","Ellipsoid","WGS84","cartographicToCartesian","southEast","centerInCartesian","addVectors","multiplyScalar","radius","subVectors","len","createSphere","Matrix4","sphere","Error","center","origin","length","halfSize","slice","quaternion","Quaternion","fromArray","y","z","transformByQuaternion","scale","toArray","xAxis","transformAsVector","yAxis","zAxis","halfAxes","Matrix3","OrientedBoundingBox","getScale","uniformScale","Math","max","BoundingSphere"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Quaternion, Vector3, Matrix3, Matrix4, degrees} from '@math.gl/core';\nimport {BoundingSphere, OrientedBoundingBox} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {assert} from '@loaders.gl/loader-utils';\n\n// const scratchProjectedBoundingSphere = new BoundingSphere();\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n// const scratchMatrix = new Matrix3();\nconst scratchScale = new Vector3();\nconst scratchNorthWest = new Vector3();\nconst scratchSouthEast = new Vector3();\n// const scratchRectangle = new Rectangle();\n// const scratchOrientedBoundingBox = new OrientedBoundingBox();\n// const scratchTransform = new Matrix4();\n\n/**\n * Create a bounding volume from the tile's bounding volume header.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param [result] The object onto which to store the result.\n * @returns The modified result parameter or a new TileBoundingVolume instance if none was provided.\n */\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n\n  // boundingVolume schema:\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n  if (boundingVolumeHeader.region) {\n    // [west, south, east, north, minimum height, maximum height]\n    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n    // Heights are in meters above (or below) the WGS 84 ellipsoid.\n    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n\n    const northWest = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(west), degrees(north), minHeight],\n      scratchNorthWest\n    );\n    const southEast = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(east), degrees(south), maxHeight],\n      scratchSouthEast\n    );\n    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    const radius = new Vector3().subVectors(northWest, southEast).len() / 2.0;\n\n    // TODO improve region boundingVolume\n    // for now, create a sphere as the boundingVolume instead of box\n    return createSphere(\n      [centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius],\n      new Matrix4()\n    );\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n\nfunction createBox(box, transform, result) {\n  // https://math.gl/modules/culling/docs/api-reference/oriented-bounding-box\n  // 1. A half-axes based representation.\n  // box: An array of 12 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box.\n  // The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.\n  // The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.\n  // The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.\n  // 2. A half-size-quaternion based representation.\n  // box: An array of 10 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box in a right-handed 3-axis (x, y, z) Cartesian coordinate system where the z-axis is up.\n  // The next three elements (with indices 3, 4, and 5) define the halfSize.\n  // The last four elements (indices 6, 7, 8 and 10) define the quaternion.\n  const center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n  let origin: number[] = [];\n  if (box.length === 10) {\n    const halfSize = box.slice(3, 6);\n    const quaternion = new Quaternion();\n    quaternion.fromArray(box, 6);\n    const x = new Vector3([1, 0, 0]);\n    const y = new Vector3([0, 1, 0]);\n    const z = new Vector3([0, 0, 1]);\n    x.transformByQuaternion(quaternion);\n    x.scale(halfSize[0]);\n    y.transformByQuaternion(quaternion);\n    y.scale(halfSize[1]);\n    z.transformByQuaternion(quaternion);\n    z.scale(halfSize[2]);\n    origin = [...x.toArray(), ...y.toArray(), ...z.toArray()];\n  } else {\n    origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];\n  }\n  const xAxis = transform.transformAsVector(origin.slice(0, 3));\n  const yAxis = transform.transformAsVector(origin.slice(3, 6));\n  const zAxis = transform.transformAsVector(origin.slice(6, 9));\n  const halfAxes = new Matrix3([\n    xAxis[0],\n    xAxis[1],\n    xAxis[2],\n    yAxis[0],\n    yAxis[1],\n    yAxis[2],\n    zAxis[0],\n    zAxis[1],\n    zAxis[2]\n  ]);\n\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n\n  return new OrientedBoundingBox(center, halfAxes);\n}\n\n/*\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    Ellipsoid.WGS84,\n    scratchOrientedBoundingBox\n  );\n  const center = orientedBoundingBox.center;\n  const halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.inverseTransformation(initialTransform, scratchTransform),\n    scratchTransform\n  );\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n*/\n\nfunction createSphere(sphere, transform, result?) {\n  // Find the transformed center\n  const center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  const scale = transform.getScale(scratchScale);\n\n  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  const radius = sphere[3] * uniformScale;\n\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n\n  return new BoundingSphere(center, radius);\n}\n"],"file":"bounding-volume.js"}