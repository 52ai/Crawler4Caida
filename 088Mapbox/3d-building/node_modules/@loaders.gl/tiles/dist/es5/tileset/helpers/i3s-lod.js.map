{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.ts"],"names":["cameraPositionCartesian","Vector3","toEye","cameraPositionEnu","extraVertexEnu","projectedOriginVector","enuToCartesianMatrix","Matrix4","cartesianToEnuMatrix","getLodStatus","tile","frameState","lodMetricValue","isNaN","screenSize","getProjectedRadius","header","children","viewport","topDownViewport","mbsLat","mbs","mbsLon","mbsZ","mbsR","mbsCenterCartesian","boundingVolume","center","cameraPositionCartographic","unprojectPosition","cameraPosition","Ellipsoid","WGS84","cartographicToCartesian","copy","subtract","normalize","eastNorthUpToFixedFrame","invert","transform","projection","Math","sqrt","extraZ","extraVertexCartesian","extraVectorCartesian","radiusVector","cross","scale","sphereMbsBorderVertexCartesian","add","sphereMbsBorderVertexCartographic","cartesianToCartographic","projectedOrigin","project","projectedMbsBorderVertex","projectedRadius","magnitude"],"mappings":";;;;;;;;;;;;AAAA;;AACA;;AAIA,IAAMA,uBAAuB,GAAG,IAAIC,aAAJ,EAAhC;AACA,IAAMC,KAAK,GAAG,IAAID,aAAJ,EAAd;AACA,IAAME,iBAAiB,GAAG,IAAIF,aAAJ,EAA1B;AACA,IAAMG,cAAc,GAAG,IAAIH,aAAJ,EAAvB;AACA,IAAMI,qBAAqB,GAAG,IAAIJ,aAAJ,EAA9B;AACA,IAAMK,oBAAoB,GAAG,IAAIC,aAAJ,EAA7B;AACA,IAAMC,oBAAoB,GAAG,IAAID,aAAJ,EAA7B;;AAWO,SAASE,YAAT,CAAsBC,IAAtB,EAAoCC,UAApC,EAAoF;AACzF,MAAID,IAAI,CAACE,cAAL,KAAwB,CAAxB,IAA6BC,KAAK,CAACH,IAAI,CAACE,cAAN,CAAtC,EAA6D;AAC3D,WAAO,KAAP;AACD;;AACD,MAAME,UAAU,GAAG,IAAIC,kBAAkB,CAACL,IAAD,EAAOC,UAAP,CAAzC;;AACA,MAAIG,UAAU,GAAG,CAAjB,EAAoB;AAClB,WAAO,KAAP;AACD;;AACD,MAAI,CAACJ,IAAI,CAACM,MAAL,CAAYC,QAAb,IAAyBH,UAAU,IAAIJ,IAAI,CAACE,cAAhD,EAAgE;AAC9D,WAAO,MAAP;AACD,GAFD,MAEO,IAAIF,IAAI,CAACM,MAAL,CAAYC,QAAhB,EAA0B;AAC/B,WAAO,KAAP;AACD;;AACD,SAAO,KAAP;AACD;;AASM,SAASF,kBAAT,CAA4BL,IAA5B,EAA0CC,UAA1C,EAA0E;AAC/E,MAAwBO,QAAxB,GAAoCP,UAApC,CAAOQ,eAAP;AACA,MAAMC,MAAM,GAAGV,IAAI,CAACM,MAAL,CAAYK,GAAZ,CAAgB,CAAhB,CAAf;AACA,MAAMC,MAAM,GAAGZ,IAAI,CAACM,MAAL,CAAYK,GAAZ,CAAgB,CAAhB,CAAf;AACA,MAAME,IAAI,GAAGb,IAAI,CAACM,MAAL,CAAYK,GAAZ,CAAgB,CAAhB,CAAb;AACA,MAAMG,IAAI,GAAGd,IAAI,CAACM,MAAL,CAAYK,GAAZ,CAAgB,CAAhB,CAAb;AACA,MAAMI,kBAAkB,oCAAOf,IAAI,CAACgB,cAAL,CAAoBC,MAA3B,CAAxB;AACA,MAAMC,0BAA0B,GAAGV,QAAQ,CAACW,iBAAT,CAA2BX,QAAQ,CAACY,cAApC,CAAnC;;AACAC,wBAAUC,KAAV,CAAgBC,uBAAhB,CAAwCL,0BAAxC,EAAoE5B,uBAApE;;AAKAE,EAAAA,KAAK,CAACgC,IAAN,CAAWlC,uBAAX,EAAoCmC,QAApC,CAA6CV,kBAA7C,EAAiEW,SAAjE;;AAEAL,wBAAUC,KAAV,CAAgBK,uBAAhB,CAAwCZ,kBAAxC,EAA4DnB,oBAA5D;;AACAE,EAAAA,oBAAoB,CAAC0B,IAArB,CAA0B5B,oBAA1B,EAAgDgC,MAAhD;AACAnC,EAAAA,iBAAiB,CAAC+B,IAAlB,CAAuBlC,uBAAvB,EAAgDuC,SAAhD,CAA0D/B,oBAA1D;AAGA,MAAMgC,UAAU,GAAGC,IAAI,CAACC,IAAL,CACjBvC,iBAAiB,CAAC,CAAD,CAAjB,GAAuBA,iBAAiB,CAAC,CAAD,CAAxC,GAA8CA,iBAAiB,CAAC,CAAD,CAAjB,GAAuBA,iBAAiB,CAAC,CAAD,CADrE,CAAnB;AAGA,MAAMwC,MAAM,GAAIH,UAAU,GAAGA,UAAd,GAA4BrC,iBAAiB,CAAC,CAAD,CAA5D;AACAC,EAAAA,cAAc,CAAC8B,IAAf,CAAoB,CAAC/B,iBAAiB,CAAC,CAAD,CAAlB,EAAuBA,iBAAiB,CAAC,CAAD,CAAxC,EAA6CwC,MAA7C,CAApB;AACA,MAAMC,oBAAoB,GAAGxC,cAAc,CAACmC,SAAf,CAAyBjC,oBAAzB,CAA7B;AACA,MAAMuC,oBAAoB,GAAGD,oBAAoB,CAACT,QAArB,CAA8BV,kBAA9B,EAAkDW,SAAlD,EAA7B;AAEA,MAAMU,YAAY,GAAG5C,KAAK,CAAC6C,KAAN,CAAYF,oBAAZ,EAAkCT,SAAlC,GAA8CY,KAA9C,CAAoDxB,IAApD,CAArB;AACA,MAAMyB,8BAA8B,GAAGH,YAAY,CAACI,GAAb,CAAiBzB,kBAAjB,CAAvC;;AACA,MAAM0B,iCAAiC,GAAGpB,sBAAUC,KAAV,CAAgBoB,uBAAhB,CACxCH,8BADwC,CAA1C;;AAMA,MAAMI,eAAe,GAAGnC,QAAQ,CAACoC,OAAT,CAAiB,CAAChC,MAAD,EAASF,MAAT,EAAiBG,IAAjB,CAAjB,CAAxB;AACA,MAAMgC,wBAAwB,GAAGrC,QAAQ,CAACoC,OAAT,CAC/BH,iCAD+B,CAAjC;AAGA,MAAMK,eAAe,GAAGnD,qBAAqB,CAC1C6B,IADqB,CAChBmB,eADgB,EAErBlB,QAFqB,CAEZoB,wBAFY,EAGrBE,SAHqB,EAAxB;AAIA,SAAOD,eAAP;AACD","sourcesContent":["import {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport Tile3D from '../tile-3d';\nimport {FrameState} from './frame-state';\n\nconst cameraPositionCartesian = new Vector3();\nconst toEye = new Vector3();\nconst cameraPositionEnu = new Vector3();\nconst extraVertexEnu = new Vector3();\nconst projectedOriginVector = new Vector3();\nconst enuToCartesianMatrix = new Matrix4();\nconst cartesianToEnuMatrix = new Matrix4();\n\n/**\n * For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n   as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n   In this sense a value of 0 means you should always load it's children,\n   or if it's a leaf node, you should always display it.\n * @param tile \n * @param frameState \n * @returns \n */\nexport function getLodStatus(tile: Tile3D, frameState: FrameState): 'DIG' | 'OUT' | 'DRAW' {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/**\n * Calculate size of MBS radius projected on the screen plane\n * @param tile\n * @param frameState\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function getProjectedRadius(tile: Tile3D, frameState: FrameState): number {\n  const {topDownViewport: viewport} = frameState;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);\n\n  // ---------------------------\n  // Calculate mbs border vertex\n  // ---------------------------\n  toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  // Add extra vector to form plane\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();\n  cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  // Mean Proportionals in Right Triangles - Altitude rule\n  // https://mathbitsnotebook.com/Geometry/RightTriangles/RTmeanRight.html\n  const projection = Math.sqrt(\n    cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]\n  );\n  const extraZ = (projection * projection) / cameraPositionEnu[2];\n  extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();\n  // We need radius vector orthogonal to toEye vector\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(\n    sphereMbsBorderVertexCartesian\n  );\n  // ---------------------------\n\n  // Project center vertex and border vertex and calculate projected radius of MBS\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(\n    sphereMbsBorderVertexCartographic as [number, number, number]\n  );\n  const projectedRadius = projectedOriginVector\n    .copy(projectedOrigin)\n    .subtract(projectedMbsBorderVertex)\n    .magnitude();\n  return projectedRadius;\n}\n"],"file":"i3s-lod.js"}