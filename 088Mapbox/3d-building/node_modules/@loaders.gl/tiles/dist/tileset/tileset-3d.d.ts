import { Matrix4, Vector3 } from '@math.gl/core';
import { Stats } from '@probe.gl/stats';
import { RequestScheduler, LoaderWithParser, LoaderOptions } from '@loaders.gl/loader-utils';
import { FrameState } from './helpers/frame-state';
import Tile3D from './tile-3d';
import TilesetTraverser from './traversers/tileset-traverser';
import { Viewport } from '../types';
export declare type Tileset3DProps = {
    throttleRequests?: boolean;
    maxRequests?: number;
    loadOptions?: LoaderOptions;
    loadTiles?: boolean;
    basePath?: string;
    maximumMemoryUsage?: number;
    maximumTilesSelected?: number;
    debounceTime?: number;
    description?: string;
    attributions?: string[];
    ellipsoid?: object;
    modelMatrix?: Matrix4;
    maximumScreenSpaceError?: number;
    viewportTraversersMap?: any;
    updateTransforms?: boolean;
    viewDistanceScale?: number;
    onTileLoad?: (tile: Tile3D) => any;
    onTileUnload?: (tile: Tile3D) => any;
    onTileError?: (tile: Tile3D, message: string, url: string) => any;
    contentLoader?: (tile: Tile3D) => Promise<void>;
    onTraversalComplete?: (selectedTiles: Tile3D[]) => Tile3D[];
};
declare type Props = {
    description: string;
    ellipsoid: object;
    modelMatrix: Matrix4;
    throttleRequests: boolean;
    maximumMemoryUsage: number;
    maximumTilesSelected: number;
    debounceTime: number;
    onTileLoad: (tile: Tile3D) => any;
    onTileUnload: (tile: Tile3D) => any;
    onTileError: (tile: Tile3D, message: string, url: string) => any;
    onTraversalComplete: (selectedTiles: Tile3D[]) => Tile3D[];
    maximumScreenSpaceError: number;
    viewportTraversersMap: any;
    attributions: string[];
    maxRequests: number;
    loadTiles: boolean;
    loadOptions: LoaderOptions;
    updateTransforms: boolean;
    viewDistanceScale: number;
    basePath: string;
    contentLoader?: (tile: Tile3D) => Promise<void>;
    i3s: {
        [key: string]: any;
    };
};
export default class Tileset3D {
    options: Props;
    loadOptions: {
        [key: string]: any;
    };
    type: string;
    tileset: {
        [key: string]: any;
    };
    loader: LoaderWithParser;
    url: string;
    basePath: string;
    modelMatrix: Matrix4;
    ellipsoid: any;
    lodMetricType: string;
    lodMetricValue: number;
    refine: string;
    root: Tile3D | null;
    roots: {
        [key: string]: Tile3D;
    };
    asset: {
        [key: string]: any;
    };
    description: string;
    properties: any;
    extras: any;
    attributions: any;
    credits: any;
    stats: Stats;
    traverseCounter: number;
    geometricError: number;
    selectedTiles: Tile3D[];
    private updatePromise;
    tilesetInitializationPromise: Promise<void>;
    cartographicCenter: Vector3 | null;
    cartesianCenter: Vector3 | null;
    zoom: number;
    boundingVolume: any;
    gpuMemoryUsageInBytes: any;
    dynamicScreenSpaceErrorComputedDensity: any;
    _traverser: TilesetTraverser;
    private _cache;
    _requestScheduler: RequestScheduler;
    _frameNumber: number;
    private _queryParamsString;
    private _queryParams;
    private _extensionsUsed;
    private _tiles;
    private _pendingCount;
    private lastUpdatedVieports;
    private _requestedTiles;
    private _emptyTiles;
    private frameStateData;
    maximumMemoryUsage: number;
    /**
     * Create a new Tileset3D
     * @param json
     * @param props
     */
    constructor(json: any, options?: Tileset3DProps);
    /** Release resources */
    destroy(): void;
    /** Is the tileset loaded (update needs to have been called at least once) */
    isLoaded(): boolean;
    get tiles(): object[];
    get frameNumber(): number;
    get queryParams(): string;
    setProps(props: Tileset3DProps): void;
    /** @deprecated */
    setOptions(options: Tileset3DProps): void;
    /**
     * Return a loadable tile url for a specific tile subpath
     * @param tilePath a tile subpath
     */
    getTileUrl(tilePath: string): string;
    hasExtension(extensionName: string): boolean;
    /**
     * Update visible tiles relying on a list of viewports
     * @param viewports - list of viewports
     * @deprecated
     */
    update(viewports?: Viewport[] | Viewport | null): void;
    /**
     * Update visible tiles relying on a list of viewports.
     * Do it with debounce delay to prevent update spam
     * @param viewports viewports
     * @returns Promise of new frameNumber
     */
    selectTiles(viewports?: Viewport[] | Viewport | null): Promise<number>;
    /**
     * Update visible tiles relying on a list of viewports
     * @param viewports viewports
     */
    private doUpdate;
    /**
     * Check if traversal is needed for particular viewport
     * @param {string} viewportId - id of a viewport
     * @return {boolean}
     */
    _needTraverse(viewportId: string): boolean;
    /**
     * The callback to post-process tiles after traversal procedure
     * @param frameState - frame state for tile culling
     */
    _onTraversalEnd(frameState: FrameState): void;
    /**
     * Update tiles relying on data from all traversers
     */
    _updateTiles(): void;
    _tilesChanged(oldSelectedTiles: any, selectedTiles: any): boolean;
    _loadTiles(): void;
    _unloadTiles(): void;
    _updateStats(): void;
    _initializeTileSet(tilesetJson: any): Promise<void>;
    /**
     * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
     * These metrics help apps center view on tileset
     * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
     * @returns
     */
    private calculateViewPropsI3S;
    /**
     * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
     * These metrics help apps center view on tileset.
     * For 3DTiles the root tile data is used to calculate view props.
     * @returns
     */
    private calculateViewPropsTiles3D;
    _initializeStats(): void;
    _initializeTileHeaders(tilesetJson: any, parentTileHeader: any): Tile3D;
    _initializeTraverser(): any;
    _destroyTileHeaders(parentTile: any): void;
    _loadTile(tile: any): Promise<void>;
    _onTileLoadError(tile: any, error: any): void;
    _onTileLoad(tile: any, loaded: any): void;
    _onStartTileLoading(): void;
    _onEndTileLoading(): void;
    _addTileToCache(tile: any): void;
    _updateCacheStats(tile: any): void;
    _unloadTile(tile: any): void;
    _destroy(): void;
    _destroySubtree(tile: any): void;
    _destroyTile(tile: any): void;
    _initializeTiles3DTileset(tilesetJson: any): void;
    _initializeI3STileset(): void;
}
export {};
//# sourceMappingURL=tileset-3d.d.ts.map