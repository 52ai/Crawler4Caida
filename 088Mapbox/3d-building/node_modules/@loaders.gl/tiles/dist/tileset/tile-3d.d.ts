import { Matrix4 } from '@math.gl/core';
import { FrameState } from './helpers/frame-state';
import type Tileset3D from './tileset-3d';
/**
 * @param tileset - Tileset3D instance
 * @param header - tile header - JSON loaded from a dataset
 * @param parentHeader - parent TileHeader instance
 * @param extendedId - optional ID to separate copies of a tile for different viewports.
 *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
 */
export declare type TileHeaderProps = {
    tileset: Tileset3D;
    header: Object;
    parentHeader: TileHeader;
    extendedId: string;
};
/**
 * A Tile3DHeader represents a tile as Tileset3D. When a tile is first created, its content is not loaded;
 * the content is loaded on-demand when needed based on the view.
 * Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.
 */
export default class TileHeader {
    tileset: Tileset3D;
    header: any;
    id: string;
    url: string;
    parent: TileHeader;
    refine: number;
    type: string;
    contentUrl: string;
    lodMetricType: string;
    lodMetricValue: number;
    boundingVolume: any;
    content: any;
    contentState: any;
    gpuMemoryUsageInBytes: number;
    children: TileHeader[];
    depth: number;
    viewportIds: any[];
    transform: Matrix4;
    extensions: any;
    userData: {
        [key: string]: any;
    };
    computedTransform: any;
    hasEmptyContent: boolean;
    hasTilesetContent: boolean;
    traverser: object;
    private _cacheNode;
    private _frameNumber;
    private _lodJudge;
    private _expireDate;
    private _expiredContent;
    private _shouldRefine;
    private _distanceToCamera;
    private _centerZDepth;
    private _screenSpaceError;
    private _visibilityPlaneMask;
    private _visible?;
    private _inRequestVolume;
    private _stackLength;
    private _selectionDepth;
    private _touchedFrame;
    private _visitedFrame;
    private _selectedFrame;
    private _requestedFrame;
    private _priority;
    private _contentBoundingVolume;
    private _viewerRequestVolume;
    _initialTransform: Matrix4;
    /**
     * @constructs
     * Create a TileHeader instance
     * @param tileset - Tileset3D instance
     * @param header - tile header - JSON loaded from a dataset
     * @param parentHeader - parent TileHeader instance
     * @param extendedId - optional ID to separate copies of a tile for different viewports.
     *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
     */
    constructor(tileset: Tileset3D, header: {
        [key: string]: any;
    }, parentHeader?: TileHeader, extendedId?: string);
    destroy(): void;
    isDestroyed(): boolean;
    get selected(): boolean;
    get isVisible(): boolean | undefined;
    get isVisibleAndInRequestVolume(): boolean | undefined;
    /** Returns true if tile is not an empty tile and not an external tileset */
    get hasRenderContent(): boolean;
    /** Returns true if tile has children */
    get hasChildren(): any;
    /**
     * Determines if the tile's content is ready. This is automatically `true` for
     * tiles with empty content.
     */
    get contentReady(): boolean;
    /**
     * Determines if the tile has available content to render.  `true` if the tile's
     * content is ready or if it has expired content this renders while new content loads; otherwise,
     */
    get contentAvailable(): boolean;
    /** Returns true if tile has renderable content but it's unloaded */
    get hasUnloadedContent(): boolean;
    /**
     * Determines if the tile's content has not be requested. `true` if tile's
     * content has not be requested; otherwise, `false`.
     */
    get contentUnloaded(): boolean;
    /**
     * Determines if the tile's content is expired. `true` if tile's
     * content is expired; otherwise, `false`.
     */
    get contentExpired(): boolean;
    get contentFailed(): boolean;
    /** Get the tile's screen space error. */
    getScreenSpaceError(frameState: any, useParentLodMetric: any): number;
    /**
     * Make tile unselected than means it won't be shown
     * but it can be still loaded in memory
     */
    unselect(): void;
    _getPriority(): number;
    /**
     *  Requests the tile's content.
     * The request may not be made if the Request Scheduler can't prioritize it.
     */
    loadContent(): Promise<boolean>;
    unloadContent(): boolean;
    /**
     * Update the tile's visibility
     * @param {Object} frameState - frame state for tile culling
     * @param {string[]} viewportIds - a list of viewport ids that show this tile
     * @return {void}
     */
    updateVisibility(frameState: any, viewportIds: any): void;
    visibility(frameState: any, parentVisibilityPlaneMask: any): any;
    contentVisibility(): boolean;
    /**
     * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
     * @param frameState The frame state.
     * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
     */
    distanceToTile(frameState: FrameState): number;
    /**
     * Computes the tile's camera-space z-depth.
     * @param frameState The frame state.
     * @returns The distance, in meters.
     */
    cameraSpaceZDepth({ camera }: {
        camera: any;
    }): number;
    /**
     * Checks if the camera is inside the viewer request volume.
     * @param {FrameState} frameState The frame state.
     * @returns {Boolean} Whether the camera is inside the volume.
     */
    insideViewerRequestVolume(frameState: FrameState): boolean;
    updateExpiration(): void;
    get extras(): any;
    _initializeLodMetric(header: any): void;
    _initializeTransforms(tileHeader: any): void;
    _initializeBoundingVolumes(tileHeader: any): void;
    _initializeContent(tileHeader: any): void;
    _initializeRenderingState(header: any): void;
    _getRefine(refine: any): any;
    _isTileset(): boolean;
    _onContentLoaded(): void;
    _updateBoundingVolume(header: any): void;
    _updateTransform(parentTransform?: Matrix4): void;
    _getLoaderSpecificOptions(loaderId: any): {
        assetGltfUpAxis: any;
    } | {
        tile: any;
        tileset: {
            [key: string]: any;
        };
        isTileHeader: boolean;
    };
}
//# sourceMappingURL=tile-3d.d.ts.map