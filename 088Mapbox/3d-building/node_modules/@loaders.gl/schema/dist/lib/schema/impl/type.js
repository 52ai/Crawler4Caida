"use strict";
// This code is adapted from ArrowJS https://github.com/apache/arrow
// under Apache license http://www.apache.org/licenses/LICENSE-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.Struct = exports.FixedSizeList = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.DateMillisecond = exports.DateDay = exports.Date = exports.Utf8 = exports.Binary = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = exports.Type = void 0;
const enum_1 = require("./enum");
var enum_2 = require("./enum");
Object.defineProperty(exports, "Type", { enumerable: true, get: function () { return enum_2.Type; } });
class DataType {
    static isNull(x) {
        return x && x.typeId === enum_1.Type.Null;
    }
    static isInt(x) {
        return x && x.typeId === enum_1.Type.Int;
    }
    static isFloat(x) {
        return x && x.typeId === enum_1.Type.Float;
    }
    static isBinary(x) {
        return x && x.typeId === enum_1.Type.Binary;
    }
    static isUtf8(x) {
        return x && x.typeId === enum_1.Type.Utf8;
    }
    static isBool(x) {
        return x && x.typeId === enum_1.Type.Bool;
    }
    static isDecimal(x) {
        return x && x.typeId === enum_1.Type.Decimal;
    }
    static isDate(x) {
        return x && x.typeId === enum_1.Type.Date;
    }
    static isTime(x) {
        return x && x.typeId === enum_1.Type.Time;
    }
    static isTimestamp(x) {
        return x && x.typeId === enum_1.Type.Timestamp;
    }
    static isInterval(x) {
        return x && x.typeId === enum_1.Type.Interval;
    }
    static isList(x) {
        return x && x.typeId === enum_1.Type.List;
    }
    static isStruct(x) {
        return x && x.typeId === enum_1.Type.Struct;
    }
    static isUnion(x) {
        return x && x.typeId === enum_1.Type.Union;
    }
    static isFixedSizeBinary(x) {
        return x && x.typeId === enum_1.Type.FixedSizeBinary;
    }
    static isFixedSizeList(x) {
        return x && x.typeId === enum_1.Type.FixedSizeList;
    }
    static isMap(x) {
        return x && x.typeId === enum_1.Type.Map;
    }
    static isDictionary(x) {
        return x && x.typeId === enum_1.Type.Dictionary;
    }
    get typeId() {
        return enum_1.Type.NONE;
    }
    // get ArrayType(): AnyArrayType {
    //   return Int8Array;
    // }
    // get ArrayType() { return Array; }
    compareTo(other) {
        // TODO
        return this === other; // comparer.visit(this, other);
    }
}
exports.DataType = DataType;
// NULL
class Null extends DataType {
    get typeId() {
        return enum_1.Type.Null;
    }
    get [Symbol.toStringTag]() {
        return 'Null';
    }
    toString() {
        return 'Null';
    }
}
exports.Null = Null;
// BOOLEANS
class Bool extends DataType {
    get typeId() {
        return enum_1.Type.Bool;
    }
    // get ArrayType() {
    //   return Uint8Array;
    // }
    get [Symbol.toStringTag]() {
        return 'Bool';
    }
    toString() {
        return 'Bool';
    }
}
exports.Bool = Bool;
// INTS
class Int extends DataType {
    constructor(isSigned, bitWidth) {
        super();
        this.isSigned = isSigned;
        this.bitWidth = bitWidth;
    }
    get typeId() {
        return enum_1.Type.Int;
    }
    // get ArrayType() {
    //   switch (this.bitWidth) {
    //     case 8:
    //       return this.isSigned ? Int8Array : Uint8Array;
    //     case 16:
    //       return this.isSigned ? Int16Array : Uint16Array;
    //     case 32:
    //       return this.isSigned ? Int32Array : Uint32Array;
    //     case 64:
    //       return this.isSigned ? Int32Array : Uint32Array;
    //     default:
    //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    //   }
    // }
    get [Symbol.toStringTag]() {
        return 'Int';
    }
    toString() {
        return `${this.isSigned ? 'I' : 'Ui'}nt${this.bitWidth}`;
    }
}
exports.Int = Int;
class Int8 extends Int {
    constructor() {
        super(true, 8);
    }
}
exports.Int8 = Int8;
class Int16 extends Int {
    constructor() {
        super(true, 16);
    }
}
exports.Int16 = Int16;
class Int32 extends Int {
    constructor() {
        super(true, 32);
    }
}
exports.Int32 = Int32;
class Int64 extends Int {
    constructor() {
        super(true, 64);
    }
}
exports.Int64 = Int64;
class Uint8 extends Int {
    constructor() {
        super(false, 8);
    }
}
exports.Uint8 = Uint8;
class Uint16 extends Int {
    constructor() {
        super(false, 16);
    }
}
exports.Uint16 = Uint16;
class Uint32 extends Int {
    constructor() {
        super(false, 32);
    }
}
exports.Uint32 = Uint32;
class Uint64 extends Int {
    constructor() {
        super(false, 64);
    }
}
exports.Uint64 = Uint64;
// FLOATS
const Precision = {
    HALF: 16,
    SINGLE: 32,
    DOUBLE: 64
};
class Float extends DataType {
    constructor(precision) {
        super();
        this.precision = precision;
    }
    get typeId() {
        return enum_1.Type.Float;
    }
    // get ArrayType() {
    //   switch (this.precision) {
    //     case Precision.HALF:
    //       return Uint16Array;
    //     case Precision.SINGLE:
    //       return Float32Array;
    //     case Precision.DOUBLE:
    //       return Float64Array;
    //     default:
    //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    //   }
    // }
    get [Symbol.toStringTag]() {
        return 'Float';
    }
    toString() {
        return `Float${this.precision}`;
    }
}
exports.Float = Float;
class Float16 extends Float {
    constructor() {
        super(Precision.HALF);
    }
}
exports.Float16 = Float16;
class Float32 extends Float {
    constructor() {
        super(Precision.SINGLE);
    }
}
exports.Float32 = Float32;
class Float64 extends Float {
    constructor() {
        super(Precision.DOUBLE);
    }
}
exports.Float64 = Float64;
class Binary extends DataType {
    constructor() {
        super();
    }
    get typeId() {
        return enum_1.Type.Binary;
    }
    toString() {
        return 'Binary';
    }
    get [Symbol.toStringTag]() {
        return 'Binary';
    }
}
exports.Binary = Binary;
// STRINGS
class Utf8 extends DataType {
    get typeId() {
        return enum_1.Type.Utf8;
    }
    // get ArrayType() {
    //   return Uint8Array;
    // }
    get [Symbol.toStringTag]() {
        return 'Utf8';
    }
    toString() {
        return 'Utf8';
    }
}
exports.Utf8 = Utf8;
// DATES, TIMES AND INTERVALS
const DateUnit = {
    DAY: 0,
    MILLISECOND: 1
};
class Date extends DataType {
    constructor(unit) {
        super();
        this.unit = unit;
    }
    get typeId() {
        return enum_1.Type.Date;
    }
    // get ArrayType() {
    //   return Int32Array;
    // }
    get [Symbol.toStringTag]() {
        return 'Date';
    }
    toString() {
        return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
    }
}
exports.Date = Date;
class DateDay extends Date {
    constructor() {
        super(DateUnit.DAY);
    }
}
exports.DateDay = DateDay;
class DateMillisecond extends Date {
    constructor() {
        super(DateUnit.MILLISECOND);
    }
}
exports.DateMillisecond = DateMillisecond;
const TimeUnit = {
    SECOND: 1,
    MILLISECOND: 1e3,
    MICROSECOND: 1e6,
    NANOSECOND: 1e9
};
class Time extends DataType {
    constructor(unit, bitWidth) {
        super();
        this.unit = unit;
        this.bitWidth = bitWidth;
    }
    get typeId() {
        return enum_1.Type.Time;
    }
    toString() {
        return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
    }
    get [Symbol.toStringTag]() {
        return 'Time';
    }
}
exports.Time = Time;
class TimeSecond extends Time {
    constructor() {
        super(TimeUnit.SECOND, 32);
    }
}
exports.TimeSecond = TimeSecond;
class TimeMillisecond extends Time {
    constructor() {
        super(TimeUnit.MILLISECOND, 32);
    }
}
exports.TimeMillisecond = TimeMillisecond;
// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }
// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }
class Timestamp extends DataType {
    constructor(unit, timezone = null) {
        super();
        this.unit = unit;
        this.timezone = timezone;
    }
    get typeId() {
        return enum_1.Type.Timestamp;
    }
    // get ArrayType() {
    //   return Int32Array;
    // }
    get [Symbol.toStringTag]() {
        return 'Timestamp';
    }
    toString() {
        return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ''}>`;
    }
}
exports.Timestamp = Timestamp;
class TimestampSecond extends Timestamp {
    constructor(timezone = null) {
        super(TimeUnit.SECOND, timezone);
    }
}
exports.TimestampSecond = TimestampSecond;
class TimestampMillisecond extends Timestamp {
    constructor(timezone = null) {
        super(TimeUnit.MILLISECOND, timezone);
    }
}
exports.TimestampMillisecond = TimestampMillisecond;
class TimestampMicrosecond extends Timestamp {
    constructor(timezone = null) {
        super(TimeUnit.MICROSECOND, timezone);
    }
}
exports.TimestampMicrosecond = TimestampMicrosecond;
class TimestampNanosecond extends Timestamp {
    constructor(timezone = null) {
        super(TimeUnit.NANOSECOND, timezone);
    }
}
exports.TimestampNanosecond = TimestampNanosecond;
const IntervalUnit = {
    DAY_TIME: 0,
    YEAR_MONTH: 1
};
class Interval extends DataType {
    constructor(unit) {
        super();
        this.unit = unit;
    }
    get typeId() {
        return enum_1.Type.Interval;
    }
    // get ArrayType() {
    //   return Int32Array;
    // }
    get [Symbol.toStringTag]() {
        return 'Interval';
    }
    toString() {
        return `Interval<${IntervalUnit[this.unit]}>`;
    }
}
exports.Interval = Interval;
class IntervalDayTime extends Interval {
    constructor() {
        super(IntervalUnit.DAY_TIME);
    }
}
exports.IntervalDayTime = IntervalDayTime;
class IntervalYearMonth extends Interval {
    constructor() {
        super(IntervalUnit.YEAR_MONTH);
    }
}
exports.IntervalYearMonth = IntervalYearMonth;
class FixedSizeList extends DataType {
    constructor(listSize, child) {
        super();
        this.listSize = listSize;
        this.children = [child];
    }
    get typeId() {
        return enum_1.Type.FixedSizeList;
    }
    get valueType() {
        return this.children[0].type;
    }
    get valueField() {
        return this.children[0];
    }
    // get ArrayType() {
    //   return this.valueType.ArrayType;
    // }
    get [Symbol.toStringTag]() {
        return 'FixedSizeList';
    }
    toString() {
        return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
    }
}
exports.FixedSizeList = FixedSizeList;
class Struct extends DataType {
    constructor(children) {
        super();
        this.children = children;
    }
    get typeId() {
        return enum_1.Type.Struct;
    }
    toString() {
        return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(', ')}}>`;
    }
    get [Symbol.toStringTag]() {
        return 'Struct';
    }
}
exports.Struct = Struct;
