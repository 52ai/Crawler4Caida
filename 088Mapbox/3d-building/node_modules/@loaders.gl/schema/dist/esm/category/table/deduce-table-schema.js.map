{"version":3,"sources":["../../../../src/category/table/deduce-table-schema.ts"],"names":["deduceTableSchema","table","schema","deducedSchema","Array","isArray","deduceSchemaForRowTable","deduceSchemaForColumnarTable","Object","assign","columnarTable","field","column","ArrayBuffer","isView","constructor","length","value","deduceTypeFromValue","rowTable","row","Date","Number","Float32Array","String"],"mappings":"AAyCA,OAAO,SAASA,iBAAT,CAA2BC,KAA3B,EAAkCC,MAAlC,EAAmD;AACxD,QAAMC,aAAa,GAAGC,KAAK,CAACC,OAAN,CAAcJ,KAAd,IAClBK,uBAAuB,CAACL,KAAD,CADL,GAElBM,4BAA4B,CAACN,KAAD,CAFhC;AAIA,SAAOO,MAAM,CAACC,MAAP,CAAcN,aAAd,EAA6BD,MAA7B,CAAP;AACD;;AAED,SAASK,4BAAT,CAAsCG,aAAtC,EAAqD;AACnD,QAAMR,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMS,KAAX,IAAoBD,aAApB,EAAmC;AACjC,UAAME,MAAM,GAAGF,aAAa,CAACC,KAAD,CAA5B;;AAEA,QAAIE,WAAW,CAACC,MAAZ,CAAmBF,MAAnB,CAAJ,EAAgC;AAC9BV,MAAAA,MAAM,CAACS,KAAD,CAAN,GAAgBC,MAAM,CAACG,WAAvB;AAED,KAHD,MAGO,IAAIH,MAAM,CAACI,MAAX,EAAmB;AACxB,YAAMC,KAAK,GAAGL,MAAM,CAAC,CAAD,CAApB;AACAV,MAAAA,MAAM,CAACS,KAAD,CAAN,GAAgBO,mBAAmB,CAACD,KAAD,CAAnC;AAED;;AAEDf,IAAAA,MAAM,CAACS,KAAD,CAAN,GAAgBT,MAAM,CAACS,KAAD,CAAN,IAAiB,IAAjC;AACD;;AACD,SAAOT,MAAP;AACD;;AAED,SAASI,uBAAT,CAAiCa,QAAjC,EAA2C;AACzC,QAAMjB,MAAM,GAAG,EAAf;;AACA,MAAIiB,QAAQ,CAACH,MAAb,EAAqB;AACnB,UAAMI,GAAG,GAAGD,QAAQ,CAAC,CAAD,CAApB;;AAEA,SAAK,MAAMR,KAAX,IAAoBS,GAApB,EAAyB;AACvB,YAAMH,KAAK,GAAGG,GAAG,CAACT,KAAD,CAAjB;AACAT,MAAAA,MAAM,CAACS,KAAD,CAAN,GAAgBO,mBAAmB,CAACD,KAAD,CAAnC;AACD;AACF;;AACD,SAAOf,MAAP;AACD;;AAED,SAASgB,mBAAT,CAA6BD,KAA7B,EAAoC;AAClC,MAAIA,KAAK,YAAYI,IAArB,EAA2B;AACzB,WAAOA,IAAP;AACD,GAFD,MAEO,IAAIJ,KAAK,YAAYK,MAArB,EAA6B;AAClC,WAAOC,YAAP;AACD,GAFM,MAEA,IAAI,OAAON,KAAP,KAAiB,QAArB,EAA+B;AACpC,WAAOO,MAAP;AACD;;AACD,SAAO,IAAP;AACD","sourcesContent":["// Type deduction\nimport {\n  Schema\n  // Int,\n  // Int8,\n  // Int16,\n  // Int32,\n  // Uint8,\n  // Uint16,\n  // Uint32,\n  // Float32,\n  // Float64\n  // Bool,\n  // Utf8,\n  // TimestampMillisecond,\n  // Null\n} from '../../lib/schema/schema';\n\n// const TYPED_ARRAY_TO_TYPE = {\n//   Int8Array: new Int8(),\n//   Int16Array: new Int16(),\n//   Int32Array: new Int32(),\n//   Uint8Array: new Uint8(),\n//   Uint8ClampedArray: new Uint8(),\n//   Uint16Array: new Uint16(),\n//   Uint32Array: new Uint32(),\n//   Float32Array: new Float32(),\n//   Float64Array: new Float64()\n// };\n\n// if (typeof BigInt64Array !== 'undefined') {\n//   TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n//   TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n// }\n\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table, schema?: Schema) {\n  const deducedSchema = Array.isArray(table)\n    ? deduceSchemaForRowTable(table)\n    : deduceSchemaForColumnarTable(table);\n  // Deduced schema will fill in missing info from partial options.schema, if provided\n  return Object.assign(deducedSchema, schema);\n}\n\nfunction deduceSchemaForColumnarTable(columnarTable) {\n  const schema = {};\n  for (const field in columnarTable) {\n    const column = columnarTable[field];\n    // Check if column is typed, if so we are done\n    if (ArrayBuffer.isView(column)) {\n      schema[field] = column.constructor;\n      // else we need data\n    } else if (column.length) {\n      const value = column[0];\n      schema[field] = deduceTypeFromValue(value);\n      // TODO - support nested schemas?\n    }\n    // else we mark as present but unknow\n    schema[field] = schema[field] || null;\n  }\n  return schema;\n}\n\nfunction deduceSchemaForRowTable(rowTable) {\n  const schema = {};\n  if (rowTable.length) {\n    const row = rowTable[0];\n    // TODO - Could look at additional rows if nulls in first row\n    for (const field in row) {\n      const value = row[field];\n      schema[field] = deduceTypeFromValue(value);\n    }\n  }\n  return schema;\n}\n\nfunction deduceTypeFromValue(value) {\n  if (value instanceof Date) {\n    return Date;\n  } else if (value instanceof Number) {\n    return Float32Array;\n  } else if (typeof value === 'string') {\n    return String;\n  }\n  return null;\n}\n\n/*\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction deduceSchema(rows) {\n  const row = rows[0];\n\n  const schema = {};\n  let i = 0;\n  for (const columnName in row) {\n    const value = row[columnName];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n\n      case 'object':\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n        break;\n\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n    i++;\n  }\n  return schema;\n}\n*/\n"],"file":"deduce-table-schema.js"}