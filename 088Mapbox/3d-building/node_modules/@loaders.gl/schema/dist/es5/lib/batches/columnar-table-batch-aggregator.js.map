{"version":3,"sources":["../../../../src/lib/batches/columnar-table-batch-aggregator.ts"],"names":["DEFAULT_ROW_COUNT","ColumnarTableBatchAggregator","schema","options","_reallocateColumns","length","row","i","fieldName","columns","_pruneColumns","Array","isArray","field","name","index","batch","shape","batchType","data","allocated","ArrayType","type","Float32Array","oldColumn","ArrayBuffer","isView","typedArray","set","Object","entries","columnName","column","slice"],"mappings":"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","sourcesContent":["import type {Schema} from '../schema/schema';\nimport type {ColumnarTableBatch, ArrowTableBatch} from '../../category/table/table-types';\nimport {TableBatchAggregator} from './table-batch-aggregator';\n\ntype ColumnarTableBatchOptions = {};\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class ColumnarTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  length: number = 0;\n  allocated: number = 0;\n  columns: {[columnName: string]: any[]} = {};\n\n  constructor(schema: Schema, options: ColumnarTableBatchOptions) {\n    this.schema = schema;\n    this._reallocateColumns();\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[]) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    let i = 0;\n    // TODO what if no csv header, columns not populated?\n    for (const fieldName in this.columns) {\n      this.columns[fieldName][this.length] = row[i++];\n    }\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}): void {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    for (const fieldName in row) {\n      this.columns[fieldName][this.length] = row[fieldName];\n    }\n    this.length++;\n  }\n\n  getBatch(): ColumnarTableBatch | ArrowTableBatch | null {\n    this._pruneColumns();\n    const columns = Array.isArray(this.schema) ? this.columns : {};\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    // columns should match schema format\n    if (!Array.isArray(this.schema)) {\n      for (const fieldName in this.schema) {\n        const field = this.schema[fieldName];\n        columns[field.name] = this.columns[field.index];\n      }\n    }\n\n    this.columns = {};\n\n    const batch: ColumnarTableBatch = {\n      shape: 'columnar-table',\n      batchType: 'data',\n      data: columns,\n      schema: this.schema,\n      length: this.length\n    };\n\n    return batch;\n  }\n\n  // HELPERS\n\n  _reallocateColumns() {\n    if (this.length < this.allocated) {\n      return;\n    }\n\n    // @ts-ignore TODO\n    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : DEFAULT_ROW_COUNT;\n    this.columns = {};\n\n    for (const fieldName in this.schema) {\n      const field = this.schema[fieldName];\n      const ArrayType = field.type || Float32Array;\n      const oldColumn = this.columns[field.index];\n\n      if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n        // Copy the old data to the new array\n        const typedArray = new ArrayType(this.allocated);\n        typedArray.set(oldColumn);\n        this.columns[field.index] = typedArray;\n      } else if (oldColumn) {\n        // Plain array\n        oldColumn.length = this.allocated;\n        this.columns[field.index] = oldColumn;\n      } else {\n        // Create new\n        this.columns[field.index] = new ArrayType(this.allocated);\n      }\n    }\n  }\n\n  _pruneColumns() {\n    for (const [columnName, column] of Object.entries(this.columns)) {\n      this.columns[columnName] = column.slice(0, this.length);\n    }\n  }\n}\n"],"file":"columnar-table-batch-aggregator.js"}