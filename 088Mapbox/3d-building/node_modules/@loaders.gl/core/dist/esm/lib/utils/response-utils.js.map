{"version":3,"sources":["../../../../src/lib/utils/response-utils.ts"],"names":["isResponse","getResourceContentLength","getResourceUrlAndType","makeResponse","resource","headers","contentLength","String","url","type","initialDataUrl","getInitialDataUrl","TextEncoder","encode","response","Response","Object","defineProperty","value","checkResponse","ok","message","getResponseError","Error","checkResponseSync","status","statusText","length","slice","contentType","get","text","includes","error","INITIAL_DATA_LENGTH","Blob","blobSlice","Promise","resolve","reader","FileReader","onload","event","target","result","readAsDataURL","ArrayBuffer","base64","arrayBufferToBase64","buffer","binary","bytes","Uint8Array","i","byteLength","fromCharCode","btoa"],"mappings":"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","sourcesContent":["import {isResponse} from '../../javascript-utils/is-type';\nimport {getResourceContentLength, getResourceUrlAndType} from './resource-utils';\n\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource: any): Promise<Response> {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  // Add content-length header if possible\n  const headers: {[header: string]: string} = {};\n\n  const contentLength = getResourceContentLength(resource);\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  // `new Response(File)` does not preserve content-type and URL\n  // so we add them here\n  const {url, type} = getResourceUrlAndType(resource);\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  // Add a custom header with initial bytes if available\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  // TODO - is this the best way of handling strings?\n  // Maybe package as data URL instead?\n  if (typeof resource === 'string') {\n    // Convert to ArrayBuffer to avoid Response treating it as a URL\n    resource = new TextEncoder().encode(resource);\n  }\n\n  // Attempt to create a Response from the resource, adding headers and setting url\n  const response = new Response(resource, {headers});\n  // We can't control `Response.url` via constructor, use a property override to record URL.\n  Object.defineProperty(response, 'url', {value: url});\n  return response;\n}\n\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response: Response): Promise<void> {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\n\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response: Response): void {\n  if (!response.ok) {\n    let message = `${response.status} ${response.statusText}`;\n    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n    throw new Error(message);\n  }\n}\n\n// HELPERS\n\nasync function getResponseError(response): Promise<string> {\n  let message = `Failed to fetch resource ${response.url} (${response.status}): `;\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n    if (contentType.includes('application/json')) {\n      text += ` ${await response.text()}`;\n    }\n    message += text;\n    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n  } catch (error) {\n    // eslint forbids return in a finally statement, so we just catch here\n  }\n  return message;\n}\n\nasync function getInitialDataUrl(resource): Promise<string | null> {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === 'string') {\n    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event?.target?.result as string);\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return `data:base64,${base64}`;\n  }\n  return null;\n}\n\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n"],"file":"response-utils.js"}