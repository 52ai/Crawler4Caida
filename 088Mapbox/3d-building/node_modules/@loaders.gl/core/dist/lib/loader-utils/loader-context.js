"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLoadersFromContext = exports.getLoaderContext = void 0;
const option_utils_1 = require("./option-utils");
/**
 * "sub" loaders invoked by other loaders get a "context" injected on `this`
 * The context will inject core methods like `parse` and contain information
 * about loaders and options passed in to the top-level `parse` call.
 *
 * @param context
 * @param options
 * @param previousContext
 */
function getLoaderContext(context, options, previousContext = null) {
    // For recursive calls, we already have a context
    // TODO - add any additional loaders to context?
    if (previousContext) {
        return previousContext;
    }
    const resolvedContext = {
        fetch: (0, option_utils_1.getFetchFunction)(options, context),
        ...context
    };
    // Recursive loading does not use single loader
    if (!Array.isArray(resolvedContext.loaders)) {
        resolvedContext.loaders = null;
    }
    return resolvedContext;
}
exports.getLoaderContext = getLoaderContext;
// eslint-disable-next-line complexity
function getLoadersFromContext(loaders, context) {
    // A single non-array loader is force selected, but only on top-level (context === null)
    if (!context && loaders && !Array.isArray(loaders)) {
        return loaders;
    }
    // Create a merged list
    let candidateLoaders;
    if (loaders) {
        candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
    }
    if (context && context.loaders) {
        const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
        candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
    }
    // If no loaders, return null to look in globally registered loaders
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}
exports.getLoadersFromContext = getLoadersFromContext;
