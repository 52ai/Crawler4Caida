"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.encodeSync = encodeSync;
exports.encodeText = encodeText;
exports.encodeInBatches = encodeInBatches;
exports.encodeURLtoURL = encodeURLtoURL;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _workerUtils = require("@loaders.gl/worker-utils");

var _writeFile = require("../fetch/write-file");

var _fetchFile = require("../fetch/fetch-file");

var _loaderOptions = require("./loader-options");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function encode(_x, _x2, _x3) {
  return _encode.apply(this, arguments);
}

function _encode() {
  _encode = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, writer, options) {
    var globalOptions, batches, chunks, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, tmpInputFilename, tmpOutputFilename, outputFilename, response;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            globalOptions = (0, _loaderOptions.getLoaderOptions)();
            options = _objectSpread(_objectSpread({}, globalOptions), options);

            if (!(0, _loaderUtils.canEncodeWithWorker)(writer, options)) {
              _context.next = 6;
              break;
            }

            _context.next = 5;
            return (0, _workerUtils.processOnWorker)(writer, data, options);

          case 5:
            return _context.abrupt("return", _context.sent);

          case 6:
            if (!writer.encode) {
              _context.next = 10;
              break;
            }

            _context.next = 9;
            return writer.encode(data, options);

          case 9:
            return _context.abrupt("return", _context.sent);

          case 10:
            if (!writer.encodeSync) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return", writer.encodeSync(data, options));

          case 12:
            if (!writer.encodeText) {
              _context.next = 18;
              break;
            }

            _context.t0 = new TextEncoder();
            _context.next = 16;
            return writer.encodeText(data, options);

          case 16:
            _context.t1 = _context.sent;
            return _context.abrupt("return", _context.t0.encode.call(_context.t0, _context.t1));

          case 18:
            if (!writer.encodeInBatches) {
              _context.next = 55;
              break;
            }

            batches = encodeInBatches(data, writer, options);
            chunks = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 23;
            _iterator = (0, _asyncIterator2.default)(batches);

          case 25:
            _context.next = 27;
            return _iterator.next();

          case 27:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 31;
            return _step.value;

          case 31:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 38;
              break;
            }

            batch = _value;
            chunks.push(batch);

          case 35:
            _iteratorNormalCompletion = true;
            _context.next = 25;
            break;

          case 38:
            _context.next = 44;
            break;

          case 40:
            _context.prev = 40;
            _context.t2 = _context["catch"](23);
            _didIteratorError = true;
            _iteratorError = _context.t2;

          case 44:
            _context.prev = 44;
            _context.prev = 45;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context.next = 49;
              break;
            }

            _context.next = 49;
            return _iterator.return();

          case 49:
            _context.prev = 49;

            if (!_didIteratorError) {
              _context.next = 52;
              break;
            }

            throw _iteratorError;

          case 52:
            return _context.finish(49);

          case 53:
            return _context.finish(44);

          case 54:
            return _context.abrupt("return", _loaderUtils.concatenateArrayBuffers.apply(void 0, chunks));

          case 55:
            if (!(!_loaderUtils.isBrowser && writer.encodeURLtoURL)) {
              _context.next = 67;
              break;
            }

            tmpInputFilename = getTemporaryFilename('input');
            _context.next = 59;
            return (0, _writeFile.writeFile)(tmpInputFilename, data);

          case 59:
            tmpOutputFilename = getTemporaryFilename('output');
            _context.next = 62;
            return encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);

          case 62:
            outputFilename = _context.sent;
            _context.next = 65;
            return (0, _fetchFile.fetchFile)(outputFilename);

          case 65:
            response = _context.sent;
            return _context.abrupt("return", response.arrayBuffer());

          case 67:
            throw new Error('Writer could not encode data');

          case 68:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[23, 40, 44, 54], [45,, 49, 53]]);
  }));
  return _encode.apply(this, arguments);
}

function encodeSync(data, writer, options) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }

  throw new Error('Writer could not synchronously encode data');
}

function encodeText(_x4, _x5, _x6) {
  return _encodeText.apply(this, arguments);
}

function _encodeText() {
  _encodeText = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(data, writer, options) {
    var arrayBuffer;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(writer.text && writer.encodeText)) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return writer.encodeText(data, options);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
            if (!(writer.text && (writer.encode || writer.encodeInBatches))) {
              _context2.next = 9;
              break;
            }

            _context2.next = 7;
            return encode(data, writer, options);

          case 7:
            arrayBuffer = _context2.sent;
            return _context2.abrupt("return", new TextDecoder().decode(arrayBuffer));

          case 9:
            throw new Error('Writer could not encode data as text');

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _encodeText.apply(this, arguments);
}

function encodeInBatches(data, writer, options) {
  if (writer.encodeInBatches) {
    var dataIterator = getIterator(data);
    return writer.encodeInBatches(dataIterator, options);
  }

  throw new Error('Writer could not encode data in batches');
}

function encodeURLtoURL(_x7, _x8, _x9, _x10) {
  return _encodeURLtoURL.apply(this, arguments);
}

function _encodeURLtoURL() {
  _encodeURLtoURL = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(inputUrl, outputUrl, writer, options) {
    var outputFilename;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            inputUrl = (0, _loaderUtils.resolvePath)(inputUrl);
            outputUrl = (0, _loaderUtils.resolvePath)(outputUrl);

            if (!(_loaderUtils.isBrowser || !writer.encodeURLtoURL)) {
              _context3.next = 4;
              break;
            }

            throw new Error();

          case 4:
            _context3.next = 6;
            return writer.encodeURLtoURL(inputUrl, outputUrl, options);

          case 6:
            outputFilename = _context3.sent;
            return _context3.abrupt("return", outputFilename);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _encodeURLtoURL.apply(this, arguments);
}

function getIterator(data) {
  var dataIterator = [{
    table: data,
    start: 0,
    end: data.length
  }];
  return dataIterator;
}

function getTemporaryFilename(filename) {
  return "/tmp/".concat(filename);
}
//# sourceMappingURL=encode.js.map