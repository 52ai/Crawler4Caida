{"version":3,"sources":["../../../../src/lib/fetch/read-array-buffer.ts"],"names":["readArrayBuffer","file","start","length","fs","_readToArrayBuffer","Blob","slice","readBlob","blob","Promise","resolve","reject","fileReader","FileReader","onload","event","target","result","onerror","error","readAsArrayBuffer"],"mappings":";;;;;;;;;;;;;;AACA;;SASsBA,e;;;;;+EAAf,iBACLC,IADK,EAELC,KAFK,EAGLC,MAHK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAKD,OAAOF,IAAP,KAAgB,QALf;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAMUG,gBAAGC,kBAAH,CAAsBJ,IAAtB,EAA4BC,KAA5B,EAAmCC,MAAnC,CANV;;AAAA;AAAA;;AAAA;AASL,gBAAI,EAAEF,IAAI,YAAYK,IAAlB,CAAJ,EAA6B;AAC3BL,cAAAA,IAAI,GAAG,IAAIK,IAAJ,CAAS,CAACL,IAAD,CAAT,CAAP;AACD;;AACKM,YAAAA,KAZD,GAYSN,IAAI,CAACM,KAAL,CAAWL,KAAX,EAAkBA,KAAK,GAAGC,MAA1B,CAZT;AAAA;AAAA,mBAaQK,QAAQ,CAACD,KAAD,CAbhB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAuBeC,Q;;;;;wEAAf,kBAAwBC,IAAxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACQ,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC5C,kBAAMC,UAAU,GAAG,IAAIC,UAAJ,EAAnB;;AACAD,cAAAA,UAAU,CAACE,MAAX,GAAoB,UAACC,KAAD;AAAA;;AAAA,uBAClBL,OAAO,CAACK,KAAD,aAACA,KAAD,wCAACA,KAAK,CAAEC,MAAR,kDAAC,cAAeC,MAAhB,CADW;AAAA,eAApB;;AAGAL,cAAAA,UAAU,CAACM,OAAX,GAAqB,UAACC,KAAD;AAAA,uBAAsCR,MAAM,CAACQ,KAAD,CAA5C;AAAA,eAArB;;AACAP,cAAAA,UAAU,CAACQ,iBAAX,CAA6BZ,IAA7B;AACD,aAPY,CADR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["//\nimport {fs} from '@loaders.gl/loader-utils';\n\n/**\n * Reads a chunk from a random access file\n * @param file\n * @param start\n * @param length\n * @returns\n */\nexport async function readArrayBuffer(\n  file: Blob | ArrayBuffer | string | number,\n  start: number,\n  length: number\n): Promise<ArrayBuffer> {\n  if (typeof file === 'number') {\n    return await fs._readToArrayBuffer(file, start, length);\n  }\n  // TODO - we can do better for ArrayBuffer and string\n  if (!(file instanceof Blob)) {\n    file = new Blob([file]);\n  }\n  const slice = file.slice(start, start + length);\n  return await readBlob(slice);\n}\n\n/**\n * Read a slice of a Blob or File, without loading the entire file into memory\n * The trick when reading File objects is to read successive \"slices\" of the File\n * Per spec https://w3c.github.io/FileAPI/, slicing a File only updates the start and end fields\n * Actually reading from file happens in `readAsArrayBuffer`\n * @param blob to read\n */\nexport async function readBlob(blob: Blob): Promise<ArrayBuffer> {\n  return await new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = (event: ProgressEvent<FileReader>) =>\n      resolve(event?.target?.result as ArrayBuffer);\n    // TODO - reject with a proper Error\n    fileReader.onerror = (error: ProgressEvent<FileReader>) => reject(error);\n    fileReader.readAsArrayBuffer(blob);\n  });\n}\n"],"file":"read-array-buffer.js"}