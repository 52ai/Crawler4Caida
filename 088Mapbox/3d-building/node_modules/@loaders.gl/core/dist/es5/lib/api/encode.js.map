{"version":3,"sources":["../../../../src/lib/api/encode.ts"],"names":["encode","data","writer","options","globalOptions","encodeSync","encodeText","TextEncoder","encodeInBatches","batches","chunks","batch","push","concatenateArrayBuffers","isBrowser","encodeURLtoURL","tmpInputFilename","getTemporaryFilename","tmpOutputFilename","outputFilename","response","arrayBuffer","Error","text","TextDecoder","decode","dataIterator","getIterator","inputUrl","outputUrl","table","start","end","length","filename"],"mappings":"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","sourcesContent":["import {Writer, LoaderOptions, canEncodeWithWorker} from '@loaders.gl/loader-utils';\nimport {processOnWorker} from '@loaders.gl/worker-utils';\nimport {concatenateArrayBuffers, resolvePath} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/loader-utils';\nimport {writeFile} from '../fetch/write-file';\nimport {fetchFile} from '../fetch/fetch-file';\nimport {getLoaderOptions} from './loader-options';\n\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport async function encode(\n  data: any,\n  writer: Writer,\n  options?: LoaderOptions\n): Promise<ArrayBuffer> {\n  const globalOptions = getLoaderOptions();\n  options = {...globalOptions, ...options};\n  if (canEncodeWithWorker(writer, options)) {\n    return await processOnWorker(writer, data, options);\n  }\n\n  // TODO Merge default writer options with options argument like it is done in load module.\n  if (writer.encode) {\n    return await writer.encode(data, options);\n  }\n\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n\n  if (writer.encodeText) {\n    return new TextEncoder().encode(await writer.encodeText(data, options));\n  }\n\n  if (writer.encodeInBatches) {\n    // Create an iterator representing the data\n    // TODO - Assumes this is a table\n    const batches = encodeInBatches(data, writer, options);\n\n    // Concatenate the output\n    const chunks: any[] = [];\n    for await (const batch of batches) {\n      chunks.push(batch);\n    }\n    // @ts-ignore\n    return concatenateArrayBuffers(...chunks);\n  }\n\n  if (!isBrowser && writer.encodeURLtoURL) {\n    // TODO - how to generate filenames with correct extensions?\n    const tmpInputFilename = getTemporaryFilename('input');\n    await writeFile(tmpInputFilename, data);\n\n    const tmpOutputFilename = getTemporaryFilename('output');\n\n    const outputFilename = await encodeURLtoURL(\n      tmpInputFilename,\n      tmpOutputFilename,\n      writer,\n      options\n    );\n\n    const response = await fetchFile(outputFilename);\n    return response.arrayBuffer();\n  }\n\n  throw new Error('Writer could not encode data');\n}\n\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport function encodeSync(data: any, writer: Writer, options?: LoaderOptions): ArrayBuffer {\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n  throw new Error('Writer could not synchronously encode data');\n}\n\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport async function encodeText(\n  data: any,\n  writer: Writer,\n  options?: LoaderOptions\n): Promise<string> {\n  if (writer.text && writer.encodeText) {\n    return await writer.encodeText(data, options);\n  }\n\n  if (writer.text && (writer.encode || writer.encodeInBatches)) {\n    const arrayBuffer = await encode(data, writer, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n\n  throw new Error('Writer could not encode data as text');\n}\n\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeInBatches(\n  data: any,\n  writer: Writer,\n  options?: LoaderOptions\n): AsyncIterable<ArrayBuffer> {\n  if (writer.encodeInBatches) {\n    const dataIterator = getIterator(data);\n    return writer.encodeInBatches(dataIterator, options);\n  }\n  // TODO -fall back to atomic encode?\n  throw new Error('Writer could not encode data in batches');\n}\n\n/**\n * Encode data stored in a file (on disk) to another file.\n * @note Node.js only. This function enables using command-line converters as \"writers\".\n */\nexport async function encodeURLtoURL(\n  inputUrl,\n  outputUrl,\n  writer: Writer,\n  options\n): Promise<string> {\n  inputUrl = resolvePath(inputUrl);\n  outputUrl = resolvePath(outputUrl);\n  if (isBrowser || !writer.encodeURLtoURL) {\n    throw new Error();\n  }\n  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n  return outputFilename;\n}\n\n/**\n * @todo TODO - this is an unacceptable hack!!!\n */\nfunction getIterator(data) {\n  const dataIterator = [{table: data, start: 0, end: data.length}];\n  return dataIterator;\n}\n\n/**\n * @todo Move to utils\n */\nfunction getTemporaryFilename(filename: string): string {\n  return `/tmp/${filename}`;\n}\n"],"file":"encode.js"}