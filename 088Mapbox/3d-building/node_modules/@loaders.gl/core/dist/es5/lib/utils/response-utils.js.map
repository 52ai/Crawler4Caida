{"version":3,"sources":["../../../../src/lib/utils/response-utils.ts"],"names":["makeResponse","resource","headers","contentLength","String","url","type","getInitialDataUrl","initialDataUrl","TextEncoder","encode","response","Response","Object","defineProperty","value","checkResponse","ok","getResponseError","message","Error","checkResponseSync","status","statusText","length","slice","contentType","get","text","includes","INITIAL_DATA_LENGTH","Blob","blobSlice","Promise","resolve","reader","FileReader","onload","event","target","result","readAsDataURL","ArrayBuffer","base64","arrayBufferToBase64","buffer","binary","bytes","Uint8Array","i","byteLength","fromCharCode","btoa"],"mappings":"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","sourcesContent":["import {isResponse} from '../../javascript-utils/is-type';\nimport {getResourceContentLength, getResourceUrlAndType} from './resource-utils';\n\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource: any): Promise<Response> {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  // Add content-length header if possible\n  const headers: {[header: string]: string} = {};\n\n  const contentLength = getResourceContentLength(resource);\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  // `new Response(File)` does not preserve content-type and URL\n  // so we add them here\n  const {url, type} = getResourceUrlAndType(resource);\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  // Add a custom header with initial bytes if available\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  // TODO - is this the best way of handling strings?\n  // Maybe package as data URL instead?\n  if (typeof resource === 'string') {\n    // Convert to ArrayBuffer to avoid Response treating it as a URL\n    resource = new TextEncoder().encode(resource);\n  }\n\n  // Attempt to create a Response from the resource, adding headers and setting url\n  const response = new Response(resource, {headers});\n  // We can't control `Response.url` via constructor, use a property override to record URL.\n  Object.defineProperty(response, 'url', {value: url});\n  return response;\n}\n\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response: Response): Promise<void> {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\n\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response: Response): void {\n  if (!response.ok) {\n    let message = `${response.status} ${response.statusText}`;\n    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n    throw new Error(message);\n  }\n}\n\n// HELPERS\n\nasync function getResponseError(response): Promise<string> {\n  let message = `Failed to fetch resource ${response.url} (${response.status}): `;\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n    if (contentType.includes('application/json')) {\n      text += ` ${await response.text()}`;\n    }\n    message += text;\n    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n  } catch (error) {\n    // eslint forbids return in a finally statement, so we just catch here\n  }\n  return message;\n}\n\nasync function getInitialDataUrl(resource): Promise<string | null> {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === 'string') {\n    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event?.target?.result as string);\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return `data:base64,${base64}`;\n  }\n  return null;\n}\n\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n"],"file":"response-utils.js"}