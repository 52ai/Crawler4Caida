{"version":3,"sources":["../../../../src/lib/binary-utils/array-buffer-utils.ts"],"names":["isBuffer","bufferToArrayBuffer","toArrayBuffer","data","ArrayBuffer","isView","byteOffset","byteLength","buffer","slice","text","uint8Array","TextEncoder","encode","_toArrayBuffer","Error","compareArrayBuffers","arrayBuffer1","arrayBuffer2","array1","Uint8Array","array2","i","length","concatenateArrayBuffers","sources","sourceArrays","map","source2","reduce","typedArray","result","offset","sourceArray","set","concatenateTypedArrays","typedArrays","arrays","TypedArrayConstructor","constructor","sumLength","acc","value","array","sliceArrayBuffer","arrayBuffer","subArray","undefined","subarray","arrayCopy"],"mappings":"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","sourcesContent":["import {TypedArray} from '../../types';\nimport {isBuffer, bufferToArrayBuffer} from './buffer-utils';\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: any): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (isBuffer(data)) {\n    return bufferToArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n\n/**\n * compare two binary arrays for equality\n * @param {ArrayBuffer} a\n * @param {ArrayBuffer} b\n * @param {number} byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param {...*} arrays - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n"],"file":"array-buffer-utils.js"}