{"version":3,"sources":["../../../../src/lib/binary-utils/encode-utils.ts"],"names":["padStringToByteAlignment","string","byteAlignment","length","paddedLength","Math","ceil","padding","whitespace","i","copyStringToDataView","dataView","byteOffset","byteLength","setUint8","charCodeAt","copyBinaryToDataView","binary"],"mappings":"AAIA,OAAO,SAASA,wBAAT,CAAkCC,MAAlC,EAA0CC,aAA1C,EAAyD;AAC9D,QAAMC,MAAM,GAAGF,MAAM,CAACE,MAAtB;AACA,QAAMC,YAAY,GAAGC,IAAI,CAACC,IAAL,CAAUH,MAAM,GAAGD,aAAnB,IAAoCA,aAAzD;AACA,QAAMK,OAAO,GAAGH,YAAY,GAAGD,MAA/B;AACA,MAAIK,UAAU,GAAG,EAAjB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAApB,EAA6B,EAAEE,CAA/B,EAAkC;AAChCD,IAAAA,UAAU,IAAI,GAAd;AACD;;AACD,SAAOP,MAAM,GAAGO,UAAhB;AACD;AAED,OAAO,SAASE,oBAAT,CAA8BC,QAA9B,EAAwCC,UAAxC,EAAoDX,MAApD,EAA4DY,UAA5D,EAAwE;AAC7E,MAAIF,QAAJ,EAAc;AACZ,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,UAApB,EAAgCJ,CAAC,EAAjC,EAAqC;AACnCE,MAAAA,QAAQ,CAACG,QAAT,CAAkBF,UAAU,GAAGH,CAA/B,EAAkCR,MAAM,CAACc,UAAP,CAAkBN,CAAlB,CAAlC;AACD;AACF;;AACD,SAAOG,UAAU,GAAGC,UAApB;AACD;AAED,OAAO,SAASG,oBAAT,CAA8BL,QAA9B,EAAwCC,UAAxC,EAAoDK,MAApD,EAA4DJ,UAA5D,EAAwE;AAC7E,MAAIF,QAAJ,EAAc;AACZ,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,UAApB,EAAgCJ,CAAC,EAAjC,EAAqC;AACnCE,MAAAA,QAAQ,CAACG,QAAT,CAAkBF,UAAU,GAAGH,CAA/B,EAAkCQ,MAAM,CAACR,CAAD,CAAxC;AACD;AACF;;AACD,SAAOG,UAAU,GAAGC,UAApB;AACD","sourcesContent":["// Note: These were broken out from gltf loader...\n// eslint-disable-next-line complexity\n\n// PERFORMANCE IDEA: No need to copy string twice...\nexport function padStringToByteAlignment(string, byteAlignment) {\n  const length = string.length;\n  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment\n  const padding = paddedLength - length;\n  let whitespace = '';\n  for (let i = 0; i < padding; ++i) {\n    whitespace += ' ';\n  }\n  return string + whitespace;\n}\n\nexport function copyStringToDataView(dataView, byteOffset, string, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n    }\n  }\n  return byteOffset + byteLength;\n}\n\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, binary[i]);\n    }\n  }\n  return byteOffset + byteLength;\n}\n"],"file":"encode-utils.js"}