{"version":3,"sources":["../../../../src/lib/worker-loader-utils/create-loader-worker.ts"],"names":["requestId","createLoaderWorker","loader","WorkerBody","inWorkerThread","onmessage","type","payload","input","options","context","parseData","arrayBuffer","parse","parseOnMainThread","result","postMessage","message","Error","error","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener","parseSync","data","parser","parseTextSync","textDecoder","TextDecoder","decode","name","modules","worker"],"mappings":"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","sourcesContent":["/* eslint-disable no-restricted-globals */\nimport type {LoaderWithParser} from '../../types';\nimport {WorkerBody} from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\n\nlet requestId = 0;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport function createLoaderWorker(loader: LoaderWithParser) {\n  // Check that we are actually in a worker thread\n  if (!WorkerBody.inWorkerThread()) {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n\n          const {input, options = {}, context = {}} = payload;\n\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            context: {\n              ...context,\n              parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {result});\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {error: message});\n        }\n        break;\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(arrayBuffer: ArrayBuffer, options: {[key: string]: any}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arrayBuffer, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n"],"file":"create-loader-worker.js"}