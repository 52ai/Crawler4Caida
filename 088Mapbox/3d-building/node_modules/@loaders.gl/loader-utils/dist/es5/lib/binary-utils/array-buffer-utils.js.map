{"version":3,"sources":["../../../../src/lib/binary-utils/array-buffer-utils.ts"],"names":["toArrayBuffer","data","ArrayBuffer","isView","byteOffset","byteLength","buffer","slice","text","uint8Array","TextEncoder","encode","_toArrayBuffer","Error","compareArrayBuffers","arrayBuffer1","arrayBuffer2","array1","Uint8Array","array2","i","length","concatenateArrayBuffers","sources","sourceArrays","map","source2","reduce","typedArray","result","offset","sourceArray","set","concatenateTypedArrays","typedArrays","arrays","TypedArrayConstructor","constructor","sumLength","acc","value","array","sliceArrayBuffer","arrayBuffer","subArray","undefined","subarray","arrayCopy"],"mappings":"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","sourcesContent":["import {TypedArray} from '../../types';\nimport {isBuffer, bufferToArrayBuffer} from './buffer-utils';\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: any): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (isBuffer(data)) {\n    return bufferToArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n\n/**\n * compare two binary arrays for equality\n * @param {ArrayBuffer} a\n * @param {ArrayBuffer} b\n * @param {number} byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param {...*} arrays - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n"],"file":"array-buffer-utils.js"}