{"version":3,"sources":["../../../../src/lib/parsers/parse-to-image.ts"],"names":["getBlobOrSVGDataUrl","parseToImage","arrayBuffer","options","url","blobOrDataUrl","URL","self","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","image","Image","src","decode","Promise","resolve","reject","onload","onerror","err","Error","error"],"mappings":"AACA,SAAQA,mBAAR,QAAkC,aAAlC;AAGA,eAAe,eAAeC,YAAf,CACbC,WADa,EAEbC,OAFa,EAGbC,GAHa,EAIc;AAK3B,QAAMC,aAAa,GAAGL,mBAAmB,CAACE,WAAD,EAAcE,GAAd,CAAzC;AACA,QAAME,GAAG,GAAGC,IAAI,CAACD,GAAL,IAAYC,IAAI,CAACC,SAA7B;AACA,QAAMC,SAAS,GAAG,OAAOJ,aAAP,KAAyB,QAAzB,IAAqCC,GAAG,CAACI,eAAJ,CAAoBL,aAApB,CAAvD;;AACA,MAAI;AACF,WAAO,MAAMM,WAAW,CAACF,SAAS,IAAIJ,aAAd,EAA6BF,OAA7B,CAAxB;AACD,GAFD,SAEU;AACR,QAAIM,SAAJ,EAAe;AACbH,MAAAA,GAAG,CAACM,eAAJ,CAAoBH,SAApB;AACD;AACF;AACF;AAED,OAAO,eAAeE,WAAf,CAA2BP,GAA3B,EAAgCD,OAAhC,EAAoE;AACzE,QAAMU,KAAK,GAAG,IAAIC,KAAJ,EAAd;AACAD,EAAAA,KAAK,CAACE,GAAN,GAAYX,GAAZ;;AASA,MAAID,OAAO,CAACU,KAAR,IAAiBV,OAAO,CAACU,KAAR,CAAcG,MAA/B,IAAyCH,KAAK,CAACG,MAAnD,EAA2D;AACzD,UAAMH,KAAK,CAACG,MAAN,EAAN;AACA,WAAOH,KAAP;AACD;;AAGD,SAAO,MAAM,IAAII,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC5C,QAAI;AACFN,MAAAA,KAAK,CAACO,MAAN,GAAe,MAAMF,OAAO,CAACL,KAAD,CAA5B;;AACAA,MAAAA,KAAK,CAACQ,OAAN,GAAiBC,GAAD,IAASH,MAAM,CAAC,IAAII,KAAJ,gCAAkCnB,GAAlC,eAA0CkB,GAA1C,EAAD,CAA/B;AACD,KAHD,CAGE,OAAOE,KAAP,EAAc;AACdL,MAAAA,MAAM,CAACK,KAAD,CAAN;AACD;AACF,GAPY,CAAb;AAQD","sourcesContent":["import type {ImageLoaderOptions} from '../../image-loader';\nimport {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(\n  arrayBuffer: ArrayBuffer,\n  options: ImageLoaderOptions,\n  url?: string\n): Promise<HTMLImageElement> {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options): Promise<HTMLImageElement> {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"],"file":"parse-to-image.js"}