{"version":3,"sources":["../../../../src/lib/parsers/parse-to-image.ts"],"names":["parseToImage","arrayBuffer","options","url","blobOrDataUrl","URL","self","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","image","Image","src","decode","Promise","resolve","reject","onload","onerror","err","Error","error"],"mappings":";;;;;;;;;;;;;;AACA;;SAG8BA,Y;;;;;4EAAf,iBACbC,WADa,EAEbC,OAFa,EAGbC,GAHa;AAAA;AAAA;AAAA;AAAA;AAAA;AASPC,YAAAA,aATO,GASS,mCAAoBH,WAApB,EAAiCE,GAAjC,CATT;AAUPE,YAAAA,GAVO,GAUDC,IAAI,CAACD,GAAL,IAAYC,IAAI,CAACC,SAVhB;AAWPC,YAAAA,SAXO,GAWK,OAAOJ,aAAP,KAAyB,QAAzB,IAAqCC,GAAG,CAACI,eAAJ,CAAoBL,aAApB,CAX1C;AAAA;AAAA;AAAA,mBAaEM,WAAW,CAACF,SAAS,IAAIJ,aAAd,EAA6BF,OAA7B,CAbb;;AAAA;AAAA;;AAAA;AAAA;;AAeX,gBAAIM,SAAJ,EAAe;AACbH,cAAAA,GAAG,CAACM,eAAJ,CAAoBH,SAApB;AACD;;AAjBU;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAqBOE,W;;;;;2EAAf,kBAA2BP,GAA3B,EAAgCD,OAAhC;AAAA;AAAA;AAAA;AAAA;AAAA;AACCU,YAAAA,KADD,GACS,IAAIC,KAAJ,EADT;AAELD,YAAAA,KAAK,CAACE,GAAN,GAAYX,GAAZ;;AAFK,kBAWDD,OAAO,CAACU,KAAR,IAAiBV,OAAO,CAACU,KAAR,CAAcG,MAA/B,IAAyCH,KAAK,CAACG,MAX9C;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAYGH,KAAK,CAACG,MAAN,EAZH;;AAAA;AAAA,8CAaIH,KAbJ;;AAAA;AAAA;AAAA,mBAiBQ,IAAII,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC5C,kBAAI;AACFN,gBAAAA,KAAK,CAACO,MAAN,GAAe;AAAA,yBAAMF,OAAO,CAACL,KAAD,CAAb;AAAA,iBAAf;;AACAA,gBAAAA,KAAK,CAACQ,OAAN,GAAgB,UAACC,GAAD;AAAA,yBAASH,MAAM,CAAC,IAAII,KAAJ,gCAAkCnB,GAAlC,eAA0CkB,GAA1C,EAAD,CAAf;AAAA,iBAAhB;AACD,eAHD,CAGE,OAAOE,KAAP,EAAc;AACdL,gBAAAA,MAAM,CAACK,KAAD,CAAN;AACD;AACF,aAPY,CAjBR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import type {ImageLoaderOptions} from '../../image-loader';\nimport {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(\n  arrayBuffer: ArrayBuffer,\n  options: ImageLoaderOptions,\n  url?: string\n): Promise<HTMLImageElement> {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options): Promise<HTMLImageElement> {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"],"file":"parse-to-image.js"}