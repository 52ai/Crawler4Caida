"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _globals = require("../env-utils/globals");

var _workerThread = _interopRequireDefault(require("./worker-thread"));

var _workerJob = _interopRequireDefault(require("./worker-job"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var WorkerPool = function () {
  function WorkerPool(props) {
    (0, _classCallCheck2.default)(this, WorkerPool);
    (0, _defineProperty2.default)(this, "name", 'unnamed');
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "maxConcurrency", 1);
    (0, _defineProperty2.default)(this, "maxMobileConcurrency", 1);
    (0, _defineProperty2.default)(this, "onDebug", function () {});
    (0, _defineProperty2.default)(this, "reuseWorkers", true);
    (0, _defineProperty2.default)(this, "props", {});
    (0, _defineProperty2.default)(this, "jobQueue", []);
    (0, _defineProperty2.default)(this, "idleQueue", []);
    (0, _defineProperty2.default)(this, "count", 0);
    (0, _defineProperty2.default)(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }

  (0, _createClass2.default)(WorkerPool, [{
    key: "destroy",
    value: function destroy() {
      this.idleQueue.forEach(function (worker) {
        return worker.destroy();
      });
      this.isDestroyed = true;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.props = _objectSpread(_objectSpread({}, this.props), props);

      if (props.name !== undefined) {
        this.name = props.name;
      }

      if (props.maxConcurrency !== undefined) {
        this.maxConcurrency = props.maxConcurrency;
      }

      if (props.maxMobileConcurrency !== undefined) {
        this.maxMobileConcurrency = props.maxMobileConcurrency;
      }

      if (props.reuseWorkers !== undefined) {
        this.reuseWorkers = props.reuseWorkers;
      }

      if (props.onDebug !== undefined) {
        this.onDebug = props.onDebug;
      }
    }
  }, {
    key: "startJob",
    value: function () {
      var _startJob = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(name) {
        var _this = this;

        var onMessage,
            onError,
            startPromise,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                onMessage = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (job, type, data) {
                  return job.done(data);
                };
                onError = _args.length > 2 && _args[2] !== undefined ? _args[2] : function (job, error) {
                  return job.error(error);
                };
                startPromise = new Promise(function (onStart) {
                  _this.jobQueue.push({
                    name: name,
                    onMessage: onMessage,
                    onError: onError,
                    onStart: onStart
                  });

                  return _this;
                });

                this._startQueuedJob();

                _context.next = 6;
                return startPromise;

              case 6:
                return _context.abrupt("return", _context.sent);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function startJob(_x) {
        return _startJob.apply(this, arguments);
      }

      return startJob;
    }()
  }, {
    key: "_startQueuedJob",
    value: function () {
      var _startQueuedJob2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
        var workerThread, queuedJob, _job;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.jobQueue.length) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                workerThread = this._getAvailableWorker();

                if (workerThread) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return");

              case 5:
                queuedJob = this.jobQueue.shift();

                if (!queuedJob) {
                  _context2.next = 18;
                  break;
                }

                this.onDebug({
                  message: 'Starting job',
                  name: queuedJob.name,
                  workerThread: workerThread,
                  backlog: this.jobQueue.length
                });
                _job = new _workerJob.default(queuedJob.name, workerThread);

                workerThread.onMessage = function (data) {
                  return queuedJob.onMessage(_job, data.type, data.payload);
                };

                workerThread.onError = function (error) {
                  return queuedJob.onError(_job, error);
                };

                queuedJob.onStart(_job);
                _context2.prev = 12;
                _context2.next = 15;
                return _job.result;

              case 15:
                _context2.prev = 15;
                this.returnWorkerToQueue(workerThread);
                return _context2.finish(15);

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[12,, 15, 18]]);
      }));

      function _startQueuedJob() {
        return _startQueuedJob2.apply(this, arguments);
      }

      return _startQueuedJob;
    }()
  }, {
    key: "returnWorkerToQueue",
    value: function returnWorkerToQueue(worker) {
      var shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();

      if (shouldDestroyWorker) {
        worker.destroy();
        this.count--;
      } else {
        this.idleQueue.push(worker);
      }

      if (!this.isDestroyed) {
        this._startQueuedJob();
      }
    }
  }, {
    key: "_getAvailableWorker",
    value: function _getAvailableWorker() {
      if (this.idleQueue.length > 0) {
        return this.idleQueue.shift() || null;
      }

      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        var name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
        return new _workerThread.default({
          name: name,
          source: this.source,
          url: this.url
        });
      }

      return null;
    }
  }, {
    key: "_getMaxConcurrency",
    value: function _getMaxConcurrency() {
      return _globals.isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return _workerThread.default.isSupported();
    }
  }]);
  return WorkerPool;
}();

exports.default = WorkerPool;
//# sourceMappingURL=worker-pool.js.map