"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWorker = createWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _asyncQueue = _interopRequireDefault(require("../async-queue/async-queue"));

var _workerBody = _interopRequireDefault(require("../worker-farm/worker-body"));

var requestId = 0;
var inputBatches;
var options;

function createWorker(process, processInBatches) {
  if (!_workerBody.default.inWorkerThread()) {
    return;
  }

  var context = {
    process: processOnMainThread
  };

  _workerBody.default.onmessage = function () {
    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(type, payload) {
      var result, resultIterator, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, message;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.t0 = type;
              _context.next = _context.t0 === 'process' ? 4 : _context.t0 === 'process-in-batches' ? 11 : _context.t0 === 'input-batch' ? 51 : _context.t0 === 'input-done' ? 53 : 55;
              break;

            case 4:
              if (process) {
                _context.next = 6;
                break;
              }

              throw new Error('Worker does not support atomic processing');

            case 6:
              _context.next = 8;
              return process(payload.input, payload.options || {}, context);

            case 8:
              result = _context.sent;

              _workerBody.default.postMessage('done', {
                result: result
              });

              return _context.abrupt("break", 55);

            case 11:
              if (processInBatches) {
                _context.next = 13;
                break;
              }

              throw new Error('Worker does not support batched processing');

            case 13:
              inputBatches = new _asyncQueue.default();
              options = payload.options || {};
              resultIterator = processInBatches(inputBatches, options, context);
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context.prev = 18;
              _iterator = (0, _asyncIterator2.default)(resultIterator);

            case 20:
              _context.next = 22;
              return _iterator.next();

            case 22:
              _step = _context.sent;
              _iteratorNormalCompletion = _step.done;
              _context.next = 26;
              return _step.value;

            case 26:
              _value = _context.sent;

              if (_iteratorNormalCompletion) {
                _context.next = 33;
                break;
              }

              batch = _value;

              _workerBody.default.postMessage('output-batch', {
                result: batch
              });

            case 30:
              _iteratorNormalCompletion = true;
              _context.next = 20;
              break;

            case 33:
              _context.next = 39;
              break;

            case 35:
              _context.prev = 35;
              _context.t1 = _context["catch"](18);
              _didIteratorError = true;
              _iteratorError = _context.t1;

            case 39:
              _context.prev = 39;
              _context.prev = 40;

              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                _context.next = 44;
                break;
              }

              _context.next = 44;
              return _iterator.return();

            case 44:
              _context.prev = 44;

              if (!_didIteratorError) {
                _context.next = 47;
                break;
              }

              throw _iteratorError;

            case 47:
              return _context.finish(44);

            case 48:
              return _context.finish(39);

            case 49:
              _workerBody.default.postMessage('done', {});

              return _context.abrupt("break", 55);

            case 51:
              inputBatches.push(payload.input);
              return _context.abrupt("break", 55);

            case 53:
              inputBatches.close();
              return _context.abrupt("break", 55);

            case 55:
              _context.next = 61;
              break;

            case 57:
              _context.prev = 57;
              _context.t2 = _context["catch"](0);
              message = _context.t2 instanceof Error ? _context.t2.message : '';

              _workerBody.default.postMessage('error', {
                error: message
              });

            case 61:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 57], [18, 35, 39, 49], [40,, 44, 48]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
}

function processOnMainThread(arrayBuffer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise(function (resolve, reject) {
    var id = requestId++;

    var onMessage = function onMessage(type, payload) {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _workerBody.default.removeEventListener(onMessage);

          resolve(payload.result);
          break;

        case 'error':
          _workerBody.default.removeEventListener(onMessage);

          reject(payload.error);
          break;

        default:
      }
    };

    _workerBody.default.addEventListener(onMessage);

    var payload = {
      id: id,
      input: arrayBuffer,
      options: options
    };

    _workerBody.default.postMessage('process', payload);
  });
}
//# sourceMappingURL=create-worker.js.map