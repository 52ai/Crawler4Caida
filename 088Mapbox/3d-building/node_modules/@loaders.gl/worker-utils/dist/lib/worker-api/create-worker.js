"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWorker = void 0;
const async_queue_1 = __importDefault(require("../async-queue/async-queue"));
const worker_body_1 = __importDefault(require("../worker-farm/worker-body"));
// import {validateWorkerVersion} from './validate-worker-version';
/** Counter for jobs */
let requestId = 0;
let inputBatches;
let options;
/**
 * Set up a WebWorkerGlobalScope to talk with the main thread
 */
function createWorker(process, processInBatches) {
    if (!worker_body_1.default.inWorkerThread()) {
        return;
    }
    const context = {
        process: processOnMainThread
    };
    // eslint-disable-next-line complexity
    worker_body_1.default.onmessage = async (type, payload) => {
        try {
            switch (type) {
                case 'process':
                    if (!process) {
                        throw new Error('Worker does not support atomic processing');
                    }
                    const result = await process(payload.input, payload.options || {}, context);
                    worker_body_1.default.postMessage('done', { result });
                    break;
                case 'process-in-batches':
                    if (!processInBatches) {
                        throw new Error('Worker does not support batched processing');
                    }
                    inputBatches = new async_queue_1.default();
                    options = payload.options || {};
                    const resultIterator = processInBatches(inputBatches, options, context);
                    for await (const batch of resultIterator) {
                        worker_body_1.default.postMessage('output-batch', { result: batch });
                    }
                    worker_body_1.default.postMessage('done', {});
                    break;
                case 'input-batch':
                    inputBatches.push(payload.input);
                    break;
                case 'input-done':
                    inputBatches.close();
                    break;
                default:
            }
        }
        catch (error) {
            const message = error instanceof Error ? error.message : '';
            worker_body_1.default.postMessage('error', { error: message });
        }
    };
}
exports.createWorker = createWorker;
function processOnMainThread(arrayBuffer, options = {}) {
    return new Promise((resolve, reject) => {
        const id = requestId++;
        /**
         */
        const onMessage = (type, payload) => {
            if (payload.id !== id) {
                // not ours
                return;
            }
            switch (type) {
                case 'done':
                    worker_body_1.default.removeEventListener(onMessage);
                    resolve(payload.result);
                    break;
                case 'error':
                    worker_body_1.default.removeEventListener(onMessage);
                    reject(payload.error);
                    break;
                default:
                // ignore
            }
        };
        worker_body_1.default.addEventListener(onMessage);
        // Ask the main thread to decode data
        const payload = { id, input: arrayBuffer, options };
        worker_body_1.default.postMessage('process', payload);
    });
}
