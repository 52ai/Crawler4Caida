{"version":3,"sources":["../../src/web-mercator-viewport.ts"],"names":["WebMercatorViewport","props","width","height","viewport","mat4","equals","projectionMatrix","viewMatrix","lngLatZ","options","topLeft","worldPosition","projectPosition","coord","pixelProjectionMatrix","x","y","y2","length","xyz","targetZ","undefined","z","targetZWorld","distanceScales","unitsPerMeter","pixelUnprojectionMatrix","unprojectPosition","X","Y","Z","Number","isFinite","metersPerUnit","altitude","fovy","latitude","longitude","zoom","pitch","bearing","position","nearZMultiplier","farZMultiplier","DEFAULT_ALTITUDE","scale","Math","max","center","push","vec3","add","mul","meterOffset","_initMatrices","Object","freeze","vpm","multiply","viewProjectionMatrix","m","translate","mInverse","invert","Error","lngLat","xy","pos","fromLocation","toLocation","vec2","negate","newCenter","bounds","assign","corners","getBoundingRegion","west","min","map","p","east","south","north","getMapCenterByLngLatPosition"],"mappings":"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","sourcesContent":["// View and Projection Matrix calculations for mapbox-js style map view properties\nimport {createMat4} from './math-utils';\n\nimport {\n  zoomToScale,\n  pixelsToWorld,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  altitudeToFovy,\n  fovyToAltitude,\n  DEFAULT_ALTITUDE,\n  getProjectionMatrix,\n  getDistanceScales,\n  getViewMatrix,\n  DistanceScales\n} from './web-mercator-utils';\nimport fitBounds from './fit-bounds';\nimport getBounds from './get-bounds';\nimport type {FitBoundsOptions} from './fit-bounds';\n\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec2 from 'gl-matrix/vec2';\nimport * as vec3 from 'gl-matrix/vec3';\n\n/**\n   * @param width=1 - Width of \"viewport\" or window\n   * @param height=1 - Height of \"viewport\" or window\n   * @param scale=1 - Either use scale or zoom\n   * @param pitch=0 - Camera angle in degrees (0 is straight down)\n   * @param bearing=0 - Map rotation in degrees (0 means north is up)\n   * @param fovy= - Field of view of camera in degrees\n   * @param altitude= - Altitude of camera in screen units                                                               \n   *\n   * Web mercator projection short-hand parameters\n   * @param latitude - Center of viewport on map\n   * @param longitude - Center of viewport on map\n   * @param zoom - Scale = Math.pow(2,zoom) on map\n\n   * Notes:\n   *  - Only one of center or [latitude, longitude] can be specified\n   *  - [latitude, longitude] can only be specified when \"mercator\" is true\n   *  - Altitude has a default value that matches assumptions in mapbox-gl\n   *  - Field of view is independent from altitude, provide `altitudeToFovy(1.5)` (default value) to match assumptions in mapbox-gl\n   *  - width and height are forced to 1 if supplied as 0, to avoid\n   *    division by zero. This is intended to reduce the burden of apps to\n   *    to check values before instantiating a Viewport.\n */\nexport type WebMercatorViewportProps = {\n  // Map state\n  width: number;\n  height: number;\n  latitude?: number;\n  longitude?: number;\n  position?: number[];\n  zoom?: number;\n  pitch?: number;\n  bearing?: number;\n  altitude?: number;\n  fovy?: number;\n  nearZMultiplier?: number;\n  farZMultiplier?: number;\n};\n\n/**\n * The WebMercatorViewport class creates\n * - view/projection matrices\n * - \"uniform values\" (for shaders) from mercator params\n *\n * Note: Instances are immutable in the sense that they only have accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nexport default class WebMercatorViewport {\n  readonly latitude: number;\n  readonly longitude: number;\n  readonly zoom: number;\n  readonly pitch: number;\n  readonly bearing: number;\n  readonly altitude: number;\n  readonly fovy: number;\n\n  readonly meterOffset: number[];\n  readonly center: number[];\n\n  readonly width: number;\n  readonly height: number;\n  readonly scale: number;\n  readonly distanceScales: DistanceScales;\n\n  readonly viewMatrix: number[];\n  readonly projectionMatrix: number[];\n\n  viewProjectionMatrix: number[];\n  pixelProjectionMatrix: number[];\n  pixelUnprojectionMatrix: number[];\n\n  /**\n   * @classdesc\n   * Creates view/projection matrices from mercator params\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   */\n  // eslint-disable-next-line max-statements\n  constructor(props: WebMercatorViewportProps = {width: 1, height: 1}) {\n    let {\n      // Map state\n      width,\n      height,\n      altitude = null,\n      fovy = null\n    } = props;\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = props;\n\n    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n    width = width || 1;\n    height = height || 1;\n\n    // `fovy` & `altitude` are independent parameters, one for the\n    // projection and the latter for the view matrix. In the past,\n    // the `fovy` was always derived from the `altitude`\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    const scale = zoomToScale(zoom);\n    // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n    altitude = Math.max(0.75, altitude);\n\n    const distanceScales = getDistanceScales({longitude, latitude});\n\n    const center: number[] = lngLatToWorld([longitude, latitude]);\n    center.push(0);\n\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      scale,\n      center,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n\n    // Save parameters\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    Object.freeze(this);\n  }\n\n  _initMatrices(): void {\n    const {width, height, projectionMatrix, viewMatrix} = this;\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // Calculate matrices and scales needed for projection\n    /**\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    const m = createMat4();\n\n    // matrix for conversion from location to screen coordinates\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n\n    const mInverse = mat4.invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n\n  /** Two viewports are equal if width and height are identical, and if\n   * their view and projection matrices are (approximately) equal.\n   */\n  equals = (viewport: WebMercatorViewport | null): boolean => {\n    if (!(viewport instanceof WebMercatorViewport)) {\n      return false;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      mat4.equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      mat4.equals(viewport.viewMatrix, this.viewMatrix)\n    );\n  };\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param options - options\n   * @param options.topLeft=true - Whether projected coords are top left\n   * @return - screen coordinates [x, y] or [x, y, z], z as pixel depth\n   */\n  project = (lngLatZ: number[], options: {topLeft?: boolean} = {}): number[] => {\n    const {topLeft = true} = options;\n    const worldPosition = this.projectPosition(lngLatZ);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  };\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates, possibly `[lon, lat]` on map.\n   *\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   *\n   * @param xyz - screen coordinates, z as pixel depth\n   * @param options - options\n   * @param options.topLeft=true - Whether projected coords are top left\n   * @param options.targetZ=0 - If pixel depth is unknown, targetZ is used as\n   *   the elevation plane to unproject onto\n   * @return - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject = (xyz: number[], options: {topLeft?: boolean; targetZ?: number} = {}): number[] => {\n    const {topLeft = true, targetZ = undefined} = options;\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  };\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition = (xyz: number[]): [number, number, number] => {\n    const [X, Y] = lngLatToWorld(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  };\n\n  unprojectPosition = (xyz: number[]): [number, number, number] => {\n    const [X, Y] = worldToLngLat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  };\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   *\n   * @param lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return [x,y] coordinates.\n   */\n  projectFlat(lngLat: number[]): number[] {\n    return lngLatToWorld(lngLat);\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   *\n   * @param xy - array with [x,y] members\n   *  representing point on projected map plane\n   * @return - array with [lat,lon] of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xy: number[]): number[] {\n    return worldToLngLat(xy);\n  }\n\n  /**\n   * Get the map center that place a given [lng, lat] coordinate at screen point [x, y]\n   * @param opt\n   * @param opt.lngLat - [lng,lat] coordinates\n   *   Specifies a point on the sphere.\n   * @param opt.pos - [x,y] coordinates\n   *   Specifies a point on the screen.\n   * @return [lng,lat] new map center.\n   */\n  getMapCenterByLngLatPosition({lngLat, pos}: {lngLat: number[]; pos: number[]}): number[] {\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n\n  /**\n   * Returns a new viewport that fit around the given rectangle.\n   * Only supports non-perspective mode.\n   * @param bounds - [[lon, lat], [lon, lat]]\n   * @param [options]\n   * @param [options.padding] - The amount of padding in pixels to add to the given bounds.\n   * @param [options.offset] - The center of the given bounds relative to the map's center,\n   *    [x, y] measured in pixels.\n   * @returns {WebMercatorViewport}\n   */\n  fitBounds(\n    bounds: [[number, number], [number, number]],\n    options: Omit<FitBoundsOptions, 'width' | 'height' | 'bounds'> = {}\n  ): WebMercatorViewport {\n    const {width, height} = this;\n    const {longitude, latitude, zoom} = fitBounds(Object.assign({width, height, bounds}, options));\n    return new WebMercatorViewport({width, height, longitude, latitude, zoom});\n  }\n\n  /**\n   * Returns the bounding box of the viewport.\n   * @param [options]\n   * @param [options.z] - The altitude at which the bounds should be calculated.\n   * @returns {Array} bounds - [[lon, lat], [lon, lat]]\n   */\n  getBounds(options?: {z?: number}): number[][] {\n    const corners = this.getBoundingRegion(options);\n\n    const west = Math.min(...corners.map((p) => p[0]));\n    const east = Math.max(...corners.map((p) => p[0]));\n    const south = Math.min(...corners.map((p) => p[1]));\n    const north = Math.max(...corners.map((p) => p[1]));\n    return [\n      [west, south],\n      [east, north]\n    ];\n  }\n\n  /**\n   * Returns the bounding box of the viewport.\n   * @param [options]\n   * @param [options.z] - The altitude at which the bounds should be calculated.\n   * @returns {Array} an array of 4 points that define the visible region\n   */\n  getBoundingRegion(options: {z?: number} = {}): number[][] {\n    return getBounds(this, options.z || 0);\n  }\n\n  // DEPRECATED\n\n  /** @deprecated Legacy method name */\n  getLocationAtPoint({lngLat, pos}: {lngLat: number[]; pos: number[]}): number[] {\n    return this.getMapCenterByLngLatPosition({lngLat, pos});\n  }\n}\n"],"file":"web-mercator-viewport.js"}