{"version":3,"sources":["../../../../src/ellipsoid/helpers/ellipsoid-transform.ts"],"names":["EPSILON14","scratchOrigin","Vector3","VECTOR_PRODUCT_LOCAL_FRAME","up","south","north","west","east","down","degeneratePositionLocalFrame","scratchAxisVectors","scratchVector1","scratchVector2","scratchVector3","localFrameToFixedFrame","ellipsoid","firstAxis","secondAxis","thirdAxis","cartesianOrigin","result","thirdAxisInferred","firstAxisVector","secondAxisVector","thirdAxisVector","origin","copy","atPole","x","y","sign","Math","z","fromArray","scale","set","normalize","geodeticSurfaceNormal","cross"],"mappings":"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","sourcesContent":["import {Vector3, assert, equals as equalsEpsilon} from '@math.gl/core';\n\nimport type Ellipsoid from '../ellipsoid';\n\nconst EPSILON14 = 1e-14;\n\nconst scratchOrigin = new Vector3();\n\n// Caclulate third axis from given two axii\nconst VECTOR_PRODUCT_LOCAL_FRAME = {\n  up: {\n    south: 'east',\n    north: 'west',\n    west: 'south',\n    east: 'north'\n  },\n  down: {\n    south: 'west',\n    north: 'east',\n    west: 'north',\n    east: 'south'\n  },\n  south: {\n    up: 'west',\n    down: 'east',\n    west: 'down',\n    east: 'up'\n  },\n  north: {\n    up: 'east',\n    down: 'west',\n    west: 'up',\n    east: 'down'\n  },\n  west: {\n    up: 'north',\n    down: 'south',\n    north: 'down',\n    south: 'up'\n  },\n  east: {\n    up: 'south',\n    down: 'north',\n    north: 'up',\n    south: 'down'\n  }\n} as const;\n\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n} as const;\n\nconst scratchAxisVectors = {\n  east: new Vector3(),\n  north: new Vector3(),\n  up: new Vector3(),\n  west: new Vector3(),\n  south: new Vector3(),\n  down: new Vector3()\n};\n\nconst scratchVector1 = new Vector3();\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\n\ntype Axis = 'up' | 'down' | 'north' | 'east' | 'south' | 'west';\n\n// Computes a 4x4 transformation matrix from a reference frame\n// centered at the provided origin to the provided ellipsoid's fixed reference frame.\n// eslint-disable-next-line max-statements, max-params, complexity\nexport default function localFrameToFixedFrame(\n  ellipsoid: Ellipsoid,\n  firstAxis: Axis,\n  secondAxis: Axis,\n  thirdAxis: Axis,\n  cartesianOrigin: number[],\n  result: number[]\n): number[] {\n  const thirdAxisInferred =\n    VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] &&\n    (VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis] as Axis);\n  // firstAxis and secondAxis must be east, north, up, west, south or down.');\n  assert(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n\n  let firstAxisVector: Vector3;\n  let secondAxisVector: Vector3;\n  let thirdAxisVector: Vector3;\n\n  const origin = scratchOrigin.copy(cartesianOrigin);\n\n  // If x and y are zero, assume origin is at a pole, which is a special case.\n  const atPole = equalsEpsilon(origin.x, 0.0, EPSILON14) && equalsEpsilon(origin.y, 0.0, EPSILON14);\n\n  if (atPole) {\n    // Look up axis value and adjust\n    const sign = Math.sign(origin.z);\n\n    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n    if (firstAxis !== 'east' && firstAxis !== 'west') {\n      firstAxisVector.scale(sign);\n    }\n\n    secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);\n    if (secondAxis !== 'east' && secondAxis !== 'west') {\n      secondAxisVector.scale(sign);\n    }\n\n    thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n    if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n      thirdAxisVector.scale(sign);\n    }\n  } else {\n    // Calculate all axis\n    const {up, east, north} = scratchAxisVectors;\n\n    east.set(-origin.y, origin.x, 0.0).normalize();\n    ellipsoid.geodeticSurfaceNormal(origin, up);\n    north.copy(up).cross(east);\n\n    const {down, west, south} = scratchAxisVectors;\n\n    down.copy(up).scale(-1);\n    west.copy(east).scale(-1);\n    south.copy(north).scale(-1);\n\n    // Pick three axis based on desired orientation\n    firstAxisVector = scratchAxisVectors[firstAxis];\n    secondAxisVector = scratchAxisVectors[secondAxis];\n    thirdAxisVector = scratchAxisVectors[thirdAxis];\n  }\n\n  // TODO - assuming the result is column-major\n  result[0] = firstAxisVector.x;\n  result[1] = firstAxisVector.y;\n  result[2] = firstAxisVector.z;\n  result[3] = 0.0;\n  result[4] = secondAxisVector.x;\n  result[5] = secondAxisVector.y;\n  result[6] = secondAxisVector.z;\n  result[7] = 0.0;\n  result[8] = thirdAxisVector.x;\n  result[9] = thirdAxisVector.y;\n  result[10] = thirdAxisVector.z;\n  result[11] = 0.0;\n  result[12] = origin.x;\n  result[13] = origin.y;\n  result[14] = origin.z;\n  result[15] = 1.0;\n  return result;\n}\n"],"file":"ellipsoid-transform.js"}