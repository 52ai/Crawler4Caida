{"version":3,"sources":["../../../src/ellipsoid/ellipsoid.ts"],"names":["scratchVector","Vector3","scratchNormal","scratchK","scratchPosition","scratchHeight","scratchCartesian","wgs84","Ellipsoid","x","y","z","_MathUtils","EPSILON1","radii","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","Math","min","maximumRadius","max","squaredXOverSquaredZ","Object","freeze","right","Boolean","equals","toString","cartographic","result","normal","k","height","geodeticSurfaceNormalCartographic","copy","scale","gamma","sqrt","dot","add","to","cartesian","from","point","scaleToGeodeticSurface","undefined","geodeticSurfaceNormal","h","subtract","longitude","atan2","latitude","asin","sign","vec3","length","origin","Matrix4","firstAxis","secondAxis","thirdAxis","normalize","cartographicVectorRadians","cosLatitude","cos","set","sin","positionX","positionY","positionZ","beta","multiplyScalar","position","buffer","EPSILON15","abs","WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {\n  Vector3,\n  Matrix4,\n  toRadians,\n  toDegrees,\n  assert,\n  equals,\n  _MathUtils,\n  NumericArray\n} from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\n\nimport {WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z} from '../constants';\nimport {fromCartographicToRadians, toCartographicFromRadians} from '../type-utils';\n\nimport scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport localFrameToFixedFrame from './helpers/ellipsoid-transform';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n\nlet wgs84;\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * `(x / a)^2 + (y / b)^2 + (z / c)^2 = 1`.  Primarily used\n * to represent the shape of planetary bodies.\n */\nexport default class Ellipsoid {\n  /** An Ellipsoid instance initialized to the WGS84 standard. */\n  static readonly WGS84: Ellipsoid = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n\n  readonly radii: Vector3;\n  readonly radiiSquared: Vector3;\n  readonly radiiToTheFourth: Vector3;\n  readonly oneOverRadii: Vector3;\n  readonly oneOverRadiiSquared: Vector3;\n  readonly minimumRadius: number;\n  readonly maximumRadius: number;\n  readonly centerToleranceSquared: number = _MathUtils.EPSILON1;\n  readonly squaredXOverSquaredZ: number;\n\n  /** Creates an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions. */\n  constructor(x: number, y: number, z: number);\n  constructor();\n\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n\n    this.radii = new Vector3(x, y, z);\n\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n\n    this.oneOverRadii = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / x,\n      y === 0.0 ? 0.0 : 1.0 / y,\n      z === 0.0 ? 0.0 : 1.0 / z\n    );\n\n    this.oneOverRadiiSquared = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / (x * x),\n      y === 0.0 ? 0.0 : 1.0 / (y * y),\n      z === 0.0 ? 0.0 : 1.0 / (z * z)\n    );\n\n    this.minimumRadius = Math.min(x, y, z);\n\n    this.maximumRadius = Math.max(x, y, z);\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */\n  equals(right: Ellipsoid): boolean {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n\n  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */\n  toString(): string {\n    return this.radii.toString();\n  }\n\n  /** Converts the provided cartographic to Cartesian representation. */\n  cartographicToCartesian(cartographic: number[], result: Vector3): Vector3;\n  cartographicToCartesian(cartographic: number[], result?: number[]): number[];\n\n  cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n\n    const [, , height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n\n    normal.scale(height);\n\n    k.add(normal);\n\n    return k.to(result);\n  }\n\n  /** Converts the provided cartesian to cartographic (lng/lat/z) representation.\n   * The cartesian is undefined at the center of the ellipsoid. */\n  cartesianToCartographic(cartesian: number[], result: Vector3): Vector3;\n  cartesianToCartographic(cartesian: number[], result?: number[]): number[];\n\n  cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n    if (!point) {\n      return undefined;\n    }\n\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame. */\n  eastNorthUpToFixedFrame(origin: number[], result?: Matrix4): Matrix4;\n  eastNorthUpToFixedFrame(origin: number[], result: number[]): number[];\n\n  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame centered at\n   * the provided origin to the ellipsoid's fixed reference frame.\n   */\n  localFrameToFixedFrame(\n    firstAxis: string,\n    secondAxis: string,\n    thirdAxis: string,\n    origin: Readonly<NumericArray>,\n    result?: Matrix4\n  ): Matrix4;\n  localFrameToFixedFrame<Matrix4T>(\n    firstAxis: string,\n    secondAxis: string,\n    thirdAxis: string,\n    origin: Readonly<NumericArray>,\n    result: number[]\n  ): number[];\n\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n\n  /** Computes the unit vector directed from the center of this ellipsoid toward\n   * the provided Cartesian position. */\n  geocentricSurfaceNormal(cartesian: number[], result?: number[]): number[];\n  geocentricSurfaceNormal<NumArray>(cartesian: number[], result: NumArray): NumArray;\n  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).normalize().to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at provided position. */\n  geodeticSurfaceNormalCartographic<NumArray>(cartographic: number[], result: NumArray): NumArray;\n  geodeticSurfaceNormalCartographic(cartographic: number[]): number[];\n  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n\n    const cosLatitude = Math.cos(latitude);\n\n    scratchVector\n      .set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude))\n      .normalize();\n\n    return scratchVector.to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position. */\n  geodeticSurfaceNormal<NumArrayT>(cartesian: number[], result: NumArrayT): NumArrayT;\n  geodeticSurfaceNormal(cartesian: number[]): number[];\n  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n\n  /** Scales the provided Cartesian position along the geodetic surface normal\n   * so that it is on the surface of this ellipsoid.  If the position is\n   * at the center of the ellipsoid, this function returns undefined. */\n  scaleToGeodeticSurface(cartesian: number[], result?: number[]): number[] {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n\n  /** Scales the provided Cartesian position along the geocentric surface normal\n   * so that it is on the surface of this ellipsoid. */\n  scaleToGeocentricSurface(cartesian: number[], result: number[] = [0, 0, 0]): number[] {\n    scratchPosition.from(cartesian);\n\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n\n    const beta =\n      1.0 /\n      Math.sqrt(\n        positionX * positionX * oneOverRadiiSquared.x +\n          positionY * positionY * oneOverRadiiSquared.y +\n          positionZ * positionZ * oneOverRadiiSquared.z\n      );\n\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#oneOverRadii` */\n  transformPositionToScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#radii`. */\n  transformPositionFromScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.radii).to(result);\n  }\n\n  /** Computes a point which is the intersection of the surface normal with the z-axis. */\n  getSurfaceNormalIntersectionWithZAxis(\n    position: number[],\n    buffer: number = 0,\n    result: number[] = [0, 0, 0]\n  ): number[] {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n"],"file":"ellipsoid.js"}