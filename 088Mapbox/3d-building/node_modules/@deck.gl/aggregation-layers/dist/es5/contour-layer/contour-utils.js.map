{"version":3,"sources":["../../../src/contour-layer/contour-utils.ts"],"names":["generateContours","thresholdData","cellWeights","gridSize","gridOrigin","cellSize","contourSegments","contourPolygons","width","height","segmentIndex","polygonIndex","data","contour","threshold","x","y","code","meanCode","opts","type","CONTOUR_TYPE","ISO_BANDS","Array","isArray","polygons","polygon","vertices","ISO_LINES","i","length","start","end"],"mappings":"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","sourcesContent":["import {getCode, getVertices, CONTOUR_TYPE} from './marching-squares';\n\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({\n  thresholdData,\n  cellWeights,\n  gridSize,\n  gridOrigin,\n  cellSize\n}: {\n  thresholdData: any;\n  cellWeights: Float32Array;\n  gridSize: number[];\n  gridOrigin: number[];\n  cellSize: number[];\n}) {\n  const contourSegments: {start: number[]; end: number[]; contour: any}[] = [];\n  const contourPolygons: {vertices: number[][]; contour: any}[] = [];\n  const width = gridSize[0];\n  const height = gridSize[1];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (const data of thresholdData) {\n    const {contour} = data;\n    const {threshold} = contour;\n    for (let x = -1; x < width; x++) {\n      for (let y = -1; y < height; y++) {\n        // Get the MarchingSquares code based on neighbor cell weights.\n        const {code, meanCode} = getCode({\n          cellWeights,\n          threshold,\n          x,\n          y,\n          width,\n          height\n        });\n        const opts = {\n          type: CONTOUR_TYPE.ISO_BANDS,\n          gridOrigin,\n          cellSize,\n          x,\n          y,\n          width,\n          height,\n          code,\n          meanCode,\n          thresholdData: data\n        };\n        if (Array.isArray(threshold)) {\n          opts.type = CONTOUR_TYPE.ISO_BANDS;\n          const polygons = getVertices(opts) as number[][][];\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          // Get the intersection vertices based on MarchingSquares code.\n          opts.type = CONTOUR_TYPE.ISO_LINES;\n          const vertices = getVertices(opts) as number[][];\n          for (let i = 0; i < vertices.length; i += 2) {\n            contourSegments[segmentIndex++] = {\n              start: vertices[i],\n              end: vertices[i + 1],\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n  return {contourSegments, contourPolygons};\n}\n/* eslint-enable max-depth */\n"],"file":"contour-utils.js"}