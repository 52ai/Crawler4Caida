{"version":3,"sources":["../../../src/text-layer/lru-cache.ts"],"names":["LRUCache","limit","key","value","_cache","_deleteOrder","_appendOrder","Object","keys","length","delete","_order","index","indexOf","splice","push"],"mappings":";;;;;;;;;;;;;;;IAOqBA,Q;AAMnB,sBAA+B;AAAA,QAAnBC,KAAmB,uEAAH,CAAG;AAAA;AAAA;AAAA,kDAJU,EAIV;AAAA,kDAFJ,EAEI;AAC7B,SAAKA,KAAL,GAAaA,KAAb;AACD;;;;WAED,aAAIC,GAAJ,EAAyB;AACvB,UAAMC,KAAK,GAAG,KAAKC,MAAL,CAAYF,GAAZ,CAAd;;AACA,UAAIC,KAAJ,EAAW;AAET,aAAKE,YAAL,CAAkBH,GAAlB;;AACA,aAAKI,YAAL,CAAkBJ,GAAlB;AACD;;AACD,aAAOC,KAAP;AACD;;;WAED,aAAID,GAAJ,EAAiBC,KAAjB,EAAsC;AACpC,UAAI,CAAC,KAAKC,MAAL,CAAYF,GAAZ,CAAL,EAAuB;AAErB,YAAIK,MAAM,CAACC,IAAP,CAAY,KAAKJ,MAAjB,EAAyBK,MAAzB,KAAoC,KAAKR,KAA7C,EAAoD;AAClD,eAAKS,MAAL,CAAY,KAAKC,MAAL,CAAY,CAAZ,CAAZ;AACD;;AAED,aAAKP,MAAL,CAAYF,GAAZ,IAAmBC,KAAnB;;AACA,aAAKG,YAAL,CAAkBJ,GAAlB;AACD,OARD,MAQO;AAEL,aAAKQ,MAAL,CAAYR,GAAZ;AAEA,aAAKE,MAAL,CAAYF,GAAZ,IAAmBC,KAAnB;;AACA,aAAKG,YAAL,CAAkBJ,GAAlB;AACD;AACF;;;WAED,iBAAOA,GAAP,EAA0B;AACxB,UAAMC,KAAK,GAAG,KAAKC,MAAL,CAAYF,GAAZ,CAAd;;AACA,UAAIC,KAAJ,EAAW;AACT,eAAO,KAAKC,MAAL,CAAYF,GAAZ,CAAP;;AACA,aAAKG,YAAL,CAAkBH,GAAlB;AACD;AACF;;;WAED,sBAAqBA,GAArB,EAAwC;AACtC,UAAMU,KAAK,GAAG,KAAKD,MAAL,CAAYE,OAAZ,CAAoBX,GAApB,CAAd;;AACA,UAAIU,KAAK,IAAI,CAAb,EAAgB;AACd,aAAKD,MAAL,CAAYG,MAAZ,CAAmBF,KAAnB,EAA0B,CAA1B;AACD;AACF;;;WAED,sBAAqBV,GAArB,EAAwC;AACtC,WAAKS,MAAL,CAAYI,IAAZ,CAAiBb,GAAjB;AACD","sourcesContent":["/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\n\nexport default class LRUCache<ValueT> {\n  private limit: number;\n  private _cache: Record<string, ValueT> = {};\n  /** access/update order, first item is oldest, last item is newest */\n  private _order: string[] = [];\n\n  constructor(limit: number = 5) {\n    this.limit = limit;\n  }\n\n  get(key: string): ValueT {\n    const value = this._cache[key];\n    if (value) {\n      // update order\n      this._deleteOrder(key);\n      this._appendOrder(key);\n    }\n    return value;\n  }\n\n  set(key: string, value: ValueT): void {\n    if (!this._cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key: string): void {\n    const value = this._cache[key];\n    if (value) {\n      delete this._cache[key];\n      this._deleteOrder(key);\n    }\n  }\n\n  private _deleteOrder(key: string): void {\n    const index = this._order.indexOf(key);\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  private _appendOrder(key: string): void {\n    this._order.push(key);\n  }\n}\n"],"file":"lru-cache.js"}