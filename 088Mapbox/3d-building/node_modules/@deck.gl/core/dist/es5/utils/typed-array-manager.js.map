{"version":3,"sources":["../../../src/utils/typed-array-manager.ts"],"names":["TypedArrayManager","options","overAlloc","poolSize","setOptions","Object","assign","opts","typedArray","count","size","type","padding","copy","initialize","maxCount","Type","constructor","Float32Array","newSize","ArrayBuffer","isView","length","BYTES_PER_ELEMENT","buffer","byteLength","maxSize","Infinity","newArray","_allocate","set","fill","_release","sizeToAllocate","Math","max","ceil","pool","_pool","i","findIndex","b","array","splice","push","shift"],"mappings":"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","sourcesContent":["import {TypedArray, TypedArrayConstructor} from '../types/types';\n\nexport type TypedArrayManagerOptions = {\n  overAlloc?: number;\n  poolSize?: number;\n};\n\nexport class TypedArrayManager {\n  private _pool: ArrayBuffer[] = [];\n  opts: {\n    overAlloc: number;\n    poolSize: number;\n  } = {overAlloc: 2, poolSize: 100};\n\n  constructor(options: TypedArrayManagerOptions = {}) {\n    this.setOptions(options);\n  }\n\n  setOptions(options: TypedArrayManagerOptions) {\n    Object.assign(this.opts, options);\n  }\n\n  allocate<T extends TypedArray>(\n    typedArray: T | null | undefined,\n    count: number,\n    {\n      size = 1,\n      type,\n      padding = 0,\n      copy = false,\n      initialize = false,\n      maxCount\n    }: {\n      size?: number;\n      type?: TypedArrayConstructor;\n      padding?: number;\n      copy?: boolean;\n      initialize?: boolean;\n      maxCount?: number;\n    }\n  ): T {\n    const Type =\n      type || (typedArray && (typedArray.constructor as TypedArrayConstructor)) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize) as T;\n      }\n    }\n\n    let maxSize: number = Infinity;\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      // Hack - always initialize the first 4 elements. NaNs crash the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray as T;\n  }\n\n  release(typedArray: TypedArray | null | undefined) {\n    this._release(typedArray);\n  }\n\n  private _allocate(\n    Type: TypedArrayConstructor,\n    size: number,\n    initialize: boolean,\n    maxSize: number\n  ): TypedArray {\n    // Allocate at least one element to ensure a valid buffer\n    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);\n    // Don't over allocate after certain specified number of elements\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n      if (initialize) {\n        // Viewing a buffer with a different type may create NaNs\n        array.fill(0);\n      }\n      return array;\n    }\n    return new Type(sizeToAllocate);\n  }\n\n  private _release(typedArray: TypedArray | null | undefined): void {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.opts.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.opts.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"],"file":"typed-array-manager.js"}