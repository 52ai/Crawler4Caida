{"version":3,"sources":["../../../src/utils/tesselator.ts"],"names":["Tesselator","opts","attributes","typedArrayManager","defaultTypedArrayManager","_attributeDefs","updateGeometry","Object","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","startRow","endRow","value","ArrayBuffer","isView","offset","stride","instanceCount","copy","name","release","def","allocate","visitor","iterable","objectInfo","object","index","geometry","indexStarts","vertexStarts","Infinity","normalizedData","_forEachGeometry","dataIndex","normalizedGeometry","normalizeGeometry","getGeometrySize","length","Buffer","byteStride","accessor","byteLength","buffer","bufferValue","elementStride","BYTES_PER_ELEMENT","_allocate","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes","vertexCount"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/webgl';\n\nimport type {BinaryAttribute} from '../lib/attribute/attribute';\nimport type {TypedArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\nimport type {TypedArrayManager} from './typed-array-manager';\n\ntype ExternalBuffer = TypedArray | Buffer | BinaryAttribute;\n\ntype TesselatorOptions<GeometryT, ExtraOptionsT> = ExtraOptionsT & {\n  attributes?: Record<string, any>;\n  getGeometry?: AccessorFunction<any, GeometryT>;\n  data?: any;\n  buffers?: Record<string, ExternalBuffer>;\n  geometryBuffer?: ExternalBuffer;\n  positionFormat?: 'XY' | 'XYZ';\n  dataChanged?: {startRow: number; endRow?: number}[] | string | false;\n  normalize?: boolean;\n};\n\nexport type GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\nexport default abstract class Tesselator<GeometryT, NormalizedGeometryT, ExtraOptionsT> {\n  opts: TesselatorOptions<GeometryT, ExtraOptionsT>;\n  typedArrayManager: TypedArrayManager;\n  indexStarts: number[] = [0];\n  vertexStarts: number[] = [0];\n  vertexCount: number = 0;\n  instanceCount: number = 0;\n  attributes: Record<string, TypedArray | null>;\n\n  protected _attributeDefs: any;\n  protected data: any;\n  protected getGeometry?: AccessorFunction<any, GeometryT> | null;\n  protected geometryBuffer?: ExternalBuffer;\n  protected buffers!: Record<string, ExternalBuffer>;\n  protected positionSize!: number;\n  protected normalize!: boolean;\n\n  constructor(opts: TesselatorOptions<GeometryT, ExtraOptionsT>) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n  }\n\n  /* Public methods */\n  updateGeometry(opts: TesselatorOptions<GeometryT, ExtraOptionsT>): void {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged as {startRow: number; endRow?: number}[]) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}: {startRow: number; endRow: number}): void {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  // Subclass interface\n\n  /** Convert geometry to a uniform shape */\n  protected abstract normalizeGeometry(geometry: GeometryT): NormalizedGeometryT;\n\n  /** Update the positions buffer of a single geometry */\n  protected abstract updateGeometryAttributes(\n    geometry: NormalizedGeometryT | null,\n    context: GeometryUpdateContext\n  );\n\n  /** Get the number of vertices in a geometry */\n  protected abstract getGeometrySize(geometry: NormalizedGeometryT): number;\n\n  protected getGeometryFromBuffer(\n    geometryBuffer: ExternalBuffer\n  ): AccessorFunction<any, GeometryT> | null {\n    const value = (geometryBuffer as BinaryAttribute).value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: (geometryBuffer as BinaryAttribute).offset,\n      stride: (geometryBuffer as BinaryAttribute).stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  private _allocate(instanceCount: number, copy: boolean): void {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  private _forEachGeometry(\n    visitor: (geometry: GeometryT | null, index: number) => void,\n    startRow: number,\n    endRow: number\n  ): void {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _rebuildGeometry(dataRange?: {startRow: number; endRow?: number}): void {\n    if (!this.data) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData: Record<number, NormalizedGeometryT | null> = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry: GeometryT | null, dataIndex: number) => {\n          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] =\n            vertexStarts[dataIndex] +\n            (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        // @ts-expect-error (2339) accessor is not typed\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    // @ts-ignore (2739) context will be populated in the loop\n    const context: GeometryUpdateContext = {};\n\n    this._forEachGeometry(\n      (geometry: GeometryT | null, dataIndex: number) => {\n        const normalizedGeometry =\n          normalizedData[dataIndex] ||\n          // @ts-expect-error (2352) GeometryT cannot be casted to NormalizedGeometryT. We are assuming the user passed already normalized data if opts.normalize is set to false.\n          (geometry as NormalizedGeometryT);\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(normalizedGeometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"],"file":"tesselator.js"}