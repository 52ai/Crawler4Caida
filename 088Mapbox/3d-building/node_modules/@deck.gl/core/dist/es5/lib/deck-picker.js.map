{"version":3,"sources":["../../../src/lib/deck-picker.ts"],"names":["DeckPicker","gl","pickLayersPass","PickLayersPass","lastPickedInfo","index","layerId","info","props","layerFilter","_pickable","pickingFBO","delete","depthFBO","color","opts","_pickClosestObject","_pickVisibleObjects","x","y","layers","viewports","lastPickedLayerId","layer","id","lastPickedViewportId","viewport","find","l","v","coordinate","unproject","Framebuffer","isSupported","colorBufferFloat","attach","Texture2D","format","type","resize","width","canvas","height","pickableLayers","filter","isPickable","isComposite","length","views","radius","depth","mode","unproject3D","onViewportActive","effects","_getPickable","pixelRatio","result","emptyInfo","_resizeBuffer","devicePixelRange","devicePixel","Math","floor","deviceRadius","round","deviceRect","_getPickingRect","deviceX","deviceY","deviceWidth","deviceHeight","cullRect","infos","affectedLayers","Set","i","pickInfo","pickedResult","_drawAndSample","pass","pickedColor","pickedObjectIndex","z","pickedLayer","pickedResultPass2","pickedX","pickedY","pickedColors","add","disablePickingIndex","values","push","restorePickingColors","get","maxObjects","leftTop","deviceLeft","deviceTop","rightBottom","deviceRight","deviceBottom","pickInfos","uniqueInfos","Map","isMaxObjects","Number","isFinite","size","picked","has","object","set","Array","from","pickZ","render","decodePickingColor","Float32Array","Uint8Array","sourceX","sourceY","sourceWidth","sourceHeight","target","max","min"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Framebuffer,\n  Texture2D,\n  isWebGL2,\n  readPixelsToArray,\n  cssToDeviceRatio,\n  cssToDevicePixels\n} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport PickLayersPass, {PickingColorDecoder} from '../passes/pick-layers-pass';\nimport {getClosestObject, getUniqueObjects, PickedPixel} from './picking/query-object';\nimport {\n  processPickInfo,\n  getLayerPickingInfo,\n  getEmptyPickingInfo,\n  PickingInfo\n} from './picking/pick-info';\n\nimport type {Framebuffer as LumaFramebuffer} from '@luma.gl/webgl';\nimport type {FilterContext, Rect} from '../passes/layers-pass';\nimport type Layer from './layer';\nimport type {Effect} from './effect';\nimport type View from '../views/view';\nimport type Viewport from '../viewports/viewport';\n\nexport type PickByPointOptions = {\n  x: number;\n  y: number;\n  radius?: number;\n  depth?: number;\n  mode?: string;\n  unproject3D?: boolean;\n};\n\nexport type PickByRectOptions = {\n  x: number;\n  y: number;\n  width?: number;\n  height?: number;\n  mode?: string;\n  maxObjects?: number | null;\n};\n\ntype PickOperationContext = {\n  layers: Layer[];\n  views: Record<string, View>;\n  viewports: Viewport[];\n  onViewportActive: (viewport: Viewport) => void;\n  effects: Effect[];\n};\n\n/** Manages picking in a Deck context */\nexport default class DeckPicker {\n  gl: WebGLRenderingContext;\n  pickingFBO?: LumaFramebuffer;\n  depthFBO?: LumaFramebuffer;\n  pickLayersPass: PickLayersPass;\n  layerFilter?: (context: FilterContext) => boolean;\n\n  /** Identifiers of the previously picked object, for callback tracking and auto highlight */\n  lastPickedInfo: {\n    index: number;\n    layerId: string | null;\n    info: PickingInfo | null;\n  };\n\n  _pickable: boolean = true;\n\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n\n  setProps(props: any): void {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n\n  /** Pick the closest info at given coordinate */\n  pickObject(opts: PickByPointOptions & PickOperationContext) {\n    return this._pickClosestObject(opts);\n  }\n\n  /** Get all unique infos within a bounding box */\n  pickObjects(opts: PickByRectOptions & PickOperationContext) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({x, y, layers, viewports}, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId =\n      lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport =\n      (lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId)) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n\n    return {...lastPickedInfo, ...info};\n  }\n\n  // Private\n\n  /** Ensures that picking framebuffer exists and matches the canvas size */\n  _resizeBuffer() {\n    const {gl} = this;\n\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n\n      if (Framebuffer.isSupported(gl, {colorBufferFloat: true})) {\n        const depthFBO = new Framebuffer(gl);\n        depthFBO.attach({\n          [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n            format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n            type: GL.FLOAT\n          })\n        });\n        this.depthFBO = depthFBO;\n      }\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    this.pickingFBO?.resize({width: gl.canvas.width, height: gl.canvas.height});\n    this.depthFBO?.resize({width: gl.canvas.width, height: gl.canvas.height});\n  }\n\n  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */\n  _getPickable(layers: Layer[]): Layer[] | null {\n    if (this._pickable === false) {\n      return null;\n    }\n    const pickableLayers = layers.filter(layer => layer.isPickable() && !layer.isComposite);\n    return pickableLayers.length ? pickableLayers : null;\n  }\n\n  // eslint-disable-next-line max-statements,complexity\n  /** Pick the closest object at the given coordinate */\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive,\n    effects\n  }: PickByPointOptions & PickOperationContext): {\n    result: PickingInfo[];\n    emptyInfo: PickingInfo;\n  } {\n    const pickableLayers = this._getPickable(layers);\n    const pixelRatio = cssToDeviceRatio(this.gl);\n\n    if (!pickableLayers) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({viewports, x, y, pixelRatio})\n      };\n    }\n\n    this._resizeBuffer();\n\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [\n      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n    ];\n\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {width, height} = this.pickingFBO as LumaFramebuffer;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    const cullRect: Rect = {\n      x: x - radius,\n      y: y - radius,\n      width: radius * 2 + 1,\n      height: radius * 2 + 1\n    };\n\n    let infos: Map<string | null, PickingInfo>;\n    const result: PickingInfo[] = [];\n    const affectedLayers = new Set<Layer>();\n\n    for (let i = 0; i < depth; i++) {\n      let pickInfo: PickedPixel;\n\n      if (deviceRect) {\n        const pickedResult = this._drawAndSample({\n          layers: pickableLayers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          cullRect,\n          effects,\n          pass: `picking:${mode}`\n        });\n\n        pickInfo = getClosestObject({\n          ...pickedResult,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius,\n          deviceRect\n        });\n      } else {\n        pickInfo = {\n          pickedColor: null,\n          pickedObjectIndex: -1\n        };\n      }\n\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const pickedResultPass2 = this._drawAndSample(\n          {\n            layers: [pickInfo.pickedLayer],\n            views,\n            viewports,\n            onViewportActive,\n            deviceRect: {\n              x: pickInfo.pickedX as number,\n              y: pickInfo.pickedY as number,\n              width: 1,\n              height: 1\n            },\n            cullRect,\n            effects,\n            pass: `picking:${mode}:z`\n          },\n          true\n        );\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        z = pickedResultPass2.pickedColors[0];\n      }\n\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers: pickableLayers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    // reset only affected buffers\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n\n    return {result, emptyInfo: infos!.get(null) as PickingInfo};\n  }\n\n  /** Pick all objects within the given bounding box */\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    maxObjects = null,\n    onViewportActive,\n    effects\n  }: PickByRectOptions & PickOperationContext): PickingInfo[] {\n    const pickableLayers = this._getPickable(layers);\n\n    if (!pickableLayers) {\n      return [];\n    }\n\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n\n    // take right and bottom (y inverted in device pixels) from end location\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedResult = this._drawAndSample({\n      layers: pickableLayers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect: {x, y, width, height},\n      effects,\n      pass: `picking:${mode}`\n    });\n\n    const pickInfos = getUniqueObjects(pickedResult);\n\n    // Only return unique infos, identified by info.object\n    const uniqueInfos = new Map();\n\n    const isMaxObjects = Number.isFinite(maxObjects);\n\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {\n        break;\n      }\n      const pickInfo = pickInfos[i];\n      let info: PickingInfo = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        pixelRatio\n      };\n\n      info = getLayerPickingInfo({layer: pickInfo.pickedLayer as Layer, info, mode});\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    }\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  /** Renders layers into the picking buffer with picking colors and read the pixels. */\n  _drawAndSample(params: {\n    deviceRect: Rect;\n    pass: string;\n    layers: Layer[];\n    views: Record<string, View>;\n    viewports: Viewport[];\n    onViewportActive: (viewport: Viewport) => void;\n    cullRect?: Rect;\n    effects: Effect[];\n  }): {\n    pickedColors: Uint8Array;\n    decodePickingColor: PickingColorDecoder;\n  };\n\n  /** Renders layers into the picking buffer with encoded z values and read the pixels. */\n  _drawAndSample(\n    params: {\n      deviceRect: Rect;\n      pass: string;\n      layers: Layer[];\n      views: Record<string, View>;\n      viewports: Viewport[];\n      onViewportActive: (viewport: Viewport) => void;\n      cullRect?: Rect;\n      effects: Effect[];\n    },\n    pickZ: true\n  ): {\n    pickedColors: Float32Array;\n    decodePickingColor: null;\n  };\n\n  _drawAndSample(\n    {\n      layers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect,\n      effects,\n      pass\n    }: {\n      deviceRect: Rect;\n      pass: string;\n      layers: Layer[];\n      views: Record<string, View>;\n      viewports: Viewport[];\n      onViewportActive: (viewport: Viewport) => void;\n      cullRect?: Rect;\n      effects: Effect[];\n    },\n    pickZ: boolean = false\n  ): {\n    pickedColors: Uint8Array | Float32Array;\n    decodePickingColor: PickingColorDecoder | null;\n  } {\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n\n    const {decodePickingColor} = this.pickLayersPass.render({\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      cullRect,\n      effects,\n      pass,\n      pickZ\n    });\n\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {x, y, width, height} = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n\n    return {pickedColors, decodePickingColor};\n  }\n\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth,\n    deviceHeight\n  }: {\n    deviceX: number;\n    deviceY: number;\n    deviceRadius: number;\n    deviceWidth: number;\n    deviceHeight: number;\n  }): Rect | null {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {x, y, width, height};\n  }\n}\n"],"file":"deck-picker.js"}