{"version":3,"sources":["../../../../src/lib/attribute/attribute-transition-utils.ts"],"names":["DEFAULT_TRANSITION_SETTINGS","interpolation","duration","easing","t","spring","stiffness","damping","normalizeTransitionSettings","userSettings","layerSettings","Number","isFinite","type","getSourceBufferAttribute","gl","attribute","buffer","getBuffer","divisor","size","normalized","settings","value","getAttributeTypeFromSize","Error","cycleBuffers","buffers","push","shift","getAttributeBufferLength","numInstances","doublePrecision","multiplier","Float64Array","noAlloc","length","padBuffer","fromLength","fromStartIndices","getData","x","precisionMultiplier","byteOffset","toStartIndices","startIndices","hasStartIndices","toLength","isConstant","toData","srcByteOffset","getter","chunk","normalizeConstant","getMissingData","i","subarray","source","data","Float32Array","target","sourceStartIndices","targetStartIndices","byteLength","reallocate","subData","offset"],"mappings":"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","sourcesContent":["import {padArray} from '../../utils/array-utils';\nimport {NumericArray} from '../../types/types';\nimport Attribute from './attribute';\nimport type {BufferAccessor} from './data-column';\nimport type {Buffer} from '@luma.gl/webgl';\n\nexport interface TransitionSettings {\n  type: string;\n  /** Callback to get the value that the entering vertices are transitioning from. */\n  enter?: (toValue: NumericArray, chunk?: NumericArray) => NumericArray;\n  /** Callback when the transition is started */\n  onStart?: () => void;\n  /** Callback when the transition is done */\n  onEnd?: () => void;\n  /** Callback when the transition is interrupted */\n  onInterrupt?: () => void;\n}\n\nexport type InterpolationTransitionSettings = TransitionSettings & {\n  type?: 'interpolation';\n  /** Duration of the transition animation, in milliseconds */\n  duration: number;\n  /** Easing function that maps a value from [0, 1] to [0, 1], see [http://easings.net/](http://easings.net/) */\n  easing?: (t: number) => number;\n};\n\nexport type SpringTransitionSettings = TransitionSettings & {\n  type: 'spring';\n  /** \"Tension\" factor for the spring */\n  stiffness: number;\n  /** \"Friction\" factor that counteracts the spring's acceleration */\n  damping: number;\n};\n\nconst DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: t => t\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\n\nexport function normalizeTransitionSettings(\n  userSettings: number | InterpolationTransitionSettings | SpringTransitionSettings,\n  layerSettings?: boolean | Partial<TransitionSettings>\n): TransitionSettings | null {\n  if (!userSettings) {\n    return null;\n  }\n  if (Number.isFinite(userSettings)) {\n    userSettings = {type: 'interpolation', duration: userSettings as number};\n  }\n  const type = (userSettings as TransitionSettings).type || 'interpolation';\n  return {\n    ...DEFAULT_TRANSITION_SETTINGS[type],\n    ...(layerSettings as TransitionSettings),\n    ...(userSettings as TransitionSettings),\n    type\n  };\n}\n\n// NOTE: NOT COPYING OVER OFFSET OR STRIDE HERE BECAUSE:\n// (1) WE DON'T SUPPORT INTERLEAVED BUFFERS FOR TRANSITIONS\n// (2) BUFFERS WITH OFFSETS ALWAYS CONTAIN VALUES OF THE SAME SIZE\n// (3) THE OPERATIONS IN THE SHADER ARE PER-COMPONENT (addition and scaling)\nexport function getSourceBufferAttribute(\n  gl: WebGLRenderingContext,\n  attribute: Attribute\n): [Buffer, BufferAccessor] | NumericArray {\n  // The Attribute we pass to Transform as a sourceBuffer must have {divisor: 0}\n  // so we create a copy of the attribute (with divisor=0) to use when running\n  // transform feedback\n  const buffer = attribute.getBuffer();\n  if (buffer) {\n    return [\n      buffer,\n      {\n        divisor: 0,\n        size: attribute.size,\n        normalized: attribute.settings.normalized\n      } as BufferAccessor\n    ];\n  }\n  // constant\n  // don't pass normalized here because the `value` from a normalized attribute is\n  // already normalized\n  return attribute.value as NumericArray;\n}\n\nexport function getAttributeTypeFromSize(size: number): string {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`No defined attribute type for size \"${size}\"`);\n  }\n}\n\nexport function cycleBuffers(buffers: Buffer[]): void {\n  buffers.push(buffers.shift() as Buffer);\n}\n\nexport function getAttributeBufferLength(attribute: Attribute, numInstances: number): number {\n  const {doublePrecision, settings, value, size} = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  return (settings.noAlloc ? (value as NumericArray).length : numInstances * size) * multiplier;\n}\n\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\nexport function padBuffer({\n  buffer,\n  numInstances,\n  attribute,\n  fromLength,\n  fromStartIndices,\n  getData = x => x\n}: {\n  buffer: Buffer;\n  numInstances: number;\n  attribute: Attribute;\n  fromLength: number;\n  fromStartIndices?: NumericArray | null;\n  getData?: (toValue: NumericArray, chunk?: NumericArray) => NumericArray;\n}): void {\n  // TODO: move the precisionMultiplier logic to the attribute when retrieving\n  // its `size` and `elementOffset`?\n  const precisionMultiplier =\n    attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const toLength = getAttributeBufferLength(attribute, numInstances);\n  const isConstant = attribute.isConstant;\n\n  // check if buffer needs to be padded\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n\n  const toData = isConstant\n    ? attribute.value\n    : (attribute.getBuffer() as Buffer).getData({srcByteOffset: byteOffset});\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n  }\n\n  const getMissingData = isConstant\n    ? (i, chunk) => getData(toData, chunk)\n    : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n\n  const source = buffer.getData({length: fromLength});\n  const data = new Float32Array(toLength);\n  padArray({\n    source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n\n  // TODO: support offset in buffer.setData?\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n  buffer.subData({data, offset: byteOffset});\n}\n"],"file":"attribute-transition-utils.js"}