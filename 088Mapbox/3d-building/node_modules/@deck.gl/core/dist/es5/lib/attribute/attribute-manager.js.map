{"version":3,"sources":["../../../../src/lib/attribute/attribute-manager.ts"],"names":["TRACE_INVALIDATE","TRACE_UPDATE_START","TRACE_UPDATE_END","TRACE_ATTRIBUTE_UPDATE_START","TRACE_ATTRIBUTE_ALLOCATE","TRACE_ATTRIBUTE_UPDATE_END","AttributeManager","gl","id","stats","timeline","attributes","updateTriggers","needsRedraw","userData","attributeTransitionManager","AttributeTransitionManager","Object","seal","attributeName","delete","finalize","opts","clearRedrawFlags","redraw","_add","instanced","attributeNameArray","name","undefined","triggerName","dataRange","invalidatedAttributes","_invalidateTrigger","setNeedsUpdate","data","numInstances","startIndices","transitions","props","buffers","context","updated","get","timeStart","attribute","accessorName","settings","accessor","log","removed","setExternalBuffer","setBinaryValue","setConstantValue","needsUpdate","_updateAttribute","timeEnd","update","transitionUpdated","run","clearChangedFlags","changedAttributes","getAttributes","hasAttribute","excludeAttributes","shaderAttributes","assign","getShaderAttributes","extraProps","_createAttribute","_mapUpdateTriggersToAttributes","size","isIndexed","divisor","Attribute","triggers","getUpdateTriggers","forEach","push","constant","value","allocate","updateBuffer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport Attribute, {AttributeOptions} from './attribute';\nimport {IShaderAttribute} from './shader-attribute';\nimport log from '../../utils/log';\nimport debug from '../../debug';\nimport {NumericArray} from '../../types/types';\n\nimport AttributeTransitionManager from './attribute-transition-manager';\n\nimport type {Stat} from 'probe.gl';\nimport type {Timeline} from '@luma.gl/engine';\n\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\n\nexport default class AttributeManager {\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   */\n  id: string;\n  gl: WebGLRenderingContext;\n  attributes: Record<string, Attribute>;\n  updateTriggers: {[name: string]: string[]};\n  needsRedraw: string | boolean;\n  userData: any;\n\n  private stats?: Stat;\n  private attributeTransitionManager: AttributeTransitionManager;\n\n  constructor(\n    gl: WebGLRenderingContext,\n    {\n      id = 'attribute-manager',\n      stats,\n      timeline\n    }: {\n      id?: string;\n      stats?: Stat;\n      timeline?: Timeline;\n    } = {}\n  ) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributes = {};\n\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n\n    this.userData = {};\n    this.stats = stats;\n\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: `${id}-transitions`,\n      timeline\n    });\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts: {clearRedrawFlags?: boolean} = {clearRedrawFlags: false}): string | false {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  setNeedsRedraw() {\n    this.needsRedraw = true;\n  }\n\n  // Adds attributes\n  add(attributes: {[id: string]: AttributeOptions}) {\n    this._add(attributes);\n  }\n\n  // Adds attributes\n  addInstanced(attributes: {[id: string]: AttributeOptions}) {\n    this._add(attributes, {instanced: 1});\n  }\n\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray: string[]) {\n    for (const name of attributeNameArray) {\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  // Marks an attribute for update\n  invalidate(triggerName: string, dataRange?: {startRow?: number; endRow?: number}) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n\n  invalidateAll(dataRange?: {startRow?: number; endRow?: number}) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n\n  // Ensure all attribute buffers are updated from props or data.\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  }: {\n    data: any;\n    numInstances: number;\n    startIndices?: NumericArray | null;\n    transitions: any;\n    props: any;\n    buffers: any;\n    context: any;\n  }) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n      attribute.numInstances = numInstances;\n\n      if (props[attributeName]) {\n        log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n      }\n\n      if (attribute.setExternalBuffer(buffers[attributeName])) {\n        // Step 1: try update attribute directly from external buffers\n      } else if (\n        attribute.setBinaryValue(\n          typeof accessorName === 'string' ? buffers[accessorName] : undefined,\n          data.startIndices\n        )\n      ) {\n        // Step 2: try set packed value from external typed array\n      } else if (\n        typeof accessorName === 'string' &&\n        !buffers[accessorName] &&\n        attribute.setConstantValue(props[accessorName])\n      ) {\n        // Step 3: try set constant value from props\n        // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n        // This may happen when setBinaryValue falls through to use the auto updater\n      } else if (attribute.needsUpdate()) {\n        // Step 4: update via updater callback\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n\n      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n    }\n\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {attributeTransitionManager} = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes(): {[id: string]: Attribute} {\n    return this.attributes;\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts: {clearChangedFlags?: boolean} = {clearChangedFlags: false}): {\n    [id: string]: Attribute;\n  } {\n    const {attributes, attributeTransitionManager} = this;\n\n    const changedAttributes = {...attributeTransitionManager.getAttributes()};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedAttributes;\n  }\n\n  // Returns shader attributes\n  getShaderAttributes(\n    attributes?: {[id: string]: Attribute},\n    excludeAttributes: Record<string, boolean> = {}\n  ): {[id: string]: IShaderAttribute} {\n    if (!attributes) {\n      attributes = this.getAttributes();\n    }\n    const shaderAttributes = {};\n    for (const attributeName in attributes) {\n      if (!excludeAttributes[attributeName]) {\n        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n      }\n    }\n    return shaderAttributes;\n  }\n\n  // PRIVATE METHODS\n\n  // Used to register an attribute\n  private _add(attributes: {[id: string]: AttributeOptions}, extraProps: any = {}) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n    }\n\n    this._mapUpdateTriggersToAttributes();\n  }\n  /* eslint-enable max-statements */\n\n  private _createAttribute(name: string, attribute: AttributeOptions, extraProps: any) {\n    // For expected default values see:\n    // https://github.com/visgl/luma.gl/blob/1affe21352e289eeaccee2a876865138858a765c/modules/webgl/src/classes/accessor.js#L5-L13\n    // and https://deck.gl/docs/api-reference/core/attribute-manager#add\n    const props: AttributeOptions = {\n      ...attribute,\n      id: name,\n      size: (attribute.isIndexed && 1) || attribute.size || 1,\n      divisor: extraProps.instanced ? 1 : attribute.divisor || 0\n    };\n\n    return new Attribute(this.gl, props);\n  }\n\n  // build updateTrigger name to attribute name mapping\n  private _mapUpdateTriggersToAttributes() {\n    const triggers: {[name: string]: string[]} = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  private _invalidateTrigger(\n    triggerName: string,\n    dataRange?: {startRow?: number; endRow?: number}\n  ): string[] {\n    const {attributes, updateTriggers} = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n\n  private _updateAttribute(opts: {\n    attribute: Attribute;\n    numInstances: number;\n    data: any;\n    props: any;\n    context: any;\n  }) {\n    const {attribute, numInstances} = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n    if (attribute.constant) {\n      // The attribute is flagged as constant outside of an update cycle\n      // Skip allocation and updater call\n      attribute.setConstantValue(attribute.value as NumericArray);\n      return;\n    }\n\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n\n    // Calls update on any buffers that need update\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}\n"],"file":"attribute-manager.js"}