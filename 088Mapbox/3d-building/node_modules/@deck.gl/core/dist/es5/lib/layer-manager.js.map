{"version":3,"sources":["../../../src/lib/layer-manager.ts"],"names":["TRACE_SET_LAYERS","TRACE_ACTIVATE_VIEWPORT","LayerManager","gl","deck","stats","viewport","timeline","context","layers","resourceManager","ResourceManager","protocol","mousePosition","userData","layerManager","programManager","Stats","id","Viewport","Timeline","onError","undefined","Object","seal","finalize","layer","_finalizeLayer","opts","clearRedrawFlags","redraw","_needsRedraw","layerNeedsRedraw","getNeedsRedraw","_nextLayers","_lastRenderedLayers","_needsUpdate","reason","layerIds","filter","find","layerId","indexOf","props","_debug","debug","newLayers","flatLayers","Boolean","_updateLayers","needsUpdate","setNeedsRedraw","setLayers","stage","error","raiseError","oldLayers","oldLayerMap","oldLayer","log","warn","generatedLayers","_updateSublayersRecursively","_finalizeOldLayers","hasUniformTransition","newLayer","sublayers","validateProps","_initializeLayer","_transferLayerState","_updateLayer","push","isComposite","getSubLayers","err","_handleError","_initialize","lifecycle","LIFECYCLE","INITIALIZED","_transferState","MATCHED","AWAITING_GC","_update","AWAITING_FINALIZATION","_finalize","FINALIZED"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Timeline} from '@luma.gl/core';\nimport {LIFECYCLE} from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport {flatten} from '../utils/flatten';\nimport {Stats} from '@probe.gl/stats';\nimport ResourceManager from './resource/resource-manager';\n\nimport Viewport from '../viewports/viewport';\nimport {createProgramManager} from '../shaderlib';\n\nimport type Layer from './layer';\nimport type CompositeLayer from './composite-layer';\nimport type Deck from './deck';\nimport type {ProgramManager} from '@luma.gl/engine';\n\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\n\nexport type LayerContext = {\n  layerManager: LayerManager;\n  resourceManager: ResourceManager;\n  deck?: Deck;\n  gl: WebGLRenderingContext;\n  programManager: ProgramManager;\n  stats: Stats;\n  viewport: Viewport;\n  timeline: Timeline;\n  mousePosition: {x: number; y: number} | null;\n  userData: any;\n  onError?: <PropsT>(error: Error, source: Layer<PropsT>) => void;\n};\n\nexport type LayersList = (Layer | undefined | false | null | LayersList)[];\n\nexport default class LayerManager {\n  layers: Layer[];\n  context: LayerContext;\n  resourceManager: ResourceManager;\n\n  private _lastRenderedLayers: LayersList = [];\n  private _needsRedraw: string | false = false;\n  private _needsUpdate: string | false = false;\n  private _nextLayers: LayersList | null = null;\n  private _debug: boolean = false;\n\n  // eslint-disable-next-line\n  constructor(\n    gl,\n    {\n      deck,\n      stats,\n      viewport,\n      timeline\n    }: {\n      deck?: Deck;\n      stats?: Stats;\n      viewport?: Viewport;\n      timeline?: Timeline;\n    } = {}\n  ) {\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n\n    // `this._lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.layers = [];\n    this.resourceManager = new ResourceManager({gl, protocol: 'deck://'});\n\n    this.context = {\n      mousePosition: null,\n      userData: {},\n      layerManager: this,\n      gl,\n      deck,\n      // Enabling luma.gl Program caching using private API (_cachePrograms)\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({id: 'deck.gl'}),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({id: 'DEFAULT-INITIAL-VIEWPORT'}), // Current viewport, exposed to layers for project* function\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager,\n      onError: undefined\n    };\n\n    Object.seal(this);\n  }\n\n  /** Method to call when the layer manager is not needed anymore. */\n  finalize() {\n    this.resourceManager.finalize();\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n\n  /** Check if a redraw is needed */\n  needsRedraw(\n    opts: {\n      /** Reset redraw flags to false after the call */\n      clearRedrawFlags: boolean;\n    } = {clearRedrawFlags: false}\n  ): string | false {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  /** Check if a deep update of all layers is needed */\n  needsUpdate(): string | false {\n    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {\n      // New layers array may be the same as the old one if `setProps` is called by React\n      return 'layers changed';\n    }\n    return this._needsUpdate;\n  }\n\n  /** Layers will be redrawn (in next animation frame) */\n  setNeedsRedraw(reason: string): void {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  /** Layers will be updated deeply (in next animation frame)\n    Potentially regenerating attributes and sub layers */\n  setNeedsUpdate(reason: string): void {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  /** Gets a list of currently rendered layers. Optionally filter by id. */\n  getLayers({layerIds}: {layerIds?: string[]} = {}): Layer[] {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds\n      ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0))\n      : this.layers;\n  }\n\n  /** Set props needed for layer rendering and picking. */\n  setProps(props: any): void {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n\n    // New layers will be processed in `updateLayers` in the next update cycle\n    if ('layers' in props) {\n      this._nextLayers = props.layers;\n    }\n\n    if ('onError' in props) {\n      this.context.onError = props.onError;\n    }\n  }\n\n  /** Supply a new layer list, initiating sublayer generation and layer matching */\n  setLayers(newLayers: LayersList, reason?: string): void {\n    debug(TRACE_SET_LAYERS, this, reason, newLayers);\n\n    this._lastRenderedLayers = newLayers;\n\n    const flatLayers = flatten(newLayers, Boolean) as Layer[];\n\n    for (const layer of flatLayers) {\n      layer.context = this.context;\n    }\n\n    this._updateLayers(this.layers, flatLayers);\n  }\n\n  /** Update layers from last cycle if `setNeedsUpdate()` has been called */\n  updateLayers(): void {\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // Force a full update\n      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);\n    }\n    // Updated, clear the backlog\n    this._nextLayers = null;\n  }\n\n  //\n  // INTERNAL METHODS\n  //\n\n  /** Make a viewport \"current\" in layer context, updating viewportChanged flags */\n  activateViewport = (viewport: Viewport) => {\n    debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n    if (viewport) {\n      this.context.viewport = viewport;\n    }\n  };\n\n  private _handleError(stage: string, error: Error, layer: Layer) {\n    layer.raiseError(error, `${stage} of ${layer}`);\n  }\n\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  /** Match all layers, checking for caught errors\n    to avoid having an exception in one layer disrupt other layers */\n  private _updateLayers(oldLayers: Layer[], newLayers: Layer[]): void {\n    // Create old layer map\n    const oldLayerMap: {[layerId: string]: Layer | null} = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${oldLayer.id}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    // Allocate array for generated layers\n    const generatedLayers: Layer[] = [];\n\n    // Match sublayers\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n    // Finalize unmatched layers\n    this._finalizeOldLayers(oldLayerMap);\n\n    let needsUpdate: string | false = false;\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = `Uniform transition in ${layer}`;\n        break;\n      }\n    }\n\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  private _updateSublayersRecursively(\n    newLayers: Layer[],\n    oldLayerMap: {[layerId: string]: Layer | null},\n    generatedLayers: Layer[]\n  ) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${newLayer.id}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n\n      let sublayers: Layer[] | null = null;\n\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          this._updateLayer(newLayer);\n        }\n        generatedLayers.push(newLayer);\n\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite ? (newLayer as CompositeLayer).getSubLayers() : null;\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        this._handleError('matching', err as Error, newLayer); // Record first exception\n      }\n\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n  /* eslint-enable complexity,max-statements */\n\n  // Finalize any old layers that were not matched\n  private _finalizeOldLayers(oldLayerMap: {[layerId: string]: Layer | null}): void {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n\n  // / EXCEPTION SAFE LAYER ACCESS\n\n  /** Safely initializes a single layer, calling layer methods */\n  private _initializeLayer(layer: Layer): void {\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      this._handleError('initialization', err as Error, layer);\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n  }\n\n  /** Transfer state from one layer to a newer version */\n  private _transferLayerState(oldLayer: Layer, newLayer: Layer): void {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n\n  /** Safely updates a single layer, cleaning all flags */\n  private _updateLayer(layer: Layer): void {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError('update', err as Error, layer);\n    }\n  }\n\n  /** Safely finalizes a single layer, removing all resources */\n  private _finalizeLayer(layer: Layer): void {\n    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;\n\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n    try {\n      layer._finalize();\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      this._handleError('finalization', err as Error, layer);\n    }\n  }\n}\n"],"file":"layer-manager.js"}