{"version":3,"sources":["../../../../src/effects/mask/mask-effect.ts"],"names":["MaskEffect","gl","layers","layerFilter","viewports","onViewportActive","views","dummyMaskMap","Texture2D","width","height","maskLayers","filter","l","props","visible","operation","OPERATION","MASK","length","masks","channels","maskPass","MaskPass","id","maskMap","channelMap","_sortMaskChannels","viewport","viewportChanged","lastViewport","equals","maskId","_renderChannel","channelInfo","oldChannelInfo","index","maskChanged","layerBounds","some","b","i","bounds","maskBounds","maskViewport","getBounds","render","pass","channel","moduleParameters","devicePixelRatio","coordinateOrigin","coordinateSystem","channelCount","layer","root","log","warn","findIndex","c","push","maskChannels","delete","undefined"],"mappings":";;;;;;;;;;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;;;;;;;IA4BqBA,U;;;8CACd,a;iDACG,I;wDACO,I;;oDAGwB,E;iDACM,I;;;;;;;;WAK7C,mBACEC,EADF,QAGQ;AAAA,UADLC,MACK,QADLA,MACK;AAAA,UADGC,WACH,QADGA,WACH;AAAA,UADgBC,SAChB,QADgBA,SAChB;AAAA,UAD2BC,gBAC3B,QAD2BA,gBAC3B;AAAA,UAD6CC,KAC7C,QAD6CA,KAC7C;;AACN,UAAI,CAAC,KAAKC,YAAV,EAAwB;AACtB,aAAKA,YAAL,GAAoB,IAAIC,eAAJ,CAAcP,EAAd,EAAkB;AACpCQ,UAAAA,KAAK,EAAE,CAD6B;AAEpCC,UAAAA,MAAM,EAAE;AAF4B,SAAlB,CAApB;AAID;;AAED,UAAMC,UAAU,GAAGT,MAAM,CAACU,MAAP,CAAc,UAAAC,CAAC;AAAA,eAAIA,CAAC,CAACC,KAAF,CAAQC,OAAR,IAAmBF,CAAC,CAACC,KAAF,CAAQE,SAAR,KAAsBC,qBAAUC,IAAvD;AAAA,OAAf,CAAnB;;AACA,UAAIP,UAAU,CAACQ,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,aAAKC,KAAL,GAAa,IAAb;AACA,aAAKC,QAAL,CAAcF,MAAd,GAAuB,CAAvB;AACA;AACD;;AACD,WAAKC,KAAL,GAAa,EAAb;;AAEA,UAAI,CAAC,KAAKE,QAAV,EAAoB;AAClB,aAAKA,QAAL,GAAgB,IAAIC,iBAAJ,CAAatB,EAAb,EAAiB;AAACuB,UAAAA,EAAE,EAAE;AAAL,SAAjB,CAAhB;AACA,aAAKC,OAAL,GAAe,KAAKH,QAAL,CAAcG,OAA7B;AACD;;AAGD,UAAMC,UAAU,GAAG,KAAKC,iBAAL,CAAuBhB,UAAvB,CAAnB;;AAEA,UAAMiB,QAAQ,GAAGxB,SAAS,CAAC,CAAD,CAA1B;AACA,UAAMyB,eAAe,GAAG,CAAC,KAAKC,YAAN,IAAsB,CAAC,KAAKA,YAAL,CAAkBC,MAAlB,CAAyBH,QAAzB,CAA/C;;AAEA,WAAK,IAAMI,MAAX,IAAqBN,UAArB,EAAiC;AAC/B,aAAKO,cAAL,CAAoBP,UAAU,CAACM,MAAD,CAA9B,EAAwC;AACtC7B,UAAAA,WAAW,EAAXA,WADsC;AAEtCE,UAAAA,gBAAgB,EAAhBA,gBAFsC;AAGtCC,UAAAA,KAAK,EAALA,KAHsC;AAItCsB,UAAAA,QAAQ,EAARA,QAJsC;AAKtCC,UAAAA,eAAe,EAAfA;AALsC,SAAxC;AAOD;AA2BF;;;WAED,wBACEK,WADF,SAeE;AAAA,UAZE/B,WAYF,SAZEA,WAYF;AAAA,UAXEE,gBAWF,SAXEA,gBAWF;AAAA,UAVEC,KAUF,SAVEA,KAUF;AAAA,UATEsB,QASF,SATEA,QASF;AAAA,UAREC,eAQF,SAREA,eAQF;AACA,UAAMM,cAAc,GAAG,KAAKd,QAAL,CAAca,WAAW,CAACE,KAA1B,CAAvB;;AACA,UAAI,CAACD,cAAL,EAAqB;AACnB;AACD;;AAED,UAAME,WAAW,GAEfH,WAAW,KAAKC,cAAhB,IAEAA,cAAc,CAACjC,MAAf,CAAsBiB,MAAtB,KAAiCe,WAAW,CAAChC,MAAZ,CAAmBiB,MAFpD,IAIAe,WAAW,CAACI,WAAZ,CAAwBC,IAAxB,CAA6B,UAACC,CAAD,EAAIC,CAAJ;AAAA,eAAUD,CAAC,KAAKL,cAAc,CAACG,WAAf,CAA2BG,CAA3B,CAAhB;AAAA,OAA7B,CANF;AAQAP,MAAAA,WAAW,CAACQ,MAAZ,GAAqBP,cAAc,CAACO,MAApC;AACAR,MAAAA,WAAW,CAACS,UAAZ,GAAyBR,cAAc,CAACQ,UAAxC;AACA,WAAKtB,QAAL,CAAca,WAAW,CAACE,KAA1B,IAAmCF,WAAnC;;AAEA,UAAIG,WAAW,IAAIR,eAAnB,EAAoC;AAElC,aAAKC,YAAL,GAAoBF,QAApB;AAEAM,QAAAA,WAAW,CAACQ,MAAZ,GAAqB,0BAAc;AAACxC,UAAAA,MAAM,EAAEgC,WAAW,CAAChC,MAArB;AAA6B0B,UAAAA,QAAQ,EAARA;AAA7B,SAAd,CAArB;;AAEA,YAAIS,WAAW,IAAI,CAAC,mBAAOH,WAAW,CAACQ,MAAnB,EAA2BP,cAAc,CAACO,MAA1C,CAApB,EAAuE;AAErE,cAAOpB,QAAP,GAA4B,IAA5B,CAAOA,QAAP;AAAA,cAAiBG,OAAjB,GAA4B,IAA5B,CAAiBA,OAAjB;AAEA,cAAMmB,YAAY,GAAG,4BAAgB;AACnCF,YAAAA,MAAM,EAAER,WAAW,CAACQ,MADe;AAEnCd,YAAAA,QAAQ,EAARA,QAFmC;AAGnCnB,YAAAA,KAAK,EAAEgB,OAAO,CAAChB,KAHoB;AAInCC,YAAAA,MAAM,EAAEe,OAAO,CAACf;AAJmB,WAAhB,CAArB;AAOAwB,UAAAA,WAAW,CAACS,UAAZ,GAAyBC,YAAY,GAAGA,YAAY,CAACC,SAAb,EAAH,GAA8B,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAnE;AAGAvB,UAAAA,QAAQ,CAACwB,MAAT,CAAgB;AACdC,YAAAA,IAAI,EAAE,MADQ;AAEdC,YAAAA,OAAO,EAAEd,WAAW,CAACE,KAFP;AAGdlC,YAAAA,MAAM,EAAEgC,WAAW,CAAChC,MAHN;AAIdC,YAAAA,WAAW,EAAXA,WAJc;AAKdC,YAAAA,SAAS,EAAEwC,YAAY,GAAG,CAACA,YAAD,CAAH,GAAoB,EAL7B;AAMdvC,YAAAA,gBAAgB,EAAhBA,gBANc;AAOdC,YAAAA,KAAK,EAALA,KAPc;AAQd2C,YAAAA,gBAAgB,EAAE;AAChBC,cAAAA,gBAAgB,EAAE;AADF;AARJ,WAAhB;AAYD;AACF;;AAGD,WAAK9B,KAAL,CAAWc,WAAW,CAACV,EAAvB,IAA6B;AAC3BY,QAAAA,KAAK,EAAEF,WAAW,CAACE,KADQ;AAE3BM,QAAAA,MAAM,EAAER,WAAW,CAACS,UAFO;AAG3BQ,QAAAA,gBAAgB,EAAEjB,WAAW,CAACiB,gBAHH;AAI3BC,QAAAA,gBAAgB,EAAElB,WAAW,CAACkB;AAJH,OAA7B;AAMD;;;WASD,2BAA0BzC,UAA1B,EAAwE;AAAA;;AACtE,UAAMe,UAAU,GAAG,EAAnB;AACA,UAAI2B,YAAY,GAAG,CAAnB;;AAFsE,iDAGlD1C,UAHkD;AAAA;;AAAA;AAAA;AAAA,cAG3D2C,KAH2D;AAIpE,cAAO9B,EAAP,GAAa8B,KAAK,CAACC,IAAnB,CAAO/B,EAAP;AACA,cAAIU,WAAW,GAAGR,UAAU,CAACF,EAAD,CAA5B;;AACA,cAAI,CAACU,WAAL,EAAkB;AAChB,gBAAI,EAAEmB,YAAF,GAAiB,CAArB,EAAwB;AACtBG,2BAAIC,IAAJ,CAAS,8CAAT;;AACA;AACD;;AACDvB,YAAAA,WAAW,GAAG;AACZV,cAAAA,EAAE,EAAFA,EADY;AAEZY,cAAAA,KAAK,EAAE,KAAI,CAACf,QAAL,CAAcqC,SAAd,CAAwB,UAAAC,CAAC;AAAA,uBAAI,CAAAA,CAAC,SAAD,IAAAA,CAAC,WAAD,YAAAA,CAAC,CAAEnC,EAAH,MAAUA,EAAd;AAAA,eAAzB,CAFK;AAGZtB,cAAAA,MAAM,EAAE,EAHI;AAIZoC,cAAAA,WAAW,EAAE,EAJD;AAKZa,cAAAA,gBAAgB,EAAEG,KAAK,CAACC,IAAN,CAAWzC,KAAX,CAAiBqC,gBALvB;AAMZC,cAAAA,gBAAgB,EAAEE,KAAK,CAACC,IAAN,CAAWzC,KAAX,CAAiBsC;AANvB,aAAd;AAQA1B,YAAAA,UAAU,CAACF,EAAD,CAAV,GAAiBU,WAAjB;AACD;;AACDA,UAAAA,WAAW,CAAChC,MAAZ,CAAmB0D,IAAnB,CAAwBN,KAAxB;AACApB,UAAAA,WAAW,CAACI,WAAZ,CAAwBsB,IAAxB,CAA6BN,KAAK,CAACT,SAAN,EAA7B;AAtBoE;;AAGtE,4DAAgC;AAAA;;AAAA,mCAM1B;AAcL;AAvBqE;AAAA;AAAA;AAAA;AAAA;;AAyBtE,WAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAMP,WAAW,GAAG,KAAKb,QAAL,CAAcoB,CAAd,CAApB;;AACA,YAAI,CAACP,WAAD,IAAgB,EAAEA,WAAW,CAACV,EAAZ,IAAkBE,UAApB,CAApB,EAAqD;AAEnD,eAAKL,QAAL,CAAcoB,CAAd,IAAmB,IAAnB;AACD;AACF;;AAED,WAAK,IAAMT,MAAX,IAAqBN,UAArB,EAAiC;AAC/B,YAAMQ,YAAW,GAAGR,UAAU,CAACM,MAAD,CAA9B;;AAEA,YAAIE,YAAW,CAACE,KAAZ,GAAoB,CAAxB,EAA2B;AACzBF,UAAAA,YAAW,CAACE,KAAZ,GAAoB,KAAKf,QAAL,CAAcqC,SAAd,CAAwB,UAAAC,CAAC;AAAA,mBAAI,CAACA,CAAL;AAAA,WAAzB,CAApB;AACA,eAAKtC,QAAL,CAAca,YAAW,CAACE,KAA1B,IAAmCF,YAAnC;AACD;AACF;;AACD,aAAOR,UAAP;AACD;;;WAED,+BAGE;AACA,aAAO;AACLD,QAAAA,OAAO,EAAE,KAAKL,KAAL,GAAa,KAAKK,OAAlB,GAA4B,KAAKlB,YADrC;AAELsD,QAAAA,YAAY,EAAE,KAAKzC;AAFd,OAAP;AAID;;;WAED,mBAAgB;AACd,UAAI,KAAKb,YAAT,EAAuB;AACrB,aAAKA,YAAL,CAAkBuD,MAAlB;AACA,aAAKvD,YAAL,GAAoBwD,SAApB;AACD;;AAED,UAAI,KAAKzC,QAAT,EAAmB;AACjB,aAAKA,QAAL,CAAcwC,MAAd;AACA,aAAKxC,QAAL,GAAgByC,SAAhB;AACA,aAAKtC,OAAL,GAAesC,SAAf;AACD;;AAED,WAAKjC,YAAL,GAAoBiC,SAApB;AACA,WAAK3C,KAAL,GAAa,IAAb;AACA,WAAKC,QAAL,CAAcF,MAAd,GAAuB,CAAvB;AACD","sourcesContent":["import {Texture2D} from '@luma.gl/core';\n// import {readPixelsToArray} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from '../../passes/mask-pass';\nimport {OPERATION} from '../../lib/constants';\nimport {getMaskBounds, getMaskViewport} from './utils';\nimport log from '../../utils/log';\n\nimport type {Effect, PreRenderOptions} from '../../lib/effect';\nimport type Layer from '../../lib/layer';\nimport type Viewport from '../../viewports/viewport';\nimport type {MaskBounds} from './utils';\nimport type {CoordinateSystem} from '../../lib/constants';\n\ntype Mask = {\n  /** The channel index */\n  index: number;\n  bounds: MaskBounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: number;\n  layers: Layer[];\n  bounds: MaskBounds;\n  maskBounds: MaskBounds;\n  layerBounds: MaskBounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n\n  private dummyMaskMap?: Texture2D;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture2D;\n  private lastViewport?: Viewport;\n\n  preRender(\n    gl: WebGLRenderingContext,\n    {layers, layerFilter, viewports, onViewportActive, views}: PreRenderOptions\n  ): void {\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation === OPERATION.MASK);\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return;\n    }\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {id: 'default-mask'});\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    for (const maskId in channelMap) {\n      this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n\n    // // Debug show FBO contents on screen\n    // const color = readPixelsToArray(this.maskMap);\n    // let canvas = document.getElementById('fbo-canvas');\n    // if (!canvas) {\n    //   canvas = document.createElement('canvas');\n    //   canvas.id = 'fbo-canvas';\n    //   canvas.width = this.maskMap.width;\n    //   canvas.height = this.maskMap.height;\n    //   canvas.style.zIndex = 100;\n    //   canvas.style.position = 'absolute';\n    //   canvas.style.right = 0;\n    //   canvas.style.border = 'blue 1px solid';\n    //   canvas.style.width = '256px';\n    //   canvas.style.transform = 'scaleY(-1)';\n    //   document.body.appendChild(canvas);\n    // }\n    // const ctx = canvas.getContext('2d');\n    // const imageData = ctx.createImageData(this.maskMap.width, this.maskMap.height);\n    // for (let i = 0; i < color.length; i += 4) {\n    //   imageData.data[i + 0] = color[i + 0];\n    //   imageData.data[i + 1] = color[i + 1];\n    //   imageData.data[i + 2] = color[i + 2];\n    //   imageData.data[i + 3] = color[i + 3] + 128;\n    // }\n    // ctx.putImageData(imageData, 0, 0);\n  }\n\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ) {\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      oldChannelInfo.layers.length !== channelInfo.layers.length ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      channelInfo.bounds = getMaskBounds({layers: channelInfo.layers, viewport});\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport = getMaskViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height\n        });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getModuleParameters(): {\n    maskMap: Texture2D;\n    maskChannels: Record<string, Mask> | null;\n  } {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n"],"file":"mask-effect.js"}