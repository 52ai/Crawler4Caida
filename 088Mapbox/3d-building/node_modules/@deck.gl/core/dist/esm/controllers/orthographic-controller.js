import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { clamp } from '@math.gl/core';
import Controller from './controller';
import { OrbitState } from './orbit-controller';
import LinearInterpolator from '../transitions/linear-interpolator';

class OrthographicState extends OrbitState {
  constructor(props) {
    super(props);

    _defineProperty(this, "zoomAxis", void 0);

    this.zoomAxis = props.zoomAxis || 'all';
  }

  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();

    if (startZoom === undefined) {
      startZoom = this.getViewportProps().zoom;
    }

    let deltaZoom = Math.log2(scale);

    if (Array.isArray(startZoom)) {
      let [newZoomX, newZoomY] = startZoom;

      switch (this.zoomAxis) {
        case 'X':
          newZoomX = clamp(newZoomX + deltaZoom, minZoom, maxZoom);
          break;

        case 'Y':
          newZoomY = clamp(newZoomY + deltaZoom, minZoom, maxZoom);
          break;

        default:
          let z = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);

          if (z < minZoom) {
            deltaZoom += minZoom - z;
          }

          z = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);

          if (z > maxZoom) {
            deltaZoom += maxZoom - z;
          }

          newZoomX += deltaZoom;
          newZoomY += deltaZoom;
      }

      return [newZoomX, newZoomY];
    }

    return clamp(startZoom + deltaZoom, minZoom, maxZoom);
  }

}

export default class OrthographicController extends Controller {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "ControllerState", OrthographicState);

    _defineProperty(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator(['target', 'zoom'])
    });

    _defineProperty(this, "dragMode", 'pan');
  }

  _onPanRotate() {
    return false;
  }

}
//# sourceMappingURL=orthographic-controller.js.map