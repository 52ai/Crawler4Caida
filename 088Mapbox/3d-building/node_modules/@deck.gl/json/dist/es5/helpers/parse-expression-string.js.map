{"version":3,"sources":["../../../src/helpers/parse-expression-string.js"],"names":["cachedExpressionMap","object","parseExpressionString","propValue","configuration","func","ast","expressionEval","parse","right","left","type","row","traverse","node","Error","eval","visitor","Array","isArray","forEach","element","key"],"mappings":";;;;;;;;;;;AAAA;;AAGA;;AAEA,IAAMA,mBAAmB,GAAG;AAC1B,OAAK,WAAAC,MAAM;AAAA,WAAIA,MAAJ;AAAA;AADe,CAA5B;;AAOe,SAASC,qBAAT,CAA+BC,SAA/B,EAA0CC,aAA1C,EAAyD;AAEtE,MAAID,SAAS,IAAIH,mBAAjB,EAAsC;AACpC,WAAOA,mBAAmB,CAACG,SAAD,CAA1B;AACD;;AAED,MAAIE,IAAJ;;AAEA,MAAMC,GAAG,GAAGC,wBAAeC,KAAf,CAAqBL,SAArB,CAAZ;;AACA,MAAI,CAACG,GAAG,CAACG,KAAL,IAAc,CAACH,GAAG,CAACI,IAAnB,IAA2BJ,GAAG,CAACK,IAAJ,KAAa,YAA5C,EAA0D;AACxDN,IAAAA,IAAI,GAAG,cAAAO,GAAG,EAAI;AACZ,aAAO,cAAIA,GAAJ,EAAST,SAAT,CAAP;AACD,KAFD;AAGD,GAJD,MAIO;AAILU,IAAAA,QAAQ,CAACP,GAAD,EAAM,UAAAQ,IAAI,EAAI;AACpB,UAAIA,IAAI,CAACH,IAAL,KAAc,gBAAlB,EAAoC;AAClC,cAAM,IAAII,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF,KAJO,CAAR;;AAMAV,IAAAA,IAAI,GAAG,cAAAO,GAAG,EAAI;AACZ,aAAOL,wBAAeS,IAAf,CAAoBV,GAApB,EAAyBM,GAAzB,CAAP;AACD,KAFD;AAGD;;AAGDZ,EAAAA,mBAAmB,CAACG,SAAD,CAAnB,GAAiCE,IAAjC;AACA,SAAOA,IAAP;AACD;;AAID,SAASQ,QAAT,CAAkBC,IAAlB,EAAwBG,OAAxB,EAAiC;AAC/B,MAAIC,KAAK,CAACC,OAAN,CAAcL,IAAd,CAAJ,EAAyB;AACvBA,IAAAA,IAAI,CAACM,OAAL,CAAa,UAAAC,OAAO;AAAA,aAAIR,QAAQ,CAACQ,OAAD,EAAUJ,OAAV,CAAZ;AAAA,KAApB;AACD,GAFD,MAEO,IAAIH,IAAI,IAAI,sBAAOA,IAAP,MAAgB,QAA5B,EAAsC;AAC3C,QAAIA,IAAI,CAACH,IAAT,EAAe;AACbM,MAAAA,OAAO,CAACH,IAAD,CAAP;AACD;;AACD,SAAK,IAAMQ,GAAX,IAAkBR,IAAlB,EAAwB;AACtBD,MAAAA,QAAQ,CAACC,IAAI,CAACQ,GAAD,CAAL,EAAYL,OAAZ,CAAR;AACD;AACF;AACF","sourcesContent":["import {get} from '../utils/get';\n\n// expression-eval: Small jsep based expression parser that supports array and object indexing\nimport expressionEval from 'expression-eval';\n\nconst cachedExpressionMap = {\n  '-': object => object\n};\n\n// Calculates an accessor function from a JSON string\n// '-' : x => x\n// 'a.b.c': x => x.a.b.c\nexport default function parseExpressionString(propValue, configuration) {\n  // NOTE: Can be null which represents invalid function. Return null so that prop can be omitted\n  if (propValue in cachedExpressionMap) {\n    return cachedExpressionMap[propValue];\n  }\n\n  let func;\n  // Compile with expression-eval\n  const ast = expressionEval.parse(propValue);\n  if (!ast.right && !ast.left && ast.type === 'Identifier') {\n    func = row => {\n      return get(row, propValue);\n    };\n  } else {\n    // NOTE: To avoid security risks, the arguments passed to the\n    // compiled expression must only give access to pure data (no globals etc)\n    // We disable function call syntax\n    traverse(ast, node => {\n      if (node.type === 'CallExpression') {\n        throw new Error('Function calls not allowed in JSON expressions');\n      }\n    });\n    // TODO Something like `expressionEval.eval(ast, {row});` would be useful for unpacking arrays\n    func = row => {\n      return expressionEval.eval(ast, row);\n    };\n  }\n\n  // Cache the compiled function\n  cachedExpressionMap[propValue] = func;\n  return func;\n}\n\n// Helper function to search all nodes in AST returned by expressionEval\n// eslint-disable-next-line complexity\nfunction traverse(node, visitor) {\n  if (Array.isArray(node)) {\n    node.forEach(element => traverse(element, visitor));\n  } else if (node && typeof node === 'object') {\n    if (node.type) {\n      visitor(node);\n    }\n    for (const key in node) {\n      traverse(node[key], visitor);\n    }\n  }\n}\n"],"file":"parse-expression-string.js"}