const state = {
  onIninitialize: _ => _,
  onFinalize: _ => _,
  onMessage: null
};
export default class Transport {
  static setCallbacks({
    onInitialize,
    onFinalize,
    onMessage
  }) {
    if (onInitialize) {
      state.onInitialize = onInitialize;
    }

    if (onFinalize) {
      state.onFinalize = onFinalize;
    }

    if (onMessage) {
      state.onMessage = onMessage;
    }
  }

  constructor(name = 'Transport') {
    this.name = name;
    this._messageQueue = [];
    this.userData = {};
  }

  getRootDOMElement() {
    return typeof document !== 'undefined' ? document.body : null;
  }

  sendJSONMessage() {
    console.error('Back-channel not implemented for this transport');
  }

  sendBinaryMessage() {
    console.error('Back-channel not implemented for this transport');
  }

  _initialize(options = {}) {
    const message = {
      transport: this,
      ...options
    };
    state.onInitialize(message);
  }

  _finalize(options = {}) {
    const message = {
      transport: this,
      ...options
    };
    state.onFinalize(message);
    this._destroyed = true;
  }

  _messageReceived(message = {}) {
    message = {
      transport: this,
      ...message
    };
    console.debug('Delivering transport message', message);
    state.onMessage(message);
  }

  static _stringifyJSONSafe(v) {
    const cache = new Set();
    return JSON.stringify(v, (key, value) => {
      if (typeof value === 'object' && value !== null) {
        if (cache.has(value)) {
          try {
            return JSON.parse(JSON.stringify(value));
          } catch (err) {
            return undefined;
          }
        }

        cache.add(value);
      }

      return value;
    });
  }

}
//# sourceMappingURL=transport.js.map