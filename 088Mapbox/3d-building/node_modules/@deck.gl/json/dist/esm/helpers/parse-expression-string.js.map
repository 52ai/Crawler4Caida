{"version":3,"sources":["../../../src/helpers/parse-expression-string.js"],"names":["get","expressionEval","cachedExpressionMap","object","parseExpressionString","propValue","configuration","func","ast","parse","right","left","type","row","traverse","node","Error","eval","visitor","Array","isArray","forEach","element","key"],"mappings":"AAAA,SAAQA,GAAR,QAAkB,cAAlB;AAGA,OAAOC,cAAP,MAA2B,iBAA3B;AAEA,MAAMC,mBAAmB,GAAG;AAC1B,OAAKC,MAAM,IAAIA;AADW,CAA5B;AAOA,eAAe,SAASC,qBAAT,CAA+BC,SAA/B,EAA0CC,aAA1C,EAAyD;AAEtE,MAAID,SAAS,IAAIH,mBAAjB,EAAsC;AACpC,WAAOA,mBAAmB,CAACG,SAAD,CAA1B;AACD;;AAED,MAAIE,IAAJ;AAEA,QAAMC,GAAG,GAAGP,cAAc,CAACQ,KAAf,CAAqBJ,SAArB,CAAZ;;AACA,MAAI,CAACG,GAAG,CAACE,KAAL,IAAc,CAACF,GAAG,CAACG,IAAnB,IAA2BH,GAAG,CAACI,IAAJ,KAAa,YAA5C,EAA0D;AACxDL,IAAAA,IAAI,GAAGM,GAAG,IAAI;AACZ,aAAOb,GAAG,CAACa,GAAD,EAAMR,SAAN,CAAV;AACD,KAFD;AAGD,GAJD,MAIO;AAILS,IAAAA,QAAQ,CAACN,GAAD,EAAMO,IAAI,IAAI;AACpB,UAAIA,IAAI,CAACH,IAAL,KAAc,gBAAlB,EAAoC;AAClC,cAAM,IAAII,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF,KAJO,CAAR;;AAMAT,IAAAA,IAAI,GAAGM,GAAG,IAAI;AACZ,aAAOZ,cAAc,CAACgB,IAAf,CAAoBT,GAApB,EAAyBK,GAAzB,CAAP;AACD,KAFD;AAGD;;AAGDX,EAAAA,mBAAmB,CAACG,SAAD,CAAnB,GAAiCE,IAAjC;AACA,SAAOA,IAAP;AACD;;AAID,SAASO,QAAT,CAAkBC,IAAlB,EAAwBG,OAAxB,EAAiC;AAC/B,MAAIC,KAAK,CAACC,OAAN,CAAcL,IAAd,CAAJ,EAAyB;AACvBA,IAAAA,IAAI,CAACM,OAAL,CAAaC,OAAO,IAAIR,QAAQ,CAACQ,OAAD,EAAUJ,OAAV,CAAhC;AACD,GAFD,MAEO,IAAIH,IAAI,IAAI,OAAOA,IAAP,KAAgB,QAA5B,EAAsC;AAC3C,QAAIA,IAAI,CAACH,IAAT,EAAe;AACbM,MAAAA,OAAO,CAACH,IAAD,CAAP;AACD;;AACD,SAAK,MAAMQ,GAAX,IAAkBR,IAAlB,EAAwB;AACtBD,MAAAA,QAAQ,CAACC,IAAI,CAACQ,GAAD,CAAL,EAAYL,OAAZ,CAAR;AACD;AACF;AACF","sourcesContent":["import {get} from '../utils/get';\n\n// expression-eval: Small jsep based expression parser that supports array and object indexing\nimport expressionEval from 'expression-eval';\n\nconst cachedExpressionMap = {\n  '-': object => object\n};\n\n// Calculates an accessor function from a JSON string\n// '-' : x => x\n// 'a.b.c': x => x.a.b.c\nexport default function parseExpressionString(propValue, configuration) {\n  // NOTE: Can be null which represents invalid function. Return null so that prop can be omitted\n  if (propValue in cachedExpressionMap) {\n    return cachedExpressionMap[propValue];\n  }\n\n  let func;\n  // Compile with expression-eval\n  const ast = expressionEval.parse(propValue);\n  if (!ast.right && !ast.left && ast.type === 'Identifier') {\n    func = row => {\n      return get(row, propValue);\n    };\n  } else {\n    // NOTE: To avoid security risks, the arguments passed to the\n    // compiled expression must only give access to pure data (no globals etc)\n    // We disable function call syntax\n    traverse(ast, node => {\n      if (node.type === 'CallExpression') {\n        throw new Error('Function calls not allowed in JSON expressions');\n      }\n    });\n    // TODO Something like `expressionEval.eval(ast, {row});` would be useful for unpacking arrays\n    func = row => {\n      return expressionEval.eval(ast, row);\n    };\n  }\n\n  // Cache the compiled function\n  cachedExpressionMap[propValue] = func;\n  return func;\n}\n\n// Helper function to search all nodes in AST returned by expressionEval\n// eslint-disable-next-line complexity\nfunction traverse(node, visitor) {\n  if (Array.isArray(node)) {\n    node.forEach(element => traverse(element, visitor));\n  } else if (node && typeof node === 'object') {\n    if (node.type) {\n      visitor(node);\n    }\n    for (const key in node) {\n      traverse(node[key], visitor);\n    }\n  }\n}\n"],"file":"parse-expression-string.js"}