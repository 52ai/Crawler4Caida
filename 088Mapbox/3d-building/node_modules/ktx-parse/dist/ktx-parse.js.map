{"version":3,"file":"ktx-parse.js","sources":["../src/constants.ts","../src/container.ts","../src/buffer-reader.ts","../src/util.ts","../src/write.ts","../src/read.ts"],"sourcesContent":["///////////////////////////////////////////////////\n// Common.\n///////////////////////////////////////////////////\n\n// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\nexport const KTX_WRITER = `KTX-Parse v${PACKAGE_VERSION}`;\n\nexport const NUL = new Uint8Array([0x00]);\n\n\n///////////////////////////////////////////////////\n// KTX2 Header.\n///////////////////////////////////////////////////\n\nexport const KTX2_ID = [\n\t// '´', 'K', 'T', 'X', '2', '0', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n\t0xAB, 0x4B, 0x54, 0x58, 0x20, 0x32, 0x30, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n];\n\nexport const HEADER_BYTE_LENGTH = 68; // 13 * 4 + 2 * 8\n\nexport enum KTX2SupercompressionScheme {\n\tNONE = 0,\n\tBASISLZ = 1,\n\tZSTD = 2,\n\tZLIB = 3,\n};\n\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport enum KTX2DataFormatType {\n    BASICFORMAT = 0x00,\n};\n\nexport const KHR_DF_VENDORID_KHRONOS = 0;\n\nexport const KHR_DF_VERSION = 2;\n\nexport const KHR_DF_BLOCKSIZE = 40;\n\nexport const VK_FORMAT_UNDEFINED = 0;\n\nexport enum KTX2DataFormatModel {\n    UNSPECIFIED = 0,\n\tETC1S = 163,\n\tUASTC = 166,\n};\n\nexport enum KTX2DataFormatPrimaries {\n    UNSPECIFIED = 0,\n    SRGB = 1,\n};\n\nexport enum KTX2DataFormatTransfer {\n    UNSPECIFIED = 0,\n    LINEAR = 1,\n    SRGB = 2,\n    ITU = 3,\n    NTSC = 4,\n    SLOG = 5,\n    SLOG2 = 6,\n};\n\nexport enum KTX2DataFormatFlags {\n    ALPHA_STRAIGHT = 0,\n    ALPHA_PREMULTIPLIED = 1,\n};\n\nexport enum KTX2DataFormatChannelETC1S {\n    RGB = 0,\n    RRR = 3,\n    GGG = 4,\n    AAA = 15,\n};\n\nexport enum KTX2DataFormatChannelUASTC {\n    RGB = 0,\n    RGBA = 3,\n    RRR = 4,\n    RRRG = 5,\n};\n","import { KHR_DF_BLOCKSIZE, KHR_DF_VENDORID_KHRONOS, KHR_DF_VERSION, KTX2DataFormatFlags, KTX2DataFormatModel, KTX2DataFormatPrimaries, KTX2DataFormatType, KTX2SupercompressionScheme, VK_FORMAT_UNDEFINED } from './constants';\n\n/**\n * Represents an unpacked KTX 2.0 texture container. Data for individual mip levels are stored in\n * the `.levels` array, typically compressed in Basis Universal formats. Additional properties\n * provide metadata required to process, transcode, and upload these textures.\n */\nexport class KTX2Container {\n\t/**\n\t * Specifies the image format using Vulkan VkFormat enum values. When using Basis Universal\n\t * texture formats, `vkFormat` must be VK_FORMAT_UNDEFINED.\n\t */\n\tpublic vkFormat = VK_FORMAT_UNDEFINED;\n\n\t/**\n\t * Size of the data type in bytes used to upload the data to a graphics API. When `vkFormat` is\n\t * VK_FORMAT_UNDEFINED, `typeSize` must be 1.\n\t */\n\tpublic typeSize: number = 1;\n\n\t/** Width of the texture image for level 0, in pixels. */\n\tpublic pixelWidth: number = 0;\n\n\t/** Height of the texture image for level 0, in pixels. */\n\tpublic pixelHeight: number = 0;\n\n\t/** Depth of the texture image for level 0, in pixels (3D textures only). */\n\tpublic pixelDepth: number = 0;\n\n\t/** Number of array elements (array textures only). */\n\tpublic layerCount: number = 0;\n\n\t/**\n\t * Number of cubemap faces. For cubemaps and cubemap arrays, `faceCount` must be 6. For all\n\t * other textures, `faceCount` must be 1. Cubemap faces are stored in +X, -X, +Y, -Y, +Z, -Z\n\t * order.\n\t */\n\tpublic faceCount: number = 1;\n\n\t/** Indicates which supercompression scheme has been applied to mip level images, if any. */\n\tpublic supercompressionScheme = KTX2SupercompressionScheme.NONE;\n\n\t/** Mip levels, ordered largest (original) to smallest (~1px). */\n\tpublic levels: KTX2Level[] = [];\n\n\t/** Data Format Descriptor. */\n\tpublic dataFormatDescriptor: KTX2DataFormatDescriptorBasicFormat[] = [{\n\t\tvendorId: KHR_DF_VENDORID_KHRONOS,\n\t\tdescriptorType: KTX2DataFormatType.BASICFORMAT,\n\t\tversionNumber: KHR_DF_VERSION,\n\t\tdescriptorBlockSize: KHR_DF_BLOCKSIZE,\n\t\tcolorModel: KTX2DataFormatModel.UNSPECIFIED,\n\t\tcolorPrimaries: KTX2DataFormatPrimaries.SRGB,\n\t\ttransferFunction: KTX2DataFormatPrimaries.SRGB,\n\t\tflags: KTX2DataFormatFlags.ALPHA_STRAIGHT,\n\t\ttexelBlockDimension: {x: 4, y: 4, z: 1, w: 1},\n\t\tbytesPlane: [],\n\t\tsamples: [],\n\t}];\n\n\t/** Key/Value Data. */\n\tpublic keyValue: {[key: string]: string | Uint8Array} = {};\n\n\t/** Supercompression Global Data. */\n\tpublic globalData: KTX2GlobalDataBasisLZ | null = null;\n}\n\n\n///////////////////////////////////////////////////\n// Mip Levels.\n///////////////////////////////////////////////////\n\nexport interface KTX2Level {\n\t/** Compressed data of the mip level. */\n\tlevelData: Uint8Array;\n\n\t/**\n\t * Size of the mip level after reflation from supercompression, if applicable. When\n\t * `supercompressionType` is BASISLZ, `uncompressedByteLength` must be 0. When\n\t * `supercompressionType` is `NONE`, `uncompressedByteLength` must match the `levelData` byte\n\t * length.\n\t *\n\t * _**NOTICE:** this implies that for formats such as UASTC, `uncompressedByteLength` may\n\t * indicate size after ZSTD reflation (and of transcoded ASTC data), but does _not_ indicate\n\t * size of decoded RGBA32 pixels._\n\t */\n\tuncompressedByteLength: number;\n};\n\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport interface KTX2DataFormatDescriptorBasicFormat {\n\tvendorId: number;\n\tdescriptorType: number;\n\tversionNumber: number;\n\tdescriptorBlockSize: number;\n\tcolorModel: number;\n\tcolorPrimaries: number;\n\ttransferFunction: number;\n\tflags: number;\n\ttexelBlockDimension: KTX2BasicFormatTexelBlockDimensions;\n\tbytesPlane: number[];\n\tsamples: KTX2BasicFormatSample[],\n};\n\nexport interface KTX2BasicFormatTexelBlockDimensions {\n\tx: number;\n\ty: number;\n\tz: number;\n\tw: number;\n};\n\nexport interface KTX2BasicFormatSample {\n\tbitOffset: number;\n\tbitLength: number;\n\tchannelID: number;\n\tsamplePosition: number[];\n\tsampleLower: number;\n\tsampleUpper: number;\n};\n\n\n///////////////////////////////////////////////////\n// Supercompression Global Data.\n///////////////////////////////////////////////////\n\nexport interface KTX2GlobalDataBasisLZ {\n\tendpointCount: number;\n\tselectorCount: number;\n\timageDescs: KTX2GlobalDataBasisLZImageDesc[];\n\tendpointsData: Uint8Array;\n\tselectorsData: Uint8Array;\n\ttablesData: Uint8Array;\n\textendedData: Uint8Array;\n};\n\ninterface KTX2GlobalDataBasisLZImageDesc {\n\timageFlags: number;\n\trgbSliceByteOffset: number;\n\trgbSliceByteLength: number;\n\talphaSliceByteOffset: number;\n\talphaSliceByteLength: number;\n};\n","export class BufferReader {\n\tprivate _dataView: DataView;\n\tprivate _littleEndian: boolean;\n\tpublic _offset: number;\n\n\tconstructor(data: Uint8Array, byteOffset: number, byteLength: number, littleEndian: boolean) {\n\t\tthis._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);\n\t\tthis._littleEndian = littleEndian;\n\t\tthis._offset = 0;\n\t}\n\n\t_nextUint8() {\n\t\tconst value = this._dataView.getUint8(this._offset);\n\t\tthis._offset += 1;\n\t\treturn value;\n\t}\n\n\t_nextUint16() {\n\t\tconst value = this._dataView.getUint16(this._offset, this._littleEndian);\n\t\tthis._offset += 2;\n\t\treturn value;\n\t}\n\n\t_nextUint32() {\n\t\tconst value = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tthis._offset += 4;\n\t\treturn value;\n\t}\n\n\t_nextUint64() {\n\t\tconst left = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tconst right = this._dataView.getUint32(this._offset + 4, this._littleEndian);\n\t\t// TODO(cleanup): Just test this...\n\t\t// const value = this._littleEndian ? left + (2 ** 32 * right) : (2 ** 32 * left) + right;\n\t\tconst value = left + (2 ** 32 * right);\n\t\tthis._offset += 8;\n\t\treturn value;\n\t}\n\n\t_skip(bytes: number) {\n\t\tthis._offset += bytes;\n\t\treturn this;\n\t}\n\n\t_scan(maxByteLength: number, term: number = 0x00): Uint8Array {\n\t\tconst byteOffset = this._offset;\n\t\tlet byteLength = 0;\n\t\twhile (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {\n\t\t\tbyteLength++;\n\t\t\tthis._offset++;\n\t\t}\n\n\t\tif (byteLength < maxByteLength) this._offset++;\n\n\t\treturn new Uint8Array(\n\t\t\tthis._dataView.buffer,\n\t\t\tthis._dataView.byteOffset + byteOffset,\n\t\t\tbyteLength\n\t\t);\n\t}\n}\n","\n/** Encodes text to an ArrayBuffer. */\nexport function encodeText(text: string): Uint8Array {\n\tif (typeof TextEncoder !== 'undefined') {\n\t\treturn new TextEncoder().encode(text);\n\t}\n\treturn Buffer.from(text);\n}\n\n/** Decodes an ArrayBuffer to text. */\nexport function decodeText(buffer: Uint8Array): string {\n\tif (typeof TextDecoder !== 'undefined') {\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\treturn Buffer.from(buffer).toString('utf8');\n}\n\n/** Concatenates N ArrayBuffers. */\nexport function concat (buffers: (ArrayBuffer | Uint8Array)[]): Uint8Array {\n\tlet totalByteLength = 0;\n\tfor (const buffer of buffers) {\n\t\ttotalByteLength += buffer.byteLength;\n\t}\n\n\tconst result = new Uint8Array(totalByteLength);\n\tlet byteOffset = 0;\n\n\tfor (const buffer of buffers) {\n\t\tresult.set(new Uint8Array(buffer), byteOffset);\n\t\tbyteOffset += buffer.byteLength;\n\t}\n\n\treturn result;\n}","import { HEADER_BYTE_LENGTH, KTX2DataFormatType, KTX2_ID, KTX_WRITER, NUL } from './constants';\nimport { KTX2Container } from './container';\nimport { concat, encodeText } from './util';\n\ninterface WriteOptions {keepWriter?: boolean};\nconst DEFAULT_OPTIONS: WriteOptions = {keepWriter: false};\n\n/**\n * Serializes a {@link KTX2Container} instance to a KTX 2.0 file. Mip levels and other binary data\n * are copied into the resulting Uint8Array, so the original container can safely be edited or\n * destroyed after it is serialized.\n *\n * Options:\n * - keepWriter: If true, 'KTXWriter' key/value field is written as provided by the container.\n * \t\tOtherwise, a string for the current ktx-parse version is generated. Default: false.\n *\n * @param container\n * @param options\n */\nexport function write(container: KTX2Container, options: WriteOptions = {}): Uint8Array {\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tlet sgdBuffer = new ArrayBuffer(0);\n\tif (container.globalData) {\n\t\tconst sgdHeaderBuffer = new ArrayBuffer(20 + container.globalData.imageDescs.length * 5 * 4);\n\t\tconst sgdHeaderView = new DataView(sgdHeaderBuffer);\n\t\tsgdHeaderView.setUint16(0, container.globalData.endpointCount, true);\n\t\tsgdHeaderView.setUint16(2, container.globalData.selectorCount, true);\n\t\tsgdHeaderView.setUint32(4, container.globalData.endpointsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(8, container.globalData.selectorsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(12, container.globalData.tablesData.byteLength, true);\n\t\tsgdHeaderView.setUint32(16, container.globalData.extendedData.byteLength, true);\n\n\t\tfor (let i = 0; i < container.globalData.imageDescs.length; i++) {\n\t\t\tconst imageDesc = container.globalData.imageDescs[i];\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 0, imageDesc.imageFlags, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 4, imageDesc.rgbSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 8, imageDesc.rgbSliceByteLength, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 12, imageDesc.alphaSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 16, imageDesc.alphaSliceByteLength, true);\n\t\t}\n\n\t\tsgdBuffer = concat([\n\t\t\tsgdHeaderBuffer,\n\t\t\tcontainer.globalData.endpointsData,\n\t\t\tcontainer.globalData.selectorsData,\n\t\t\tcontainer.globalData.tablesData,\n\t\t\tcontainer.globalData.extendedData,\n\t\t]);\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst keyValueData: Uint8Array[] = [];\n\tlet keyValue = container.keyValue;\n\n\tif (!options.keepWriter) {\n\t\tkeyValue = {...container.keyValue, 'KTXwriter': KTX_WRITER};\n\t}\n\n\tfor (const key in keyValue) {\n\t\tconst value = keyValue[key];\n\t\tconst keyData = encodeText(key);\n\t\tconst valueData = typeof value === 'string' ? encodeText(value) : value;\n\t\tconst kvByteLength = keyData.byteLength + 1 + valueData.byteLength + 1;\n\t\tconst kvPadding = kvByteLength % 4 ? (4 - (kvByteLength % 4)) : 0; // align(4)\n\t\tkeyValueData.push(concat([\n\t\t\tnew Uint32Array([kvByteLength]),\n\t\t\tkeyData,\n\t\t\tNUL,\n\t\t\tvalueData,\n\t\t\tNUL,\n\t\t\tnew Uint8Array(kvPadding).fill(0x00), // align(4)\n\t\t]));\n\t}\n\n\tconst kvdBuffer = concat(keyValueData);\n\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tconst dfdBuffer = new ArrayBuffer(44);\n\tconst dfdView = new DataView(dfdBuffer);\n\n\tif (container.dataFormatDescriptor.length !== 1\n\t\t\t|| container.dataFormatDescriptor[0].descriptorType !== KTX2DataFormatType.BASICFORMAT) {\n\t\tthrow new Error('Only BASICFORMAT Data Format Descriptor output supported.');\n\t}\n\n\tconst dfd = container.dataFormatDescriptor[0];\n\n\tdfdView.setUint32(0, 44, true);\n\tdfdView.setUint16(4, dfd.vendorId, true);\n\tdfdView.setUint16(6, dfd.descriptorType, true);\n\tdfdView.setUint16(8, dfd.versionNumber, true);\n\tdfdView.setUint16(10, dfd.descriptorBlockSize, true);\n\n\tdfdView.setUint8(12, dfd.colorModel);\n\tdfdView.setUint8(13, dfd.colorPrimaries);\n\tdfdView.setUint8(14, dfd.transferFunction);\n\tdfdView.setUint8(15, dfd.flags);\n\n\tdfdView.setUint8(16, dfd.texelBlockDimension.x - 1);\n\tdfdView.setUint8(17, dfd.texelBlockDimension.y - 1);\n\tdfdView.setUint8(18, dfd.texelBlockDimension.z - 1);\n\tdfdView.setUint8(19, dfd.texelBlockDimension.w - 1);\n\n\tfor (let i = 0; i < 8; i++) dfdView.setUint8(20 + i, dfd.bytesPlane[i]);\n\n\tfor (let i = 0; i < dfd.samples.length; i++) {\n\t\tconst sample = dfd.samples[i];\n\t\tconst sampleByteOffset = 28 + i * 16;\n\n\t\tdfdView.setUint16(sampleByteOffset + 0, sample.bitOffset, true);\n\t\tdfdView.setUint8(sampleByteOffset + 2, sample.bitLength);\n\t\tdfdView.setUint8(sampleByteOffset + 3, sample.channelID);\n\n\t\tdfdView.setUint8(sampleByteOffset + 4, sample.samplePosition[0]);\n\t\tdfdView.setUint8(sampleByteOffset + 5, sample.samplePosition[1]);\n\t\tdfdView.setUint8(sampleByteOffset + 6, sample.samplePosition[2]);\n\t\tdfdView.setUint8(sampleByteOffset + 7, sample.samplePosition[3]);\n\n\t\tdfdView.setUint32(sampleByteOffset + 8, sample.sampleLower, true);\n\t\tdfdView.setUint32(sampleByteOffset + 12, sample.sampleUpper, true);\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Data alignment.\n\t///////////////////////////////////////////////////\n\n\tconst dfdByteOffset = KTX2_ID.length + HEADER_BYTE_LENGTH + container.levels.length * 3 * 8;\n\tconst kvdByteOffset = dfdByteOffset + dfdBuffer.byteLength;\n\tlet sgdByteOffset = kvdByteOffset + kvdBuffer.byteLength;\n\tif (sgdByteOffset % 8) sgdByteOffset += 8 - (sgdByteOffset % 8); // align(8)\n\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelData: Uint8Array[] = [];\n\tconst levelIndex = new DataView(new ArrayBuffer(container.levels.length * 3 * 8));\n\n\tlet levelDataByteOffset = sgdByteOffset + sgdBuffer.byteLength;\n\tfor (let i = 0; i < container.levels.length; i++) {\n\t\tconst level = container.levels[i];\n\t\tlevelData.push(level.levelData);\n\t\tlevelIndex.setBigUint64(i * 24 + 0, BigInt(levelDataByteOffset), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 8, BigInt(level.levelData.byteLength), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 16, BigInt(level.uncompressedByteLength), true);\n\t\tlevelDataByteOffset += level.levelData.byteLength;\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerBuffer = new ArrayBuffer(HEADER_BYTE_LENGTH);\n\tconst headerView = new DataView(headerBuffer);\n\theaderView.setUint32(0, container.vkFormat, true);\n\theaderView.setUint32(4, container.typeSize, true);\n\theaderView.setUint32(8, container.pixelWidth, true);\n\theaderView.setUint32(12, container.pixelHeight, true);\n\theaderView.setUint32(16, container.pixelDepth, true);\n\theaderView.setUint32(20, container.layerCount, true);\n\theaderView.setUint32(24, container.faceCount, true);\n\theaderView.setUint32(28, container.levels.length, true);\n\theaderView.setUint32(32, container.supercompressionScheme, true);\n\n\theaderView.setUint32(36, dfdByteOffset, true);\n\theaderView.setUint32(40, dfdBuffer.byteLength, true);\n\theaderView.setUint32(44, kvdByteOffset, true);\n\theaderView.setUint32(48, kvdBuffer.byteLength, true);\n\theaderView.setBigUint64(52, BigInt(sgdByteOffset), true);\n\theaderView.setBigUint64(60, BigInt(sgdBuffer.byteLength), true);\n\n\n\t///////////////////////////////////////////////////\n\t// Compose.\n\t///////////////////////////////////////////////////\n\n\treturn new Uint8Array(concat([\n\t\tnew Uint8Array(KTX2_ID).buffer,\n\t\theaderBuffer,\n\t\tlevelIndex.buffer,\n\t\tdfdBuffer,\n\t\tkvdBuffer,\n\t\tnew ArrayBuffer(sgdByteOffset - (kvdByteOffset + kvdBuffer.byteLength)), // align(8)\n\t\tsgdBuffer,\n\t\t...levelData,\n\t]));\n}\n\n","import { BufferReader } from './buffer-reader';\nimport { KTX2_ID } from './constants';\nimport { KTX2Container, KTX2DataFormatDescriptorBasicFormat } from './container';\nimport { decodeText } from './util';\n\n/**\n * Parses a KTX 2.0 file, returning an unpacked {@link KTX2Container} instance with all associated\n * data. The container's mip levels and other binary data are pointers into the original file, not\n * copies, so the original file should not be overwritten after reading.\n *\n * @param data Bytes of KTX 2.0 file, as Uint8Array or Buffer.\n */\nexport function read(data: Uint8Array): KTX2Container {\n\n\t///////////////////////////////////////////////////\n\t// KTX 2.0 Identifier.\n\t///////////////////////////////////////////////////\n\n\tconst id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);\n\tif (id[0] !== KTX2_ID[0] || // '´'\n\t\tid[1] !== KTX2_ID[1] || // 'K'\n\t\tid[2] !== KTX2_ID[2] || // 'T'\n\t\tid[3] !== KTX2_ID[3] || // 'X'\n\t\tid[4] !== KTX2_ID[4] || // ' '\n\t\tid[5] !== KTX2_ID[5] || // '2'\n\t\tid[6] !== KTX2_ID[6] || // '0'\n\t\tid[7] !== KTX2_ID[7] || // 'ª'\n\t\tid[8] !== KTX2_ID[8] || // '\\r'\n\t\tid[9] !== KTX2_ID[9] || // '\\n'\n\t\tid[10] !== KTX2_ID[10] || // '\\x1A'\n\t\tid[11] !== KTX2_ID[11] // '\\n'\n\t) {\n\t\tthrow new Error('Missing KTX 2.0 identifier.');\n\t}\n\n\tconst container = new KTX2Container();\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;\n\tconst headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);\n\n\tcontainer.vkFormat = headerReader._nextUint32();\n\tcontainer.typeSize = headerReader._nextUint32();\n\tcontainer.pixelWidth = headerReader._nextUint32();\n\tcontainer.pixelHeight = headerReader._nextUint32();\n\tcontainer.pixelDepth = headerReader._nextUint32();\n\tcontainer.layerCount = headerReader._nextUint32();\n\tcontainer.faceCount = headerReader._nextUint32();\n\n\tconst levelCount = headerReader._nextUint32();\n\n\tcontainer.supercompressionScheme = headerReader._nextUint32();\n\n\tconst dfdByteOffset = headerReader._nextUint32();\n\tconst dfdByteLength = headerReader._nextUint32();\n\tconst kvdByteOffset = headerReader._nextUint32();\n\tconst kvdByteLength = headerReader._nextUint32();\n\tconst sgdByteOffset = headerReader._nextUint64();\n\tconst sgdByteLength = headerReader._nextUint64();\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelByteLength = levelCount * 3 * 8;\n\tconst levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);\n\n\tfor (let i = 0; i < levelCount; i ++) {\n\t\tcontainer.levels.push({\n\t\t\tlevelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),\n\t\t\tuncompressedByteLength: levelReader._nextUint64(),\n\t\t});\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tconst dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);\n\n\tconst dfd: KTX2DataFormatDescriptorBasicFormat = {\n\t\tvendorId: dfdReader._skip(4 /* totalSize */)._nextUint16(),\n\t\tdescriptorType: dfdReader._nextUint16(),\n\t\tversionNumber: dfdReader._nextUint16(),\n\t\tdescriptorBlockSize: dfdReader._nextUint16(),\n\t\tcolorModel: dfdReader._nextUint8(),\n\t\tcolorPrimaries: dfdReader._nextUint8(),\n\t\ttransferFunction: dfdReader._nextUint8(),\n\t\tflags: dfdReader._nextUint8(),\n\t\ttexelBlockDimension: {\n\t\t\tx: dfdReader._nextUint8() + 1,\n\t\t\ty: dfdReader._nextUint8() + 1,\n\t\t\tz: dfdReader._nextUint8() + 1,\n\t\t\tw: dfdReader._nextUint8() + 1,\n\t\t},\n\t\tbytesPlane: [\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t],\n\t\tsamples: [],\n\t};\n\n\tconst sampleStart = 6;\n\tconst sampleWords = 4;\n\tconst numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;\n\n\tfor (let i = 0; i < numSamples; i ++) {\n\t\tdfd.samples[ i ] = {\n\t\t\tbitOffset: dfdReader._nextUint16(),\n\t\t\tbitLength: dfdReader._nextUint8(),\n\t\t\tchannelID: dfdReader._nextUint8(),\n\t\t\tsamplePosition: [\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t],\n\t\t\tsampleLower: dfdReader._nextUint32(),\n\t\t\tsampleUpper: dfdReader._nextUint32(),\n\t\t};\n\t}\n\n\tcontainer.dataFormatDescriptor.length = 0;\n\tcontainer.dataFormatDescriptor.push(dfd);\n\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);\n\n\twhile (kvdReader._offset < kvdByteLength) {\n\t\tconst keyValueByteLength = kvdReader._nextUint32();\n\t\tconst keyData = kvdReader._scan(keyValueByteLength);\n\t\tconst key = decodeText(keyData);\n\t\tconst valueData = kvdReader._scan(keyValueByteLength - keyData.byteLength);\n\t\tcontainer.keyValue[key] = key.match(/^ktx/i) ? decodeText(valueData) : valueData;\n\n\t\t// 4-byte alignment.\n\t\tif (keyValueByteLength % 4) kvdReader._skip(4 - (keyValueByteLength % 4));\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tif (sgdByteLength <= 0) return container;\n\n\tconst sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);\n\n\tconst endpointCount = sgdReader._nextUint16();\n\tconst selectorCount = sgdReader._nextUint16();\n\tconst endpointsByteLength = sgdReader._nextUint32();\n\tconst selectorsByteLength = sgdReader._nextUint32();\n\tconst tablesByteLength = sgdReader._nextUint32();\n\tconst extendedByteLength = sgdReader._nextUint32();\n\n\tconst imageDescs = [];\n\tfor (let i = 0; i < levelCount; i ++) {\n\t\timageDescs.push({\n\t\t\timageFlags: sgdReader._nextUint32(),\n\t\t\trgbSliceByteOffset: sgdReader._nextUint32(),\n\t\t\trgbSliceByteLength: sgdReader._nextUint32(),\n\t\t\talphaSliceByteOffset: sgdReader._nextUint32(),\n\t\t\talphaSliceByteLength: sgdReader._nextUint32(),\n\t\t});\n\t}\n\n\tconst endpointsByteOffset = sgdByteOffset + sgdReader._offset;\n\tconst selectorsByteOffset = endpointsByteOffset + endpointsByteLength;\n\tconst tablesByteOffset = selectorsByteOffset + selectorsByteLength;\n\tconst extendedByteOffset = tablesByteOffset + tablesByteLength;\n\n\tconst endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);\n\tconst selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);\n\tconst tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);\n\tconst extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);\n\n\tcontainer.globalData = {\n\t\tendpointCount,\n\t\tselectorCount,\n\t\timageDescs,\n\t\tendpointsData,\n\t\tselectorsData,\n\t\ttablesData,\n\t\textendedData,\n\t};\n\n\treturn container;\n}\n"],"names":["KTX2SupercompressionScheme","KTX2DataFormatType","KTX2DataFormatModel","KTX2DataFormatPrimaries","KTX2DataFormatTransfer","KTX2DataFormatFlags","KTX2DataFormatChannelETC1S","KTX2DataFormatChannelUASTC","NUL","Uint8Array","KTX2_ID","KTX2Container","this","NONE","vendorId","descriptorType","BASICFORMAT","versionNumber","descriptorBlockSize","colorModel","UNSPECIFIED","colorPrimaries","SRGB","transferFunction","flags","ALPHA_STRAIGHT","texelBlockDimension","x","y","z","w","bytesPlane","samples","BufferReader","data","byteOffset","byteLength","littleEndian","_dataView","DataView","buffer","_littleEndian","_offset","_nextUint8","value","getUint8","_nextUint16","getUint16","_nextUint32","getUint32","_nextUint64","left","right","Math","_skip","bytes","_scan","maxByteLength","term","encodeText","text","TextEncoder","encode","Buffer","from","decodeText","TextDecoder","decode","toString","concat","buffers","totalByteLength","result","set","DEFAULT_OPTIONS","keepWriter","id","length","Error","container","headerByteLength","Uint32Array","BYTES_PER_ELEMENT","headerReader","vkFormat","typeSize","pixelWidth","pixelHeight","pixelDepth","layerCount","faceCount","levelCount","supercompressionScheme","dfdByteOffset","dfdByteLength","kvdByteOffset","kvdByteLength","sgdByteOffset","sgdByteLength","levelReader","i","levels","push","levelData","uncompressedByteLength","dfdReader","dfd","numSamples","bitOffset","bitLength","channelID","samplePosition","sampleLower","sampleUpper","dataFormatDescriptor","kvdReader","keyValueByteLength","keyData","key","valueData","keyValue","match","sgdReader","endpointCount","selectorCount","endpointsByteLength","selectorsByteLength","tablesByteLength","extendedByteLength","imageDescs","imageFlags","rgbSliceByteOffset","rgbSliceByteLength","alphaSliceByteOffset","alphaSliceByteLength","endpointsByteOffset","selectorsByteOffset","tablesByteOffset","extendedByteOffset","endpointsData","selectorsData","tablesData","extendedData","globalData","options","sgdBuffer","ArrayBuffer","sgdHeaderBuffer","sgdHeaderView","setUint16","setUint32","imageDesc","keyValueData","KTXwriter","kvByteLength","kvPadding","fill","kvdBuffer","dfdBuffer","dfdView","setUint8","sample","sampleByteOffset","levelIndex","levelDataByteOffset","level","setBigUint64","BigInt","headerBuffer","headerView"],"mappings":"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"}