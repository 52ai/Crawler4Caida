{"version":3,"sources":["../../src/type-utils.ts"],"names":["identity","x","scratchVector","Vector3","fromCartographic","cartographic","result","map","longitude","latitude","height","y","z","fromCartographicToRadians","vector","config","_cartographicRadians","toRadians","fromCartographicToDegrees","toDegrees","toCartographic","toCartographicFromRadians","toCartographicFromDegrees","isWGS84","from","oneOverRadiiSquared","WGS84_CONSTANTS","centerToleranceSquared","x2","y2","z2","Math","abs"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport type {NumericArray} from '@math.gl/core';\nimport {Vector3, toRadians, toDegrees, config} from '@math.gl/core';\nimport {WGS84_CONSTANTS} from './constants';\n\ntype LngLatHeightObject = {\n  longitude: number;\n  latitude: number;\n  height: number;\n};\n\ntype XYZObject = {\n  x: number;\n  y: number;\n  z: number;\n};\n\ntype Cartographic = LngLatHeightObject | XYZObject | NumericArray;\n\nfunction identity(x: number): number {\n  return x;\n}\n\nconst scratchVector = new Vector3();\n\nexport function fromCartographic(cartographic: Cartographic): number[];\nexport function fromCartographic<NumArrayT>(\n  cartographic: Cartographic,\n  result: NumArrayT,\n  map?: (x: number) => number\n): NumArrayT;\nexport function fromCartographic(\n  cartographic: Cartographic,\n  result = [] as number[],\n  map = identity\n): number[] {\n  if ('longitude' in cartographic) {\n    result[0] = map(cartographic.longitude);\n    result[1] = map(cartographic.latitude);\n    result[2] = cartographic.height;\n  } else if ('x' in cartographic) {\n    result[0] = map(cartographic.x);\n    result[1] = map(cartographic.y);\n    result[2] = cartographic.z;\n  } else {\n    result[0] = map(cartographic[0]);\n    result[1] = map(cartographic[1]);\n    result[2] = cartographic[2];\n  }\n  return result;\n}\n\nexport function fromCartographicToRadians(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToRadians<TArray>(\n  cartographic: Cartographic,\n  result: TArray\n): TArray;\nexport function fromCartographicToRadians(\n  cartographic: Cartographic,\n  vector = [] as number[]\n): number[] {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? identity : toRadians);\n}\n\nexport function fromCartographicToDegrees(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToDegrees<TArray>(\n  cartographic: Cartographic,\n  result: TArray\n): TArray;\nexport function fromCartographicToDegrees(\n  cartographic: Cartographic,\n  vector = [] as number[]\n): number[] {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? toDegrees : identity);\n}\n\nexport function toCartographic<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T,\n  map: (x: number) => number = identity\n): T {\n  if ('longitude' in cartographic) {\n    cartographic.longitude = map(vector[0]);\n    cartographic.latitude = map(vector[1]);\n    cartographic.height = vector[2];\n  } else if ('x' in cartographic) {\n    cartographic.x = map(vector[0]);\n    cartographic.y = map(vector[1]);\n    cartographic.z = vector[2];\n  } else {\n    cartographic[0] = map(vector[0]);\n    cartographic[1] = map(vector[1]);\n    cartographic[2] = vector[2];\n  }\n  return cartographic;\n}\n\nexport function toCartographicFromRadians<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T\n): T {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? identity : toDegrees);\n}\n\nexport function toCartographicFromDegrees<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T\n): T {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? toRadians : identity);\n}\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: Readonly<NumericArray>): boolean {\n  if (!vector) {\n    return false;\n  }\n  scratchVector.from(vector);\n  const {oneOverRadiiSquared, centerToleranceSquared} = WGS84_CONSTANTS;\n  const x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];\n  const y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];\n  const z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];\n  return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;\n}\n\n/*\n\nexport function fromCartographic(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographic(cartographic: Cartographic, result: TypedArray): TypedArray;\nexport function fromCartographicToRadians(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToRadians(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\nexport function fromCartographicToDegrees(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToDegrees(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\n\nexport function toCartographic(vector: number[] | TypedArray, result: Cartographic): number[];\nexport function toCartographicFromRadians(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\nexport function toCartographicFromDegrees(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: number[] | TypedArray): boolean;\n*/\n"],"file":"type-utils.js"}