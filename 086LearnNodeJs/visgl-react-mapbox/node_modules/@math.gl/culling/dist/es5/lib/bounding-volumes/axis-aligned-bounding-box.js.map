{"version":3,"sources":["../../../../src/lib/bounding-volumes/axis-aligned-bounding-box.ts"],"names":["scratchVector","Vector3","scratchNormal","AxisAlignedBoundingBox","minimum","maximum","center","copy","add","scale","halfDiagonal","subtract","right","Boolean","equals","transform","transformAsPoint","plane","normal","from","e","x","Math","abs","y","z","s","dot","distance","INTERSECTION","INSIDE","OUTSIDE","INTERSECTING","point","sqrt","distanceSquaredTo","offset","distanceSquared","d"],"mappings":"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","sourcesContent":["import {BoundingVolume} from './bounding-volume';\nimport {Vector3} from '@math.gl/core';\nimport Plane from '../plane';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n\n/**\n * An axis aligned bounding box - aligned with coordinate axes\n * @see BoundingVolume\n * @see BoundingRectangle\n * @see OrientedBoundingBox\n */\nexport default class AxisAlignedBoundingBox implements BoundingVolume {\n  /** The center point of the bounding box. */\n  readonly center: Vector3;\n  /** The positive half diagonal of the bounding box. */\n  readonly halfDiagonal: Vector3;\n  /** The minimum point defining the bounding box. [0, 0, 0] for empty box */\n  readonly minimum: Vector3;\n  /** The maximum point defining the bounding box. [0, 0, 0] for empty box */\n  readonly maximum: Vector3;\n\n  /**\n   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.\n   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.\n   * @param center The center of the box; automatically computed if not supplied.\n   */\n  constructor(\n    minimum: readonly number[] = [0, 0, 0],\n    maximum: readonly number[] = [0, 0, 0],\n    center?: readonly number[]\n  ) {\n    // If center was not defined, compute it.\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n  }\n\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone(): AxisAlignedBoundingBox {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right: AxisAlignedBoundingBox): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum))\n    );\n  }\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transformAsPoint(transform);\n    // TODO - this.halfDiagonal.transformAsVector(transform);\n    this.halfDiagonal.transform(transform);\n    this.minimum.transform(transform);\n    this.maximum.transform(transform);\n    return this;\n  }\n\n  /**\n   * Determines which side of a plane a box is located.\n   */\n  intersectPlane(plane: Plane): number {\n    const {halfDiagonal} = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e =\n      halfDiagonal.x * Math.abs(normal.x) +\n      halfDiagonal.y * Math.abs(normal.y) +\n      halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return INTERSECTION.OUTSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point: readonly number[]): number {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */\n  distanceSquaredTo(point: readonly number[]): number {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {halfDiagonal} = this;\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.x) - halfDiagonal.x;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.y) - halfDiagonal.y;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.z) - halfDiagonal.z;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n}\n"],"file":"axis-aligned-bounding-box.js"}