{"version":3,"sources":["../../../src/lib/culling-volume.ts"],"names":["faces","Vector3","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","Plane","CullingVolume","planes","boundingSphere","length","center","radius","planeIndex","faceNormal","plane0","plane1","plane0Center","copy","scale","add","plane0Distance","dot","fromPointNormal","plane1Center","negatedFaceNormal","negate","plane1Distance","boundingVolume","intersect","INTERSECTION","INSIDE","plane","result","intersectPlane","OUTSIDE","INTERSECTING","parentPlaneMask","Number","isFinite","MASK_OUTSIDE","MASK_INSIDE","mask","k","flag"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, assert} from '@math.gl/core';\nimport {INTERSECTION} from '../constants';\nimport Plane from './plane';\nimport type {BoundingVolume} from './bounding-volumes/bounding-volume';\nimport type BoundingSphere from './bounding-volumes/bounding-sphere';\n\n// X, Y, Z Unit vectors\nconst faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\n\nconst scratchPlaneCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\nconst scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n\n/** A culling volume defined by planes. */\nexport default class CullingVolume {\n  /**\n   * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n   * represents the case where the object bounding volume is entirely outside the culling volume.\n   */\n  static MASK_OUTSIDE = 0xffffffff;\n\n  /**\n   * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n   * represents the case where the object bounding volume is entirely inside the culling volume.\n   */\n  static MASK_INSIDE = 0x00000000;\n\n  /**\n   * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n   * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n   */\n  static MASK_INDETERMINATE = 0x7fffffff;\n\n  /** Array of clipping planes. */\n  readonly planes: Plane[];\n\n  /**\n   * Create a new `CullingVolume` bounded by an array of clipping planed\n   * @param planes Array of clipping planes.\n   * */\n  constructor(planes: Plane[] = []) {\n    this.planes = planes;\n  }\n\n  /**\n   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n   * The planes are aligned to the x, y, and z axes in world coordinates.\n   */\n  fromBoundingSphere(boundingSphere: BoundingSphere): CullingVolume {\n    this.planes.length = 2 * faces.length;\n\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n\n    let planeIndex = 0;\n\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new Plane();\n      }\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new Plane();\n      }\n\n      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n      const plane0Distance = -faceNormal.dot(plane0Center);\n\n      plane0.fromPointNormal(plane0Center, faceNormal);\n\n      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n\n      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n\n      const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n\n      planeIndex += 2;\n    }\n\n    return this;\n  }\n\n  /** Determines whether a bounding volume intersects the culling volume. */\n  computeVisibility(boundingVolume: BoundingVolume): number {\n    // const planes = this.planes;\n    let intersect: number = INTERSECTION.INSIDE;\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n      switch (result) {\n        case INTERSECTION.OUTSIDE:\n          // We are done\n          return INTERSECTION.OUTSIDE;\n\n        case INTERSECTION.INTERSECTING:\n          // If no other intersection is outside, return INTERSECTING\n          intersect = INTERSECTION.INTERSECTING;\n          break;\n\n        default:\n      }\n    }\n\n    return intersect;\n  }\n\n  /**\n   * Determines whether a bounding volume intersects the culling volume.\n   *\n   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n   *   the parent (and therefore this) volume is completely inside plane[planeIndex]\n   *   and that plane check can be skipped.\n   */\n  computeVisibilityWithPlaneMask(boundingVolume: BoundingVolume, parentPlaneMask: number): number {\n    assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n    if (\n      parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n      parentPlaneMask === CullingVolume.MASK_INSIDE\n    ) {\n      // parent is completely outside or completely inside, so this child is as well.\n      return parentPlaneMask;\n    }\n\n    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n    let mask = CullingVolume.MASK_INSIDE;\n\n    const planes = this.planes;\n    for (let k = 0; k < this.planes.length; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      const flag = k < 31 ? 1 << k : 0;\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        // boundingVolume is known to be INSIDE this plane.\n        continue;\n      }\n\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n      if (result === INTERSECTION.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      } else if (result === INTERSECTION.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n}\n"],"file":"culling-volume.js"}