{"version":3,"sources":["../../../src/lib/plane.ts"],"names":["scratchPosition","Vector3","scratchNormal","Plane","normal","distance","fromNormalDistance","Number","isFinite","from","normalize","point","dot","a","b","c","d","set","len","right","matrix4","copy","transformAsVector","scale","transform","fromPointNormal","result","pointDistance","getPointDistance","scaledNormal","subtract","to"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, equals, assert, NumericArray} from '@math.gl/core';\n\nconst scratchPosition = new Vector3();\nconst scratchNormal = new Vector3();\n\n// A plane in Hessian Normal Form\nexport default class Plane {\n  readonly normal: Vector3;\n  distance: number;\n\n  constructor(normal: Readonly<NumericArray> = [0, 0, 1], distance: number = 0) {\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  /** Creates a plane from a normal and a distance from the origin. */\n  fromNormalDistance(normal: Readonly<NumericArray>, distance: number): this {\n    assert(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n\n  /** Creates a plane from a normal and a point on the plane. */\n  fromPointNormal(point: Readonly<NumericArray>, normal: Readonly<NumericArray>): this {\n    point = scratchPosition.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n    return this;\n  }\n\n  /** Creates a plane from the general equation */\n  fromCoefficients(a: number, b: number, c: number, d: number): this {\n    this.normal.set(a, b, c);\n    assert(equals(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n\n  /** Duplicates a Plane instance. */\n  clone(): Plane {\n    return new Plane(this.normal, this.distance);\n  }\n\n  /** Compares the provided Planes by normal and distance */\n  equals(right: Plane): boolean {\n    return equals(this.distance, right.distance) && equals(this.normal, right.normal);\n  }\n\n  /** Computes the signed shortest distance of a point to a plane.\n   * The sign of the distance determines which side of the plane the point is on.\n   */\n  getPointDistance(point: Readonly<NumericArray>): number {\n    return this.normal.dot(point) + this.distance;\n  }\n\n  /** Transforms the plane by the given transformation matrix. */\n  transform(matrix4: Readonly<NumericArray>): this {\n    const normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n\n  /** Projects a point onto the plane. */\n  projectPointOntoPlane(point: Readonly<NumericArray>, result: Vector3): Vector3;\n  projectPointOntoPlane(\n    point: Readonly<NumericArray>,\n    result?: readonly number[]\n  ): readonly number[];\n\n  projectPointOntoPlane(point, result = [0, 0, 0]) {\n    point = scratchPosition.from(point);\n    // projectedPoint = point - (normal.point + scale) * normal\n    const pointDistance = this.getPointDistance(point);\n    const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n\n    return point.subtract(scaledNormal).to(result);\n  }\n}\n"],"file":"plane.js"}