{"version":3,"sources":["../../../../src/lib/algorithms/bounding-sphere-from-points.ts"],"names":["fromPointsXMin","Vector3","fromPointsYMin","fromPointsZMin","fromPointsXMax","fromPointsYMax","fromPointsZMax","fromPointsCurrentPos","fromPointsScratch","fromPointsRitterCenter","fromPointsMinBoxPt","fromPointsMaxBoxPt","fromPointsNaiveCenterScratch","volumeConstant","Math","PI","makeBoundingSphereFromPoints","positions","result","BoundingSphere","length","fromCenterRadius","currentPos","copy","xMin","yMin","zMin","xMax","yMax","zMax","position","x","y","z","xSpan","subtract","magnitudeSquared","ySpan","zSpan","diameter1","diameter2","maxSpan","ritterCenter","radiusSquared","ritterRadius","sqrt","minBoxPt","maxBoxPt","naiveCenter","add","multiplyByScalar","naiveRadius","r","magnitude","oldCenterToPointSquared","oldCenterToPoint","oldToNew","to","center","radius"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3} from '@math.gl/core';\nimport BoundingSphere from '../bounding-volumes/bounding-sphere';\n\n/* eslint-disable */\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\nconst volumeConstant = (4.0 / 3.0) * Math.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n *\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n * Bounding sphere computation article http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding\n *\n * @param positions An array of points that the bounding sphere will enclose.\n * @param result Optional object onto which to store the result.\n * @returns The modified result parameter or a new `BoundingSphere` instance if not provided.\n */\nexport default function makeBoundingSphereFromPoints(\n  positions: number[][],\n  result: BoundingSphere = new BoundingSphere()\n): BoundingSphere {\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = fromPointsNaiveCenterScratch\n    .copy(minBoxPt)\n    .add(maxBoxPt)\n    .multiplyByScalar(0.5);\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = fromPointsScratch\n      .copy(currentPos)\n      .subtract(ritterCenter)\n      .magnitudeSquared();\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}\n"],"file":"bounding-sphere-from-points.js"}