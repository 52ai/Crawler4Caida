{"version":3,"sources":["../../../../src/lib/bounding-volumes/bounding-sphere.ts"],"names":["scratchVector","Vector3","scratchVector2","BoundingSphere","center","radius","fromCenterRadius","from","corner","oppositeCorner","add","scale","distance","right","Boolean","equals","boundingSphere","leftCenter","leftRadius","rightCenter","rightRadius","toRightCenter","copy","subtract","centerSeparation","magnitude","clone","halfDistanceBetweenTangentPoints","point","scratchPoint","transform","mat4","getScaling","Math","max","d","distanceTo","delta","len","plane","normal","distanceToPlane","dot","INTERSECTION","OUTSIDE","INTERSECTING","INSIDE"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {NumericArray, Vector3} from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport {INTERSECTION} from '../../constants';\nimport {BoundingVolume} from './bounding-volume';\nimport Plane from '../plane';\n\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n\n/** A BoundingSphere */\nexport default class BoundingSphere implements BoundingVolume {\n  center: Vector3;\n  radius: number;\n\n  /** Creates a bounding sphere */\n  constructor(center: readonly number[] = [0, 0, 0], radius: number = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  /** Sets the bounding sphere from `center` and `radius`. */\n  fromCenterRadius(center: readonly number[], radius: number): this {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  /**\n   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n   * tightly and fully encompasses the box.\n   */\n  fromCornerPoints(corner: readonly number[], oppositeCorner: readonly number[]): this {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  /** Compares the provided BoundingSphere component wise */\n  equals(right: BoundingSphere): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.radius === right.radius)\n    );\n  }\n\n  /** Duplicates a BoundingSphere instance. */\n  clone(): BoundingSphere {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  /** Computes a bounding sphere that contains both the left and right bounding spheres. */\n  union(boundingSphere: BoundingSphere): BoundingSphere {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      // Left sphere wins.\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      // Right sphere wins.\n      return boundingSphere.clone();\n    }\n\n    // There are two tangent points, one on far side of each sphere.\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n    // Compute the center point halfway between the two tangent points.\n    scratchVector2\n      .copy(toRightCenter)\n      .scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation)\n      .add(leftCenter);\n\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n\n    return this;\n  }\n\n  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */\n  expand(point: readonly number[]): this {\n    const scratchPoint = scratchVector.from(point);\n    const radius = scratchPoint.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n\n  // BoundingVolume interface\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param sphere The bounding sphere to apply the transformation to.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns self.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */\n  distanceSquaredTo(point: Readonly<NumericArray>): number {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */\n  distanceTo(point: Readonly<NumericArray>): number {\n    const scratchPoint = scratchVector.from(point);\n    const delta = scratchPoint.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n\n  /** Determines which side of a plane a sphere is located. */\n  intersectPlane(plane: Plane): number {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    // The center point is negative side of the plane normal\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n    // The center point and radius is positive side of the plane\n    return INTERSECTION.INSIDE;\n  }\n}\n"],"file":"bounding-sphere.js"}