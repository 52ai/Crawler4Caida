{"version":3,"sources":["../../../../src/lib/algorithms/compute-eigen-decomposition.ts"],"names":["Matrix3","_MathUtils","scratchMatrix","scratchUnitary","scratchDiagonal","jMatrix","jMatrixTranspose","computeEigenDecomposition","matrix","result","EIGEN_TOLERANCE","EPSILON20","EIGEN_MAX_SWEEPS","count","sweep","unitaryMatrix","diagonalMatrix","identity","copy","epsilon","computeFrobeniusNorm","offDiagonalFrobeniusNorm","shurDecomposition","transpose","multiplyRight","multiplyLeft","unitary","toTarget","diagonal","norm","i","temp","Math","sqrt","rowVal","colVal","getElementIndex","tolerance","EPSILON15","maxDiagonal","rotAxis","abs","p","q","c","s","qq","pp","qp","tau","t","IDENTITY","to"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Matrix3, _MathUtils} from '@math.gl/core';\n\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\nexport type EigenDecomposition = {\n  unitary: Matrix3;\n  diagonal: Matrix3;\n};\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n *\n * - Returns a diagonal matrix and unitary matrix such that:\n * `matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)`\n * - The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * - This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n * section 8.4.3 The Classical Jacobi Algorithm\n *\n * @param matrix The 3x3 matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param result Optional object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symmetric matrix\n * const result = {\n *   unitary : new Matrix3(),\n *   diagonal : new Matrix3()\n * };\n * computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Matrix3.transpose(result.unitary, new Matrix3());\n * const b = Matrix3.multiply(result.unitary, result.diagonal, new Matrix3());\n * Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = result.diagonal.getColumn(0, new Vector3()).x;  // first eigenvalue\n * const v = result.unitary.getColumn(0, new Vector3());          // first eigenvector\n * const c = v.multiplyByScalar(lambda);                          // equal to v.transformByMatrix3(a)\n */\nexport default function computeEigenDecomposition(\n  matrix: number[],\n  // @ts-expect-error accept empty object type\n  result: EigenDecomposition = {}\n): EigenDecomposition {\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n\n    jMatrixTranspose.copy(jMatrix).transpose();\n\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n\n  return result;\n}\n\nfunction computeFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\n// Computes the \"off-diagonal\" Frobenius norm.\n// Assumes matrix is symmetric.\nfunction offDiagonalFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\n// The routine takes a matrix, which is assumed to be symmetric, and\n// finds the largest off-diagonal term, and then creates\n// a matrix (result) which can be used to help reduce it\n//\n// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n// section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n//\n// eslint-disable-next-line max-statements\nfunction shurDecomposition(matrix: Matrix3, result: Matrix3): Matrix3 {\n  const tolerance = _MathUtils.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  let c = 1.0;\n  let s = 0.0;\n\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  // Copy into result\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n"],"file":"compute-eigen-decomposition.js"}