{"version":3,"names":[],"sources":["../../../src/path/generated/validators.ts"],"sourcesContent":["/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport type * as t from \"@babel/types\";\nimport type NodePath from \"../index\";\nimport type { VirtualTypeNodePathValidators } from \"../lib/virtual-types-validator\";\n\ninterface BaseNodePathValidators {\n  isAccessor<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Accessor>;\n  isAnyTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.AnyTypeAnnotation>;\n  isArgumentPlaceholder<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ArgumentPlaceholder>;\n  isArrayExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ArrayExpression>;\n  isArrayPattern<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ArrayPattern>;\n  isArrayTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ArrayTypeAnnotation>;\n  isArrowFunctionExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ArrowFunctionExpression>;\n  isAssignmentExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.AssignmentExpression>;\n  isAssignmentPattern<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.AssignmentPattern>;\n  isAwaitExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.AwaitExpression>;\n  isBigIntLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.BigIntLiteral>;\n  isBinary<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Binary>;\n  isBinaryExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.BinaryExpression>;\n  isBindExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.BindExpression>;\n  isBlock<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Block>;\n  isBlockParent<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.BlockParent>;\n  isBlockStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.BlockStatement>;\n  isBooleanLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.BooleanLiteral>;\n  isBooleanLiteralTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.BooleanLiteralTypeAnnotation>;\n  isBooleanTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.BooleanTypeAnnotation>;\n  isBreakStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.BreakStatement>;\n  isCallExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.CallExpression>;\n  isCatchClause<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.CatchClause>;\n  isClass<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Class>;\n  isClassAccessorProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ClassAccessorProperty>;\n  isClassBody<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ClassBody>;\n  isClassDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ClassDeclaration>;\n  isClassExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ClassExpression>;\n  isClassImplements<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ClassImplements>;\n  isClassMethod<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ClassMethod>;\n  isClassPrivateMethod<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ClassPrivateMethod>;\n  isClassPrivateProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ClassPrivateProperty>;\n  isClassProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ClassProperty>;\n  isCompletionStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.CompletionStatement>;\n  isConditional<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Conditional>;\n  isConditionalExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ConditionalExpression>;\n  isContinueStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ContinueStatement>;\n  isDebuggerStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DebuggerStatement>;\n  isDecimalLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DecimalLiteral>;\n  isDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Declaration>;\n  isDeclareClass<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclareClass>;\n  isDeclareExportAllDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclareExportAllDeclaration>;\n  isDeclareExportDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclareExportDeclaration>;\n  isDeclareFunction<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclareFunction>;\n  isDeclareInterface<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclareInterface>;\n  isDeclareModule<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclareModule>;\n  isDeclareModuleExports<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclareModuleExports>;\n  isDeclareOpaqueType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclareOpaqueType>;\n  isDeclareTypeAlias<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclareTypeAlias>;\n  isDeclareVariable<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclareVariable>;\n  isDeclaredPredicate<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DeclaredPredicate>;\n  isDecorator<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Decorator>;\n  isDirective<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Directive>;\n  isDirectiveLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DirectiveLiteral>;\n  isDoExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DoExpression>;\n  isDoWhileStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.DoWhileStatement>;\n  isEmptyStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EmptyStatement>;\n  isEmptyTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EmptyTypeAnnotation>;\n  isEnumBody<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumBody>;\n  isEnumBooleanBody<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumBooleanBody>;\n  isEnumBooleanMember<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumBooleanMember>;\n  isEnumDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumDeclaration>;\n  isEnumDefaultedMember<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumDefaultedMember>;\n  isEnumMember<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumMember>;\n  isEnumNumberBody<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumNumberBody>;\n  isEnumNumberMember<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumNumberMember>;\n  isEnumStringBody<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumStringBody>;\n  isEnumStringMember<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumStringMember>;\n  isEnumSymbolBody<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.EnumSymbolBody>;\n  isExistsTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ExistsTypeAnnotation>;\n  isExportAllDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ExportAllDeclaration>;\n  isExportDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ExportDeclaration>;\n  isExportDefaultDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ExportDefaultDeclaration>;\n  isExportDefaultSpecifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ExportDefaultSpecifier>;\n  isExportNamedDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ExportNamedDeclaration>;\n  isExportNamespaceSpecifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ExportNamespaceSpecifier>;\n  isExportSpecifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ExportSpecifier>;\n  isExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Expression>;\n  isExpressionStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ExpressionStatement>;\n  isExpressionWrapper<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ExpressionWrapper>;\n  isFile<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.File>;\n  isFlow<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Flow>;\n  isFlowBaseAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.FlowBaseAnnotation>;\n  isFlowDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.FlowDeclaration>;\n  isFlowPredicate<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.FlowPredicate>;\n  isFlowType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.FlowType>;\n  isFor<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.For>;\n  isForInStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ForInStatement>;\n  isForOfStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ForOfStatement>;\n  isForStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ForStatement>;\n  isForXStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ForXStatement>;\n  isFunction<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Function>;\n  isFunctionDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.FunctionDeclaration>;\n  isFunctionExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.FunctionExpression>;\n  isFunctionParent<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.FunctionParent>;\n  isFunctionTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.FunctionTypeAnnotation>;\n  isFunctionTypeParam<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.FunctionTypeParam>;\n  isGenericTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.GenericTypeAnnotation>;\n  isIdentifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Identifier>;\n  isIfStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.IfStatement>;\n  isImmutable<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Immutable>;\n  isImport<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Import>;\n  isImportAttribute<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ImportAttribute>;\n  isImportDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ImportDeclaration>;\n  isImportDefaultSpecifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ImportDefaultSpecifier>;\n  isImportNamespaceSpecifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ImportNamespaceSpecifier>;\n  isImportSpecifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ImportSpecifier>;\n  isIndexedAccessType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.IndexedAccessType>;\n  isInferredPredicate<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.InferredPredicate>;\n  isInterfaceDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.InterfaceDeclaration>;\n  isInterfaceExtends<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.InterfaceExtends>;\n  isInterfaceTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.InterfaceTypeAnnotation>;\n  isInterpreterDirective<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.InterpreterDirective>;\n  isIntersectionTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.IntersectionTypeAnnotation>;\n  isJSX<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSX>;\n  isJSXAttribute<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXAttribute>;\n  isJSXClosingElement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXClosingElement>;\n  isJSXClosingFragment<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXClosingFragment>;\n  isJSXElement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXElement>;\n  isJSXEmptyExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXEmptyExpression>;\n  isJSXExpressionContainer<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXExpressionContainer>;\n  isJSXFragment<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXFragment>;\n  isJSXIdentifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXIdentifier>;\n  isJSXMemberExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXMemberExpression>;\n  isJSXNamespacedName<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXNamespacedName>;\n  isJSXOpeningElement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXOpeningElement>;\n  isJSXOpeningFragment<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXOpeningFragment>;\n  isJSXSpreadAttribute<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXSpreadAttribute>;\n  isJSXSpreadChild<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXSpreadChild>;\n  isJSXText<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.JSXText>;\n  isLVal<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.LVal>;\n  isLabeledStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.LabeledStatement>;\n  isLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Literal>;\n  isLogicalExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.LogicalExpression>;\n  isLoop<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Loop>;\n  isMemberExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.MemberExpression>;\n  isMetaProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.MetaProperty>;\n  isMethod<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Method>;\n  isMiscellaneous<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Miscellaneous>;\n  isMixedTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.MixedTypeAnnotation>;\n  isModuleDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ModuleDeclaration>;\n  isModuleExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ModuleExpression>;\n  isModuleSpecifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ModuleSpecifier>;\n  isNewExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.NewExpression>;\n  isNoop<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Noop>;\n  isNullLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.NullLiteral>;\n  isNullLiteralTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.NullLiteralTypeAnnotation>;\n  isNullableTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.NullableTypeAnnotation>;\n  isNumberLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.NumberLiteral>;\n  isNumberLiteralTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.NumberLiteralTypeAnnotation>;\n  isNumberTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.NumberTypeAnnotation>;\n  isNumericLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.NumericLiteral>;\n  isObjectExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectExpression>;\n  isObjectMember<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectMember>;\n  isObjectMethod<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectMethod>;\n  isObjectPattern<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectPattern>;\n  isObjectProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectProperty>;\n  isObjectTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectTypeAnnotation>;\n  isObjectTypeCallProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectTypeCallProperty>;\n  isObjectTypeIndexer<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectTypeIndexer>;\n  isObjectTypeInternalSlot<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectTypeInternalSlot>;\n  isObjectTypeProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectTypeProperty>;\n  isObjectTypeSpreadProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ObjectTypeSpreadProperty>;\n  isOpaqueType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.OpaqueType>;\n  isOptionalCallExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.OptionalCallExpression>;\n  isOptionalIndexedAccessType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.OptionalIndexedAccessType>;\n  isOptionalMemberExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.OptionalMemberExpression>;\n  isParenthesizedExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ParenthesizedExpression>;\n  isPattern<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Pattern>;\n  isPatternLike<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.PatternLike>;\n  isPipelineBareFunction<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.PipelineBareFunction>;\n  isPipelinePrimaryTopicReference<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.PipelinePrimaryTopicReference>;\n  isPipelineTopicExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.PipelineTopicExpression>;\n  isPlaceholder<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Placeholder>;\n  isPrivate<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Private>;\n  isPrivateName<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.PrivateName>;\n  isProgram<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Program>;\n  isProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Property>;\n  isPureish<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Pureish>;\n  isQualifiedTypeIdentifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.QualifiedTypeIdentifier>;\n  isRecordExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.RecordExpression>;\n  isRegExpLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.RegExpLiteral>;\n  isRegexLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.RegexLiteral>;\n  isRestElement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.RestElement>;\n  isRestProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.RestProperty>;\n  isReturnStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ReturnStatement>;\n  isScopable<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Scopable>;\n  isSequenceExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.SequenceExpression>;\n  isSpreadElement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.SpreadElement>;\n  isSpreadProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.SpreadProperty>;\n  isStandardized<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Standardized>;\n  isStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Statement>;\n  isStaticBlock<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.StaticBlock>;\n  isStringLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.StringLiteral>;\n  isStringLiteralTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.StringLiteralTypeAnnotation>;\n  isStringTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.StringTypeAnnotation>;\n  isSuper<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Super>;\n  isSwitchCase<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.SwitchCase>;\n  isSwitchStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.SwitchStatement>;\n  isSymbolTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.SymbolTypeAnnotation>;\n  isTSAnyKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSAnyKeyword>;\n  isTSArrayType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSArrayType>;\n  isTSAsExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSAsExpression>;\n  isTSBaseType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSBaseType>;\n  isTSBigIntKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSBigIntKeyword>;\n  isTSBooleanKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSBooleanKeyword>;\n  isTSCallSignatureDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSCallSignatureDeclaration>;\n  isTSConditionalType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSConditionalType>;\n  isTSConstructSignatureDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSConstructSignatureDeclaration>;\n  isTSConstructorType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSConstructorType>;\n  isTSDeclareFunction<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSDeclareFunction>;\n  isTSDeclareMethod<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSDeclareMethod>;\n  isTSEntityName<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSEntityName>;\n  isTSEnumDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSEnumDeclaration>;\n  isTSEnumMember<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSEnumMember>;\n  isTSExportAssignment<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSExportAssignment>;\n  isTSExpressionWithTypeArguments<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSExpressionWithTypeArguments>;\n  isTSExternalModuleReference<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSExternalModuleReference>;\n  isTSFunctionType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSFunctionType>;\n  isTSImportEqualsDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSImportEqualsDeclaration>;\n  isTSImportType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSImportType>;\n  isTSIndexSignature<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSIndexSignature>;\n  isTSIndexedAccessType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSIndexedAccessType>;\n  isTSInferType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSInferType>;\n  isTSInstantiationExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSInstantiationExpression>;\n  isTSInterfaceBody<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSInterfaceBody>;\n  isTSInterfaceDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSInterfaceDeclaration>;\n  isTSIntersectionType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSIntersectionType>;\n  isTSIntrinsicKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSIntrinsicKeyword>;\n  isTSLiteralType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSLiteralType>;\n  isTSMappedType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSMappedType>;\n  isTSMethodSignature<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSMethodSignature>;\n  isTSModuleBlock<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSModuleBlock>;\n  isTSModuleDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSModuleDeclaration>;\n  isTSNamedTupleMember<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSNamedTupleMember>;\n  isTSNamespaceExportDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSNamespaceExportDeclaration>;\n  isTSNeverKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSNeverKeyword>;\n  isTSNonNullExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSNonNullExpression>;\n  isTSNullKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSNullKeyword>;\n  isTSNumberKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSNumberKeyword>;\n  isTSObjectKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSObjectKeyword>;\n  isTSOptionalType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSOptionalType>;\n  isTSParameterProperty<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSParameterProperty>;\n  isTSParenthesizedType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSParenthesizedType>;\n  isTSPropertySignature<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSPropertySignature>;\n  isTSQualifiedName<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSQualifiedName>;\n  isTSRestType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSRestType>;\n  isTSStringKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSStringKeyword>;\n  isTSSymbolKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSSymbolKeyword>;\n  isTSThisType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSThisType>;\n  isTSTupleType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTupleType>;\n  isTSType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSType>;\n  isTSTypeAliasDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeAliasDeclaration>;\n  isTSTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeAnnotation>;\n  isTSTypeAssertion<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeAssertion>;\n  isTSTypeElement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeElement>;\n  isTSTypeLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeLiteral>;\n  isTSTypeOperator<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeOperator>;\n  isTSTypeParameter<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeParameter>;\n  isTSTypeParameterDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeParameterDeclaration>;\n  isTSTypeParameterInstantiation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeParameterInstantiation>;\n  isTSTypePredicate<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypePredicate>;\n  isTSTypeQuery<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeQuery>;\n  isTSTypeReference<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSTypeReference>;\n  isTSUndefinedKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSUndefinedKeyword>;\n  isTSUnionType<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSUnionType>;\n  isTSUnknownKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSUnknownKeyword>;\n  isTSVoidKeyword<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TSVoidKeyword>;\n  isTaggedTemplateExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TaggedTemplateExpression>;\n  isTemplateElement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TemplateElement>;\n  isTemplateLiteral<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TemplateLiteral>;\n  isTerminatorless<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Terminatorless>;\n  isThisExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ThisExpression>;\n  isThisTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ThisTypeAnnotation>;\n  isThrowStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.ThrowStatement>;\n  isTopicReference<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TopicReference>;\n  isTryStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TryStatement>;\n  isTupleExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TupleExpression>;\n  isTupleTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TupleTypeAnnotation>;\n  isTypeAlias<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TypeAlias>;\n  isTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TypeAnnotation>;\n  isTypeCastExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TypeCastExpression>;\n  isTypeParameter<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TypeParameter>;\n  isTypeParameterDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TypeParameterDeclaration>;\n  isTypeParameterInstantiation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TypeParameterInstantiation>;\n  isTypeScript<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TypeScript>;\n  isTypeofTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.TypeofTypeAnnotation>;\n  isUnaryExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.UnaryExpression>;\n  isUnaryLike<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.UnaryLike>;\n  isUnionTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.UnionTypeAnnotation>;\n  isUpdateExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.UpdateExpression>;\n  isUserWhitespacable<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.UserWhitespacable>;\n  isV8IntrinsicIdentifier<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.V8IntrinsicIdentifier>;\n  isVariableDeclaration<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.VariableDeclaration>;\n  isVariableDeclarator<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.VariableDeclarator>;\n  isVariance<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.Variance>;\n  isVoidTypeAnnotation<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.VoidTypeAnnotation>;\n  isWhile<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.While>;\n  isWhileStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.WhileStatement>;\n  isWithStatement<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.WithStatement>;\n  isYieldExpression<T extends t.Node>(\n    this: NodePath<T>,\n    opts?: object,\n  ): this is NodePath<T & t.YieldExpression>;\n}\n\nexport interface NodePathValidators\n  extends BaseNodePathValidators,\n    VirtualTypeNodePathValidators {}\n"],"mappings":""}