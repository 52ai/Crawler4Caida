"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _gltools = require("@luma.gl/gltools");

var _webgl = require("@luma.gl/webgl");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var BufferTransform = function () {
  function BufferTransform(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, BufferTransform);
    this.gl = gl;
    this.currentIndex = 0;
    this.feedbackMap = {};
    this.varyings = null;
    this.bindings = [];
    this.resources = {};

    this._initialize(props);

    Object.seal(this);
  }

  (0, _createClass2.default)(BufferTransform, [{
    key: "setupResources",
    value: function setupResources(opts) {
      var _iterator = _createForOfIteratorHelper(this.bindings),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var binding = _step.value;

          this._setupTransformFeedback(binding, opts);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "updateModelProps",
    value: function updateModelProps() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var varyings = this.varyings;

      if (varyings.length > 0) {
        props = Object.assign({}, props, {
          varyings: varyings
        });
      }

      return props;
    }
  }, {
    key: "getDrawOptions",
    value: function getDrawOptions() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var binding = this.bindings[this.currentIndex];
      var sourceBuffers = binding.sourceBuffers,
          transformFeedback = binding.transformFeedback;
      var attributes = Object.assign({}, sourceBuffers, opts.attributes);
      return {
        attributes: attributes,
        transformFeedback: transformFeedback
      };
    }
  }, {
    key: "swap",
    value: function swap() {
      if (this.feedbackMap) {
        this.currentIndex = this._getNextIndex();
        return true;
      }

      return false;
    }
  }, {
    key: "update",
    value: function update() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this._setupBuffers(opts);
    }
  }, {
    key: "getBuffer",
    value: function getBuffer(varyingName) {
      var feedbackBuffers = this.bindings[this.currentIndex].feedbackBuffers;
      var bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;

      if (!bufferOrParams) {
        return null;
      }

      return bufferOrParams instanceof _webgl.Buffer ? bufferOrParams : bufferOrParams.buffer;
    }
  }, {
    key: "getData",
    value: function getData() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var varyingName = options.varyingName;
      var buffer = this.getBuffer(varyingName);

      if (buffer) {
        return buffer.getData();
      }

      return null;
    }
  }, {
    key: "delete",
    value: function _delete() {
      for (var name in this.resources) {
        this.resources[name].delete();
      }
    }
  }, {
    key: "_initialize",
    value: function _initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this._setupBuffers(props);

      this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);

      if (this.varyings.length > 0) {
        (0, _webgl.assert)((0, _gltools.isWebGL2)(this.gl));
      }
    }
  }, {
    key: "_getFeedbackBuffers",
    value: function _getFeedbackBuffers(props) {
      var _props$sourceBuffers = props.sourceBuffers,
          sourceBuffers = _props$sourceBuffers === void 0 ? {} : _props$sourceBuffers;
      var feedbackBuffers = {};

      if (this.bindings[this.currentIndex]) {
        Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
      }

      if (this.feedbackMap) {
        for (var sourceName in this.feedbackMap) {
          var feedbackName = this.feedbackMap[sourceName];

          if (sourceName in sourceBuffers) {
            feedbackBuffers[feedbackName] = sourceName;
          }
        }
      }

      Object.assign(feedbackBuffers, props.feedbackBuffers);

      for (var bufferName in feedbackBuffers) {
        var bufferOrRef = feedbackBuffers[bufferName];

        if (typeof bufferOrRef === 'string') {
          var sourceBuffer = sourceBuffers[bufferOrRef];
          var byteLength = sourceBuffer.byteLength,
              usage = sourceBuffer.usage,
              accessor = sourceBuffer.accessor;
          feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
            byteLength: byteLength,
            usage: usage,
            accessor: accessor
          });
        }
      }

      return feedbackBuffers;
    }
  }, {
    key: "_setupBuffers",
    value: function _setupBuffers() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _props$sourceBuffers2 = props.sourceBuffers,
          sourceBuffers = _props$sourceBuffers2 === void 0 ? null : _props$sourceBuffers2;
      Object.assign(this.feedbackMap, props.feedbackMap);

      var feedbackBuffers = this._getFeedbackBuffers(props);

      this._updateBindings({
        sourceBuffers: sourceBuffers,
        feedbackBuffers: feedbackBuffers
      });
    }
  }, {
    key: "_setupTransformFeedback",
    value: function _setupTransformFeedback(binding, _ref) {
      var model = _ref.model;
      var program = model.program;
      binding.transformFeedback = new _webgl.TransformFeedback(this.gl, {
        program: program,
        buffers: binding.feedbackBuffers
      });
    }
  }, {
    key: "_updateBindings",
    value: function _updateBindings(opts) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);

      if (this.feedbackMap) {
        var _this$_swapBuffers = this._swapBuffers(this.bindings[this.currentIndex]),
            sourceBuffers = _this$_swapBuffers.sourceBuffers,
            feedbackBuffers = _this$_swapBuffers.feedbackBuffers;

        var nextIndex = this._getNextIndex();

        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
          sourceBuffers: sourceBuffers,
          feedbackBuffers: feedbackBuffers
        });
      }
    }
  }, {
    key: "_updateBinding",
    value: function _updateBinding(binding, opts) {
      if (!binding) {
        return {
          sourceBuffers: Object.assign({}, opts.sourceBuffers),
          feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
        };
      }

      Object.assign(binding.sourceBuffers, opts.sourceBuffers);
      Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);

      if (binding.transformFeedback) {
        binding.transformFeedback.setBuffers(binding.feedbackBuffers);
      }

      return binding;
    }
  }, {
    key: "_swapBuffers",
    value: function _swapBuffers(opts) {
      if (!this.feedbackMap) {
        return null;
      }

      var sourceBuffers = Object.assign({}, opts.sourceBuffers);
      var feedbackBuffers = Object.assign({}, opts.feedbackBuffers);

      for (var srcName in this.feedbackMap) {
        var dstName = this.feedbackMap[srcName];
        sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
        feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
        (0, _webgl.assert)(feedbackBuffers[dstName] instanceof _webgl.Buffer);
      }

      return {
        sourceBuffers: sourceBuffers,
        feedbackBuffers: feedbackBuffers
      };
    }
  }, {
    key: "_createNewBuffer",
    value: function _createNewBuffer(name, opts) {
      var buffer = new _webgl.Buffer(this.gl, opts);

      if (this.resources[name]) {
        this.resources[name].delete();
      }

      this.resources[name] = buffer;
      return buffer;
    }
  }, {
    key: "_getNextIndex",
    value: function _getNextIndex() {
      return (this.currentIndex + 1) % 2;
    }
  }]);
  return BufferTransform;
}();

exports.default = BufferTransform;
//# sourceMappingURL=buffer-transform.js.map