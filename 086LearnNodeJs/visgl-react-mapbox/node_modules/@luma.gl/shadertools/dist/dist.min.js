!function(n,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t=e();for(var o in t)("object"==typeof exports?exports:n)[o]=t[o]}}(window,(function(){return function(n){var e={};function t(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return n[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=n,t.c=e,t.d=function(n,e,o){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)t.d(o,r,function(e){return n[e]}.bind(null,r));return o},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=14)}([function(n,e){function t(e){return n.exports=t=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)},t(e)}n.exports=t},function(n,e,t){var o=t(15),r=t(16),i=t(9),a=t(17);n.exports=function(n,e){return o(n)||r(n,e)||i(n,e)||a()}},function(n,e){n.exports=function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}},function(n,e){function t(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}n.exports=function(n,e,o){return e&&t(n.prototype,e),o&&t(n,o),n}},function(n,e){function t(e){return"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?n.exports=t=function(n){return typeof n}:n.exports=t=function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},t(e)}n.exports=t},function(n,e,t){var o=t(11);n.exports=function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&o(n,e)}},function(n,e,t){var o=t(4),r=t(18);n.exports=function(n,e){return!e||"object"!==o(e)&&"function"!=typeof e?r(n):e}},function(n,e){n.exports=function(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}},,function(n,e,t){var o=t(10);n.exports=function(n,e){if(n){if("string"==typeof n)return o(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?o(n,e):void 0}}},function(n,e){n.exports=function(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}},function(n,e){function t(e,o){return n.exports=t=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n},t(e,o)}n.exports=t},function(n,e,t){var o=t(11),r=t(19);function i(e,t,a){return r()?n.exports=i=Reflect.construct:n.exports=i=function(n,e,t){var r=[null];r.push.apply(r,e);var i=new(Function.bind.apply(n,r));return t&&o(i,t.prototype),i},i.apply(null,arguments)}n.exports=i},function(n,e,t){var o=t(20),r=t(21),i=t(9),a=t(22);n.exports=function(n){return o(n)||r(n)||i(n)||a()}},function(n,e,t){var o=t(23);globalThis.luma=globalThis.luma||{},n.exports=Object.assign(globalThis.luma,o)},function(n,e){n.exports=function(n){if(Array.isArray(n))return n}},function(n,e){n.exports=function(n,e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n)){var t=[],o=!0,r=!1,i=void 0;try{for(var a,l=n[Symbol.iterator]();!(o=(a=l.next()).done)&&(t.push(a.value),!e||t.length!==e);o=!0);}catch(n){r=!0,i=n}finally{try{o||null==l.return||l.return()}finally{if(r)throw i}}return t}}},function(n,e){n.exports=function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}},function(n,e){n.exports=function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}},function(n,e){n.exports=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}},function(n,e,t){var o=t(10);n.exports=function(n){if(Array.isArray(n))return o(n)}},function(n,e){n.exports=function(n){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n))return Array.from(n)}},function(n,e){n.exports=function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}},function(n,e,t){"use strict";t.r(e),t.d(e,"assembleShaders",(function(){return tn})),t.d(e,"combineInjects",(function(){return w})),t.d(e,"normalizeShaderModule",(function(){return A})),t.d(e,"getQualifierDetails",(function(){return fn})),t.d(e,"getPassthroughFS",(function(){return sn})),t.d(e,"typeToChannelSuffix",(function(){return un})),t.d(e,"typeToChannelCount",(function(){return _n})),t.d(e,"convertToVec4",(function(){return dn})),t.d(e,"random",(function(){return vn})),t.d(e,"fp32",(function(){return pn})),t.d(e,"fp64",(function(){return Pn})),t.d(e,"fp64arithmetic",(function(){return xn})),t.d(e,"project",(function(){return re})),t.d(e,"lights",(function(){return ue})),t.d(e,"dirlight",(function(){return de})),t.d(e,"picking",(function(){return pe})),t.d(e,"gouraudLighting",(function(){return xe})),t.d(e,"phongLighting",(function(){return Pe})),t.d(e,"pbr",(function(){return be})),t.d(e,"tiltShift",(function(){return Fe})),t.d(e,"triangleBlur",(function(){return ye})),t.d(e,"zoomBlur",(function(){return Le})),t.d(e,"brightnessContrast",(function(){return Ee})),t.d(e,"denoise",(function(){return Ne})),t.d(e,"hueSaturation",(function(){return Ie})),t.d(e,"noise",(function(){return Te})),t.d(e,"sepia",(function(){return Se})),t.d(e,"vibrance",(function(){return Ce})),t.d(e,"vignette",(function(){return Re})),t.d(e,"colorHalftone",(function(){return Oe})),t.d(e,"dotScreen",(function(){return Ue})),t.d(e,"edgeWork",(function(){return ke})),t.d(e,"hexagonalPixelate",(function(){return Me})),t.d(e,"ink",(function(){return we})),t.d(e,"magnify",(function(){return Xe})),t.d(e,"bulgePinch",(function(){return Qe})),t.d(e,"swirl",(function(){return Ye})),t.d(e,"_warp",(function(){return De})),t.d(e,"fxaa",(function(){return Be})),t.d(e,"_transform",(function(){return ze}));var o=t(1),r=t.n(o),i=t(7),a=t.n(i),l=t(2),c=t.n(l),f=t(3),s=t.n(f);function u(n,e){if(!n)throw new Error(e||"shadertools: assertion failed.")}var _=t(4),d=t.n(_),v={number:{validate:function(n,e){return Number.isFinite(n)&&(!("max"in e)||n<=e.max)&&(!("min"in e)||n>=e.min)}},array:{validate:function(n,e){return Array.isArray(n)||ArrayBuffer.isView(n)}}};function p(n){var e=m(n);return"object"===e?n?"type"in n?Object.assign({},n,v[n.type]):"value"in n?(e=m(n.value),Object.assign({type:e},n,v[e])):{type:"object",value:n}:{type:"object",value:null}:Object.assign({type:e,value:n},v[e])}function m(n){return Array.isArray(n)||ArrayBuffer.isView(n)?"array":d()(n)}var h=function(){function n(e){var t=e.name,o=e.vs,r=e.fs,i=e.dependencies,a=void 0===i?[]:i,l=e.uniforms,f=e.getUniforms,s=e.deprecations,_=void 0===s?[]:s,d=e.defines,v=void 0===d?{}:d,m=e.inject,h=void 0===m?{}:m,A=e.vertexShader,g=e.fragmentShader;c()(this,n),u("string"==typeof t),this.name=t,this.vs=o||A,this.fs=r||g,this.getModuleUniforms=f,this.dependencies=a,this.deprecations=this._parseDeprecationDefinitions(_),this.defines=v,this.injections=function(n){var e={vs:{},fs:{}};for(var t in n){var o=n[t],r=t.slice(0,2);"string"==typeof o&&(o={order:0,injection:o}),e[r][t]=o}return e}(h),l&&(this.uniforms=function(n){var e={};for(var t in n){var o=p(n[t]);e[t]=o}return e}(l))}return s()(n,[{key:"getModuleSource",value:function(n){var e;switch(n){case"vs":e=this.vs||"";break;case"fs":e=this.fs||"";break;default:u(!1)}return"#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi,"_"),"\n").concat(e,"// END MODULE_").concat(this.name,"\n\n")}},{key:"getUniforms",value:function(n,e){return this.getModuleUniforms?this.getModuleUniforms(n,e):this.uniforms?this._defaultGetUniforms(n):{}}},{key:"getDefines",value:function(){return this.defines}},{key:"checkDeprecations",value:function(n,e){this.deprecations.forEach((function(t){t.regex.test(n)&&(t.deprecated?e.deprecated(t.old,t.new)():e.removed(t.old,t.new)())}))}},{key:"_parseDeprecationDefinitions",value:function(n){return n.forEach((function(n){switch(n.type){case"function":n.regex=new RegExp("\\b".concat(n.old,"\\("));break;default:n.regex=new RegExp("".concat(n.type," ").concat(n.old,";"))}})),n}},{key:"_defaultGetUniforms",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e={},t=this.uniforms;for(var o in t){var r=t[o];o in n&&!r.private?(r.validate&&u(r.validate(n[o],r),"".concat(this.name,": invalid ").concat(o)),e[o]=n[o]):e[o]=r.value}return e}}]),n}();function A(n){if(!n.normalized&&(n.normalized=!0,n.uniforms&&!n.getUniforms)){var e=new h(n);n.getUniforms=e.getUniforms.bind(e)}return n}function g(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=function(n,e){if(!n)return;if("string"==typeof n)return x(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);"Object"===t&&n.constructor&&(t=n.constructor.name);if("Map"===t||"Set"===t)return Array.from(n);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return x(n,e)}(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var o=0,r=function(){};return{s:r,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,l=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return a=n.done,n},e:function(n){l=!0,i=n},f:function(){try{a||null==t.return||t.return()}finally{if(l)throw i}}}}function x(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}function P(n){return b(function n(e,t){return e.map((function(e){return e instanceof h||(u("string"!=typeof e,"Shader module use by name is deprecated. Import shader module '".concat(e,"' and use it directly.")),u(e.name,"shader module has no name"),(e=new h(e)).dependencies=n(e.dependencies)),e}))}(n))}function b(n){var e={},t={};return F({modules:n,level:0,moduleMap:e,moduleDepth:t}),Object.keys(t).sort((function(n,e){return t[e]-t[n]})).map((function(n){return e[n]}))}function F(n){var e=n.modules,t=n.level,o=n.moduleMap,r=n.moduleDepth;if(t>=5)throw new Error("Possible loop in shader dependency graph");var i,a=g(e);try{for(a.s();!(i=a.n()).done;){var l=i.value;o[l.name]=l,(void 0===r[l.name]||r[l.name]<t)&&(r[l.name]=t)}}catch(n){a.e(n)}finally{a.f()}var c,f=g(e);try{for(f.s();!(c=f.n()).done;){var s=c.value;s.dependencies&&F({modules:s.dependencies,level:t+1,moduleMap:o,moduleDepth:r})}}catch(n){f.e(n)}finally{f.f()}}function y(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e="undefined"!=typeof window&&window.navigator||{},t=n.userAgent||e.userAgent||"",o=-1!==t.indexOf("MSIE "),r=-1!==t.indexOf("Trident/");return o||r}var L={GLSL_FRAG_DATA:["WEBGL_draw_buffers",!0],GLSL_FRAG_DEPTH:["EXT_frag_depth",!0],GLSL_DERIVATIVES:["OES_standard_derivatives",!0],GLSL_TEXTURE_LOD:["EXT_shader_texture_lod",!0]},E={};Object.keys(L).forEach((function(n){E[n]=n}));var N={};function I(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=L[e];if(u(o,e),!y(t))return!0;if(e in N)return N[e];var r=o[0],i=t.behavior||"enable",a="#extension GL_".concat(r," : ").concat(i,"\nvoid main(void) {}"),l=n.createShader(35633);n.shaderSource(l,a),n.compileShader(l);var c=n.getShaderParameter(l,35713);return n.deleteShader(l),N[e]=c,c}function T(n,e){var t=L[e];u(t,e);var o=function(n){return"undefined"!=typeof WebGL2RenderingContext&&n instanceof WebGL2RenderingContext||Boolean(n&&2===n._version)}(n)&&t[1]||t[0],r="string"==typeof o?Boolean(n.getExtension(o)):o;return u(!1===r||!0===r),r}function S(n,e){return(e=Array.isArray(e)?e:[e]).every((function(e){return T(n,e)}))}var C,R=(C={},a()(C,"vs","#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n"),a()(C,"fs","#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n"),C),O=/void\s+main\s*\([^)]*\)\s*\{\n?/,U=/}\n?[^{}]*$/,k=[];function M(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r="vs"===e,i=function(e){var o=t[e];o.sort((function(n,e){return n.order-e.order})),k.length=o.length;for(var i=0,a=o.length;i<a;++i)k[i]=o[i].injection;var l="".concat(k.join("\n"),"\n");switch(e){case"vs:#decl":r&&(n=n.replace("__LUMA_INJECT_DECLARATIONS__",l));break;case"vs:#main-start":r&&(n=n.replace(O,(function(n){return n+l})));break;case"vs:#main-end":r&&(n=n.replace(U,(function(n){return l+n})));break;case"fs:#decl":r||(n=n.replace("__LUMA_INJECT_DECLARATIONS__",l));break;case"fs:#main-start":r||(n=n.replace(O,(function(n){return n+l})));break;case"fs:#main-end":r||(n=n.replace(U,(function(n){return l+n})));break;default:n=n.replace(e,(function(n){return n+l}))}};for(var a in t)i(a);return n=n.replace("__LUMA_INJECT_DECLARATIONS__",""),o&&(n=n.replace(/\}\s*$/,(function(n){return n+R[e]}))),n}function w(n){var e={};return u(Array.isArray(n)&&n.length>1),n.forEach((function(n){for(var t in n)e[t]=e[t]?"".concat(e[t],"\n").concat(n[t]):n[t]})),e}function X(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=function(n,e){if(!n)return;if("string"==typeof n)return D(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);"Object"===t&&n.constructor&&(t=n.constructor.name);if("Map"===t||"Set"===t)return Array.from(n);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return D(n,e)}(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var o=0,r=function(){};return{s:r,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,l=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return a=n.done,n},e:function(n){l=!0,i=n},f:function(){try{a||null==t.return||t.return()}finally{if(l)throw i}}}}function D(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}function Q(n){return new RegExp("\\b".concat(n,"[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"),"g")}var Y,B=[[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,"#version 300 es\n"],[/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,"textureLod("],[/\btexture(2D|2DProj|Cube)(EXT)?\(/g,"texture("]],z=[].concat(B,[[Q("attribute"),"in $1"],[Q("varying"),"out $1"]]),j=[].concat(B,[[Q("varying"),"in $1"]]),W=[[/^#version[ \t]+300[ \t]+es/,"#version 100"],[/\btexture(2D|2DProj|Cube)Lod\(/g,"texture$1LodEXT("],[/\btexture\(/g,"texture2D("],[/\btextureLod\(/g,"texture2DLodEXT("]],G=[].concat(W,[[Q("in"),"attribute $1"],[Q("out"),"varying $1"]]),V=[].concat(W,[[Q("in"),"varying $1"]]),H=/\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/,q=/void\s+main\s*\([^)]*\)\s*\{\n?/;function K(n,e,t){switch(e){case 300:return t?$(n,z):function(n){var e=(n=$(n,j)).match(H);if(e){var t=e[1];n=n.replace(new RegExp("\\b".concat("gl_FragColor","\\b"),"g"),t)}else{n=n.replace(q,(function(n){return"out vec4 ".concat("fragmentColor",";\n").concat(n)})).replace(new RegExp("\\b".concat("gl_FragColor","\\b"),"g"),"fragmentColor")}return n}(n);case 100:return t?$(n,G):function(n){var e=(n=$(n,V)).match(H);if(e){var t=e[1];n=n.replace(H,"").replace(new RegExp("\\b".concat(t,"\\b"),"g"),"gl_FragColor")}return n}(n);default:throw new Error("unknown GLSL version ".concat(e))}}function $(n,e){var t,o=X(e);try{for(o.s();!(t=o.n()).done;){var i=r()(t.value,2),a=i[0],l=i[1];n=n.replace(a,l)}}catch(n){o.e(n)}finally{o.f()}return n}function Z(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=function(n,e){if(!n)return;if("string"==typeof n)return J(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);"Object"===t&&n.constructor&&(t=n.constructor.name);if("Map"===t||"Set"===t)return Array.from(n);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return J(n,e)}(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var o=0,r=function(){};return{s:r,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,l=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return a=n.done,n},e:function(n){l=!0,i=n},f:function(){try{a||null==t.return||t.return()}finally{if(l)throw i}}}}function J(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}var nn="\n\n".concat("__LUMA_INJECT_DECLARATIONS__","\n\n"),en=(Y={},a()(Y,"vs","vertex"),a()(Y,"fs","fragment"),Y);function tn(n,e){var t=e.vs,o=e.fs,r=P(e.modules||[]);return{gl:n,vs:on(n,Object.assign({},e,{source:t,type:"vs",modules:r})),fs:on(n,Object.assign({},e,{source:o,type:"fs",modules:r})),getUniforms:rn(r)}}function on(n,e){var t=e.id,o=e.source,i=e.type,a=e.modules,l=e.defines,c=void 0===l?{}:l,f=e.hookFunctions,s=void 0===f?[]:f,_=e.inject,d=void 0===_?{}:_,v=e.transpileToGLSL100,p=void 0!==v&&v,m=e.prologue,h=void 0===m||m,A=e.log;u("string"==typeof o,"shader source must be a string");var g="vs"===i,x=o.split("\n"),P=100,b="",F=o;0===x[0].indexOf("#version ")?(P=300,b=x[0],F=x.slice(1).join("\n")):b="#version ".concat(P);var y={};a.forEach((function(n){Object.assign(y,n.getDefines())})),Object.assign(y,c);var L=h?"".concat(b,"\n").concat(function(n){var e=n.id,t=n.source,o=n.type;return e&&"string"==typeof e&&-1===t.indexOf("SHADER_NAME")?"\n#define SHADER_NAME ".concat(e,"_").concat(en[o],"\n\n"):""}({id:t,source:o,type:i}),"\n").concat(function(n){var e=n.type;return"\n#define SHADER_TYPE_".concat(en[e].toUpperCase(),"\n")}({type:i}),"\n").concat(function(n){switch(function(n){var e=n.getExtension("WEBGL_debug_renderer_info"),t=n.getParameter(e&&e.UNMASKED_VENDOR_WEBGL||7936),o=n.getParameter(e&&e.UNMASKED_RENDERER_WEBGL||7937);return{gpuVendor:function(n,e){if(n.match(/NVIDIA/i)||e.match(/NVIDIA/i))return"NVIDIA";if(n.match(/INTEL/i)||e.match(/INTEL/i))return"INTEL";if(n.match(/AMD/i)||e.match(/AMD/i)||n.match(/ATI/i)||e.match(/ATI/i))return"AMD";return"UNKNOWN GPU"}(t,o),vendor:t,renderer:o,version:n.getParameter(7938),shadingLanguageVersion:n.getParameter(35724)}}(n).gpuVendor.toLowerCase()){case"nvidia":return"#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";case"intel":return"#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";case"amd":return"#define AMD_GPU\n";default:return"#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n"}}(n),"\n").concat(function(n,e,t){var o="#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";return S(n,E.GLSL_FRAG_DEPTH)&&(o+="\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n"),S(n,E.GLSL_DERIVATIVES)&&I(n,E.GLSL_DERIVATIVES)&&(o+="\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n"),S(n,E.GLSL_FRAG_DATA)&&I(n,E.GLSL_FRAG_DATA,{behavior:"require"})&&(o+="\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n"),S(n,E.GLSL_TEXTURE_LOD)&&(o+="// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n"),o}(n),"\n").concat(function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=0,t="";for(var o in n){0===e&&(t+="\n// APPLICATION DEFINES\n"),e++;var r=n[o];(r||Number.isFinite(r))&&(t+="#define ".concat(o.toUpperCase()," ").concat(n[o],"\n"))}0===e&&(t+="\n");return t}(y),"\n").concat(g?"":"precision highp float;\n\n","\n"):"".concat(b,"\n"),N=function(n){var e={vs:{},fs:{}};return n.forEach((function(n){var t;"string"!=typeof n?n=(t=n).hook:t={};var o=(n=n.trim()).split(":"),i=r()(o,2),a=i[0],l=i[1],c=n.replace(/\(.+/,"");e[a][c]=Object.assign(t,{signature:l})})),e}(s),T={},C={},R={};for(var O in d){var U="string"==typeof d[O]?{injection:d[O],order:0}:d[O],k=O.match(/^(v|f)s:(#)?([\w-]+)$/);if(k){var w=k[2],X=k[3];w?"decl"===X?C[O]=[U]:R[O]=[U]:T[O]=[U]}else R[O]=[U]}var D,Q=Z(a);try{for(Q.s();!(D=Q.n()).done;){var Y=D.value;A&&Y.checkDeprecations(F,A),L+=Y.getModuleSource(i,P);var B=Y.injections[i];for(var z in B){var j=z.match(/^(v|f)s:#([\w-]+)$/);if(j){var W="decl"===j[2]?C:R;W[z]=W[z]||[],W[z].push(B[z])}else T[z]=T[z]||[],T[z].push(B[z])}}}catch(n){Q.e(n)}finally{Q.f()}return L=M(L+=nn,i,C),L+=function(n,e){var t="";for(var o in n){var r=n[o];if(t+="void ".concat(r.signature," {\n"),r.header&&(t+="  ".concat(r.header)),e[o]){var i=e[o];i.sort((function(n,e){return n.order-e.order}));var a,l=Z(i);try{for(l.s();!(a=l.n()).done;){var c=a.value;t+="  ".concat(c.injection,"\n")}}catch(n){l.e(n)}finally{l.f()}}r.footer&&(t+="  ".concat(r.footer)),t+="}\n"}return t}(N[i],T),L=K(L=M(L+=F,i,R),p?100:P,g)}function rn(n){return function(e){var t,o={},r=Z(n);try{for(r.s();!(t=r.n()).done;){var i=t.value.getUniforms(e,o);Object.assign(o,i)}}catch(n){r.e(n)}finally{r.f()}return o}}var an="void main() {gl_FragColor = vec4(0);}",ln="out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}",cn="#version 300 es\n".concat(ln);function fn(n,e){e=Array.isArray(e)?e:[e];var t=n.replace(/^\s+/,"").split(/\s+/),o=r()(t,3),i=o[0],a=o[1],l=o[2];return e.includes(i)&&a&&l?{qualifier:i,type:a,name:l.split(";")[0]}:null}function sn(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.version,t=void 0===e?100:e,o=n.input,r=n.inputType,i=n.output;if(!o)return 300===t?cn:t>300?"#version ".concat(t,"\n").concat(ln):an;var a=dn(o,r);return t>=300?"#version ".concat(t," ").concat(300===t?"es":"","\nin ").concat(r," ").concat(o,";\nout vec4 ").concat(i,";\nvoid main() {\n  ").concat(i," = ").concat(a,";\n}"):"varying ".concat(r," ").concat(o,";\nvoid main() {\n  gl_FragColor = ").concat(a,";\n}")}function un(n){switch(n){case"float":return"x";case"vec2":return"xy";case"vec3":return"xyz";case"vec4":return"xyzw";default:return u(!1),null}}function _n(n){switch(n){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;default:return u(!1),null}}function dn(n,e){switch(e){case"float":return"vec4(".concat(n,", 0.0, 0.0, 1.0)");case"vec2":return"vec4(".concat(n,", 0.0, 1.0)");case"vec3":return"vec4(".concat(n,", 1.0)");case"vec4":return n;default:return u(!1),null}}var vn={name:"random",fs:"float random(vec3 scale, float seed) {\n  /* use the fragment position for a different seed per-pixel */\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n"},pn={name:"fp32",vs:"#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n",fs:null};function mn(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=Math.fround(n),r=n-o;return e[t]=o,e[t+1]=r,e}function hn(n){return n-Math.fround(n)}function An(n){for(var e=new Float32Array(32),t=0;t<4;++t)for(var o=0;o<4;++o){var r=4*t+o;mn(n[4*o+t],e,2*r)}return e}var gn={ONE:1};var xn={name:"fp64-arithmetic",vs:"uniform float ONE;\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n",fs:null,getUniforms:function(){return gn},fp64ify:mn,fp64LowPart:hn,fp64ifyMatrix4:An},Pn={name:"fp64",vs:"const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\nvec2 exp_fp64(vec2 a) {\n\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n\n\n\n\n\n  s = sum_fp64(s, t);\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n",fs:null,dependencies:[xn],fp64ify:mn,fp64LowPart:hn,fp64ifyMatrix4:An},bn=t(5),Fn=t.n(bn),yn=t(6),Ln=t.n(yn),En=t(0),Nn=t.n(En);t(12),t(13);function In(n,e){if(!n)throw new Error("math.gl assertion ".concat(e))}Math.PI,Math.PI;var Tn={};function Sn(n){return Math.round(n/Tn.EPSILON)*Tn.EPSILON}function Cn(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=e.precision,o=void 0===t?Tn.precision||4:t;return n=Sn(n),"".concat(parseFloat(n.toPrecision(o)))}function Rn(n){return Array.isArray(n)||ArrayBuffer.isView(n)&&!(n instanceof DataView)}function On(n,e,t){var o=Tn.EPSILON;t&&(Tn.EPSILON=t);try{if(n===e)return!0;if(Rn(n)&&Rn(e)){if(n.length!==e.length)return!1;for(var r=0;r<n.length;++r)if(!On(n[r],e[r]))return!1;return!0}return n&&n.equals?n.equals(e):e&&e.equals?e.equals(n):!(!Number.isFinite(n)||!Number.isFinite(e))&&Math.abs(n-e)<=Tn.EPSILON*Math.max(1,Math.abs(n),Math.abs(e))}finally{Tn.EPSILON=o}}function Un(n,e){if(n.length!==e)return!1;for(var t=0;t<n.length;++t)if(!Number.isFinite(n[t]))return!1;return!0}function kn(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if(Tn.debug&&!Un(n,e))throw new Error("math.gl: ".concat(t," some fields set to invalid numbers'"));return n}Tn.EPSILON=1e-12,Tn.debug=!1,Tn.precision=4,Tn.printTypes=!1,Tn.printDegrees=!1,Tn.printRowMajor=!0;var Mn={};function wn(n,e){Mn[n]||(Mn[n]=!0,console.warn("".concat(n," has been removed in version ").concat(e,", see upgrade guide for more information")))}function Xn(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,o=Nn()(n);if(e){var r=Nn()(this).constructor;t=Reflect.construct(o,arguments,r)}else t=o.apply(this,arguments);return Ln()(this,t)}}function Dn(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,o=Nn()(n);if(e){var r=Nn()(this).constructor;t=Reflect.construct(o,arguments,r)}else t=o.apply(this,arguments);return Ln()(this,t)}}var Qn=function(n){Fn()(t,n);var e=Dn(t);function t(){return c()(this,t),e.apply(this,arguments)}return s()(t,[{key:"ELEMENTS",get:function(){return In(!1),0}},{key:"RANK",get:function(){return In(!1),0}},{key:"toString",value:function(){var n="[";if(Tn.printRowMajor){n+="row-major:";for(var e=0;e<this.RANK;++e)for(var t=0;t<this.RANK;++t)n+=" ".concat(this[t*this.RANK+e])}else{n+="column-major:";for(var o=0;o<this.ELEMENTS;++o)n+=" ".concat(this[o])}return n+="]"}},{key:"getElementIndex",value:function(n,e){return e*this.RANK+n}},{key:"getElement",value:function(n,e){return this[e*this.RANK+n]}},{key:"setElement",value:function(n,e,t){return this[e*this.RANK+n]=function(n){if(!Number.isFinite(n))throw new Error("Invalid number ".concat(n));return n}(t),this}},{key:"getColumn",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Array(this.RANK).fill(-0),t=n*this.RANK,o=0;o<this.RANK;++o)e[o]=this[t+o];return e}},{key:"setColumn",value:function(n,e){for(var t=n*this.RANK,o=0;o<this.RANK;++o)this[t+o]=e[o];return this}}]),t}(function(n){Fn()(t,n);var e=Xn(t);function t(){return c()(this,t),e.apply(this,arguments)}return s()(t,[{key:"ELEMENTS",get:function(){return In(!1),0}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"from",value:function(n){return Array.isArray(n)?this.copy(n):this.fromObject(n)}},{key:"fromArray",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=0;t<this.ELEMENTS;++t)this[t]=n[t+e];return this.check()}},{key:"to",value:function(n){return n===this?this:Rn(n)?this.toArray(n):this.toObject(n)}},{key:"toTarget",value:function(n){return n?this.to(n):this}},{key:"toArray",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=0;t<this.ELEMENTS;++t)n[e+t]=this[t];return n}},{key:"toFloat32Array",value:function(){return new Float32Array(this)}},{key:"toString",value:function(){return this.formatString(Tn)}},{key:"formatString",value:function(n){for(var e="",t=0;t<this.ELEMENTS;++t)e+=(t>0?", ":"")+Cn(this[t],n);return"".concat(n.printTypes?this.constructor.name:"","[").concat(e,"]")}},{key:"equals",value:function(n){if(!n||this.length!==n.length)return!1;for(var e=0;e<this.ELEMENTS;++e)if(!On(this[e],n[e]))return!1;return!0}},{key:"exactEquals",value:function(n){if(!n||this.length!==n.length)return!1;for(var e=0;e<this.ELEMENTS;++e)if(this[e]!==n[e])return!1;return!0}},{key:"negate",value:function(){for(var n=0;n<this.ELEMENTS;++n)this[n]=-this[n];return this.check()}},{key:"lerp",value:function(n,e,t){void 0===t&&(t=e,e=n,n=this);for(var o=0;o<this.ELEMENTS;++o){var r=n[o];this[o]=r+t*(e[o]-r)}return this.check()}},{key:"min",value:function(n){for(var e=0;e<this.ELEMENTS;++e)this[e]=Math.min(n[e],this[e]);return this.check()}},{key:"max",value:function(n){for(var e=0;e<this.ELEMENTS;++e)this[e]=Math.max(n[e],this[e]);return this.check()}},{key:"clamp",value:function(n,e){for(var t=0;t<this.ELEMENTS;++t)this[t]=Math.min(Math.max(this[t],n[t]),e[t]);return this.check()}},{key:"add",value:function(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];for(var o=0,r=e;o<r.length;o++)for(var i=r[o],a=0;a<this.ELEMENTS;++a)this[a]+=i[a];return this.check()}},{key:"subtract",value:function(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];for(var o=0,r=e;o<r.length;o++)for(var i=r[o],a=0;a<this.ELEMENTS;++a)this[a]-=i[a];return this.check()}},{key:"scale",value:function(n){if(Array.isArray(n))return this.multiply(n);for(var e=0;e<this.ELEMENTS;++e)this[e]*=n;return this.check()}},{key:"sub",value:function(n){return this.subtract(n)}},{key:"setScalar",value:function(n){for(var e=0;e<this.ELEMENTS;++e)this[e]=n;return this.check()}},{key:"addScalar",value:function(n){for(var e=0;e<this.ELEMENTS;++e)this[e]+=n;return this.check()}},{key:"subScalar",value:function(n){return this.addScalar(-n)}},{key:"multiplyScalar",value:function(n){for(var e=0;e<this.ELEMENTS;++e)this[e]*=n;return this.check()}},{key:"divideScalar",value:function(n){return this.scale(1/n)}},{key:"clampScalar",value:function(n,e){for(var t=0;t<this.ELEMENTS;++t)this[t]=Math.min(Math.max(this[t],n),e);return this.check()}},{key:"multiplyByScalar",value:function(n){return this.scale(n)}},{key:"elements",get:function(){return this}},{key:"check",value:function(){if(Tn.debug&&!this.validate())throw new Error("math.gl: ".concat(this.constructor.name," some fields set to invalid numbers'"));return this}},{key:"validate",value:function(){for(var n=this.length===this.ELEMENTS,e=0;e<this.ELEMENTS;++e)n=n&&Number.isFinite(this[e]);return n}}]),t}(function(n){function e(){var e=Reflect.construct(n,Array.from(arguments));return Object.setPrototypeOf(e,Object.getPrototypeOf(this)),e}return e.prototype=Object.create(n.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n,e}(Array)));var Yn=1e-6,Bn="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;Math.PI;function zn(n,e,t){var o=e[0],r=e[1],i=e[2],a=e[3],l=e[4],c=e[5],f=e[6],s=e[7],u=e[8],_=e[9],d=e[10],v=e[11],p=e[12],m=e[13],h=e[14],A=e[15],g=t[0],x=t[1],P=t[2],b=t[3];return n[0]=g*o+x*l+P*u+b*p,n[1]=g*r+x*c+P*_+b*m,n[2]=g*i+x*f+P*d+b*h,n[3]=g*a+x*s+P*v+b*A,g=t[4],x=t[5],P=t[6],b=t[7],n[4]=g*o+x*l+P*u+b*p,n[5]=g*r+x*c+P*_+b*m,n[6]=g*i+x*f+P*d+b*h,n[7]=g*a+x*s+P*v+b*A,g=t[8],x=t[9],P=t[10],b=t[11],n[8]=g*o+x*l+P*u+b*p,n[9]=g*r+x*c+P*_+b*m,n[10]=g*i+x*f+P*d+b*h,n[11]=g*a+x*s+P*v+b*A,g=t[12],x=t[13],P=t[14],b=t[15],n[12]=g*o+x*l+P*u+b*p,n[13]=g*r+x*c+P*_+b*m,n[14]=g*i+x*f+P*d+b*h,n[15]=g*a+x*s+P*v+b*A,n}function jn(n,e,t){var o=t[0],r=t[1],i=t[2];return n[0]=e[0]*o,n[1]=e[1]*o,n[2]=e[2]*o,n[3]=e[3]*o,n[4]=e[4]*r,n[5]=e[5]*r,n[6]=e[6]*r,n[7]=e[7]*r,n[8]=e[8]*i,n[9]=e[9]*i,n[10]=e[10]*i,n[11]=e[11]*i,n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15],n}function Wn(n,e,t,o,r){var i,a=1/Math.tan(e/2);return n[0]=a/t,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=a,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=-1,n[12]=0,n[13]=0,n[15]=0,null!=r&&r!==1/0?(i=1/(o-r),n[10]=(r+o)*i,n[14]=2*r*o*i):(n[10]=-1,n[14]=-2*o),n}function Gn(n,e,t,o){var r,i,a,l,c,f,s,u,_,d,v=e[0],p=e[1],m=e[2],h=o[0],A=o[1],g=o[2],x=t[0],P=t[1],b=t[2];return Math.abs(v-x)<Yn&&Math.abs(p-P)<Yn&&Math.abs(m-b)<Yn?function(n){return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}(n):(s=v-x,u=p-P,_=m-b,r=A*(_*=d=1/Math.hypot(s,u,_))-g*(u*=d),i=g*(s*=d)-h*_,a=h*u-A*s,(d=Math.hypot(r,i,a))?(r*=d=1/d,i*=d,a*=d):(r=0,i=0,a=0),l=u*a-_*i,c=_*r-s*a,f=s*i-u*r,(d=Math.hypot(l,c,f))?(l*=d=1/d,c*=d,f*=d):(l=0,c=0,f=0),n[0]=r,n[1]=l,n[2]=s,n[3]=0,n[4]=i,n[5]=c,n[6]=u,n[7]=0,n[8]=a,n[9]=f,n[10]=_,n[11]=0,n[12]=-(r*v+i*p+a*m),n[13]=-(l*v+c*p+f*m),n[14]=-(s*v+u*p+_*m),n[15]=1,n)}Math.hypot||(Math.hypot=function(){for(var n=0,e=arguments.length;e--;)n+=arguments[e]*arguments[e];return Math.sqrt(n)});var Vn,Hn;Vn=new Bn(2),Bn!=Float32Array&&(Vn[0]=0,Vn[1]=0),Hn=Vn;!function(){var n=function(){var n=new Bn(3);return Bn!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0),n}()}();!function(){var n=function(){var n=new Bn(4);return Bn!=Float32Array&&(n[0]=0,n[1]=0,n[2]=0,n[3]=0),n}()}();function qn(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,o=Nn()(n);if(e){var r=Nn()(this).constructor;t=Reflect.construct(o,arguments,r)}else t=o.apply(this,arguments);return Ln()(this,t)}}var Kn=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),$n=Object.freeze([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Zn=Object.freeze({COL0ROW0:0,COL0ROW1:1,COL0ROW2:2,COL0ROW3:3,COL1ROW0:4,COL1ROW1:5,COL1ROW2:6,COL1ROW3:7,COL2ROW0:8,COL2ROW1:9,COL2ROW2:10,COL2ROW3:11,COL3ROW0:12,COL3ROW1:13,COL3ROW2:14,COL3ROW3:15}),Jn={},ne=function(n){Fn()(t,n);var e=qn(t);function t(n){var o;return c()(this,t),o=e.call(this,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),1===arguments.length&&Array.isArray(n)?o.copy(n):o.identity(),o}return s()(t,[{key:"INDICES",get:function(){return Zn}},{key:"ELEMENTS",get:function(){return 16}},{key:"RANK",get:function(){return 4}},{key:"copy",value:function(n){return this[0]=n[0],this[1]=n[1],this[2]=n[2],this[3]=n[3],this[4]=n[4],this[5]=n[5],this[6]=n[6],this[7]=n[7],this[8]=n[8],this[9]=n[9],this[10]=n[10],this[11]=n[11],this[12]=n[12],this[13]=n[13],this[14]=n[14],this[15]=n[15],this.check()}},{key:"set",value:function(n,e,t,o,r,i,a,l,c,f,s,u,_,d,v,p){return this[0]=n,this[1]=e,this[2]=t,this[3]=o,this[4]=r,this[5]=i,this[6]=a,this[7]=l,this[8]=c,this[9]=f,this[10]=s,this[11]=u,this[12]=_,this[13]=d,this[14]=v,this[15]=p,this.check()}},{key:"setRowMajor",value:function(n,e,t,o,r,i,a,l,c,f,s,u,_,d,v,p){return this[0]=n,this[1]=r,this[2]=c,this[3]=_,this[4]=e,this[5]=i,this[6]=f,this[7]=d,this[8]=t,this[9]=a,this[10]=s,this[11]=v,this[12]=o,this[13]=l,this[14]=u,this[15]=p,this.check()}},{key:"toRowMajor",value:function(n){return n[0]=this[0],n[1]=this[4],n[2]=this[8],n[3]=this[12],n[4]=this[1],n[5]=this[5],n[6]=this[9],n[7]=this[13],n[8]=this[2],n[9]=this[6],n[10]=this[10],n[11]=this[14],n[12]=this[3],n[13]=this[7],n[14]=this[11],n[15]=this[15],n}},{key:"identity",value:function(){return this.copy(Kn)}},{key:"fromQuaternion",value:function(n){return function(n,e){var t=e[0],o=e[1],r=e[2],i=e[3],a=t+t,l=o+o,c=r+r,f=t*a,s=o*a,u=o*l,_=r*a,d=r*l,v=r*c,p=i*a,m=i*l,h=i*c;n[0]=1-u-v,n[1]=s+h,n[2]=_-m,n[3]=0,n[4]=s-h,n[5]=1-f-v,n[6]=d+p,n[7]=0,n[8]=_+m,n[9]=d-p,n[10]=1-f-u,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1}(this,n),this.check()}},{key:"frustum",value:function(n){var e=n.left,o=n.right,r=n.bottom,i=n.top,a=n.near,l=n.far;return l===1/0?t._computeInfinitePerspectiveOffCenter(this,e,o,r,i,a):function(n,e,t,o,r,i,a){var l=1/(t-e),c=1/(r-o),f=1/(i-a);n[0]=2*i*l,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=2*i*c,n[6]=0,n[7]=0,n[8]=(t+e)*l,n[9]=(r+o)*c,n[10]=(a+i)*f,n[11]=-1,n[12]=0,n[13]=0,n[14]=a*i*2*f,n[15]=0}(this,e,o,r,i,a,l),this.check()}},{key:"lookAt",value:function(n,e,t){if(1===arguments.length){var o=n;n=o.eye,e=o.center,t=o.up}return Gn(this,n,e=e||[0,0,0],t=t||[0,1,0]),this.check()}},{key:"ortho",value:function(n){var e=n.left,t=n.right,o=n.bottom,r=n.top,i=n.near,a=void 0===i?.1:i,l=n.far;return function(n,e,t,o,r,i,a){var l=1/(e-t),c=1/(o-r),f=1/(i-a);n[0]=-2*l,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=-2*c,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=2*f,n[11]=0,n[12]=(e+t)*l,n[13]=(r+o)*c,n[14]=(a+i)*f,n[15]=1}(this,e,t,o,r,a,void 0===l?500:l),this.check()}},{key:"orthographic",value:function(n){var e=n.fovy,o=void 0===e?45*Math.PI/180:e,r=n.aspect,i=void 0===r?1:r,a=n.focalDistance,l=void 0===a?1:a,c=n.near,f=void 0===c?.1:c,s=n.far,u=void 0===s?500:s;if(o>2*Math.PI)throw Error("radians");var _=o/2,d=l*Math.tan(_),v=d*i;return(new t).ortho({left:-v,right:v,bottom:-d,top:d,near:f,far:u})}},{key:"perspective",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.fovy,t=void 0===e?void 0:e,o=n.fov,r=void 0===o?45*Math.PI/180:o,i=n.aspect,a=void 0===i?1:i,l=n.near,c=void 0===l?.1:l,f=n.far,s=void 0===f?500:f;if((t=t||r)>2*Math.PI)throw Error("radians");return Wn(this,t,a,c,s),this.check()}},{key:"determinant",value:function(){return e=(n=this)[0],t=n[1],o=n[2],r=n[3],i=n[4],a=n[5],l=n[6],c=n[7],f=n[8],s=n[9],u=n[10],_=n[11],d=n[12],v=n[13],p=n[14],m=n[15],(e*a-t*i)*(u*m-_*p)-(e*l-o*i)*(s*m-_*v)+(e*c-r*i)*(s*p-u*v)+(t*l-o*a)*(f*m-_*d)-(t*c-r*a)*(f*p-u*d)+(o*c-r*l)*(f*v-s*d);var n,e,t,o,r,i,a,l,c,f,s,u,_,d,v,p,m}},{key:"getScale",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[-0,-0,-0];return n[0]=Math.sqrt(this[0]*this[0]+this[1]*this[1]+this[2]*this[2]),n[1]=Math.sqrt(this[4]*this[4]+this[5]*this[5]+this[6]*this[6]),n[2]=Math.sqrt(this[8]*this[8]+this[9]*this[9]+this[10]*this[10]),n}},{key:"getTranslation",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[-0,-0,-0];return n[0]=this[12],n[1]=this[13],n[2]=this[14],n}},{key:"getRotation",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=this.getScale(e||[-0,-0,-0]),o=1/t[0],r=1/t[1],i=1/t[2];return n[0]=this[0]*o,n[1]=this[1]*r,n[2]=this[2]*i,n[3]=0,n[4]=this[4]*o,n[5]=this[5]*r,n[6]=this[6]*i,n[7]=0,n[8]=this[8]*o,n[9]=this[9]*r,n[10]=this[10]*i,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}},{key:"getRotationMatrix3",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[-0,-0,-0,-0,-0,-0,-0,-0,-0],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=this.getScale(e||[-0,-0,-0]),o=1/t[0],r=1/t[1],i=1/t[2];return n[0]=this[0]*o,n[1]=this[1]*r,n[2]=this[2]*i,n[3]=this[4]*o,n[4]=this[5]*r,n[5]=this[6]*i,n[6]=this[8]*o,n[7]=this[9]*r,n[8]=this[10]*i,n}},{key:"transpose",value:function(){return function(n,e){if(n===e){var t=e[1],o=e[2],r=e[3],i=e[6],a=e[7],l=e[11];n[1]=e[4],n[2]=e[8],n[3]=e[12],n[4]=t,n[6]=e[9],n[7]=e[13],n[8]=o,n[9]=i,n[11]=e[14],n[12]=r,n[13]=a,n[14]=l}else n[0]=e[0],n[1]=e[4],n[2]=e[8],n[3]=e[12],n[4]=e[1],n[5]=e[5],n[6]=e[9],n[7]=e[13],n[8]=e[2],n[9]=e[6],n[10]=e[10],n[11]=e[14],n[12]=e[3],n[13]=e[7],n[14]=e[11],n[15]=e[15]}(this,this),this.check()}},{key:"invert",value:function(){return function(n,e){var t=e[0],o=e[1],r=e[2],i=e[3],a=e[4],l=e[5],c=e[6],f=e[7],s=e[8],u=e[9],_=e[10],d=e[11],v=e[12],p=e[13],m=e[14],h=e[15],A=t*l-o*a,g=t*c-r*a,x=t*f-i*a,P=o*c-r*l,b=o*f-i*l,F=r*f-i*c,y=s*p-u*v,L=s*m-_*v,E=s*h-d*v,N=u*m-_*p,I=u*h-d*p,T=_*h-d*m,S=A*T-g*I+x*N+P*E-b*L+F*y;S&&(S=1/S,n[0]=(l*T-c*I+f*N)*S,n[1]=(r*I-o*T-i*N)*S,n[2]=(p*F-m*b+h*P)*S,n[3]=(_*b-u*F-d*P)*S,n[4]=(c*E-a*T-f*L)*S,n[5]=(t*T-r*E+i*L)*S,n[6]=(m*x-v*F-h*g)*S,n[7]=(s*F-_*x+d*g)*S,n[8]=(a*I-l*E+f*y)*S,n[9]=(o*E-t*I-i*y)*S,n[10]=(v*b-p*x+h*A)*S,n[11]=(u*x-s*b-d*A)*S,n[12]=(l*L-a*N-c*y)*S,n[13]=(t*N-o*L+r*y)*S,n[14]=(p*g-v*P-m*A)*S,n[15]=(s*P-u*g+_*A)*S)}(this,this),this.check()}},{key:"multiplyLeft",value:function(n){return zn(this,n,this),this.check()}},{key:"multiplyRight",value:function(n){return zn(this,this,n),this.check()}},{key:"rotateX",value:function(n){return function(n,e,t){var o=Math.sin(t),r=Math.cos(t),i=e[4],a=e[5],l=e[6],c=e[7],f=e[8],s=e[9],u=e[10],_=e[11];e!==n&&(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n[4]=i*r+f*o,n[5]=a*r+s*o,n[6]=l*r+u*o,n[7]=c*r+_*o,n[8]=f*r-i*o,n[9]=s*r-a*o,n[10]=u*r-l*o,n[11]=_*r-c*o}(this,this,n),this.check()}},{key:"rotateY",value:function(n){return function(n,e,t){var o=Math.sin(t),r=Math.cos(t),i=e[0],a=e[1],l=e[2],c=e[3],f=e[8],s=e[9],u=e[10],_=e[11];e!==n&&(n[4]=e[4],n[5]=e[5],n[6]=e[6],n[7]=e[7],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n[0]=i*r-f*o,n[1]=a*r-s*o,n[2]=l*r-u*o,n[3]=c*r-_*o,n[8]=i*o+f*r,n[9]=a*o+s*r,n[10]=l*o+u*r,n[11]=c*o+_*r}(this,this,n),this.check()}},{key:"rotateZ",value:function(n){return function(n,e,t){var o=Math.sin(t),r=Math.cos(t),i=e[0],a=e[1],l=e[2],c=e[3],f=e[4],s=e[5],u=e[6],_=e[7];e!==n&&(n[8]=e[8],n[9]=e[9],n[10]=e[10],n[11]=e[11],n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]),n[0]=i*r+f*o,n[1]=a*r+s*o,n[2]=l*r+u*o,n[3]=c*r+_*o,n[4]=f*r-i*o,n[5]=s*r-a*o,n[6]=u*r-l*o,n[7]=_*r-c*o}(this,this,n),this.check()}},{key:"rotateXYZ",value:function(n){var e=r()(n,3),t=e[0],o=e[1],i=e[2];return this.rotateX(t).rotateY(o).rotateZ(i)}},{key:"rotateAxis",value:function(n,e){return function(n,e,t,o){var r,i,a,l,c,f,s,u,_,d,v,p,m,h,A,g,x,P,b,F,y,L,E,N,I=o[0],T=o[1],S=o[2],C=Math.hypot(I,T,S);C<Yn||(I*=C=1/C,T*=C,S*=C,r=Math.sin(t),a=1-(i=Math.cos(t)),l=e[0],c=e[1],f=e[2],s=e[3],u=e[4],_=e[5],d=e[6],v=e[7],p=e[8],m=e[9],h=e[10],A=e[11],g=I*I*a+i,x=T*I*a+S*r,P=S*I*a-T*r,b=I*T*a-S*r,F=T*T*a+i,y=S*T*a+I*r,L=I*S*a+T*r,E=T*S*a-I*r,N=S*S*a+i,n[0]=l*g+u*x+p*P,n[1]=c*g+_*x+m*P,n[2]=f*g+d*x+h*P,n[3]=s*g+v*x+A*P,n[4]=l*b+u*F+p*y,n[5]=c*b+_*F+m*y,n[6]=f*b+d*F+h*y,n[7]=s*b+v*F+A*y,n[8]=l*L+u*E+p*N,n[9]=c*L+_*E+m*N,n[10]=f*L+d*E+h*N,n[11]=s*L+v*E+A*N,e!==n&&(n[12]=e[12],n[13]=e[13],n[14]=e[14],n[15]=e[15]))}(this,this,n,e),this.check()}},{key:"scale",value:function(n){return Array.isArray(n)?jn(this,this,n):jn(this,this,[n,n,n]),this.check()}},{key:"translate",value:function(n){return function(n,e,t){var o,r,i,a,l,c,f,s,u,_,d,v,p=t[0],m=t[1],h=t[2];e===n?(n[12]=e[0]*p+e[4]*m+e[8]*h+e[12],n[13]=e[1]*p+e[5]*m+e[9]*h+e[13],n[14]=e[2]*p+e[6]*m+e[10]*h+e[14],n[15]=e[3]*p+e[7]*m+e[11]*h+e[15]):(o=e[0],r=e[1],i=e[2],a=e[3],l=e[4],c=e[5],f=e[6],s=e[7],u=e[8],_=e[9],d=e[10],v=e[11],n[0]=o,n[1]=r,n[2]=i,n[3]=a,n[4]=l,n[5]=c,n[6]=f,n[7]=s,n[8]=u,n[9]=_,n[10]=d,n[11]=v,n[12]=o*p+l*m+u*h+e[12],n[13]=r*p+c*m+_*h+e[13],n[14]=i*p+f*m+d*h+e[14],n[15]=a*p+s*m+v*h+e[15])}(this,this,n),this.check()}},{key:"transform",value:function(n,e){return 4===n.length?(kn(e=function(n,e,t){var o=e[0],r=e[1],i=e[2],a=e[3];return n[0]=t[0]*o+t[4]*r+t[8]*i+t[12]*a,n[1]=t[1]*o+t[5]*r+t[9]*i+t[13]*a,n[2]=t[2]*o+t[6]*r+t[10]*i+t[14]*a,n[3]=t[3]*o+t[7]*r+t[11]*i+t[15]*a,n}(e||[-0,-0,-0,-0],n,this),4),e):this.transformAsPoint(n,e)}},{key:"transformAsPoint",value:function(n,e){switch(n.length){case 2:e=function(n,e,t){var o=e[0],r=e[1];return n[0]=t[0]*o+t[4]*r+t[12],n[1]=t[1]*o+t[5]*r+t[13],n}(e||[-0,-0],n,this);break;case 3:e=function(n,e,t){var o=e[0],r=e[1],i=e[2],a=t[3]*o+t[7]*r+t[11]*i+t[15];return a=a||1,n[0]=(t[0]*o+t[4]*r+t[8]*i+t[12])/a,n[1]=(t[1]*o+t[5]*r+t[9]*i+t[13])/a,n[2]=(t[2]*o+t[6]*r+t[10]*i+t[14])/a,n}(e||[-0,-0,-0],n,this);break;default:throw new Error("Illegal vector")}return kn(e,n.length),e}},{key:"transformAsVector",value:function(n,e){switch(n.length){case 2:e=function(n,e,t){var o=e[0],r=e[1],i=t[3]*o+t[7]*r||1;return n[0]=(t[0]*o+t[4]*r)/i,n[1]=(t[1]*o+t[5]*r)/i,n}(e||[-0,-0],n,this);break;case 3:e=function(n,e,t){var o=e[0],r=e[1],i=e[2],a=t[3]*o+t[7]*r+t[11]*i||1;return n[0]=(t[0]*o+t[4]*r+t[8]*i)/a,n[1]=(t[1]*o+t[5]*r+t[9]*i)/a,n[2]=(t[2]*o+t[6]*r+t[10]*i)/a,n}(e||[-0,-0,-0],n,this);break;default:throw new Error("Illegal vector")}return kn(e,n.length),e}},{key:"makeRotationX",value:function(n){return this.identity().rotateX(n)}},{key:"makeTranslation",value:function(n,e,t){return this.identity().translate([n,e,t])}},{key:"transformPoint",value:function(n,e){return wn("Matrix4.transformPoint","3.0"),this.transformAsPoint(n,e)}},{key:"transformVector",value:function(n,e){return wn("Matrix4.transformVector","3.0"),this.transformAsPoint(n,e)}},{key:"transformDirection",value:function(n,e){return wn("Matrix4.transformDirection","3.0"),this.transformAsVector(n,e)}}],[{key:"IDENTITY",get:function(){return Jn.IDENTITY=Jn.IDENTITY||Object.freeze(new t(Kn)),Jn.IDENTITY}},{key:"ZERO",get:function(){return Jn.ZERO=Jn.ZERO||Object.freeze(new t($n)),Jn.ZERO}},{key:"_computeInfinitePerspectiveOffCenter",value:function(n,e,t,o,r,i){var a=2*i/(t-e),l=2*i/(r-o),c=(t+e)/(t-e),f=(r+o)/(r-o),s=-2*i;return n[0]=a,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=l,n[6]=0,n[7]=0,n[8]=c,n[9]=f,n[10]=-1,n[11]=-1,n[12]=0,n[13]=0,n[14]=s,n[15]=0,n}}]),t}(Qn),ee=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],te={modelMatrix:ee,viewMatrix:ee,projectionMatrix:ee,cameraPositionWorld:[0,0,0]};var oe="varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n",re={name:"project",getUniforms:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:te,e={};return void 0!==n.modelMatrix&&(e.modelMatrix=n.modelMatrix),void 0!==n.viewMatrix&&(e.viewMatrix=n.viewMatrix),void 0!==n.projectionMatrix&&(e.projectionMatrix=n.projectionMatrix),void 0!==n.cameraPositionWorld&&(e.cameraPositionWorld=n.cameraPositionWorld),void 0===n.projectionMatrix&&void 0===n.viewMatrix||(e.viewProjectionMatrix=new ne(n.projectionMatrix).multiplyRight(n.viewMatrix)),e},vs:"".concat(oe,"\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n"),fs:"\n".concat(oe)},ie="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";function ae(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=function(n,e){if(!n)return;if("string"==typeof n)return le(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);"Object"===t&&n.constructor&&(t=n.constructor.name);if("Map"===t||"Set"===t)return Array.from(n);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return le(n,e)}(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var o=0,r=function(){};return{s:r,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,l=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return a=n.done,n},e:function(n){l=!0,i=n},f:function(){try{a||null==t.return||t.return()}finally{if(l)throw i}}}}function le(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}var ce={lightSources:{}};function fe(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.color,t=void 0===e?[0,0,0]:e,o=n.intensity,r=void 0===o?1:o;return t.map((function(n){return n*r/255}))}function se(n){var e=n.ambientLight,t=n.pointLights,o=void 0===t?[]:t,r=n.directionalLights,i=void 0===r?[]:r,a={};return a["lighting_uAmbientLight.color"]=e?fe(e):[0,0,0],o.forEach((function(n,e){a["lighting_uPointLight[".concat(e,"].color")]=fe(n),a["lighting_uPointLight[".concat(e,"].position")]=n.position,a["lighting_uPointLight[".concat(e,"].attenuation")]=n.attenuation||[1,0,0]})),a.lighting_uPointLightCount=o.length,i.forEach((function(n,e){a["lighting_uDirectionalLight[".concat(e,"].color")]=fe(n),a["lighting_uDirectionalLight[".concat(e,"].direction")]=n.direction})),a.lighting_uDirectionalLightCount=i.length,a}var ue={name:"lights",vs:ie,fs:ie,getUniforms:function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:ce;if("lightSources"in e){var t=e.lightSources||{},o=t.ambientLight,r=t.pointLights,i=t.directionalLights,a=o||r&&r.length>0||i&&i.length>0;return a?Object.assign({},se({ambientLight:o,pointLights:r,directionalLights:i}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in e){var l,c={pointLights:[],directionalLights:[]},f=ae(e.lights||[]);try{for(f.s();!(l=f.n()).done;){var s=l.value;switch(s.type){case"ambient":c.ambientLight=s;break;case"directional":c.directionalLights.push(s);break;case"point":c.pointLights.push(s)}}}catch(n){f.e(n)}finally{f.f()}return n({lightSources:c})}return{}},defines:{MAX_LIGHTS:3}},_e={lightDirection:new Float32Array([1,1,2])};var de={name:"dirlight",vs:null,fs:"uniform vec3 dirlight_uLightDirection;\n\n/*\n * Returns color attenuated by angle from light source\n */\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n",getUniforms:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:_e,e={};return n.lightDirection&&(e.dirlight_uLightDirection=n.lightDirection),e},dependencies:[re]},ve={pickingSelectedColor:null,pickingHighlightColor:new Uint8Array([0,255,255,255]),pickingActive:!1,pickingAttribute:!1};var pe={name:"picking",vs:"uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",getUniforms:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:ve,e={};if(void 0!==n.pickingSelectedColor)if(n.pickingSelectedColor){var t=n.pickingSelectedColor.slice(0,3);e.picking_uSelectedColorValid=1,e.picking_uSelectedColor=t}else e.picking_uSelectedColorValid=0;if(n.pickingHighlightColor){var o=Array.from(n.pickingHighlightColor,(function(n){return n/255}));Number.isFinite(o[3])||(o[3]=1),e.picking_uHighlightColor=o}return void 0!==n.pickingActive&&(e.picking_uActive=Boolean(n.pickingActive),e.picking_uAttribute=Boolean(n.pickingAttribute)),e}},me="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",he={};function Ae(n){var e=n.ambient,t=void 0===e?.35:e,o=n.diffuse,r=void 0===o?.6:o,i=n.shininess,a=void 0===i?32:i,l=n.specularColor;return{lighting_uAmbient:t,lighting_uDiffuse:r,lighting_uShininess:a,lighting_uSpecularColor:(void 0===l?[30,30,30]:l).map((function(n){return n/255}))}}function ge(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:he;if(!("material"in n))return{};var e=n.material;return e?Ae(e):{lighting_uEnabled:!1}}var xe={name:"gouraud-lighting",dependencies:[ue],vs:me,defines:{LIGHTING_VERTEX:1},getUniforms:ge},Pe={name:"phong-lighting",dependencies:[ue],fs:me,defines:{LIGHTING_FRAGMENT:1},getUniforms:ge},be={name:"pbr",vs:"uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n",fs:"#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)\n# error PBR fragment shader: Texture LOD is not available\n#endif\n\n#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)\n# error PBR fragment shader: Derivatives are not available\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n\n\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();\n    vec3 v = normalize(u_Camera - pbr_vPosition);\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0,\n      NdotV,\n      0.0,\n      0.0,\n      0.0,\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n",defines:{LIGHTING_FRAGMENT:1},dependencies:[ue]},Fe={name:"tiltShift",uniforms:{blurRadius:{value:15,min:0,max:50},gradientRadius:{value:200,min:0,max:400},start:[0,0],end:[1,1],invert:{value:!1,private:!0}},fs:"uniform float blurRadius;\nuniform float gradientRadius;\nuniform vec2 start;\nuniform vec2 end;\nuniform bool invert;\n\nvec2 tiltShift_getDelta(vec2 texSize) {\n  vec2 vector = normalize((end - start) * texSize);\n  return invert ? vec2(-vector.y, vector.x) : vector;\n}\n\nvec4 tiltShift_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  vec2 normal = normalize(vec2((start.y - end.y) * texSize.y, (end.x - start.x) * texSize.x));\n  float radius = smoothstep(0.0, 1.0,\n    abs(dot(texCoord * texSize - start * texSize, normal)) / gradientRadius) * blurRadius;\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 sample = texture2D(texture, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);\n\n    /* switch to pre-multiplied alpha to correctly blur transparent images */\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n\n  /* switch back from pre-multiplied alpha */\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n",dependencies:[vn],passes:[{sampler:!0,uniforms:{invert:!1}},{sampler:!0,uniforms:{invert:!0}}]},ye={name:"triangleBlur",uniforms:{radius:{value:20,min:0,softMax:100},delta:{value:[1,0],private:!0}},fs:"uniform float radius;\nuniform vec2 delta;\n\nvec4 triangleBlur_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 adjustedDelta = delta * radius / texSize;\n\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 sample = texture2D(texture, texCoord + adjustedDelta * percent);\n\n    /* switch to pre-multiplied alpha to correctly blur transparent images */\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n\n  /* switch back from pre-multiplied alpha */\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n",dependencies:[vn],passes:[{sampler:!0,uniforms:{delta:[1,0]}},{sampler:!0,uniforms:{delta:[0,1]}}]},Le={name:"zoomBlur",uniforms:{center:[.5,.5],strength:{value:.3,min:0,softMax:1}},fs:"\nuniform vec2 center;\nuniform float strength;\n\nvec4 zoomBlur_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  vec2 toCenter = center * texSize - texCoord * texSize;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = 0.0; t <= 40.0; t++) {\n    float percent = (t + offset) / 40.0;\n    float weight = 4.0 * (percent - percent * percent);\n    vec4 sample = texture2D(texture, texCoord + toCenter * percent * strength / texSize);\n\n    /* switch to pre-multiplied alpha to correctly blur transparent images */\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n\n  /* switch back from pre-multiplied alpha */\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n",dependencies:[vn],passes:[{sampler:!0}]},Ee={name:"brightnessContrast",uniforms:{brightness:{value:0,min:-1,max:1},contrast:{value:0,min:-1,max:1}},fs:"uniform float brightness;\nuniform float contrast;\n\nvec4 brightnessContrast_filterColor(vec4 color) {\n  color.rgb += brightness;\n  if (contrast > 0.0) {\n    color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;\n  } else {\n    color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;\n  }\n  return color;\n}\n\nvec4 brightnessContrast_filterColor(vec4 color, vec2 texSize, vec2 texCoords) {\n  return brightnessContrast_filterColor(color);\n}\n",passes:[{filter:!0}]},Ne={name:"denoise",uniforms:{strength:{value:.5,min:0,max:.1,adjust:function(n){return.53+200*Math.pow(1-n,4)}}},fs:"uniform float strength;\n\nvec4 denoise_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  float adjustedExponent = 3. + 200. * pow(1. - strength, 4.);\n\n  vec4 center = texture2D(texture, texCoord);\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  for (float x = -4.0; x <= 4.0; x += 1.0) {\n    for (float y = -4.0; y <= 4.0; y += 1.0) {\n      vec4 sample = texture2D(texture, texCoord + vec2(x, y) / texSize);\n      float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));\n      weight = pow(weight, adjustedExponent);\n      color += sample * weight;\n      total += weight;\n    }\n  }\n\n  return color / total;\n}\n",passes:[{sampler:!0},{sampler:!0}]},Ie={name:"hueSaturation",uniforms:{hue:{value:0,min:-1,max:1},saturation:{value:0,min:-1,max:1}},fs:"uniform float hue;\nuniform float saturation;\n\nvec4 hueSaturation_filterColor(vec4 color) {\n  // hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}]\n  float angle = hue * 3.14159265;\n  float s = sin(angle), c = cos(angle);\n  vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n  float len = length(color.rgb);\n  color.rgb = vec3(\n    dot(color.rgb, weights.xyz),\n    dot(color.rgb, weights.zxy),\n    dot(color.rgb, weights.yzx)\n  );\n\n  // saturation adjustment\n  float average = (color.r + color.g + color.b) / 3.0;\n  if (saturation > 0.0) {\n    color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n  } else {\n    color.rgb += (average - color.rgb) * (-saturation);\n  }\n\n  return color;\n}\n\nvec4 hueSaturation_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return hueSaturation_filterColor(color);\n}\n",passes:[{filter:!0}]},Te={name:"noise",uniforms:{amount:{value:.5,min:0,max:1}},fs:"uniform float amount;\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 noise_filterColor(vec4 color, vec2 texCoord) {\n  float diff = (rand(texCoord) - 0.5) * amount;\n  color.r += diff;\n  color.g += diff;\n  color.b += diff;\n  return color;\n}\n\nvec4 noise_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return noise_filterColor(color, texCoord);\n}\n",passes:[{filter:!0}]},Se={name:"sepia",uniforms:{amount:{value:.5,min:0,max:1}},fs:"uniform float amount;\n\nvec4 sepia_filterColor(vec4 color) {\n  float r = color.r;\n  float g = color.g;\n  float b = color.b;\n\n  color.r =\n    min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));\n  color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));\n  color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));\n\n  return color;\n}\n\nvec4 sepia_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return sepia_filterColor(color);\n}\n",passes:[{filter:!0}]},Ce={name:"vibrance",uniforms:{amount:{value:0,min:-1,max:1}},fs:"uniform float amount;\n\nvec4 vibrance_filterColor(vec4 color) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  float mx = max(color.r, max(color.g, color.b));\n  float amt = (mx - average) * (-amount * 3.0);\n  color.rgb = mix(color.rgb, vec3(mx), amt);\n  return color;\n}\n\nvec4 vibrance_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vibrance_filterColor(color);\n}\n",passes:[{filter:!0}]},Re={name:"vignette",fs:"uniform float radius;\nuniform float amount;\n\nvec4 vignette_filterColor(vec4 color, vec2 texCoord) {\n  float dist = distance(texCoord, vec2(0.5, 0.5));\n  float ratio = smoothstep(0.8, radius * 0.799, dist * (amount + radius));\n  return color.rgba * ratio + (1.0 - ratio)*vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 vignette_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vignette_filterColor(color, texCoord);\n}\n",uniforms:{radius:{value:.5,min:0,max:1},amount:{value:.5,min:0,max:1}},passes:[{filter:!0}]},Oe={name:"colorHalftone",uniforms:{center:[.5,.5],angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:4,min:1,softMin:3,softMax:20}},fs:"uniform vec2 center;\nuniform float angle;\nuniform float size;\n\nfloat scale = 3.1514 / size;\n\nfloat pattern(float angle, vec2 texSize, vec2 texCoord) {\n  float s = sin(angle), c = cos(angle);\n  vec2 tex = texCoord * texSize - center * texSize;\n  vec2 point = vec2(\n\tc * tex.x - s * tex.y,\n\ts * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 colorHalftone_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  vec3 cmy = 1.0 - color.rgb;\n  float k = min(cmy.x, min(cmy.y, cmy.z));\n  cmy = (cmy - k) / (1.0 - k);\n  cmy = clamp(\n\tcmy * 10.0 - 3.0 + vec3(\n    pattern(angle + 0.26179, texSize, texCoord),\n\t  pattern(angle + 1.30899, texSize, texCoord),\n    pattern(angle, texSize, texCoord)\n  ),\n\t0.0,\n\t1.0\n  );\n  k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539, texSize, texCoord), 0.0, 1.0);\n  return vec4(1.0 - cmy - k, color.a);\n}\n",passes:[{filter:!0}]},Ue={name:"dotScreen",uniforms:{center:[.5,.5],angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:3,min:1,softMin:3,softMax:20}},fs:"uniform vec2 center;\nuniform float angle;\nuniform float size;\n\nfloat pattern(vec2 texSize, vec2 texCoord) {\n  float scale = 3.1415 / size;\n\n  float s = sin(angle), c = cos(angle);\n  vec2 tex = texCoord * texSize - center * texSize;\n  vec2 point = vec2(\n    c * tex.x - s * tex.y,\n    s * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 dotScreen_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);\n}\n",passes:[{filter:!0}]},ke={name:"edgeWork",uniforms:{radius:{value:2,min:1,softMax:50},delta:{value:[1,0],private:!0}},fs:"uniform float radius;\nuniform vec2 delta;\n\nvec4 edgeWork_sampleColor1(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 relativeDelta = radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec3 sampleColor = texture2D(source, texCoord + relativeDelta * percent).rgb;\n    float average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;\n    color.x += average * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += average * weight;\n      total.y += weight;\n    }\n  }\n  return vec4(color / total, 0.0, 1.0);\n}\n\nvec4 edgeWork_sampleColor2(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 relativeDelta = radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec2 sampleColor = texture2D(source, texCoord + relativeDelta * percent).xy;\n    color.x += sampleColor.x * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += sampleColor.y * weight;\n      total.y += weight;\n    }\n  }\n  float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);\n  return vec4(c, c, c, 1.0);\n}\n",dependencies:[vn],passes:[{sampler:"edgeWork_sampleColor1",uniforms:{delta:[1,0]}},{sampler:"edgeWork_sampleColor2",uniforms:{delta:[0,1]}}]},Me={name:"hexagonalPixelate",uniforms:{center:{value:[.5,.5],hint:"screenspace"},scale:{value:10,min:1,softMin:5,softMax:50}},fs:"uniform vec2 center;\nuniform float scale;\n\nvec4 hexagonalPixelate_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 tex = (texCoord * texSize - center * texSize) / scale;\n  tex.y /= 0.866025404;\n  tex.x -= tex.y * 0.5;\n\n  vec2 a;\n  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n    a = vec2(floor(tex.x), floor(tex.y));\n  }\n  else a = vec2(ceil(tex.x), ceil(tex.y));\n  vec2 b = vec2(ceil(tex.x), floor(tex.y));\n  vec2 c = vec2(floor(tex.x), ceil(tex.y));\n\n  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n\n  float alen = length(TEX - A);\n  float blen = length(TEX - B);\n  float clen = length(TEX - C);\n\n  vec2 choice;\n  if (alen < blen) {\n    if (alen < clen) choice = a;\n    else choice = c;\n  } else {\n    if (blen < clen) choice = b;\n    else choice = c;\n  }\n\n  choice.x += choice.y * 0.5;\n  choice.y *= 0.866025404;\n  choice *= scale / texSize;\n\n  return texture2D(texture, choice + center);\n}\n",passes:[{sampler:!0}]},we={name:"ink",uniforms:{strength:{value:.25,min:0,softMax:1}},fs:"uniform float strength;\n\nvec4 ink_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 dx = vec2(1.0 / texSize.x, 0.0);\n  vec2 dy = vec2(0.0, 1.0 / texSize.y);\n  vec4 color = texture2D(texture, texCoord);\n  float bigTotal = 0.0;\n  float smallTotal = 0.0;\n  vec3 bigAverage = vec3(0.0);\n  vec3 smallAverage = vec3(0.0);\n  for (float x = -2.0; x <= 2.0; x += 1.0) {\n    for (float y = -2.0; y <= 2.0; y += 1.0) {\n      vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;\n      bigAverage += sample;\n      bigTotal += 1.0;\n      if (abs(x) + abs(y) < 2.0) {\n        smallAverage += sample;\n        smallTotal += 1.0;\n      }\n    }\n  }\n  vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\n  float power = strength * strength * strength * strength * strength;\n  return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);\n}\n",passes:[{sampler:!0}]},Xe={name:"magnify",uniforms:{screenXY:[0,0],radiusPixels:200,zoom:2,borderWidthPixels:0,borderColor:[255,255,255,255]},fs:"uniform vec2 screenXY;\nuniform float radiusPixels;\nuniform float zoom;\nuniform float borderWidthPixels;\nuniform vec4 borderColor;\n\nvec4 magnify_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 pos = vec2(screenXY.x, 1.0 - screenXY.y);\n  float dist = distance(texCoord * texSize, pos * texSize);\n  if (dist < radiusPixels) {\n    return texture2D(texture, (texCoord - pos) / zoom + pos);\n  }\n\n  if (dist <= radiusPixels + borderWidthPixels) {\n    return borderColor;\n  }\n  return texture2D(texture, texCoord);\n}\n",passes:[{sampler:!0}]},De={name:"warp",fs:"vec4 warp_sampleColor(sampler2D texture, vec2 texSize, vec2 coord) {\n  vec4 color = texture2D(texture, coord / texSize);\n  vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\n  if (coord != clampedCoord) {\n    /* fade to transparent if we are outside the image */\n    color.a *= max(0.0, 1.0 - length(coord - clampedCoord));\n  }\n\n  return color;\n}\n"},Qe={name:"bulgePinch",fs:"uniform float radius;\nuniform float strength;\nuniform vec2 center;\n\nvec2 bulgePinch_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < radius) {\n    float percent = distance / radius;\n    if (strength > 0.0) {\n      coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n    } else {\n      coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n    }\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 bulgePinch_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = bulgePinch_warp(coord, center * texSize);\n\n  return warp_sampleColor(texture, texSize, coord);\n}\n",uniforms:{center:[.5,.5],radius:{value:200,min:1,softMax:600},strength:{value:.5,min:-1,max:1}},dependencies:[De],passes:[{sampler:!0}]},Ye={name:"swirl",fs:"uniform float radius;\nuniform float angle;\nuniform vec2 center;\n\nvec2 swirl_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < radius) {\n    float percent = (radius - distance) / radius;\n    float theta = percent * percent * angle;\n    float s = sin(theta);\n    float c = cos(theta);\n    coord = vec2(\n      coord.x * c - coord.y * s,\n      coord.x * s + coord.y * c\n    );\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 swirl_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = swirl_warp(coord, center * texSize);\n\n  return warp_sampleColor(texture, texSize, coord);\n}\n",uniforms:{center:[.5,.5],radius:{value:200,min:1,softMax:600},angle:{value:3,softMin:-25,softMax:25}},dependencies:[De],passes:[{sampler:!0}]},Be={name:"fxaa",uniforms:{},fs:"\n#define FXAA_QUALITY_PRESET 29\n\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n#define FxaaBool bool\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 vec2\n#define FxaaTex sampler2D\n\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTexTop(t, p) texture2D(t, p)\n#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))\n\nFxaaFloat FxaaLuma_(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.2126, 0.7152, 0.0722)); }\n\nFxaaFloat4 FxaaPixelShader_(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {___a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n    #define lumaM rgbyM.y\n    FxaaFloat lumaS = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaN = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        return rgbyM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaNE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    return FxaaTexTop(tex, posM);\n}\n\nvec4 fxaa_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n    const float fxaa_QualitySubpix = 0.5;\n    const float fxaa_QualityEdgeThreshold = 0.125;\n    const float fxaa_QualityEdgeThresholdMin = 0.0833;\n\n    return FxaaPixelShader_(\n        texCoord,\n        texture,\n        vec2(1.0) / texSize,\n        fxaa_QualitySubpix,\n        fxaa_QualityEdgeThreshold,\n        fxaa_QualityEdgeThresholdMin\n    );\n}\n",passes:[{sampler:!0}]},ze={name:"transform",vs:"attribute float transform_elementID;\n\n// returns half of pixel size, used to move the pixel position to center of the pixel.\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\n// returns current elements pixel indeces [x, y],\n// where x ranges in [0 to texSize-1] and y ranges in [0 to texSize-1]\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  // Add safe offset (half of pixel height) before doing floor\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\n\n// returns current elementID's texture co-ordianate\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\n\n// returns current elementID's position\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  // Change from [0 1] range to [-1 1]\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\n\n// returns current elementID's pixel value\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n",fs:null}}])}));