{"version":3,"file":"copy-and-blit.js","names":["readPixelsToArray","source","options","sourceX","sourceY","sourceFormat","sourceAttachment","target","sourceWidth","sourceHeight","sourceType","getFramebuffer","framebuffer","deleteFramebuffer","assert","gl","handle","attachments","width","height","type","getPixelArray","getGLTypeFromTypedArray","prevHandle","bindFramebuffer","readPixels","delete","readPixelsToBuffer","targetByteOffset","gl2","assertWebGL2Context","components","glFormatToComponents","byteCount","glTypeToBytes","byteLength","Buffer","accessor","size","bind","withParameters","unbind","copyToDataUrl","targetMaxHeight","Number","MAX_SAFE_INTEGER","data","scalePixels","flipRows","canvas","document","createElement","context","getContext","imageData","createImageData","set","putImageData","toDataURL","copyToImage","targetImage","dataUrl","Image","src","copyToTexture","targetMipmaplevel","targetInternalFormat","targetX","targetY","targetZ","isSubCopy","texture","Texture","isFinite","copyTexImage2D","copyTexSubImage2D","copyTexSubImage3D","blit","sourceX0","sourceY0","targetX0","targetY0","color","depth","stencil","filter","sourceX1","sourceY1","targetX1","targetY1","mask","srcFramebuffer","deleteSrcFramebuffer","dstFramebuffer","deleteDstFramebuffer","readBuffer","log","warn","undefined","prevDrawHandle","prevReadHandle","blitFramebuffer","Framebuffer","toFramebuffer","pixelArray","format","ArrayType","getTypedArrayFromGLType","clamped"],"sources":["../../../src/classes/copy-and-blit.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport Buffer from './buffer';\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport {assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\nimport {flipRows, scalePixels} from '../webgl-utils/typed-array-utils';\nimport {getTypedArrayFromGLType, getGLTypeFromTypedArray} from '../webgl-utils/typed-array-utils';\nimport {glFormatToComponents, glTypeToBytes} from '../webgl-utils/format-utils';\nimport {toFramebuffer} from '../webgl-utils/texture-utils';\nimport {assert} from '../utils/assert';\n\n// NOTE: Slow requires roundtrip to GPU\n// Copies data from a Framebuffer or a Texture object into ArrayBuffer object.\n// App can provide targetPixelArray or have it auto allocated by this method\n// @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n//  newly allocated by this method unless provided by app.\nexport function readPixelsToArray(source, options = {}) {\n  const {sourceX = 0, sourceY = 0, sourceFormat = GL.RGBA} = options;\n  let {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    target = null,\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = options;\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle, attachments} = framebuffer;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // TODO - Set and unset gl.readBuffer\n  if (sourceAttachment === GL.COLOR_ATTACHMENT0 && handle === null) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  assert(attachments[sourceAttachment]);\n\n  // Deduce the type from color attachment if not provided.\n  sourceType = sourceType || attachments[sourceAttachment].type;\n\n  // Deduce type and allocated pixelArray if needed\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n\n  // Pixel array available, if necessary, deduce type from it.\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  // @ts-ignore\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return target;\n}\n\n// NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n// Copies data from a Framebuffer or a Texture object into a Buffer object.\nexport function readPixelsToBuffer(\n  source,\n  {\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = GL.RGBA,\n    target = null, // A new Buffer object is created when not provided.\n    targetByteOffset = 0, // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  }\n) {\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const gl2 = assertWebGL2Context(framebuffer.gl);\n\n  // deduce type if not available.\n  sourceType = sourceType || (target ? target.type : GL.UNSIGNED_BYTE);\n\n  if (!target) {\n    // Create new buffer with enough size\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    target = new Buffer(gl2, {byteLength, accessor: {type: sourceType, size: components}});\n  }\n\n  target.bind({target: GL.PIXEL_PACK_BUFFER});\n  withParameters(gl2, {framebuffer}, () => {\n    gl2.readPixels(\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      sourceFormat,\n      sourceType,\n      targetByteOffset\n    );\n  });\n  target.unbind({target: GL.PIXEL_PACK_BUFFER});\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return target;\n}\n\n// Reads pixels from a Framebuffer or Texture object to a dataUrl\nexport function copyToDataUrl(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMaxHeight = Number.MAX_SAFE_INTEGER\n  } = {}\n) {\n  let data = readPixelsToArray(source, {sourceAttachment});\n\n  // Scale down\n  let {width, height} = source;\n  while (height > targetMaxHeight) {\n    ({data, width, height} = scalePixels({data, width, height}));\n  }\n\n  // Flip to top down coordinate system\n  flipRows({data, width, height});\n\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d');\n\n  // Copy the pixels to a 2D canvas\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n\n  return canvas.toDataURL();\n}\n\n// Reads pixels from a Framebuffer or Texture object into an HTML Image\nexport function copyToImage(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetImage = null\n  } = {}\n) {\n  const dataUrl = copyToDataUrl(source, {sourceAttachment});\n  targetImage = targetImage || new Image();\n  targetImage.src = dataUrl;\n  return targetImage;\n}\n\n// Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n// eslint-disable-next-line complexity, max-statements\nexport function copyToTexture(source, target, options = {}) {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMipmaplevel = 0,\n    targetInternalFormat = GL.RGBA\n  } = options;\n  let {\n    targetX,\n    targetY,\n    targetZ,\n    width, // defaults to target width\n    height // defaults to target height\n  } = options;\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle} = framebuffer;\n  const isSubCopy =\n    typeof targetX !== 'undefined' ||\n    typeof targetY !== 'undefined' ||\n    typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  assert(target);\n  let texture = null;\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    target = texture.target;\n  }\n\n  if (!isSubCopy) {\n    gl.copyTexImage2D(\n      target,\n      targetMipmaplevel,\n      targetInternalFormat,\n      sourceX,\n      sourceY,\n      width,\n      height,\n      0 /* border must be 0 */\n    );\n  } else {\n    switch (target) {\n      case GL.TEXTURE_2D:\n      case GL.TEXTURE_CUBE_MAP:\n        gl.copyTexSubImage2D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      case GL.TEXTURE_2D_ARRAY:\n      case GL.TEXTURE_3D:\n        const gl2 = assertWebGL2Context(gl);\n        gl2.copyTexSubImage3D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          targetZ,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  // @ts-ignore\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return texture;\n}\n\n// NOTE: WEBLG2 only\n// Copies a rectangle of pixels between Framebuffer or Texture objects\n// eslint-disable-next-line max-statements, complexity\nexport function blit(source, target, options = {}) {\n  const {\n    sourceX0 = 0,\n    sourceY0 = 0,\n    targetX0 = 0,\n    targetY0 = 0,\n    color = true,\n    depth = false,\n    stencil = false,\n    filter = GL.NEAREST\n  } = options;\n\n  let {\n    sourceX1,\n    sourceY1,\n    targetX1,\n    targetY1,\n    sourceAttachment = GL.COLOR_ATTACHMENT0,\n    mask = 0\n  } = options;\n\n  const {framebuffer: srcFramebuffer, deleteFramebuffer: deleteSrcFramebuffer} = getFramebuffer(\n    source\n  );\n  const {framebuffer: dstFramebuffer, deleteFramebuffer: deleteDstFramebuffer} = getFramebuffer(\n    target\n  );\n\n  assert(srcFramebuffer);\n  assert(dstFramebuffer);\n  // @ts-ignore\n  const {gl, handle, width, height, readBuffer} = dstFramebuffer;\n  const gl2 = assertWebGL2Context(gl);\n\n  if (!srcFramebuffer.handle && sourceAttachment === GL.COLOR_ATTACHMENT0) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  if (color) {\n    mask |= GL.COLOR_BUFFER_BIT;\n  }\n  if (depth) {\n    mask |= GL.DEPTH_BUFFER_BIT;\n  }\n  if (stencil) {\n    mask |= GL.STENCIL_BUFFER_BIT;\n  }\n\n  if (deleteSrcFramebuffer || deleteDstFramebuffer) {\n    // Either source or destiantion was a texture object, which is wrapped in a Framebuffer objecgt as color attachment.\n    // Overwrite the mask to `COLOR_BUFFER_BIT`\n    if (mask & (GL.DEPTH_BUFFER_BIT | GL.STENCIL_BUFFER_BIT)) {\n      mask = GL.COLOR_BUFFER_BIT;\n      log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();\n    }\n  }\n  assert(mask);\n\n  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;\n  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;\n  targetX1 = targetX1 === undefined ? width : targetX1;\n  targetY1 = targetY1 === undefined ? height : targetY1;\n\n  const prevDrawHandle = gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, handle);\n  const prevReadHandle = gl.bindFramebuffer(GL.READ_FRAMEBUFFER, srcFramebuffer.handle);\n  gl2.readBuffer(sourceAttachment);\n  gl2.blitFramebuffer(\n    sourceX0,\n    sourceY0,\n    sourceX1,\n    sourceY1,\n    targetX0,\n    targetY0,\n    targetX1,\n    targetY1,\n    mask,\n    filter\n  );\n  gl2.readBuffer(readBuffer);\n  // @ts-ignore\n  gl2.bindFramebuffer(GL.READ_FRAMEBUFFER, prevReadHandle || null);\n  // @ts-ignore\n  gl2.bindFramebuffer(GL.DRAW_FRAMEBUFFER, prevDrawHandle || null);\n  if (deleteSrcFramebuffer) {\n    srcFramebuffer.delete();\n  }\n  if (deleteDstFramebuffer) {\n    dstFramebuffer.delete();\n  }\n\n  return dstFramebuffer;\n}\n\n// Helper methods\n\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {framebuffer: toFramebuffer(source), deleteFramebuffer: true};\n  }\n  return {framebuffer: source, deleteFramebuffer: false};\n}\n\nfunction getPixelArray(pixelArray, type, format, width, height) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  // Allocate pixel array if not already available, using supplied type\n  type = type || GL.UNSIGNED_BYTE;\n  const ArrayType = getTypedArrayFromGLType(type, {clamped: false});\n  const components = glFormatToComponents(format);\n  // TODO - check for composite type (components = 1).\n  return new ArrayType(width * height * components);\n}\n"],"mappings":"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"}