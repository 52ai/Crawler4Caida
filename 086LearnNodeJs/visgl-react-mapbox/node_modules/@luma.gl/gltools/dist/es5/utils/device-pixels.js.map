{"version":3,"file":"device-pixels.js","names":["cssToDeviceRatio","gl","luma","canvas","clientWidth","canvasSizeInfo","drawingBufferWidth","cssToDevicePixels","cssPixel","yInvert","ratio","width","height","drawingBufferHeight","scalePixels","getDevicePixelRatio","useDevicePixels","windowRatio","window","devicePixelRatio","Number","isFinite","pixel","x","scaleX","y","scaleY","t","xHigh","yHigh","Math","max","r","min","round"],"sources":["../../../src/utils/device-pixels.js"],"sourcesContent":["/** @typedef {import('./device-pixels')} types */\n\n/**\n * Returns multiplier need to convert CSS size to Device size\n * @type {types['cssToDeviceRatio']}\n */\nexport function cssToDeviceRatio(gl) {\n  // @ts-ignore\n  const {luma} = gl;\n\n  if (gl.canvas && luma) {\n    // For headless gl we might have used custom width and height\n    // hence use cached clientWidth\n    const {clientWidth} = luma.canvasSizeInfo;\n    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;\n  }\n  // use default device pixel ratio\n  return 1;\n}\n\n/**\n * Maps CSS pixel position to device pixel position\n * @type {types['cssToDevicePixels']}\n */\nexport function cssToDevicePixels(gl, cssPixel, yInvert = true) {\n  const ratio = cssToDeviceRatio(gl);\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  return scalePixels(cssPixel, ratio, width, height, yInvert);\n}\n\n// HELPER METHOD\n\n/**\n * Calulates device pixel ratio, used during context creation\n * @type {types['getDevicePixelRatio']}\n */\nexport function getDevicePixelRatio(useDevicePixels) {\n  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n  if (Number.isFinite(useDevicePixels)) {\n    // @ts-ignore Can no longer be boolean after previous line\n    return useDevicePixels <= 0 ? 1 : useDevicePixels;\n  }\n  return useDevicePixels ? windowRatio : 1;\n}\n\n// PRIVATE\n\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const x = scaleX(pixel[0], ratio, width);\n  let y = scaleY(pixel[1], ratio, height, yInvert);\n\n  // Find boundaries of next pixel to provide valid range of device pixel locaitons\n\n  let t = scaleX(pixel[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n\n  t = scaleY(pixel[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x, ratio, width) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y, ratio, height, yInvert) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert\n    ? Math.max(0, height - 1 - Math.round(y * ratio))\n    : Math.min(Math.round(y * ratio), height - 1);\n}\n"],"mappings":"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"}