"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMap = parseMap;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _layerMap = require("./layer-map");

var _core = require("@deck.gl/core");

var _utils = require("../utils");

var _excluded = ["id", "config"],
    _excluded2 = ["textLabel"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function parseMap(json) {
  var keplerMapConfig = json.keplerMapConfig,
      datasets = json.datasets;
  (0, _utils.assert)(keplerMapConfig.version === 'v1', 'Only support Kepler v1');
  var _keplerMapConfig$conf = keplerMapConfig.config,
      mapState = _keplerMapConfig$conf.mapState,
      mapStyle = _keplerMapConfig$conf.mapStyle;
  var _keplerMapConfig$conf2 = keplerMapConfig.config.visState,
      layers = _keplerMapConfig$conf2.layers,
      layerBlending = _keplerMapConfig$conf2.layerBlending,
      interactionConfig = _keplerMapConfig$conf2.interactionConfig;
  return {
    id: json.id,
    title: json.title,
    description: json.description,
    createdAt: json.createdAt,
    updatedAt: json.updatedAt,
    initialViewState: mapState,
    mapStyle: mapStyle,
    layers: extractTextLayers(layers.reverse()).map(function (_ref) {
      var id = _ref.id,
          type = _ref.type,
          config = _ref.config,
          visualChannels = _ref.visualChannels;

      try {
        var dataId = config.dataId;
        var dataset = datasets.find(function (d) {
          return d.id === dataId;
        });
        (0, _utils.assert)(dataset, "No dataset matching dataId: ".concat(dataId));
        var data = dataset.data;
        (0, _utils.assert)(data, "No data loaded for dataId: ".concat(dataId));

        var _getLayer = (0, _layerMap.getLayer)(type, config, dataset),
            Layer = _getLayer.Layer,
            propMap = _getLayer.propMap,
            defaultProps = _getLayer.defaultProps;

        return new Layer(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
          id: id,
          data: data
        }, defaultProps), createBlendingProps(layerBlending)), !config.textLabel && createInteractionProps(interactionConfig)), createStyleProps(config, propMap)), createChannelProps(visualChannels, type, config, data)));
      } catch (e) {
        _core.log.error(e.message)();

        return undefined;
      }
    })
  };
}

function extractTextLayers(layers) {
  return (0, _core._flatten)(layers.map(function (_ref2) {
    var id = _ref2.id,
        config = _ref2.config,
        rest = (0, _objectWithoutProperties2.default)(_ref2, _excluded);
    var textLabel = config.textLabel,
        configRest = (0, _objectWithoutProperties2.default)(config, _excluded2);
    return [_objectSpread({
      id: id,
      config: configRest
    }, rest)].concat((0, _toConsumableArray2.default)(textLabel.filter(function (t) {
      return t.field;
    }).map(function (t) {
      return _objectSpread({
        id: "".concat(id, "-label-").concat(t.field.name),
        config: _objectSpread(_objectSpread({
          textLabel: t
        }, configRest), {}, {
          label: "".concat(config.label, "-label-").concat(t.field.name),
          visConfig: _objectSpread(_objectSpread({}, configRest.visConfig), {}, {
            opacity: 1
          })
        })
      }, rest);
    })));
  }));
}

function createBlendingProps(layerBlending) {
  if (layerBlending === 'additive') {
    return {
      parameters: {
        blendFunc: [770, 772],
        blendEquation: 32774
      }
    };
  } else if (layerBlending === 'subtractive') {
    return {
      parameters: {
        blendFunc: [1, 775, 770, 772],
        blendEquation: [32778, 32774]
      }
    };
  }

  return {};
}

function createInteractionProps(interactionConfig) {
  var pickable = interactionConfig && interactionConfig.tooltip.enabled;
  return {
    autoHighlight: pickable,
    pickable: pickable
  };
}

function mapProps(source, target, mapping) {
  for (var sourceKey in mapping) {
    var sourceValue = source[sourceKey];
    var targetKey = mapping[sourceKey];

    if (sourceValue === undefined) {
      continue;
    }

    if (typeof targetKey === 'string') {
      target[targetKey] = sourceValue;
    } else if (typeof targetKey === 'function') {
      var _Object$entries$ = (0, _slicedToArray2.default)(Object.entries(targetKey(sourceValue))[0], 2),
          key = _Object$entries$[0],
          value = _Object$entries$[1];

      target[key] = value;
    } else if ((0, _typeof2.default)(targetKey) === 'object') {
      mapProps(sourceValue, target, targetKey);
    }
  }
}

function createStyleProps(config, mapping) {
  var result = {};
  mapProps(config, result, mapping);

  if (result.stroked && !result.getLineColor) {
    result.getLineColor = result.getFillColor;
  }

  for (var colorAccessor in _layerMap.OPACITY_MAP) {
    if (Array.isArray(result[colorAccessor])) {
      var color = (0, _toConsumableArray2.default)(result[colorAccessor]);
      var opacityKey = _layerMap.OPACITY_MAP[colorAccessor];
      var opacity = config.visConfig[opacityKey];
      color[3] = (0, _layerMap.opacityToAlpha)(opacity);
      result[colorAccessor] = color;
    }
  }

  result.highlightColor = config.visConfig.enable3d ? [255, 255, 255, 60] : [252, 242, 26, 255];
  return result;
}

function createChannelProps(visualChannels, type, config, data) {
  var colorField = visualChannels.colorField,
      colorScale = visualChannels.colorScale,
      radiusField = visualChannels.radiusField,
      radiusScale = visualChannels.radiusScale,
      sizeField = visualChannels.sizeField,
      sizeScale = visualChannels.sizeScale,
      strokeColorField = visualChannels.strokeColorField,
      strokeColorScale = visualChannels.strokeColorScale;
  var heightField = visualChannels.heightField,
      heightScale = visualChannels.heightScale;

  if (type === 'hexagonId') {
    heightField = sizeField;
    heightScale = sizeScale;
  }

  var textLabel = config.textLabel,
      visConfig = config.visConfig;
  var result = {};
  var textLabelField = textLabel && textLabel.field;

  if (type === 'grid' || type === 'hexagon') {
    result.colorScaleType = colorScale;

    if (colorField) {
      var colorAggregation = config.visConfig.colorAggregation;

      if (!_layerMap.AGGREGATION[colorAggregation]) {
        result.getColorValue = (0, _layerMap.getColorValueAccessor)(colorField, colorAggregation, data);
      } else {
        result.getColorWeight = function (d) {
          return d[colorField.name];
        };
      }
    }
  } else if (colorField) {
    var aggregation = visConfig.colorAggregation,
        range = visConfig.colorRange;
    result.getFillColor = (0, _layerMap.getColorAccessor)(colorField, colorScale, {
      aggregation: aggregation,
      range: range
    }, visConfig.opacity, data);
  }

  if (radiusField || sizeField) {
    result.getPointRadius = (0, _layerMap.getSizeAccessor)(radiusField || sizeField, radiusScale || sizeScale, visConfig.sizeAggregation, visConfig.radiusRange || visConfig.sizeRange, data);
  }

  if (strokeColorField) {
    var fallbackOpacity = type === 'point' ? visConfig.opacity : 1;
    var opacity = visConfig.strokeOpacity !== undefined ? visConfig.strokeOpacity : fallbackOpacity;
    var _aggregation = visConfig.strokeColorAggregation,
        _range = visConfig.strokeColorRange;
    result.getLineColor = (0, _layerMap.getColorAccessor)(strokeColorField, strokeColorScale, {
      aggregation: _aggregation,
      range: _range
    }, opacity, data);
  }

  if (heightField) {
    result.getElevation = (0, _layerMap.getSizeAccessor)(heightField, heightScale, visConfig.heightAggregation, visConfig.heightRange || visConfig.sizeRange, data);
  }

  if (textLabelField) {
    result.getText = (0, _layerMap.getTextAccessor)(textLabelField, data);
    result.pointType = 'text';
    var radius = result.getPointRadius || visConfig.radius;
    result.getTextPixelOffset = (0, _layerMap.getTextPixelOffsetAccessor)(textLabel, radius);
  } else if (visConfig.customMarkers) {
    var maxIconSize = (0, _layerMap.getMaxMarkerSize)(visConfig, visualChannels);
    var getPointRadius = result.getPointRadius,
        getFillColor = result.getFillColor;
    result.pointType = 'icon';
    result.getIcon = (0, _layerMap.getIconUrlAccessor)(visualChannels.customMarkersField, visConfig.customMarkersUrl, visConfig.customMarkersRange, maxIconSize, data);
    result._subLayerProps = {
      'points-icon': {
        loadOptions: {
          image: {
            type: 'imagebitmap'
          },
          imagebitmap: {
            resizeWidth: maxIconSize,
            resizeHeight: maxIconSize,
            resizeQuality: 'high'
          }
        }
      }
    };

    if (getFillColor) {
      result.getIconColor = getFillColor;
    }

    if (getPointRadius) {
      result.getIconSize = getPointRadius;
    }

    if (visualChannels.rotationField) {
      result.getIconAngle = (0, _layerMap.negateAccessor)((0, _layerMap.getSizeAccessor)(visualChannels.rotationField, undefined, null, undefined, data));
    }
  }

  return result;
}
//# sourceMappingURL=parseMap.js.map