import { AGGREGATION, getLayer, getColorAccessor, getColorValueAccessor, getSizeAccessor, getTextAccessor, getTextPixelOffsetAccessor, OPACITY_MAP, opacityToAlpha, getIconUrlAccessor, negateAccessor, getMaxMarkerSize } from './layer-map';
import { _flatten as flatten, log } from '@deck.gl/core';
import { assert } from '../utils';
export function parseMap(json) {
  const {
    keplerMapConfig,
    datasets
  } = json;
  assert(keplerMapConfig.version === 'v1', 'Only support Kepler v1');
  const {
    mapState,
    mapStyle
  } = keplerMapConfig.config;
  const {
    layers,
    layerBlending,
    interactionConfig
  } = keplerMapConfig.config.visState;
  return {
    id: json.id,
    title: json.title,
    description: json.description,
    createdAt: json.createdAt,
    updatedAt: json.updatedAt,
    initialViewState: mapState,
    mapStyle,
    layers: extractTextLayers(layers.reverse()).map(({
      id,
      type,
      config,
      visualChannels
    }) => {
      try {
        const {
          dataId
        } = config;
        const dataset = datasets.find(d => d.id === dataId);
        assert(dataset, "No dataset matching dataId: ".concat(dataId));
        const {
          data
        } = dataset;
        assert(data, "No data loaded for dataId: ".concat(dataId));
        const {
          Layer,
          propMap,
          defaultProps
        } = getLayer(type, config, dataset);
        return new Layer({
          id,
          data,
          ...defaultProps,
          ...createBlendingProps(layerBlending),
          ...(!config.textLabel && createInteractionProps(interactionConfig)),
          ...createStyleProps(config, propMap),
          ...createChannelProps(visualChannels, type, config, data)
        });
      } catch (e) {
        log.error(e.message)();
        return undefined;
      }
    })
  };
}

function extractTextLayers(layers) {
  return flatten(layers.map(({
    id,
    config,
    ...rest
  }) => {
    const {
      textLabel,
      ...configRest
    } = config;
    return [{
      id,
      config: configRest,
      ...rest
    }, ...textLabel.filter(t => t.field).map(t => {
      return {
        id: "".concat(id, "-label-").concat(t.field.name),
        config: {
          textLabel: t,
          ...configRest,
          label: "".concat(config.label, "-label-").concat(t.field.name),
          visConfig: { ...configRest.visConfig,
            opacity: 1
          }
        },
        ...rest
      };
    })];
  }));
}

function createBlendingProps(layerBlending) {
  if (layerBlending === 'additive') {
    return {
      parameters: {
        blendFunc: [770, 772],
        blendEquation: 32774
      }
    };
  } else if (layerBlending === 'subtractive') {
    return {
      parameters: {
        blendFunc: [1, 775, 770, 772],
        blendEquation: [32778, 32774]
      }
    };
  }

  return {};
}

function createInteractionProps(interactionConfig) {
  const pickable = interactionConfig && interactionConfig.tooltip.enabled;
  return {
    autoHighlight: pickable,
    pickable
  };
}

function mapProps(source, target, mapping) {
  for (const sourceKey in mapping) {
    const sourceValue = source[sourceKey];
    const targetKey = mapping[sourceKey];

    if (sourceValue === undefined) {
      continue;
    }

    if (typeof targetKey === 'string') {
      target[targetKey] = sourceValue;
    } else if (typeof targetKey === 'function') {
      const [key, value] = Object.entries(targetKey(sourceValue))[0];
      target[key] = value;
    } else if (typeof targetKey === 'object') {
      mapProps(sourceValue, target, targetKey);
    }
  }
}

function createStyleProps(config, mapping) {
  const result = {};
  mapProps(config, result, mapping);

  if (result.stroked && !result.getLineColor) {
    result.getLineColor = result.getFillColor;
  }

  for (const colorAccessor in OPACITY_MAP) {
    if (Array.isArray(result[colorAccessor])) {
      const color = [...result[colorAccessor]];
      const opacityKey = OPACITY_MAP[colorAccessor];
      const opacity = config.visConfig[opacityKey];
      color[3] = opacityToAlpha(opacity);
      result[colorAccessor] = color;
    }
  }

  result.highlightColor = config.visConfig.enable3d ? [255, 255, 255, 60] : [252, 242, 26, 255];
  return result;
}

function createChannelProps(visualChannels, type, config, data) {
  const {
    colorField,
    colorScale,
    radiusField,
    radiusScale,
    sizeField,
    sizeScale,
    strokeColorField,
    strokeColorScale
  } = visualChannels;
  let {
    heightField,
    heightScale
  } = visualChannels;

  if (type === 'hexagonId') {
    heightField = sizeField;
    heightScale = sizeScale;
  }

  const {
    textLabel,
    visConfig
  } = config;
  const result = {};
  const textLabelField = textLabel && textLabel.field;

  if (type === 'grid' || type === 'hexagon') {
    result.colorScaleType = colorScale;

    if (colorField) {
      const {
        colorAggregation
      } = config.visConfig;

      if (!AGGREGATION[colorAggregation]) {
        result.getColorValue = getColorValueAccessor(colorField, colorAggregation, data);
      } else {
        result.getColorWeight = d => d[colorField.name];
      }
    }
  } else if (colorField) {
    const {
      colorAggregation: aggregation,
      colorRange: range
    } = visConfig;
    result.getFillColor = getColorAccessor(colorField, colorScale, {
      aggregation,
      range
    }, visConfig.opacity, data);
  }

  if (radiusField || sizeField) {
    result.getPointRadius = getSizeAccessor(radiusField || sizeField, radiusScale || sizeScale, visConfig.sizeAggregation, visConfig.radiusRange || visConfig.sizeRange, data);
  }

  if (strokeColorField) {
    const fallbackOpacity = type === 'point' ? visConfig.opacity : 1;
    const opacity = visConfig.strokeOpacity !== undefined ? visConfig.strokeOpacity : fallbackOpacity;
    const {
      strokeColorAggregation: aggregation,
      strokeColorRange: range
    } = visConfig;
    result.getLineColor = getColorAccessor(strokeColorField, strokeColorScale, {
      aggregation,
      range
    }, opacity, data);
  }

  if (heightField) {
    result.getElevation = getSizeAccessor(heightField, heightScale, visConfig.heightAggregation, visConfig.heightRange || visConfig.sizeRange, data);
  }

  if (textLabelField) {
    result.getText = getTextAccessor(textLabelField, data);
    result.pointType = 'text';
    const radius = result.getPointRadius || visConfig.radius;
    result.getTextPixelOffset = getTextPixelOffsetAccessor(textLabel, radius);
  } else if (visConfig.customMarkers) {
    const maxIconSize = getMaxMarkerSize(visConfig, visualChannels);
    const {
      getPointRadius,
      getFillColor
    } = result;
    result.pointType = 'icon';
    result.getIcon = getIconUrlAccessor(visualChannels.customMarkersField, visConfig.customMarkersUrl, visConfig.customMarkersRange, maxIconSize, data);
    result._subLayerProps = {
      'points-icon': {
        loadOptions: {
          image: {
            type: 'imagebitmap'
          },
          imagebitmap: {
            resizeWidth: maxIconSize,
            resizeHeight: maxIconSize,
            resizeQuality: 'high'
          }
        }
      }
    };

    if (getFillColor) {
      result.getIconColor = getFillColor;
    }

    if (getPointRadius) {
      result.getIconSize = getPointRadius;
    }

    if (visualChannels.rotationField) {
      result.getIconAngle = negateAccessor(getSizeAccessor(visualChannels.rotationField, undefined, null, undefined, data));
    }
  }

  return result;
}
//# sourceMappingURL=parseMap.js.map