import { getDefaultCredentials, buildMapsUrlFromBase, buildStatsUrlFromBase } from '../config';
import { API_VERSIONS, COLUMNS_SUPPORT, encodeParameter, FORMATS, GEO_COLUMN_SUPPORT, MAP_TYPES, TILE_FORMATS } from './maps-api-common';
import { parseMap } from './parseMap';
import { log } from '@deck.gl/core';
import { assert } from '../utils';
const MAX_GET_LENGTH = 2048;
const DEFAULT_CLIENT = 'deck-gl-carto';

async function request({
  method,
  url,
  headers: customHeaders,
  accessToken,
  body
}) {
  const headers = { ...customHeaders,
    Accept: 'application/json'
  };

  if (accessToken) {
    headers.Authorization = "Bearer ".concat(accessToken);
  }

  if (method === 'POST') {
    headers['Content-Type'] = 'application/json';
  }

  try {
    return await fetch(url, {
      method,
      headers,
      body
    });
  } catch (error) {
    throw new Error("Failed to connect to Maps API: ".concat(error));
  }
}

async function requestJson({
  method,
  url,
  headers,
  accessToken,
  body
}) {
  const response = await request({
    method,
    url,
    headers,
    accessToken,
    body
  });
  const json = await response.json();

  if (!response.ok) {
    dealWithError({
      response,
      error: json.error
    });
  }

  return json;
}

async function requestData({
  method,
  url,
  accessToken,
  format,
  body
}) {
  if (format === FORMATS.NDJSON) {
    return request({
      method,
      url,
      accessToken,
      body
    });
  }

  const data = await requestJson({
    method,
    url,
    accessToken,
    body
  });
  return data.rows ? data.rows : data;
}

function dealWithError({
  response,
  error
}) {
  switch (response.status) {
    case 400:
      throw new Error("Bad request. ".concat(error));

    case 401:
    case 403:
      throw new Error("Unauthorized access. ".concat(error));

    default:
      throw new Error(error);
  }
}

function getParameters({
  type,
  source,
  geoColumn,
  columns,
  clientId,
  aggregationExp,
  aggregationResLevel,
  queryParameters
}) {
  const parameters = [encodeParameter('client', clientId || DEFAULT_CLIENT)];
  const sourceName = type === MAP_TYPES.QUERY ? 'q' : 'name';
  parameters.push(encodeParameter(sourceName, source));

  if (queryParameters) {
    parameters.push(encodeParameter('queryParameters', JSON.stringify(queryParameters)));
  }

  if (geoColumn) {
    parameters.push(encodeParameter('geo_column', geoColumn));
  }

  if (columns) {
    parameters.push(encodeParameter('columns', columns.join(',')));
  }

  if (aggregationExp) {
    parameters.push(encodeParameter('aggregationExp', aggregationExp));
  } else if (isSpatialIndexGeoColumn(geoColumn)) {
    parameters.push(encodeParameter('aggregationExp', '1 AS value'));
  }

  if (aggregationResLevel) {
    parameters.push(encodeParameter('aggregationResLevel', aggregationResLevel));
  }

  return parameters.join('&');
}

function isSpatialIndexGeoColumn(geoColumn) {
  const spatialIndex = geoColumn === null || geoColumn === void 0 ? void 0 : geoColumn.split(':')[0];
  return spatialIndex === 'h3' || spatialIndex === 'quadbin';
}

export async function mapInstantiation({
  type,
  source,
  connection,
  credentials,
  geoColumn,
  columns,
  clientId,
  headers,
  aggregationExp,
  aggregationResLevel,
  queryParameters
}) {
  const baseUrl = "".concat(credentials.mapsUrl, "/").concat(connection, "/").concat(type);
  const url = "".concat(baseUrl, "?").concat(getParameters({
    type,
    source,
    geoColumn,
    columns,
    clientId,
    aggregationResLevel,
    aggregationExp,
    queryParameters
  }));
  const {
    accessToken
  } = credentials;

  if (url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY) {
    const body = JSON.stringify({
      q: source,
      client: clientId || DEFAULT_CLIENT,
      queryParameters
    });
    return await requestJson({
      method: 'POST',
      url: baseUrl,
      headers,
      accessToken,
      body
    });
  }

  return await requestJson({
    url,
    headers,
    accessToken
  });
}

function getUrlFromMetadata(metadata, format) {
  const m = metadata[format];

  if (m && !m.error && m.url) {
    return m.url[0];
  }

  return null;
}

function checkFetchLayerDataParameters({
  type,
  source,
  connection,
  credentials,
  geoColumn,
  columns,
  aggregationExp,
  aggregationResLevel
}) {
  assert(connection, 'Must define connection');
  assert(type, 'Must define a type');
  assert(source, 'Must define a source');
  assert(credentials.apiVersion === API_VERSIONS.V3, 'Method only available for v3');
  assert(credentials.apiBaseUrl, 'Must define apiBaseUrl');
  assert(credentials.accessToken, 'Must define an accessToken');

  if (columns) {
    assert(COLUMNS_SUPPORT.includes(type), "The columns parameter is not supported by type ".concat(type));
  }

  if (geoColumn) {
    assert(GEO_COLUMN_SUPPORT.includes(type), "The geoColumn parameter is not supported by type ".concat(type));
  } else {
    assert(!aggregationExp, 'Have aggregationExp, but geoColumn parameter is missing');
    assert(!aggregationResLevel, 'Have aggregationResLevel, but geoColumn parameter is missing');
  }

  if (!aggregationExp) {
    assert(!aggregationResLevel, 'Have aggregationResLevel, but aggregationExp parameter is missing');
  }
}

export async function fetchLayerData({
  type,
  source,
  connection,
  credentials,
  geoColumn,
  columns,
  format,
  formatTiles,
  clientId,
  headers,
  aggregationExp,
  aggregationResLevel,
  queryParameters
}) {
  const {
    url,
    accessToken,
    mapFormat,
    metadata
  } = await _fetchDataUrl({
    type,
    source,
    connection,
    credentials,
    geoColumn,
    columns,
    format,
    formatTiles,
    clientId,
    headers,
    aggregationExp,
    aggregationResLevel,
    queryParameters
  });
  const data = await requestData({
    url,
    format: mapFormat,
    accessToken
  });
  const result = {
    data,
    format: mapFormat,
    schema: metadata.schema
  };
  return result;
}

async function _fetchDataUrl({
  type,
  source,
  connection,
  credentials,
  geoColumn,
  columns,
  format,
  formatTiles,
  clientId,
  headers,
  aggregationExp,
  aggregationResLevel,
  queryParameters
}) {
  const defaultCredentials = getDefaultCredentials();
  const localCreds = { ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),
    ...credentials
  };
  checkFetchLayerDataParameters({
    type,
    source,
    connection,
    credentials: localCreds,
    geoColumn,
    columns,
    aggregationExp,
    aggregationResLevel
  });

  if (!localCreds.mapsUrl) {
    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);
  }

  const metadata = await mapInstantiation({
    type,
    source,
    connection,
    credentials: localCreds,
    geoColumn,
    columns,
    clientId,
    headers,
    aggregationExp,
    aggregationResLevel,
    queryParameters
  });
  let url = null;
  let mapFormat;

  if (format) {
    mapFormat = format;
    url = getUrlFromMetadata(metadata, format);
    assert(url, "Format ".concat(format, " not available"));
  } else {
    const prioritizedFormats = [FORMATS.GEOJSON, FORMATS.JSON, FORMATS.NDJSON, FORMATS.TILEJSON];

    for (const f of prioritizedFormats) {
      url = getUrlFromMetadata(metadata, f);

      if (url) {
        mapFormat = f;
        break;
      }
    }

    assert(url && mapFormat, 'Unsupported data formats received from backend.');
  }

  if (format === FORMATS.TILEJSON && formatTiles) {
    log.assert(Object.values(TILE_FORMATS).includes(formatTiles), "Invalid value for formatTiles: ".concat(formatTiles, ". Use value from TILE_FORMATS"));
    url += "&".concat(encodeParameter('formatTiles', formatTiles));
  }

  const {
    accessToken
  } = localCreds;
  return {
    url,
    accessToken,
    mapFormat,
    metadata
  };
}

async function _fetchMapDataset(dataset, accessToken, credentials, clientId, headers) {
  const {
    aggregationExp,
    aggregationResLevel,
    connectionName: connection,
    columns,
    format,
    geoColumn,
    source,
    type,
    queryParameters
  } = dataset;
  const {
    url,
    mapFormat
  } = await _fetchDataUrl({
    aggregationExp,
    aggregationResLevel,
    clientId,
    credentials: { ...credentials,
      accessToken
    },
    connection,
    columns,
    format,
    geoColumn,
    headers,
    source,
    type,
    queryParameters
  });
  const cache = parseInt(new URL(url).searchParams.get('cache') || '', 10);

  if (cache && dataset.cache === cache) {
    return false;
  }

  dataset.cache = cache;
  dataset.data = await requestData({
    url,
    format: mapFormat,
    accessToken
  });
  return true;
}

async function _fetchTilestats(attribute, dataset, accessToken, credentials) {
  const {
    connectionName: connection,
    source,
    type
  } = dataset;
  const statsUrl = buildStatsUrlFromBase(credentials.apiBaseUrl);
  let url = "".concat(statsUrl, "/").concat(connection, "/");

  if (type === MAP_TYPES.QUERY) {
    url += "".concat(attribute, "?q=").concat(source);
  } else {
    url += "".concat(source, "/").concat(attribute);
  }

  const stats = await requestData({
    url,
    format: FORMATS.JSON,
    accessToken
  });
  const {
    attributes
  } = dataset.data.tilestats.layers[0];
  const index = attributes.findIndex(d => d.attribute === attribute);
  attributes[index] = stats;
  return true;
}

async function fillInMapDatasets({
  datasets,
  token
}, clientId, credentials, headers) {
  const promises = datasets.map(dataset => _fetchMapDataset(dataset, token, credentials, clientId, headers));
  return await Promise.all(promises);
}

async function fillInTileStats({
  datasets,
  keplerMapConfig,
  token
}, credentials) {
  const attributes = [];
  const {
    layers
  } = keplerMapConfig.config.visState;

  for (const layer of layers) {
    for (const channel of Object.keys(layer.visualChannels)) {
      var _layer$visualChannels;

      const attribute = (_layer$visualChannels = layer.visualChannels[channel]) === null || _layer$visualChannels === void 0 ? void 0 : _layer$visualChannels.name;

      if (attribute) {
        const dataset = datasets.find(d => d.id === layer.config.dataId);

        if (dataset.data.tilestats && dataset.type !== MAP_TYPES.TILESET) {
          attributes.push({
            attribute,
            dataset
          });
        }
      }
    }
  }

  const filteredAttributes = [];

  for (const a of attributes) {
    if (!filteredAttributes.find(({
      attribute,
      dataset
    }) => attribute === a.attribute && dataset === a.dataset)) {
      filteredAttributes.push(a);
    }
  }

  const promises = filteredAttributes.map(({
    attribute,
    dataset
  }) => _fetchTilestats(attribute, dataset, token, credentials));
  return await Promise.all(promises);
}

export async function fetchMap({
  cartoMapId,
  clientId,
  credentials,
  headers,
  autoRefresh,
  onNewData
}) {
  const defaultCredentials = getDefaultCredentials();
  const localCreds = { ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),
    ...credentials
  };
  const {
    accessToken
  } = localCreds;
  assert(cartoMapId, 'Must define CARTO map id: fetchMap({cartoMapId: "XXXX-XXXX-XXXX"})');
  assert(localCreds.apiVersion === API_VERSIONS.V3, 'Method only available for v3');
  assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');

  if (!localCreds.mapsUrl) {
    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);
  }

  if (autoRefresh || onNewData) {
    assert(onNewData, 'Must define `onNewData` when using autoRefresh');
    assert(typeof onNewData === 'function', '`onNewData` must be a function');
    assert(typeof autoRefresh === 'number' && autoRefresh > 0, '`autoRefresh` must be a positive number');
  }

  const url = "".concat(localCreds.mapsUrl, "/public/").concat(cartoMapId);
  const map = await requestJson({
    url,
    headers,
    accessToken
  });
  let stopAutoRefresh;

  if (autoRefresh) {
    const intervalId = setInterval(async () => {
      const changed = await fillInMapDatasets(map, clientId, localCreds, headers);

      if (onNewData && changed.some(v => v === true)) {
        onNewData(parseMap(map));
      }
    }, autoRefresh * 1000);

    stopAutoRefresh = () => {
      clearInterval(intervalId);
    };
  }

  const geojsonLayers = map.keplerMapConfig.config.visState.layers.filter(({
    type
  }) => type === 'geojson' || type === 'point');
  const geojsonDatasetIds = geojsonLayers.map(({
    config
  }) => config.dataId);
  map.datasets.forEach(dataset => {
    if (geojsonDatasetIds.includes(dataset.id)) {
      dataset.format = 'geojson';
    }
  });
  await fillInMapDatasets(map, clientId, localCreds, headers);
  await fillInTileStats(map, localCreds);
  return { ...parseMap(map),
    ...{
      stopAutoRefresh
    }
  };
}
//# sourceMappingURL=maps-v3-client.js.map