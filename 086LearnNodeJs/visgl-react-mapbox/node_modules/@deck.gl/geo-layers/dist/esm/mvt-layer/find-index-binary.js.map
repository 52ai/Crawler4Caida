{"version":3,"sources":["../../../src/mvt-layer/find-index-binary.ts"],"names":["GEOM_TYPES","findIndexBinary","data","uniqueIdProperty","featureId","layerName","gt","index","findIndexByType","geomData","featureIds","value","length","startFeatureIndex","endFeatureIndex","layerRange","getLayerRange","featureIndex","numericProps","vertexIndex","findIndex","x","i","globalFeatureIds","properties","elem","fields","id","getGlobalFeatureId","__layers","layerNames","key","__ids","result","array","predicate","startIndex","endIndex"],"mappings":"AASA,MAAMA,UAAU,GAAG,CAAC,QAAD,EAAW,OAAX,EAAoB,UAApB,CAAnB;AAUA,eAAe,SAASC,eAAT,CACbC,IADa,EAEbC,gBAFa,EAGbC,SAHa,EAIbC,SAJa,EAKL;AACR,OAAK,MAAMC,EAAX,IAAiBN,UAAjB,EAA6B;AAC3B,UAAMO,KAAK,GAAGL,IAAI,CAACI,EAAD,CAAJ,IAAYE,eAAe,CAACN,IAAI,CAACI,EAAD,CAAL,EAAWH,gBAAX,EAA6BC,SAA7B,EAAwCC,SAAxC,CAAzC;;AACA,QAAIE,KAAK,IAAI,CAAb,EAAgB;AACd,aAAOA,KAAP;AACD;AACF;;AAED,SAAO,CAAC,CAAR;AACD;;AAED,SAASC,eAAT,CACEC,QADF,EAEEN,gBAFF,EAGEC,SAHF,EAIEC,SAJF,EAKU;AACR,QAAMK,UAAU,GAAGD,QAAQ,CAACC,UAAT,CAAoBC,KAAvC;;AAEA,MAAI,CAACD,UAAU,CAACE,MAAhB,EAAwB;AACtB,WAAO,CAAC,CAAR;AACD;;AAED,MAAIC,iBAAiB,GAAG,CAAxB;AACA,MAAIC,eAAe,GAAGJ,UAAU,CAACA,UAAU,CAACE,MAAX,GAAoB,CAArB,CAAV,GAAoC,CAA1D;;AACA,MAAIP,SAAJ,EAAe;AACb,UAAMU,UAAU,GAAGC,aAAa,CAACP,QAAD,EAAWJ,SAAX,CAAhC;;AACA,QAAIU,UAAJ,EAAgB;AACdF,MAAAA,iBAAiB,GAAGE,UAAU,CAAC,CAAD,CAA9B;AACAD,MAAAA,eAAe,GAAGC,UAAU,CAAC,CAAD,CAAV,GAAgB,CAAlC;AACD,KAHD,MAGO;AACL,aAAO,CAAC,CAAR;AACD;AACF;;AAGD,MAAIE,YAAY,GAAG,CAAC,CAApB;;AACA,MAAId,gBAAgB,IAAIM,QAAQ,CAACS,YAAjC,EAA+C;AAC7C,UAAMC,WAAW,GAAGV,QAAQ,CAACS,YAAT,CAAsBf,gBAAtB,EAAwCQ,KAAxC,CAA8CS,SAA9C,CAClB,CAACC,CAAD,EAAIC,CAAJ,KACED,CAAC,KAAKjB,SAAN,IAAmBM,UAAU,CAACY,CAAD,CAAV,IAAiBT,iBAApC,IAAyDH,UAAU,CAACY,CAAD,CAAV,GAAgBR,eAFzD,CAApB;AAIA,WAAOK,WAAW,IAAI,CAAf,GAAmBV,QAAQ,CAACc,gBAAT,CAA0BZ,KAA1B,CAAgCQ,WAAhC,CAAnB,GAAkE,CAAC,CAA1E;AACD,GAND,MAMO,IAAIhB,gBAAJ,EAAsB;AAC3Bc,IAAAA,YAAY,GAAGG,SAAS,CACtBX,QAAQ,CAACe,UADa,EAEtBC,IAAI,IAAIA,IAAI,CAACtB,gBAAD,CAAJ,KAA2BC,SAFb,EAGtBS,iBAHsB,EAItBC,eAJsB,CAAxB;AAMD,GAPM,MAOA,IAAIL,QAAQ,CAACiB,MAAb,EAAqB;AAC1BT,IAAAA,YAAY,GAAGG,SAAS,CACtBX,QAAQ,CAACiB,MADa,EAErBD,IAAD,IAAeA,IAAI,CAACE,EAAL,KAAYvB,SAFL,EAGtBS,iBAHsB,EAItBC,eAJsB,CAAxB;AAMD;;AACD,SAAOG,YAAY,IAAI,CAAhB,GAAoBW,kBAAkB,CAACnB,QAAD,EAAWQ,YAAX,CAAtC,GAAiE,CAAC,CAAzE;AACD;;AAMD,SAASD,aAAT,CACEP,QADF,EAIEJ,SAJF,EAK0B;AACxB,MAAI,CAACI,QAAQ,CAACoB,QAAd,EAAwB;AAEtB,UAAMC,UAAsC,GAAG,EAA/C;AACA,UAAM;AAACN,MAAAA;AAAD,QAAef,QAArB;;AACA,SAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGE,UAAU,CAACZ,MAA/B,EAAuCU,CAAC,EAAxC,EAA4C;AAC1C,YAAM;AAACjB,QAAAA,SAAS,EAAE0B;AAAZ,UAAmBP,UAAU,CAACF,CAAD,CAAnC;;AACA,UAAI,CAACS,GAAL,EAAU,CAET,CAFD,MAEO,IAAID,UAAU,CAACC,GAAD,CAAd,EAAqB;AAC1BD,QAAAA,UAAU,CAACC,GAAD,CAAV,CAAgB,CAAhB,IAAqBT,CAArB;AACD,OAFM,MAEA;AACLQ,QAAAA,UAAU,CAACC,GAAD,CAAV,GAAkB,CAACT,CAAD,EAAIA,CAAJ,CAAlB;AACD;AACF;;AACDb,IAAAA,QAAQ,CAACoB,QAAT,GAAoBC,UAApB;AACD;;AACD,SAAOrB,QAAQ,CAACoB,QAAT,CAAkBxB,SAAlB,CAAP;AACD;;AAGD,SAASuB,kBAAT,CAA4BnB,QAA5B,EAAsCQ,YAAtC,EAA4D;AAC1D,MAAI,CAACR,QAAQ,CAACuB,KAAd,EAAqB;AAEnB,UAAMC,MAAgB,GAAG,EAAzB;AACA,UAAMvB,UAAU,GAAGD,QAAQ,CAACC,UAAT,CAAoBC,KAAvC;AACA,UAAMY,gBAAgB,GAAGd,QAAQ,CAACc,gBAAT,CAA0BZ,KAAnD;;AACA,SAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,UAAU,CAACE,MAA/B,EAAuCU,CAAC,EAAxC,EAA4C;AAC1CW,MAAAA,MAAM,CAACvB,UAAU,CAACY,CAAD,CAAX,CAAN,GAAwBC,gBAAgB,CAACD,CAAD,CAAxC;AACD;;AACDb,IAAAA,QAAQ,CAACuB,KAAT,GAAiBC,MAAjB;AACD;;AACD,SAAOxB,QAAQ,CAACuB,KAAT,CAAef,YAAf,CAAP;AACD;;AAGD,SAASG,SAAT,CACEc,KADF,EAEEC,SAFF,EAGEC,UAHF,EAIEC,QAJF,EAKU;AACR,OAAK,IAAIf,CAAC,GAAGc,UAAb,EAAyBd,CAAC,GAAGe,QAA7B,EAAuCf,CAAC,EAAxC,EAA4C;AAC1C,QAAIa,SAAS,CAACD,KAAK,CAACZ,CAAD,CAAN,EAAWA,CAAX,CAAb,EAA4B;AAC1B,aAAOA,CAAP;AACD;AACF;;AACD,SAAO,CAAC,CAAR;AACD","sourcesContent":["import type {\n  BinaryFeatures,\n  BinaryLineFeatures,\n  BinaryPointFeatures,\n  BinaryPolygonFeatures\n} from '@loaders.gl/schema';\n\ntype FeatureTypes = BinaryPointFeatures | BinaryLineFeatures | BinaryPolygonFeatures;\n\nconst GEOM_TYPES = ['points', 'lines', 'polygons'];\n/**\n * Return the index of feature (numericProps or featureIds) for given feature id\n * Example: findIndexBinary(data, 'id', 33) will return the index in the array of numericProps\n * of the feature 33.\n * @param {Object} data - The data in binary format\n * @param {String} uniqueIdProperty - Name of the unique id property\n * @param {Number|String} featureId - feature id to find\n * @param {String} layerName - the layer to search in\n */\nexport default function findIndexBinary(\n  data: BinaryFeatures,\n  uniqueIdProperty: string,\n  featureId: string | number,\n  layerName: string\n): number {\n  for (const gt of GEOM_TYPES) {\n    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);\n    if (index >= 0) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(\n  geomData: FeatureTypes,\n  uniqueIdProperty: string,\n  featureId: string | number,\n  layerName: string\n): number {\n  const featureIds = geomData.featureIds.value;\n\n  if (!featureIds.length) {\n    return -1;\n  }\n\n  let startFeatureIndex = 0;\n  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;\n  if (layerName) {\n    const layerRange = getLayerRange(geomData, layerName);\n    if (layerRange) {\n      startFeatureIndex = layerRange[0];\n      endFeatureIndex = layerRange[1] + 1;\n    } else {\n      return -1;\n    }\n  }\n\n  // Look for the uniqueIdProperty\n  let featureIndex = -1;\n  if (uniqueIdProperty in geomData.numericProps) {\n    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex(\n      (x, i) =>\n        x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex\n    );\n    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;\n  } else if (uniqueIdProperty) {\n    featureIndex = findIndex(\n      geomData.properties,\n      elem => elem[uniqueIdProperty] === featureId,\n      startFeatureIndex,\n      endFeatureIndex\n    );\n  } else if (geomData.fields) {\n    featureIndex = findIndex(\n      geomData.fields,\n      (elem: any) => elem.id === featureId,\n      startFeatureIndex,\n      endFeatureIndex\n    );\n  }\n  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;\n}\n\ntype LayerRange = [firstFeatureIndex: number, lastFeatureIndex: number];\n\n// Returns [firstFeatureIndex, lastFeatureIndex]\n// MVTLoader parses tiles layer-by-layer, so each layer is a continuous range\nfunction getLayerRange(\n  geomData: FeatureTypes & {\n    __layers?: Record<string, LayerRange>;\n  },\n  layerName: string\n): LayerRange | undefined {\n  if (!geomData.__layers) {\n    // Cache a map from properties.layerName to index ranges\n    const layerNames: Record<string, LayerRange> = {};\n    const {properties} = geomData;\n    for (let i = 0; i < properties.length; i++) {\n      const {layerName: key} = properties[i] as Record<string, any>;\n      if (!key) {\n        // ignore\n      } else if (layerNames[key]) {\n        layerNames[key][1] = i;\n      } else {\n        layerNames[key] = [i, i];\n      }\n    }\n    geomData.__layers = layerNames;\n  }\n  return geomData.__layers[layerName];\n}\n\n// Returns global feature id\nfunction getGlobalFeatureId(geomData, featureIndex: number) {\n  if (!geomData.__ids) {\n    // Cache a map from featureId to globalFeatureId\n    const result: string[] = [];\n    const featureIds = geomData.featureIds.value;\n    const globalFeatureIds = geomData.globalFeatureIds.value;\n    for (let i = 0; i < featureIds.length; i++) {\n      result[featureIds[i]] = globalFeatureIds[i];\n    }\n    geomData.__ids = result;\n  }\n  return geomData.__ids[featureIndex];\n}\n\n// Like array.findIndex, but only search within a range\nfunction findIndex<T>(\n  array: T[],\n  predicate: (v: T, index: number) => boolean,\n  startIndex: number,\n  endIndex: number\n): number {\n  for (let i = startIndex; i < endIndex; i++) {\n    if (predicate(array[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n"],"file":"find-index-binary.js"}