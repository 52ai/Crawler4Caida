{"version":3,"sources":["../../../src/contour-layer/contour-layer.ts"],"names":["DEFAULT_COLOR","DEFAULT_STROKE_WIDTH","DEFAULT_THRESHOLD","defaultProps","cellSize","type","min","max","value","getPosition","x","position","getWeight","gpuAggregation","aggregation","contours","threshold","zOffset","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ContourLayer","dimensions","setState","contourData","projectPoints","count","size","operation","AGGREGATION_OPERATION","SUM","attributeManager","getAttributeManager","add","accessor","fp64","use64bitPositions","opts","contoursChanged","oldProps","aggregationDirty","state","_updateThresholdData","getNumInstances","_generateContours","contourSegments","contourPolygons","LinesSubLayerClass","getSubLayerClass","LineLayer","BandsSubLayerClass","SolidPolygonLayer","lineLayer","length","getSubLayerProps","id","getSourcePosition","d","start","getTargetPosition","end","getColor","contour","color","getWidth","strokeWidth","bandsLayer","getPolygon","vertices","getFillColor","coordinateSystem","viewport","context","cellSizeChanged","GPUGridAggregator","isSupported","gl","log","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","boundingBox","getAttributes","gridOffset","translation","width","height","numCol","numRow","allocateResources","posOffset","slice","gridOrigin","aggregationDataDirty","isAggregationDirty","dimension","compareAll","aggregationWeightsDirty","_updateAccessors","_resetResults","getValue","aggregationData","thresholdData","aggregationBuffer","getData","getCellData","countsData","cellWeights","gridSize","xOffset","yOffset","Array","i","zIndex","GridAggregationLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {LineLayer, SolidPolygonLayer} from '@deck.gl/layers';\nimport {generateContours} from './contour-utils';\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  Layer,\n  log,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\n\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_THRESHOLD = 1;\n\nconst defaultProps: DefaultProps<ContourLayerProps> = {\n  // grid aggregation\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  gpuAggregation: true,\n  aggregation: 'SUM',\n\n  // contour lines\n  contours: [{threshold: DEFAULT_THRESHOLD}],\n\n  zOffset: 0.005\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\n/** All properties supported by ContourLayer. */\nexport type ContourLayerProps<DataT = any> = _ContourLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by ContourLayer. */\nexport type _ContourLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\n   * @default true\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation, valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'.\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Definition of contours to be drawn.\n   * @default [{threshold: 1}]\n   */\n  contours: {\n    /**\n     * Isolines: `threshold` value must be a single `Number`, Isolines are generated based on this threshold value.\n     *\n     * Isobands: `threshold` value must be an Array of two `Number`s. Isobands are generated using `[threshold[0], threshold[1])` as threshold range, i.e area that has values `>= threshold[0]` and `< threshold[1]` are rendered with corresponding color. NOTE: `threshold[0]` is inclusive and `threshold[1]` is not inclusive.\n     */\n    threshold: number | number[];\n\n    /**\n     * RGBA color array to be used to render the contour.\n     * @default [255, 255, 255, 255]\n     */\n    color?: Color;\n\n    /**\n     * Applicable for `Isoline`s only, width of the Isoline in pixels.\n     * @default 1\n     */\n    strokeWidth?: number;\n\n    /** Defines z order of the contour. */\n    zIndex?: number;\n  }[];\n\n  /**\n   * A very small z offset that is added for each vertex of a contour (Isoline or Isoband).\n   * @default 0.005\n   */\n  zOffset?: number;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n};\n\n/** Aggregate data into iso-lines or iso-bands for a given threshold and cell size. */\nexport default class ContourLayer<DataT = any, ExtraPropsT = {}> extends GridAggregationLayer<\n  ExtraPropsT & Required<_ContourLayerProps<DataT>>\n> {\n  static layerName = 'ContourLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      contourData: {},\n      projectPoints: false,\n      weights: {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM\n        }\n      }\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>): void {\n    super.updateState(opts);\n    let contoursChanged = false;\n    const {oldProps, props} = opts;\n    const {aggregationDirty} = this.state;\n\n    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n      contoursChanged = true;\n      this._updateThresholdData(opts.props);\n    }\n\n    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n      this._generateContours();\n    }\n  }\n\n  renderLayers(): Layer[] {\n    const {contourSegments, contourPolygons} = this.state.contourData;\n\n    const LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n\n    // Contour lines layer\n    const lineLayer =\n      contourSegments &&\n      contourSegments.length > 0 &&\n      new LinesSubLayerClass(\n        this.getSubLayerProps({\n          id: 'lines'\n        }),\n        {\n          data: this.state.contourData.contourSegments,\n          getSourcePosition: d => d.start,\n          getTargetPosition: d => d.end,\n          getColor: d => d.contour.color || DEFAULT_COLOR,\n          getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH\n        }\n      );\n\n    // Contour bands layer\n    const bandsLayer =\n      contourPolygons &&\n      contourPolygons.length > 0 &&\n      new BandsSubLayerClass(\n        this.getSubLayerProps({\n          id: 'bands'\n        }),\n        {\n          data: this.state.contourData.contourPolygons,\n          getPolygon: d => d.vertices,\n          getFillColor: d => d.contour.color || DEFAULT_COLOR\n        }\n      );\n\n    return [lineLayer, bandsLayer];\n  }\n\n  // Aggregation Overrides\n\n  /* eslint-disable max-statements, complexity */\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    let gpuAggregation = props.gpuAggregation;\n    if (this.state.gpuAggregation !== props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const {dimensions} = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {data, weights} = dimensions;\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        boundingBox,\n        translation,\n        posOffset: translation.slice(), // Used for CPU aggregation, to offset points\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: data,\n        compareAll: gpuAggregation // check for all (including extentions props) when using gpu aggregation\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n  }\n  /* eslint-enable max-statements, complexity */\n\n  // Private (Aggregation)\n\n  private _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  private _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n  // Private (Contours)\n\n  private _generateContours() {\n    const {numCol, numRow, gridOrigin, gridOffset, thresholdData} = this.state;\n    const {count} = this.state.weights;\n    let {aggregationData} = count;\n    if (!aggregationData) {\n      aggregationData = count.aggregationBuffer.getData();\n      count.aggregationData = aggregationData;\n    }\n\n    const {cellWeights} = GPUGridAggregator.getCellData({countsData: aggregationData});\n    const contourData = generateContours({\n      thresholdData,\n      cellWeights,\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n    });\n\n    // contourData contains both iso-lines and iso-bands if requested.\n    this.setState({contourData});\n  }\n\n  private _updateThresholdData(props) {\n    const {contours, zOffset} = props;\n    const count = contours.length;\n    const thresholdData = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const contour = contours[i];\n      thresholdData[i] = {\n        contour,\n        zIndex: contour.zIndex || i,\n        zOffset\n      };\n    }\n    this.setState({thresholdData});\n  }\n}\n"],"file":"contour-layer.js"}