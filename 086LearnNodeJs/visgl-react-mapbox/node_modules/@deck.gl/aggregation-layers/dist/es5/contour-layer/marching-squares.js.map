{"version":3,"sources":["../../../src/contour-layer/marching-squares.ts"],"names":["CONTOUR_TYPE","ISO_LINES","ISO_BANDS","DEFAULT_THRESHOLD_DATA","zIndex","zOffset","getVertexCode","weight","threshold","Array","isArray","getCode","opts","cellWeights","x","y","width","height","thresholdValue","log","deprecated","isLeftBoundary","isRightBoundary","isBottomBoundary","isTopBoundary","isBoundary","weights","codes","top","topRight","right","current","code","Number","isFinite","meanCode","getVertices","gridOrigin","cellSize","type","thresholdData","offsets","ISOBANDS_CODE_OFFSET_MAP","ISOLINES_CODE_OFFSET_MAP","vZ","rX","rY","refVertexX","refVertexY","polygons","forEach","polygonOffsets","polygon","xyOffset","vX","vY","push","lines","xyOffsets","offset"],"mappings":"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","sourcesContent":["// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n\nimport {log} from '@deck.gl/core';\nimport {ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP} from './marching-squares-codes';\n\nexport const CONTOUR_TYPE = {\n  ISO_LINES: 1,\n  ISO_BANDS: 2\n};\n\nconst DEFAULT_THRESHOLD_DATA = {\n  zIndex: 0,\n  zOffset: 0.005\n};\n\n// Utility methods\n\nfunction getVertexCode(weight: number, threshold: number | number[]): number {\n  // threshold must be a single value or a range (array of size 2)\n\n  // Iso-bands\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  // Iso-lines\n  return weight >= threshold ? 1 : 0;\n}\n\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts) {\n  // Assumptions\n  // Origin is on bottom-left , and X increase to right, Y to top\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\n  // to create a 2X2 cell grid\n  const {cellWeights, x, y, width, height} = opts;\n  let threshold = opts.threshold;\n  if (opts.thresholdValue) {\n    log.deprecated('thresholdValue', 'threshold')();\n    threshold = opts.thresholdValue;\n  }\n\n  const isLeftBoundary = x < 0;\n  const isRightBoundary = x >= width - 1;\n  const isBottomBoundary = y < 0;\n  const isTopBoundary = y >= height - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n\n  const weights: Record<string, number> = {};\n  const codes: Record<string, number> = {};\n\n  // TOP\n  if (isLeftBoundary || isTopBoundary) {\n    codes.top = 0;\n  } else {\n    weights.top = cellWeights[(y + 1) * width + x];\n    codes.top = getVertexCode(weights.top, threshold);\n  }\n\n  // TOP-RIGHT\n  if (isRightBoundary || isTopBoundary) {\n    codes.topRight = 0;\n  } else {\n    weights.topRight = cellWeights[(y + 1) * width + x + 1];\n    codes.topRight = getVertexCode(weights.topRight, threshold);\n  }\n\n  // RIGHT\n  if (isRightBoundary || isBottomBoundary) {\n    codes.right = 0;\n  } else {\n    weights.right = cellWeights[y * width + x + 1];\n    codes.right = getVertexCode(weights.right, threshold);\n  }\n\n  // CURRENT\n  if (isLeftBoundary || isBottomBoundary) {\n    codes.current = 0;\n  } else {\n    weights.current = cellWeights[y * width + x];\n    codes.current = getVertexCode(weights.current, threshold);\n  }\n\n  const {top, topRight, right, current} = codes;\n  let code = -1;\n  if (Number.isFinite(threshold)) {\n    code = (top << 3) | (topRight << 2) | (right << 1) | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = (top << 6) | (topRight << 4) | (right << 2) | current;\n  }\n\n  let meanCode = 0;\n  // meanCode is only needed for saddle cases, and they should\n  // only occur when we are not processing a cell on boundary\n  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n  if (!isBoundary) {\n    meanCode = getVertexCode(\n      (weights.top + weights.topRight + weights.right + weights.current) / 4,\n      threshold\n    );\n  }\n  return {code, meanCode};\n}\n/* eslint-enable complexity, max-statements*/\n\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getVertices(opts) {\n  const {gridOrigin, cellSize, x, y, code, meanCode, type = CONTOUR_TYPE.ISO_LINES} = opts;\n  const thresholdData = {...DEFAULT_THRESHOLD_DATA, ...opts.thresholdData};\n  let offsets =\n    type === CONTOUR_TYPE.ISO_BANDS\n      ? ISOBANDS_CODE_OFFSET_MAP[code]\n      : ISOLINES_CODE_OFFSET_MAP[code];\n\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  // Reference vertex is at top-right move to top-right corner\n\n  const vZ = thresholdData.zIndex * thresholdData.zOffset;\n  const rX = (x + 1) * cellSize[0];\n  const rY = (y + 1) * cellSize[1];\n\n  const refVertexX = gridOrigin[0] + rX;\n  const refVertexY = gridOrigin[1] + rY;\n\n  // offsets format\n  // ISO_LINES: [[1A, 1B], [2A, 2B]],\n  // ISO_BANDS: [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n\n  // vertices format\n\n  // ISO_LINES: [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n\n  // ISO_BANDS:  => confirms to SolidPolygonLayer's simple polygon format\n  //      [\n  //        [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n  //        ...\n  //      ]\n\n  if (type === CONTOUR_TYPE.ISO_BANDS) {\n    const polygons: number[][][] = [];\n    offsets.forEach(polygonOffsets => {\n      const polygon: number[][] = [];\n      polygonOffsets.forEach(xyOffset => {\n        const vX = refVertexX + xyOffset[0] * cellSize[0];\n        const vY = refVertexY + xyOffset[1] * cellSize[1];\n        polygon.push([vX, vY, vZ]);\n      });\n      polygons.push(polygon);\n    });\n    return polygons;\n  }\n\n  // default case is ISO_LINES\n  const lines: number[][] = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = refVertexX + offset[0] * cellSize[0];\n      const vY = refVertexY + offset[1] * cellSize[1];\n      lines.push([vX, vY, vZ]);\n    });\n  });\n  return lines;\n}\n"],"file":"marching-squares.js"}