{"version":3,"sources":["../../../src/gpu-grid-layer/gpu-grid-layer.ts"],"names":["defaultProps","colorDomain","colorRange","defaultColorRange","getColorWeight","type","value","colorAggregation","elevationDomain","elevationRange","getElevationWeight","elevationAggregation","elevationScale","min","cellSize","max","coverage","getPosition","x","position","extruded","material","DIMENSIONS","data","props","POSITION_ATTRIBUTE_NAME","GPUGridLayer","gl","isSupported","GPUGridAggregator","log","error","dimensions","setState","gpuAggregation","projectPoints","weights","color","needMin","needMax","combineMaxMin","maxMinBuffer","Buffer","byteLength","accessor","size","divisor","elevation","positionAttributeName","attributeManager","getAttributeManager","add","fp64","use64bitPositions","opts","state","aggregationDirty","gridHash","index","numRow","numCol","boundingBox","gridOffset","gridSize","gridOrigin","xMin","yMin","xOffset","yOffset","yIndex","Math","floor","xIndex","latIdx","lonIdx","yPos","xPos","info","mode","object","gpuGridAggregator","getPositionForIndex","colorInfo","getAggregationData","pixelIndex","getData","elevationInfo","colorValue","cellWeight","elevationValue","count","cellCount","totalCount","translation","viewport","context","attributes","getAttributes","cpuAggregation","key","getHashKeyForIndex","cpuAggregationData","Object","assign","picked","Boolean","cellSizeMeters","SubLayerClass","getSubLayerClass","GPUGridCellLayer","getSubLayerProps","id","colors","aggregationBuffer","elevations","colorMaxMinBuffer","elevationMaxMinBuffer","numInstances","forEach","weight","delete","oldProps","coordinateSystem","cellSizeChanged","positionsChanged","isAttributeChanged","attributesChanged","getNumInstances","width","height","allocateResources","aggregationDataDirty","isAggregationDirty","dimension","compareAll","_updateAccessors","operation","AGGREGATION_OPERATION","GridAggregationLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Buffer} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  Material,\n  GetPickingInfoParams,\n  LayerContext,\n  log,\n  PickingInfo,\n  Position,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION} from '../utils/aggregation-operation-utils';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport {pointToDensityGridDataCPU} from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\n\nconst defaultProps: DefaultProps<GPUGridLayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: x => x.position},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n// This layer only perform GPU aggregation, no need to seperate data and weight props\n// aggregation will be dirty when any of the props are changed.\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n  // rest of the changes are detected by `state.attributesChanged`\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\n/** All properties supported by GPUGridLayer. */\nexport type GPUGridLayerProps<DataT = any> = _GPUGridLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by GPUGridLayer. */\nexport type _GPUGridLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\n   */\n  colorRange?: Color[];\n\n  /**\n   * Cell size multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Cell elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * @default 'SUM'\n   */\n  colorAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * @default 'SUM'\n   */\n  elevationAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a cell.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a cell.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n};\n\n/** Aggregate data into a grid-based heatmap. Aggregation is performed on GPU (WebGL2 only). */\nexport default class GPUGridLayer<DataT = any, ExtraPropsT = {}> extends GridAggregationLayer<\n  ExtraPropsT & Required<_GPUGridLayerProps<DataT>>\n> {\n  static layerName = 'GPUGridLayer';\n  static defaultProps = defaultProps;\n\n  initializeState({gl}: LayerContext): void {\n    const isSupported = GPUGridAggregator.isSupported(gl);\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false, // aggregation in world space\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      color: {size: 3, accessor: 'getColorWeight'},\n      elevation: {size: 3, accessor: 'getElevationWeight'}\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      // Skip update, layer not supported\n      return;\n    }\n    super.updateState(opts);\n    const {aggregationDirty} = this.state;\n    if (aggregationDirty) {\n      // reset cached CPU Aggregation results (used for picking)\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index: number): string {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    // This will match the index to the hash-key to access aggregation data from CPU aggregation results.\n    const latIdx = Math.floor(\n      (yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]\n    );\n    const lonIdx = Math.floor(\n      (xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]\n    );\n    return `${latIdx}-${lonIdx}`;\n  }\n\n  getPositionForIndex(index: number): Position {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo({info, mode}: GetPickingInfoParams): PickingInfo {\n    const {index} = info;\n    let object: any = null;\n    if (index >= 0) {\n      const {gpuGridAggregator} = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n      if (mode !== 'hover') {\n        // perform CPU aggregation for full list of points for each cell\n        const {props} = this;\n        let {gridHash} = this.state;\n        if (!gridHash) {\n          const {gridOffset, translation, boundingBox} = this.state;\n          const {viewport} = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props as any, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({gridHash});\n        }\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n\n    const {weights, numRow, numCol, gridOrigin, gridOffset} = this.state;\n    const {color, elevation} = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n\n    return new SubLayerClass(\n      {\n        gridSize: [numCol, numRow],\n        gridOrigin,\n        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n        colorRange,\n        elevationRange,\n        colorDomain,\n        elevationDomain,\n\n        cellSize: cellSizeMeters,\n        coverage,\n        material,\n        elevationScale,\n        extruded\n      },\n      this.getSubLayerProps({\n        id: 'gpu-grid-cell'\n      }),\n      {\n        data: {\n          attributes: {\n            colors: color.aggregationBuffer,\n            elevations: elevation.aggregationBuffer\n          }\n        },\n        colorMaxMinBuffer: color.maxMinBuffer,\n        elevationMaxMinBuffer: elevation.maxMinBuffer,\n        numInstances: numCol * numRow\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext) {\n    const {color, elevation} = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {aggregationBuffer, maxMinBuffer} = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer?.delete();\n    });\n    super.finalizeState(context);\n  }\n\n  // Aggregation Overrides\n\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {dimensions} = this.state;\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    // any attribute changed\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      attributesChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: dimensions.data,\n        compareAll: true\n      });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {colorAggregation, elevationAggregation} = opts.props;\n    const {color, elevation} = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n}\n"],"file":"gpu-grid-layer.js"}