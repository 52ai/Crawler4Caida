{"version":3,"sources":["../../src/grid-aggregation-layer.ts"],"names":["GridAggregationLayer","dimensions","gl","context","setState","layerData","gpuGridAggregator","GPUGridAggregator","id","cpuGridAggregator","pointToDensityGridDataCPU","opts","updateAggregationState","state","aggregationDataDirty","aggregationWeightsDirty","gpuAggregation","getNumInstances","aggregationDirty","_updateAggregation","_updateWeightBins","_uploadAggregationResults","count","weights","aggregationBuffer","delete","shaders","updateShaders","log","assert","numRow","numCol","dataBytes","name","weight","Buffer","byteLength","accessor","size","type","divisor","aggregationData","maxMinData","maxData","minData","gridOffset","posOffset","translation","scaling","boundingBox","projectPoints","props","viewport","attributes","getAttributes","vertexCount","result","run","cellSize","xOffset","yOffset","moduleSettings","getModuleSettings","getValue","sortedBins","BinSorter","data","aggregatedBins","minValue","maxValue","totalCount","ELEMENTCOUNT","aggregationSize","Float32Array","fill","bin","i","lonIdx","latIdx","value","counts","cellIndex","updateResults","AggregationLayer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport AggregationLayer, {AggregationLayerProps} from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {Buffer} from '@luma.gl/core';\nimport {LayerContext, log, UpdateParameters} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport BinSorter from './utils/bin-sorter';\nimport {pointToDensityGridDataCPU} from './cpu-grid-layer/grid-aggregator';\n\nexport type GridAggregationLayerProps<DataT = any> = AggregationLayerProps<DataT>;\n\nexport default abstract class GridAggregationLayer<\n  ExtraPropsT = {}\n> extends AggregationLayer<ExtraPropsT> {\n  static layerName = 'GridAggregationLayer';\n\n  state!: AggregationLayer['state'] & {\n    aggregationDataDirty?: any;\n    aggregationWeightsDirty?: any;\n    gpuAggregation?: any;\n    getValue?: () => any;\n    sortedBins?: BinSorter;\n  };\n\n  initializeAggregationLayer({dimensions}) {\n    const {gl} = this.context;\n    super.initializeAggregationLayer(dimensions);\n    this.setState({\n      // CPU aggregation results\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {id: `${this.id}-gpu-aggregator`}),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    // get current attributes\n    super.updateState(opts);\n\n    this.updateAggregationState(opts);\n\n    const {aggregationDataDirty, aggregationWeightsDirty, gpuAggregation} = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    // CPU aggregation is two steps\n    // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin\n    // For GPU aggregation both above steps are combined into one step\n\n    // step-1\n    if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    // step-2 (Applicalbe for CPU aggregation only)\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n\n    this.setState({aggregationDirty});\n  }\n\n  finalizeState(context: LayerContext) {\n    const {count} = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    this.state.gpuGridAggregator?.delete();\n    super.finalizeState(context);\n  }\n\n  updateShaders(shaders: any): void {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  // Methods that can be overriden by subclasses for customizations\n\n  updateAggregationState(opts) {\n    // Sublayers should implement this method.\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {weights} = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: GL.FLOAT,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({aggregationData, maxMinData, maxData, minData}) {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  // Private\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {props} = opts;\n    const {viewport} = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {weights} = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {getValue} = this.state;\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {getValue});\n    this.setState({sortedBins});\n  }\n\n  _uploadAggregationResults(): void {\n    const {numCol, numRow} = this.state;\n    const {data} = this.state.layerData;\n    const {aggregatedBins, minValue, maxValue, totalCount} = this.state.sortedBins!;\n\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {lonIdx, latIdx} = data[bin.i];\n      const {value, counts} = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({aggregationData, maxMinData, maxData, minData});\n  }\n}\n"],"file":"grid-aggregation-layer.js"}