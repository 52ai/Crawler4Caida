{"version":3,"sources":["../../../src/heatmap-layer/heatmap-layer-utils.ts"],"names":["getBounds","points","x","map","p","y","xMin","Math","min","apply","xMax","max","yMin","yMax","boundsContain","currentBounds","targetBounds","scratchArray","Float32Array","packVertices","dimensions","index","point","i","scaleToAspectRatio","boundingBox","width","height","currentWidth","currentHeight","newWidth","newHeight","xCenter","yCenter","getTextureCoordinates","bounds","getTextureParams","gl","floatTargetSupport","format","type"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {isWebGL2} from '@luma.gl/core';\n\nexport function getBounds(points: number[][]): number[] {\n  // Now build bounding box in world space (aligned to world coordiante system)\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n\n  return [xMin, yMin, xMax, yMax];\n}\n\n// true if currentBounds contains targetBounds, false otherwise\nexport function boundsContain(currentBounds: number[], targetBounds: number[]): boolean {\n  if (\n    targetBounds[0] >= currentBounds[0] &&\n    targetBounds[2] <= currentBounds[2] &&\n    targetBounds[1] >= currentBounds[1] &&\n    targetBounds[3] <= currentBounds[3]\n  ) {\n    return true;\n  }\n  return false;\n}\n\nconst scratchArray = new Float32Array(12);\n\n// For given rectangle bounds generates two triangles vertices that coverit completely\nexport function packVertices(points: number[][], dimensions: number = 2): Float32Array {\n  let index = 0;\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n  return scratchArray;\n}\n\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\nexport function scaleToAspectRatio(boundingBox: number[], width: number, height: number): number[] {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n  if (currentWidth / currentHeight < width / height) {\n    // expand bounding box width\n    newWidth = (width / height) * currentHeight;\n  } else {\n    newHeight = (height / width) * currentWidth;\n  }\n\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n\n  return [\n    xCenter - newWidth / 2,\n    yCenter - newHeight / 2,\n    xCenter + newWidth / 2,\n    yCenter + newHeight / 2\n  ];\n}\n\n// Get texture coordiante of point inside a bounding box\nexport function getTextureCoordinates(point: number[], bounds: number[]) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\n\n// Returns format and type for creating texture objects\nexport function getTextureParams({gl, floatTargetSupport}) {\n  return floatTargetSupport\n    ? {\n        // format:  should be RGBA32F on WebGL2 (float textures), RGBA in WebGL1 for float or non float textures\n        format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n        type: GL.FLOAT\n      }\n    : {\n        format: GL.RGBA,\n        type: GL.UNSIGNED_BYTE\n      };\n}\n"],"file":"heatmap-layer-utils.js"}