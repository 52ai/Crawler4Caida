(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["deck"] = factory();
	else
		root["deck"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./bundle.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/expression-eval/index.js":
/*!************************************************************************!*\
  !*** /Users/alasarr/dev/deck.gl/node_modules/expression-eval/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const jsep = __webpack_require__(/*! jsep */ "../../node_modules/jsep/build/jsep.js");

/**
 * Evaluation code from JSEP project, under MIT License.
 * Copyright (c) 2013 Stephen Oney, http://jsep.from.so/
 */

const binops = {
  '||':  function (a, b) { return a || b; },
  '&&':  function (a, b) { return a && b; },
  '|':   function (a, b) { return a | b; },
  '^':   function (a, b) { return a ^ b; },
  '&':   function (a, b) { return a & b; },
  '==':  function (a, b) { return a == b; }, // jshint ignore:line
  '!=':  function (a, b) { return a != b; }, // jshint ignore:line
  '===': function (a, b) { return a === b; },
  '!==': function (a, b) { return a !== b; },
  '<':   function (a, b) { return a < b; },
  '>':   function (a, b) { return a > b; },
  '<=':  function (a, b) { return a <= b; },
  '>=':  function (a, b) { return a >= b; },
  '<<':  function (a, b) { return a << b; },
  '>>':  function (a, b) { return a >> b; },
  '>>>': function (a, b) { return a >>> b; },
  '+':   function (a, b) { return a + b; },
  '-':   function (a, b) { return a - b; },
  '*':   function (a, b) { return a * b; },
  '/':   function (a, b) { return a / b; },
  '%':   function (a, b) { return a % b; }
};

const unops = {
  '-' :  function (a) { return -a; },
  '+' :  function (a) { return +a; },
  '~' :  function (a) { return ~a; },
  '!' :  function (a) { return !a; },
};

function evaluateArray ( list, context ) {
  return list.map(function (v) { return evaluate(v, context); });
}

async function evaluateArrayAsync( list, context ) {
  const res = await Promise.all(list.map((v) => evaluateAsync(v, context)));
  return res;
}

function evaluateMember ( node, context ) {
  const object = evaluate(node.object, context);
  if ( node.computed ) {
    return [object, object[evaluate(node.property, context)]];
  } else {
    return [object, object[node.property.name]];
  }
}

async function evaluateMemberAsync( node, context ) {
  const object = await evaluateAsync(node.object, context);
  if (  node.computed) {
    return [object, object[await evaluateAsync(node.property, context)]];
  } else {
    return [object, object[node.property.name]];
  }
}

function evaluate ( node, context ) {

  switch ( node.type ) {

    case 'ArrayExpression':
      return evaluateArray( node.elements, context );

    case 'BinaryExpression':
      return binops[ node.operator ]( evaluate( node.left, context ), evaluate( node.right, context ) );

    case 'CallExpression':
      let caller, fn, assign;
      if (node.callee.type === 'MemberExpression') {
        assign = evaluateMember( node.callee, context );
        caller = assign[0];
        fn = assign[1];
      } else {
        fn = evaluate( node.callee, context );
      }
      if (typeof fn  !== 'function') { return undefined; }
      return fn.apply( caller, evaluateArray( node.arguments, context ) );

    case 'ConditionalExpression':
      return evaluate( node.test, context )
        ? evaluate( node.consequent, context )
        : evaluate( node.alternate, context );

    case 'Identifier':
      return context[node.name];

    case 'Literal':
      return node.value;

    case 'LogicalExpression':
      if (node.operator === '||') {
        return evaluate( node.left, context ) || evaluate( node.right, context );
      } else if (node.operator === '&&') {
        return evaluate( node.left, context ) && evaluate( node.right, context );
      }
      return binops[ node.operator ]( evaluate( node.left, context ), evaluate( node.right, context ) );

    case 'MemberExpression':
      return evaluateMember(node, context)[1];

    case 'ThisExpression':
      return context;

    case 'UnaryExpression':
      return unops[ node.operator ]( evaluate( node.argument, context ) );

    default:
      return undefined;
  }

}

async function evaluateAsync( node, context ) {

  switch ( node.type ) {

    case 'ArrayExpression':
      return await evaluateArrayAsync( node.elements, context );

    case 'BinaryExpression': {
      const [left, right] = await Promise.all([
        evaluateAsync( node.left, context ),
        evaluateAsync( node.right, context )
      ]);
      return binops[ node.operator ]( left, right );
    }

    case 'CallExpression':
      let caller, fn, assign;
      if (node.callee.type === 'MemberExpression') {
        assign = await evaluateMemberAsync( node.callee, context );
        caller = assign[0];
        fn = assign[1];
      } else {
        fn = await evaluateAsync( node.callee, context );
      }
      if (typeof fn !== 'function') {
        return undefined;
      }
      return await fn.apply(
        caller,
        await evaluateArrayAsync( node.arguments, context )
      );

    case 'ConditionalExpression':
      return (await evaluateAsync( node.test, context ))
        ? await evaluateAsync( node.consequent, context )
        : await evaluateAsync( node.alternate, context );

    case 'Identifier':
      return context[node.name];

    case 'Literal':
      return node.value;

    case 'LogicalExpression': {
      if (node.operator === '||') {
        return (
          (await evaluateAsync( node.left, context )) ||
          (await evaluateAsync( node.right, context ))
        );
      } else if (node.operator === '&&') {
        return (
          (await evaluateAsync( node.left, context )) &&
          (await evaluateAsync( node.right, context ))
        );
      }

      const [left, right] = await Promise.all([
        evaluateAsync( node.left, context ),
        evaluateAsync( node.right, context )
      ]);

      return binops[ node.operator ]( left, right );
    }

    case 'MemberExpression':
      return (await evaluateMemberAsync(node, context))[1];

    case 'ThisExpression':
      return context;

    case 'UnaryExpression':
      return unops[ node.operator ](await evaluateAsync( node.argument, context ));

    default:
      return undefined;
  }
}

function compile (expression) {
  return evaluate.bind(null, jsep(expression));
}

function compileAsync(expression) {
  return evaluateAsync.bind(null, jsep(expression));
}

module.exports = {
  parse: jsep,
  eval: evaluate,
  evalAsync: evaluateAsync,
  compile: compile,
  compileAsync: compileAsync
};


/***/ }),

/***/ "../../node_modules/jsep/build/jsep.js":
/*!******************************************************************!*\
  !*** /Users/alasarr/dev/deck.gl/node_modules/jsep/build/jsep.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//     JavaScript Expression Parser (JSEP) 0.3.4
//     JSEP may be freely distributed under the MIT License
//     http://jsep.from.so/

/*global module: true, exports: true, console: true */
(function (root) {
	'use strict';
	// Node Types
	// ----------

	// This is the full set of types that any JSEP node can be.
	// Store them here to save space when minified
	var COMPOUND = 'Compound',
		IDENTIFIER = 'Identifier',
		MEMBER_EXP = 'MemberExpression',
		LITERAL = 'Literal',
		THIS_EXP = 'ThisExpression',
		CALL_EXP = 'CallExpression',
		UNARY_EXP = 'UnaryExpression',
		BINARY_EXP = 'BinaryExpression',
		LOGICAL_EXP = 'LogicalExpression',
		CONDITIONAL_EXP = 'ConditionalExpression',
		ARRAY_EXP = 'ArrayExpression',

		PERIOD_CODE = 46, // '.'
		COMMA_CODE  = 44, // ','
		SQUOTE_CODE = 39, // single quote
		DQUOTE_CODE = 34, // double quotes
		OPAREN_CODE = 40, // (
		CPAREN_CODE = 41, // )
		OBRACK_CODE = 91, // [
		CBRACK_CODE = 93, // ]
		QUMARK_CODE = 63, // ?
		SEMCOL_CODE = 59, // ;
		COLON_CODE  = 58, // :

		throwError = function(message, index) {
			var error = new Error(message + ' at character ' + index);
			error.index = index;
			error.description = message;
			throw error;
		},

	// Operations
	// ----------

	// Set `t` to `true` to save space (when minified, not gzipped)
		t = true,
	// Use a quickly-accessible map to store all of the unary operators
	// Values are set to `true` (it really doesn't matter)
		unary_ops = {'-': t, '!': t, '~': t, '+': t},
	// Also use a map for the binary operations but set their values to their
	// binary precedence for quick reference:
	// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)
		binary_ops = {
			'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,
			'==': 6, '!=': 6, '===': 6, '!==': 6,
			'<': 7,  '>': 7,  '<=': 7,  '>=': 7,
			'<<':8,  '>>': 8, '>>>': 8,
			'+': 9, '-': 9,
			'*': 10, '/': 10, '%': 10
		},
	// Get return the longest key length of any object
		getMaxKeyLen = function(obj) {
			var max_len = 0, len;
			for(var key in obj) {
				if((len = key.length) > max_len && obj.hasOwnProperty(key)) {
					max_len = len;
				}
			}
			return max_len;
		},
		max_unop_len = getMaxKeyLen(unary_ops),
		max_binop_len = getMaxKeyLen(binary_ops),
	// Literals
	// ----------
	// Store the values to return for the various literals we may encounter
		literals = {
			'true': true,
			'false': false,
			'null': null
		},
	// Except for `this`, which is special. This could be changed to something like `'self'` as well
		this_str = 'this',
	// Returns the precedence of a binary operator or `0` if it isn't a binary operator
		binaryPrecedence = function(op_val) {
			return binary_ops[op_val] || 0;
		},
	// Utility function (gets called from multiple places)
	// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions
		createBinaryExpression = function (operator, left, right) {
			var type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;
			return {
				type: type,
				operator: operator,
				left: left,
				right: right
			};
		},
		// `ch` is a character code in the next three functions
		isDecimalDigit = function(ch) {
			return (ch >= 48 && ch <= 57); // 0...9
		},
		isIdentifierStart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator
		},
		isIdentifierPart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
					(ch >= 48 && ch <= 57) || // 0...9
                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator
		},

		// Parsing
		// -------
		// `expr` is a string with the passed in expression
		jsep = function(expr) {
			// `index` stores the character number we are currently at while `length` is a constant
			// All of the gobbles below will modify `index` as we move along
			var index = 0,
				charAtFunc = expr.charAt,
				charCodeAtFunc = expr.charCodeAt,
				exprI = function(i) { return charAtFunc.call(expr, i); },
				exprICode = function(i) { return charCodeAtFunc.call(expr, i); },
				length = expr.length,

				// Push `index` up to the next non-space character
				gobbleSpaces = function() {
					var ch = exprICode(index);
					// space or tab
					while(ch === 32 || ch === 9 || ch === 10 || ch === 13) {
						ch = exprICode(++index);
					}
				},

				// The main parsing function. Much of this code is dedicated to ternary expressions
				gobbleExpression = function() {
					var test = gobbleBinaryExpression(),
						consequent, alternate;
					gobbleSpaces();
					if(exprICode(index) === QUMARK_CODE) {
						// Ternary expression: test ? consequent : alternate
						index++;
						consequent = gobbleExpression();
						if(!consequent) {
							throwError('Expected expression', index);
						}
						gobbleSpaces();
						if(exprICode(index) === COLON_CODE) {
							index++;
							alternate = gobbleExpression();
							if(!alternate) {
								throwError('Expected expression', index);
							}
							return {
								type: CONDITIONAL_EXP,
								test: test,
								consequent: consequent,
								alternate: alternate
							};
						} else {
							throwError('Expected :', index);
						}
					} else {
						return test;
					}
				},

				// Search for the operation portion of the string (e.g. `+`, `===`)
				// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
				// and move down from 3 to 2 to 1 character until a matching binary operation is found
				// then, return that binary operation
				gobbleBinaryOp = function() {
					gobbleSpaces();
					var biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;
					while(tc_len > 0) {
						// Don't accept a binary op when it is an identifier.
						// Binary ops that start with a identifier-valid character must be followed
						// by a non identifier-part valid character
						if(binary_ops.hasOwnProperty(to_check) && (
							!isIdentifierStart(exprICode(index)) ||
							(index+to_check.length< expr.length && !isIdentifierPart(exprICode(index+to_check.length)))
						)) {
							index += tc_len;
							return to_check;
						}
						to_check = to_check.substr(0, --tc_len);
					}
					return false;
				},

				// This function is responsible for gobbling an individual expression,
				// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
				gobbleBinaryExpression = function() {
					var ch_i, node, biop, prec, stack, biop_info, left, right, i;

					// First, try to get the leftmost thing
					// Then, check to see if there's a binary operator operating on that leftmost thing
					left = gobbleToken();
					biop = gobbleBinaryOp();

					// If there wasn't a binary operator, just return the leftmost node
					if(!biop) {
						return left;
					}

					// Otherwise, we need to start a stack to properly place the binary operations in their
					// precedence structure
					biop_info = { value: biop, prec: binaryPrecedence(biop)};

					right = gobbleToken();
					if(!right) {
						throwError("Expected expression after " + biop, index);
					}
					stack = [left, biop_info, right];

					// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
					while((biop = gobbleBinaryOp())) {
						prec = binaryPrecedence(biop);

						if(prec === 0) {
							break;
						}
						biop_info = { value: biop, prec: prec };

						// Reduce: make a binary expression from the three topmost entries.
						while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
							right = stack.pop();
							biop = stack.pop().value;
							left = stack.pop();
							node = createBinaryExpression(biop, left, right);
							stack.push(node);
						}

						node = gobbleToken();
						if(!node) {
							throwError("Expected expression after " + biop, index);
						}
						stack.push(biop_info, node);
					}

					i = stack.length - 1;
					node = stack[i];
					while(i > 1) {
						node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);
						i -= 2;
					}
					return node;
				},

				// An individual part of a binary expression:
				// e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
				gobbleToken = function() {
					var ch, to_check, tc_len;

					gobbleSpaces();
					ch = exprICode(index);

					if(isDecimalDigit(ch) || ch === PERIOD_CODE) {
						// Char code 46 is a dot `.` which can start off a numeric literal
						return gobbleNumericLiteral();
					} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
						// Single or double quotes
						return gobbleStringLiteral();
					} else if (ch === OBRACK_CODE) {
						return gobbleArray();
					} else {
						to_check = expr.substr(index, max_unop_len);
						tc_len = to_check.length;
						while(tc_len > 0) {
						// Don't accept an unary op when it is an identifier.
						// Unary ops that start with a identifier-valid character must be followed
						// by a non identifier-part valid character
							if(unary_ops.hasOwnProperty(to_check) && (
								!isIdentifierStart(exprICode(index)) ||
								(index+to_check.length < expr.length && !isIdentifierPart(exprICode(index+to_check.length)))
							)) {
								index += tc_len;
								return {
									type: UNARY_EXP,
									operator: to_check,
									argument: gobbleToken(),
									prefix: true
								};
							}
							to_check = to_check.substr(0, --tc_len);
						}

						if (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis
							// `foo`, `bar.baz`
							return gobbleVariable();
						}
					}

					return false;
				},
				// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
				// keep track of everything in the numeric literal and then calling `parseFloat` on that string
				gobbleNumericLiteral = function() {
					var number = '', ch, chCode;
					while(isDecimalDigit(exprICode(index))) {
						number += exprI(index++);
					}

					if(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker
						number += exprI(index++);

						while(isDecimalDigit(exprICode(index))) {
							number += exprI(index++);
						}
					}

					ch = exprI(index);
					if(ch === 'e' || ch === 'E') { // exponent marker
						number += exprI(index++);
						ch = exprI(index);
						if(ch === '+' || ch === '-') { // exponent sign
							number += exprI(index++);
						}
						while(isDecimalDigit(exprICode(index))) { //exponent itself
							number += exprI(index++);
						}
						if(!isDecimalDigit(exprICode(index-1)) ) {
							throwError('Expected exponent (' + number + exprI(index) + ')', index);
						}
					}


					chCode = exprICode(index);
					// Check to make sure this isn't a variable name that start with a number (123abc)
					if(isIdentifierStart(chCode)) {
						throwError('Variable names cannot start with a number (' +
									number + exprI(index) + ')', index);
					} else if(chCode === PERIOD_CODE) {
						throwError('Unexpected period', index);
					}

					return {
						type: LITERAL,
						value: parseFloat(number),
						raw: number
					};
				},

				// Parses a string literal, staring with single or double quotes with basic support for escape codes
				// e.g. `"hello world"`, `'this is\nJSEP'`
				gobbleStringLiteral = function() {
					var str = '', quote = exprI(index++), closed = false, ch;

					while(index < length) {
						ch = exprI(index++);
						if(ch === quote) {
							closed = true;
							break;
						} else if(ch === '\\') {
							// Check for all of the common escape codes
							ch = exprI(index++);
							switch(ch) {
								case 'n': str += '\n'; break;
								case 'r': str += '\r'; break;
								case 't': str += '\t'; break;
								case 'b': str += '\b'; break;
								case 'f': str += '\f'; break;
								case 'v': str += '\x0B'; break;
								default : str += ch;
							}
						} else {
							str += ch;
						}
					}

					if(!closed) {
						throwError('Unclosed quote after "'+str+'"', index);
					}

					return {
						type: LITERAL,
						value: str,
						raw: quote + str + quote
					};
				},

				// Gobbles only identifiers
				// e.g.: `foo`, `_value`, `$x1`
				// Also, this function checks if that identifier is a literal:
				// (e.g. `true`, `false`, `null`) or `this`
				gobbleIdentifier = function() {
					var ch = exprICode(index), start = index, identifier;

					if(isIdentifierStart(ch)) {
						index++;
					} else {
						throwError('Unexpected ' + exprI(index), index);
					}

					while(index < length) {
						ch = exprICode(index);
						if(isIdentifierPart(ch)) {
							index++;
						} else {
							break;
						}
					}
					identifier = expr.slice(start, index);

					if(literals.hasOwnProperty(identifier)) {
						return {
							type: LITERAL,
							value: literals[identifier],
							raw: identifier
						};
					} else if(identifier === this_str) {
						return { type: THIS_EXP };
					} else {
						return {
							type: IDENTIFIER,
							name: identifier
						};
					}
				},

				// Gobbles a list of arguments within the context of a function call
				// or array literal. This function also assumes that the opening character
				// `(` or `[` has already been gobbled, and gobbles expressions and commas
				// until the terminator character `)` or `]` is encountered.
				// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
				gobbleArguments = function(termination) {
					var ch_i, args = [], node, closed = false;
					while(index < length) {
						gobbleSpaces();
						ch_i = exprICode(index);
						if(ch_i === termination) { // done parsing
							closed = true;
							index++;
							break;
						} else if (ch_i === COMMA_CODE) { // between expressions
							index++;
						} else {
							node = gobbleExpression();
							if(!node || node.type === COMPOUND) {
								throwError('Expected comma', index);
							}
							args.push(node);
						}
					}
					if (!closed) {
						throwError('Expected ' + String.fromCharCode(termination), index);
					}
					return args;
				},

				// Gobble a non-literal variable name. This variable name may include properties
				// e.g. `foo`, `bar.baz`, `foo['bar'].baz`
				// It also gobbles function calls:
				// e.g. `Math.acos(obj.angle)`
				gobbleVariable = function() {
					var ch_i, node;
					ch_i = exprICode(index);

					if(ch_i === OPAREN_CODE) {
						node = gobbleGroup();
					} else {
						node = gobbleIdentifier();
					}
					gobbleSpaces();
					ch_i = exprICode(index);
					while(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {
						index++;
						if(ch_i === PERIOD_CODE) {
							gobbleSpaces();
							node = {
								type: MEMBER_EXP,
								computed: false,
								object: node,
								property: gobbleIdentifier()
							};
						} else if(ch_i === OBRACK_CODE) {
							node = {
								type: MEMBER_EXP,
								computed: true,
								object: node,
								property: gobbleExpression()
							};
							gobbleSpaces();
							ch_i = exprICode(index);
							if(ch_i !== CBRACK_CODE) {
								throwError('Unclosed [', index);
							}
							index++;
						} else if(ch_i === OPAREN_CODE) {
							// A function call is being made; gobble all the arguments
							node = {
								type: CALL_EXP,
								'arguments': gobbleArguments(CPAREN_CODE),
								callee: node
							};
						}
						gobbleSpaces();
						ch_i = exprICode(index);
					}
					return node;
				},

				// Responsible for parsing a group of things within parentheses `()`
				// This function assumes that it needs to gobble the opening parenthesis
				// and then tries to gobble everything within that parenthesis, assuming
				// that the next thing it should see is the close parenthesis. If not,
				// then the expression probably doesn't have a `)`
				gobbleGroup = function() {
					index++;
					var node = gobbleExpression();
					gobbleSpaces();
					if(exprICode(index) === CPAREN_CODE) {
						index++;
						return node;
					} else {
						throwError('Unclosed (', index);
					}
				},

				// Responsible for parsing Array literals `[1, 2, 3]`
				// This function assumes that it needs to gobble the opening bracket
				// and then tries to gobble the expressions as arguments.
				gobbleArray = function() {
					index++;
					return {
						type: ARRAY_EXP,
						elements: gobbleArguments(CBRACK_CODE)
					};
				},

				nodes = [], ch_i, node;

			while(index < length) {
				ch_i = exprICode(index);

				// Expressions can be separated by semicolons, commas, or just inferred without any
				// separators
				if(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
					index++; // ignore separators
				} else {
					// Try to gobble each expression individually
					if((node = gobbleExpression())) {
						nodes.push(node);
					// If we weren't able to find a binary expression and are out of room, then
					// the expression passed in probably has too much
					} else if(index < length) {
						throwError('Unexpected "' + exprI(index) + '"', index);
					}
				}
			}

			// If there's only one expression just try returning the expression
			if(nodes.length === 1) {
				return nodes[0];
			} else {
				return {
					type: COMPOUND,
					body: nodes
				};
			}
		};

	// To be filled in by the template
	jsep.version = '0.3.4';
	jsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };

	/**
	 * @method jsep.addUnaryOp
	 * @param {string} op_name The name of the unary op to add
	 * @return jsep
	 */
	jsep.addUnaryOp = function(op_name) {
		max_unop_len = Math.max(op_name.length, max_unop_len);
		unary_ops[op_name] = t; return this;
	};

	/**
	 * @method jsep.addBinaryOp
	 * @param {string} op_name The name of the binary op to add
	 * @param {number} precedence The precedence of the binary op (can be a float)
	 * @return jsep
	 */
	jsep.addBinaryOp = function(op_name, precedence) {
		max_binop_len = Math.max(op_name.length, max_binop_len);
		binary_ops[op_name] = precedence;
		return this;
	};

	/**
	 * @method jsep.addLiteral
	 * @param {string} literal_name The name of the literal to add
	 * @param {*} literal_value The value of the literal
	 * @return jsep
	 */
	jsep.addLiteral = function(literal_name, literal_value) {
		literals[literal_name] = literal_value;
		return this;
	};

	/**
	 * @method jsep.removeUnaryOp
	 * @param {string} op_name The name of the unary op to remove
	 * @return jsep
	 */
	jsep.removeUnaryOp = function(op_name) {
		delete unary_ops[op_name];
		if(op_name.length === max_unop_len) {
			max_unop_len = getMaxKeyLen(unary_ops);
		}
		return this;
	};

	/**
	 * @method jsep.removeAllUnaryOps
	 * @return jsep
	 */
	jsep.removeAllUnaryOps = function() {
		unary_ops = {};
		max_unop_len = 0;

		return this;
	};

	/**
	 * @method jsep.removeBinaryOp
	 * @param {string} op_name The name of the binary op to remove
	 * @return jsep
	 */
	jsep.removeBinaryOp = function(op_name) {
		delete binary_ops[op_name];
		if(op_name.length === max_binop_len) {
			max_binop_len = getMaxKeyLen(binary_ops);
		}
		return this;
	};

	/**
	 * @method jsep.removeAllBinaryOps
	 * @return jsep
	 */
	jsep.removeAllBinaryOps = function() {
		binary_ops = {};
		max_binop_len = 0;

		return this;
	};

	/**
	 * @method jsep.removeLiteral
	 * @param {string} literal_name The name of the literal to remove
	 * @return jsep
	 */
	jsep.removeLiteral = function(literal_name) {
		delete literals[literal_name];
		return this;
	};

	/**
	 * @method jsep.removeAllLiterals
	 * @return jsep
	 */
	jsep.removeAllLiterals = function() {
		literals = {};

		return this;
	};

	// In desktop environments, have a way to restore the old value for `jsep`
	if (false) { var old_jsep; } else {
		// In Node.JS environments
		if ( true && module.exports) {
			exports = module.exports = jsep;
		} else {
			exports.parse = jsep;
		}
	}
}(this));


/***/ }),

/***/ "./bundle.ts":
/*!*******************!*\
  !*** ./bundle.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const JSONUtils = __webpack_require__(/*! ./src */ "./src/index.js");

const deck = globalThis.deck || {}; // Check if peer dependencies are included

if (!deck.Layer) {
  throw new Error('@deck.gl/core is not found');
}

module.exports = Object.assign(deck, JSONUtils);

/***/ }),

/***/ "./src/helpers/convert-functions.js":
/*!******************************************!*\
  !*** ./src/helpers/convert-functions.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return convertFunctions; });
/* harmony import */ var _parse_expression_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-expression-string */ "./src/helpers/parse-expression-string.js");
/* harmony import */ var _syntactic_sugar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../syntactic-sugar */ "./src/syntactic-sugar.js");



function hasFunctionIdentifier(value) {
  return typeof value === 'string' && value.startsWith(_syntactic_sugar__WEBPACK_IMPORTED_MODULE_1__["FUNCTION_IDENTIFIER"]);
}

function trimFunctionIdentifier(value) {
  return value.replace(_syntactic_sugar__WEBPACK_IMPORTED_MODULE_1__["FUNCTION_IDENTIFIER"], '');
} // Try to determine if any props are function valued
// and if so convert their string values to functions


function convertFunctions(props, configuration) {
  // Use deck.gl prop types if available.
  const replacedProps = {};

  for (const propName in props) {
    let propValue = props[propName]; // Parse string valued expressions

    const isFunction = hasFunctionIdentifier(propValue);

    if (isFunction) {
      // Parse string as "expression", return equivalent JavaScript function
      propValue = trimFunctionIdentifier(propValue);
      propValue = Object(_parse_expression_string__WEBPACK_IMPORTED_MODULE_0__["default"])(propValue, configuration);
    }

    replacedProps[propName] = propValue;
  }

  return replacedProps;
}

/***/ }),

/***/ "./src/helpers/execute-function.js":
/*!*****************************************!*\
  !*** ./src/helpers/execute-function.js ***!
  \*****************************************/
/*! exports provided: executeFunction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "executeFunction", function() { return executeFunction; });
// This attempts to execute a function
function executeFunction(targetFunction, props, configuration) {
  // Find the function
  const matchedFunction = configuration.functions[targetFunction]; // Check that the function is in the configuration.

  if (!matchedFunction) {
    const {
      log
    } = configuration; // eslint-disable-line

    if (log) {
      const stringProps = JSON.stringify(props, null, 0).slice(0, 40);
      log.warn(`JSON converter: No registered function ${targetFunction}(${stringProps}...)  `);
    }

    return null;
  }

  return matchedFunction(props);
}

/***/ }),

/***/ "./src/helpers/instantiate-class.js":
/*!******************************************!*\
  !*** ./src/helpers/instantiate-class.js ***!
  \******************************************/
/*! exports provided: instantiateClass */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "instantiateClass", function() { return instantiateClass; });
/* harmony import */ var _convert_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./convert-functions */ "./src/helpers/convert-functions.js");
 // This attempts to instantiate a class, either as a class or as a React component

function instantiateClass(type, props, configuration) {
  // Find the class
  const Class = configuration.classes[type];
  const Component = configuration.reactComponents[type]; // Check that the class is in the configuration.

  if (!Class && !Component) {
    const {
      log
    } = configuration; // eslint-disable-line

    if (log) {
      const stringProps = JSON.stringify(props, null, 0).slice(0, 40);
      log.warn(`JSON converter: No registered class of type ${type}(${stringProps}...)  `);
    }

    return null;
  }

  if (Class) {
    return instantiateJavaScriptClass(Class, props, configuration);
  }

  return instantiateReactComponent(Component, props, configuration);
}

function instantiateJavaScriptClass(Class, props, configuration) {
  if (configuration.preProcessClassProps) {
    props = configuration.preProcessClassProps(Class, props, configuration);
  }

  props = Object(_convert_functions__WEBPACK_IMPORTED_MODULE_0__["default"])(props, configuration);
  return new Class(props);
}

function instantiateReactComponent(Component, props, configuration) {
  const {
    React
  } = configuration;
  const {
    children = []
  } = props;
  delete props.children;

  if (configuration.preProcessClassProps) {
    props = configuration.preProcessClassProps(Component, props, configuration);
  }

  props = Object(_convert_functions__WEBPACK_IMPORTED_MODULE_0__["default"])(props, configuration);
  return React.createElement(Component, props, children);
}

/***/ }),

/***/ "./src/helpers/parse-expression-string.js":
/*!************************************************!*\
  !*** ./src/helpers/parse-expression-string.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseExpressionString; });
/* harmony import */ var _utils_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/get */ "./src/utils/get.js");
/* harmony import */ var expression_eval__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! expression-eval */ "../../node_modules/expression-eval/index.js");
/* harmony import */ var expression_eval__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(expression_eval__WEBPACK_IMPORTED_MODULE_1__);
 // expression-eval: Small jsep based expression parser that supports array and object indexing


const cachedExpressionMap = {
  '-': object => object
}; // Calculates an accessor function from a JSON string
// '-' : x => x
// 'a.b.c': x => x.a.b.c

function parseExpressionString(propValue, configuration) {
  // NOTE: Can be null which represents invalid function. Return null so that prop can be omitted
  if (propValue in cachedExpressionMap) {
    return cachedExpressionMap[propValue];
  }

  let func; // Compile with expression-eval

  const ast = expression_eval__WEBPACK_IMPORTED_MODULE_1___default.a.parse(propValue);

  if (!ast.right && !ast.left && ast.type === 'Identifier') {
    func = row => {
      return Object(_utils_get__WEBPACK_IMPORTED_MODULE_0__["get"])(row, propValue);
    };
  } else {
    // NOTE: To avoid security risks, the arguments passed to the
    // compiled expression must only give access to pure data (no globals etc)
    // We disable function call syntax
    traverse(ast, node => {
      if (node.type === 'CallExpression') {
        throw new Error('Function calls not allowed in JSON expressions');
      }
    }); // TODO Something like `expressionEval.eval(ast, {row});` would be useful for unpacking arrays

    func = row => {
      return expression_eval__WEBPACK_IMPORTED_MODULE_1___default.a.eval(ast, row);
    };
  } // Cache the compiled function


  cachedExpressionMap[propValue] = func;
  return func;
} // Helper function to search all nodes in AST returned by expressionEval
// eslint-disable-next-line complexity

function traverse(node, visitor) {
  if (Array.isArray(node)) {
    node.forEach(element => traverse(element, visitor));
  } else if (node && typeof node === 'object') {
    if (node.type) {
      visitor(node);
    }

    for (const key in node) {
      traverse(node[key], visitor);
    }
  }
}

/***/ }),

/***/ "./src/helpers/parse-json.js":
/*!***********************************!*\
  !*** ./src/helpers/parse-json.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseJSON; });
// Accept JSON strings by parsing them
// TODO - use a parser that provides meaninful error messages
function parseJSON(json) {
  return typeof json === 'string' ? JSON.parse(json) : json;
}

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: JSONConverter, JSONConfiguration, Transport, _convertFunctions, _parseExpressionString, _shallowEqualObjects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _json_converter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./json-converter */ "./src/json-converter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSONConverter", function() { return _json_converter__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _json_configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./json-configuration */ "./src/json-configuration.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSONConfiguration", function() { return _json_configuration__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _transports_transport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transports/transport */ "./src/transports/transport.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Transport", function() { return _transports_transport__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _helpers_convert_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers/convert-functions */ "./src/helpers/convert-functions.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_convertFunctions", function() { return _helpers_convert_functions__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _helpers_parse_expression_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/parse-expression-string */ "./src/helpers/parse-expression-string.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_parseExpressionString", function() { return _helpers_parse_expression_string__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _utils_shallow_equal_objects__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/shallow-equal-objects */ "./src/utils/shallow-equal-objects.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_shallowEqualObjects", function() { return _utils_shallow_equal_objects__WEBPACK_IMPORTED_MODULE_5__["shallowEqualObjects"]; });

// @deck.gl/json: top-level exports
// Generic JSON converter, usable by other wrapper modules

 // Transports

 // Helpers





/***/ }),

/***/ "./src/json-configuration.js":
/*!***********************************!*\
  !*** ./src/json-configuration.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return JSONConfiguration; });
/* harmony import */ var _helpers_parse_expression_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/parse-expression-string */ "./src/helpers/parse-expression-string.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _syntactic_sugar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./syntactic-sugar */ "./src/syntactic-sugar.js");
// TODO - default parsing code should not be part of the configuration.




const isObject = value => value && typeof value === 'object';

class JSONConfiguration {
  constructor(...configurations) {
    // Initialize config with default values
    this.typeKey = _syntactic_sugar__WEBPACK_IMPORTED_MODULE_2__["TYPE_KEY"];
    this.functionKey = _syntactic_sugar__WEBPACK_IMPORTED_MODULE_2__["FUNCTION_KEY"];
    this.log = console; // eslint-disable-line

    this.classes = {};
    this.reactComponents = {};
    this.enumerations = {};
    this.constants = {};
    this.functions = {}; // TODO - this needs to be simpler, function conversion should be built in

    this.convertFunction = _helpers_parse_expression_string__WEBPACK_IMPORTED_MODULE_0__["default"];

    this.preProcessClassProps = (Class, props) => props;

    this.postProcessConvertedJson = json => json;

    for (const configuration of configurations) {
      this.merge(configuration);
    }
  }

  merge(configuration) {
    for (const key in configuration) {
      switch (key) {
        // DEPRECATED = For backwards compatibility, add views and layers to classes;
        case 'layers':
        case 'views':
          Object.assign(this.classes, configuration[key]);
          break;

        default:
          // Store configuration as root fields (this.classes, ...)
          if (key in this) {
            const value = configuration[key];
            this[key] = isObject(this[key]) ? Object.assign(this[key], value) : value;
          }

      }
    }
  }

  validate(configuration) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(!this.typeKey || typeof this.typeKey === 'string');
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(isObject(this.classes));
    return true;
  }

}

/***/ }),

/***/ "./src/json-converter.js":
/*!*******************************!*\
  !*** ./src/json-converter.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return JSONConverter; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/assert */ "./src/utils/assert.js");
/* harmony import */ var _json_configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./json-configuration */ "./src/json-configuration.js");
/* harmony import */ var _helpers_instantiate_class__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/instantiate-class */ "./src/helpers/instantiate-class.js");
/* harmony import */ var _helpers_execute_function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers/execute-function */ "./src/helpers/execute-function.js");
/* harmony import */ var _syntactic_sugar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./syntactic-sugar */ "./src/syntactic-sugar.js");
/* harmony import */ var _helpers_parse_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers/parse-json */ "./src/helpers/parse-json.js");
// Converts JSON to props ("hydrating" classes, resolving enums and functions etc).
// Lightly processes `json` props, transform string values, and extract `views` and `layers`
// See: https://github.com/visgl/deck.gl/blob/master/dev-docs/RFCs/v6.1/json-layers-rfc.md
//
// NOTES:
// * This is intended to provide minimal necessary processing required to support
//   existing deck.gl props via JSON. This is not an implementation of alternate JSON schemas.
// * Optionally, error checking could be applied, but ideally should leverage
//   non-JSON specific mechanisms like prop types.







const isObject = value => value && typeof value === 'object';

class JSONConverter {
  constructor(props) {
    this.log = console; // eslint-disable-line

    this.configuration = {};

    this.onJSONChange = () => {};

    this.json = null;
    this.convertedJson = null;
    this.setProps(props);
  }

  finalize() {}

  setProps(props) {
    // HANDLE CONFIGURATION PROPS
    if ('configuration' in props) {
      // Accept object or `JSONConfiguration`
      this.configuration = props.configuration instanceof _json_configuration__WEBPACK_IMPORTED_MODULE_1__["default"] ? props.configuration : new _json_configuration__WEBPACK_IMPORTED_MODULE_1__["default"](props.configuration);
    }

    if ('onJSONChange' in props) {
      this.onJSONChange = props.onJSONChange;
    }
  }

  mergeConfiguration(config) {
    this.configuration.merge(config);
  }

  convert(json) {
    // Use shallow equality to ensure we only convert same json once
    if (!json || json === this.json) {
      return this.convertedJson;
    } // Save json for shallow diffing


    this.json = json; // Accept JSON strings by parsing them

    const parsedJSON = Object(_helpers_parse_json__WEBPACK_IMPORTED_MODULE_5__["default"])(json); // Convert the JSON

    let convertedJson = convertJSON(parsedJSON, this.configuration);
    convertedJson = this.configuration.postProcessConvertedJson(convertedJson);
    this.convertedJson = convertedJson;
    return convertedJson;
  } // DEPRECATED: Backwards compatibility


  convertJson(json) {
    return this.convert(json);
  }

}

function convertJSON(json, configuration) {
  // Fixup configuration
  configuration = new _json_configuration__WEBPACK_IMPORTED_MODULE_1__["default"](configuration);
  return convertJSONRecursively(json, '', configuration);
} // Converts JSON to props ("hydrating" classes, resolving enums and functions etc).


function convertJSONRecursively(json, key, configuration) {
  if (Array.isArray(json)) {
    return json.map((element, i) => convertJSONRecursively(element, String(i), configuration));
  } // If object.type is in configuration, instantiate


  if (isClassInstance(json, configuration)) {
    return convertClassInstance(json, configuration);
  }

  if (isObject(json)) {
    // If object.function is in configuration, convert object to function
    if (_syntactic_sugar__WEBPACK_IMPORTED_MODULE_4__["FUNCTION_KEY"] in json) {
      return convertFunctionObject(json, configuration);
    }

    return convertPlainObject(json, configuration);
  } // Single value


  if (typeof json === 'string') {
    return convertString(json, key, configuration);
  } // Return unchanged (number, boolean, ...)


  return json;
} // Returns true if an object has a `type` field


function isClassInstance(json, configuration) {
  const {
    typeKey
  } = configuration;
  const isClass = isObject(json) && Boolean(json[typeKey]);
  return isClass;
}

function convertClassInstance(json, configuration) {
  // Extract the class type field
  const {
    typeKey
  } = configuration;
  const type = json[typeKey]; // Prepare a props object and ensure all values have been converted

  let props = { ...json
  };
  delete props[typeKey];
  props = convertPlainObject(props, configuration);
  return Object(_helpers_instantiate_class__WEBPACK_IMPORTED_MODULE_2__["instantiateClass"])(type, props, configuration);
} // Plain JS object, embed functions.


function convertFunctionObject(json, configuration) {
  // Extract the target function field
  const {
    functionKey
  } = configuration;
  const targetFunction = json[functionKey]; // Prepare a props object and ensure all values have been converted

  let props = { ...json
  };
  delete props[functionKey];
  props = convertPlainObject(props, configuration);
  return Object(_helpers_execute_function__WEBPACK_IMPORTED_MODULE_3__["executeFunction"])(targetFunction, props, configuration);
} // Plain JS object, convert each key and return.


function convertPlainObject(json, configuration) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(isObject(json));
  const result = {};

  for (const key in json) {
    const value = json[key];
    result[key] = convertJSONRecursively(value, key, configuration);
  }

  return result;
} // Convert one string value in an object
// TODO - We could also support string syntax for hydrating other types, like regexps...
// But no current use case


function convertString(string, key, configuration) {
  // Here the JSON value is supposed to be treated as a function
  if (string.startsWith(_syntactic_sugar__WEBPACK_IMPORTED_MODULE_4__["FUNCTION_IDENTIFIER"]) && configuration.convertFunction) {
    string = string.replace(_syntactic_sugar__WEBPACK_IMPORTED_MODULE_4__["FUNCTION_IDENTIFIER"], '');
    return configuration.convertFunction(string, configuration);
  }

  if (string.startsWith(_syntactic_sugar__WEBPACK_IMPORTED_MODULE_4__["CONSTANT_IDENTIFIER"])) {
    string = string.replace(_syntactic_sugar__WEBPACK_IMPORTED_MODULE_4__["CONSTANT_IDENTIFIER"], '');

    if (configuration.constants[string]) {
      return configuration.constants[string];
    } // enum


    const [enumVarName, enumValName] = string.split('.');
    return configuration.enumerations[enumVarName][enumValName];
  }

  return string;
}

/***/ }),

/***/ "./src/syntactic-sugar.js":
/*!********************************!*\
  !*** ./src/syntactic-sugar.js ***!
  \********************************/
/*! exports provided: FUNCTION_IDENTIFIER, CONSTANT_IDENTIFIER, TYPE_KEY, FUNCTION_KEY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FUNCTION_IDENTIFIER", function() { return FUNCTION_IDENTIFIER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSTANT_IDENTIFIER", function() { return CONSTANT_IDENTIFIER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TYPE_KEY", function() { return TYPE_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FUNCTION_KEY", function() { return FUNCTION_KEY; });
const FUNCTION_IDENTIFIER = '@@=';
const CONSTANT_IDENTIFIER = '@@#';
const TYPE_KEY = '@@type';
const FUNCTION_KEY = '@@function';


/***/ }),

/***/ "./src/transports/transport.js":
/*!*************************************!*\
  !*** ./src/transports/transport.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Transport; });
/* global document */
const state = {
  onIninitialize: _ => _,
  onFinalize: _ => _,
  onMessage: null
};
class Transport {
  static setCallbacks({
    onInitialize,
    onFinalize,
    onMessage
  }) {
    if (onInitialize) {
      state.onInitialize = onInitialize;
    }

    if (onFinalize) {
      state.onFinalize = onFinalize;
    }

    if (onMessage) {
      state.onMessage = onMessage;
    } // this._flushQueuedConnections();

  }

  constructor(name = 'Transport') {
    this.name = name;
    this._messageQueue = [];
    this.userData = {};
  }
  /**
   * Return a root DOM element for this transport connection
   * @return {HTMLElement} default implementation returns document.body
   * Jupyter Notebook transports will return an element associated with the notebook cell
   */


  getRootDOMElement() {
    return typeof document !== 'undefined' ? document.body : null;
  }
  /**
   * Back-channel messaging
   */


  sendJSONMessage() {
    // eslint-disable-next-line
    console.error('Back-channel not implemented for this transport');
  }
  /**
   * Back-channel messaging
   */


  sendBinaryMessage() {
    // eslint-disable-next-line
    console.error('Back-channel not implemented for this transport');
  } //
  // API for transports (not intended for apps)
  //


  _initialize(options = {}) {
    const message = {
      transport: this,
      ...options
    };
    state.onInitialize(message); // console.debug('Resolving init promise', options); // eslint-disable-line
    // this._initResolvers.resolve(message);
  }

  _finalize(options = {}) {
    const message = {
      transport: this,
      ...options
    }; // TODO - could potentially be called without Initialize being called

    state.onFinalize(message);
    this._destroyed = true;
  }

  _messageReceived(message = {}) {
    message = {
      transport: this,
      ...message
    }; // TODO - this function could potentially be called before callback registered/ Initialize called
    // if (!state.onMessage) {
    //   console.error('Queueing transport message', message); // eslint-disable-line
    //   this._messageQueue.push(message);
    //   return;
    // }

    console.debug('Delivering transport message', message); // eslint-disable-line

    state.onMessage(message);
  }
  /*
  // This tries to handle the case that a transport connection initializes before the application
  // has set the callbacks.
  // Note: It is not clear that this can actually happen in the in initial Jupyter widget transport
  _flushQueuedConnections() {
    if (onInitialize) {
      state._initPromise.then(initArgs => {
        onInitialize(initArgs);
         if (state._onMessage) {
          // Send any queued messages
          let message;
          while ((message = this._messageQueue.pop())) {
            console.debug('Delivering queued transport message', message); // eslint-disable-line
            this._onMessage(message);
          }
        }
      });
    }
  }
  */


  static _stringifyJSONSafe(v) {
    const cache = new Set();
    return JSON.stringify(v, (key, value) => {
      if (typeof value === 'object' && value !== null) {
        if (cache.has(value)) {
          // Circular reference found
          try {
            // If this value does not reference a parent it can be deduped
            return JSON.parse(JSON.stringify(value));
          } catch (err) {
            // discard key if value cannot be deduped
            return undefined;
          }
        } // Store value in our set


        cache.add(value);
      }

      return value;
    });
  }

}

/***/ }),

/***/ "./src/utils/assert.js":
/*!*****************************!*\
  !*** ./src/utils/assert.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message = '') {
  if (!condition) {
    throw new Error(`JSON conversion error ${message}`);
  }
}

/***/ }),

/***/ "./src/utils/get.js":
/*!**************************!*\
  !*** ./src/utils/get.js ***!
  \**************************/
/*! exports provided: get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * Access properties of nested containers using dot-path notation
 * Returns `undefined` if any container is not valid, instead of throwing
 * @param {Object} container - container that supports get
 * @param {String|*} compositeKey - key to access, can be '.'-separated string
 * @return {*} - value in the final key of the nested container, or `undefined`
 */
function get(container, compositeKey) {
  // Split the key into subkeys
  const keyList = getKeys(compositeKey); // Recursively get the value of each key;

  let value = container;

  for (const key of keyList) {
    // If any intermediate subfield is not an object, return undefined
    value = isObject(value) ? value[key] : undefined;
  }

  return value;
}
/**
 * Checks if argument is an "indexable" object (not a primitive value, nor null)
 * @param {*} value - JavaScript value to be tested
 * @return {Boolean} - true if argument is a JavaScript object
 */

function isObject(value) {
  return value !== null && typeof value === 'object';
} // Cache key to key arrays for speed


const keyMap = {}; // Takes a string of '.' separated keys and returns an array of keys
// - 'feature.geometry.type' => ['feature', 'geometry', 'type']
// - 'feature' => ['feature']

function getKeys(compositeKey) {
  if (typeof compositeKey === 'string') {
    // else assume string and split around dots
    let keyList = keyMap[compositeKey];

    if (!keyList) {
      keyList = compositeKey.split('.');
      keyMap[compositeKey] = keyList;
    }

    return keyList;
  } // Wrap in array if needed


  return Array.isArray(compositeKey) ? compositeKey : [compositeKey];
}

/***/ }),

/***/ "./src/utils/shallow-equal-objects.js":
/*!********************************************!*\
  !*** ./src/utils/shallow-equal-objects.js ***!
  \********************************************/
/*! exports provided: shallowEqualObjects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shallowEqualObjects", function() { return shallowEqualObjects; });
// TODO - can we reuse the core util? Assuming we don't want to export it

/* eslint-disable complexity */
// Compares two objects to see if their keys are shallowly equal
function shallowEqualObjects(a, b) {
  if (a === b) {
    return true;
  }

  if (typeof a !== 'object' || a === null || typeof b !== 'object' || b === null) {
    return false;
  }

  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }

  for (const key in a) {
    if (!(key in b) || a[key] !== b[key]) {
      return false;
    }
  }

  for (const key in b) {
    if (!(key in a)) {
      return false;
    }
  }

  return true;
}

/***/ })

/******/ });
});