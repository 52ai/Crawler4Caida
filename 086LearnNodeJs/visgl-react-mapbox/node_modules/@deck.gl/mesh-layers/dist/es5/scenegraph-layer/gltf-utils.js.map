{"version":3,"sources":["../../../src/scenegraph-layer/gltf-utils.ts"],"names":["waitForGLTFAssets","gltfObjects","remaining","scenes","forEach","scene","traverse","model","Object","values","getUniforms","uniform","loaded","push","waitWhileCondition","some","condition","Promise","resolve","requestAnimationFrame"],"mappings":";;;;;;;;;;;;;SAGsBA,iB;;;;;iFAAf,iBAAiCC,WAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AACCC,YAAAA,SADD,GACoB,EADpB;AAGLD,YAAAA,WAAW,CAACE,MAAZ,CAAmBC,OAAnB,CAA2B,UAAAC,KAAK,EAAI;AAClCA,cAAAA,KAAK,CAACC,QAAN,CAAe,UAACC,KAAD,EAAsB;AACnCC,gBAAAA,MAAM,CAACC,MAAP,CAAcF,KAAK,CAACA,KAAN,CAAYG,WAAZ,EAAd,EAAyCN,OAAzC,CAAiD,UAACO,OAAD,EAAkB;AACjE,sBAAIA,OAAO,CAACC,MAAR,KAAmB,KAAvB,EAA8B;AAC5BV,oBAAAA,SAAS,CAACW,IAAV,CAAeF,OAAf;AACD;AACF,iBAJD;AAKD,eAND;AAOD,aARD;AAHK;AAAA,mBAaQG,kBAAkB,CAAC;AAAA,qBAAMZ,SAAS,CAACa,IAAV,CAAe,UAAAJ,OAAO;AAAA,uBAAI,CAACA,OAAO,CAACC,MAAb;AAAA,eAAtB,CAAN;AAAA,aAAD,CAb1B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAgBQE,kB;;;;;kFAAf,kBAAkCE,SAAlC;AAAA;AAAA;AAAA;AAAA;AAAA,iBACSA,SAAS,EADlB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAEU,IAAIC,OAAJ,CAAY,UAAAC,OAAO;AAAA,qBAAIC,qBAAqB,CAACD,OAAD,CAAzB;AAAA,aAAnB,CAFV;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["/* global requestAnimationFrame */\nimport type {GroupNode, ModelNode} from '@luma.gl/experimental';\n\nexport async function waitForGLTFAssets(gltfObjects: {scenes: GroupNode[]}): Promise<void> {\n  const remaining: any[] = [];\n\n  gltfObjects.scenes.forEach(scene => {\n    scene.traverse((model: ModelNode) => {\n      Object.values(model.model.getUniforms()).forEach((uniform: any) => {\n        if (uniform.loaded === false) {\n          remaining.push(uniform);\n        }\n      });\n    });\n  });\n\n  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\n\nasync function waitWhileCondition(condition: () => boolean): Promise<void> {\n  while (condition()) {\n    await new Promise(resolve => requestAnimationFrame(resolve));\n  }\n}\n"],"file":"gltf-utils.js"}