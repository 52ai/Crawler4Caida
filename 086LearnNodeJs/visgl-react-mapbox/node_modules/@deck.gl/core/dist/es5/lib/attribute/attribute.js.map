{"version":3,"sources":["../../../../src/lib/attribute/attribute.ts"],"names":["Attribute","gl","opts","startIndices","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","updateRanges","range","FULL","settings","update","accessor","_autoUpdater","undefined","Object","seal","state","_validateAttributeUpdaters","layout","clearChangedFlags","id","concat","Boolean","transition","supportsTransition","layerSettings","userSettings","Array","isArray","find","a","reason","dataRange","setNeedsRedraw","startRow","endRow","Infinity","add","EMPTY","numInstances","noAlloc","data","props","context","updated","call","value","constant","buffer","byteLength","byteOffset","setData","startOffset","Number","isFinite","getVertexOffset","endOffset","length","size","_checkAttributeArray","clearNeedsUpdate","hasChanged","transform","ArrayBuffer","isView","needsNormalize","stride","offset","nested","row","vertexIndex","shaderAttributeDefs","shaderAttributes","shaderAttributeName","assign","attribute","accessorFunc","i","iterable","objectInfo","object","index","objectValue","numVertices","startIndex","item","_normalizeValue","set","target","source","start","count","hasUpdater","Error","limit","Math","min","valid","DataColumn"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport DataColumn, {DataColumnOptions, ShaderAttributeOptions, BufferAccessor} from './data-column';\nimport {IShaderAttribute} from './shader-attribute';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {normalizeTransitionSettings, TransitionSettings} from './attribute-transition-utils';\nimport type {Buffer} from '@luma.gl/webgl';\n\nimport type {NumericArray, TypedArray} from '../../types/types';\n\nexport type Accessor<DataType, ReturnType> = (\n  object: DataType,\n  context: {\n    data: any;\n    index: number;\n    target: number[];\n  }\n) => ReturnType;\n\nexport type Updater = (\n  attribute: Attribute,\n  {\n    data,\n    startRow,\n    endRow,\n    props,\n    numInstances\n  }: {\n    data: any;\n    startRow: number;\n    endRow: number;\n    props: any;\n    numInstances: number;\n  }\n) => void;\n\nexport type AttributeOptions = DataColumnOptions<{\n  transition?: boolean | Partial<TransitionSettings>;\n  noAlloc?: boolean;\n  update?: Updater;\n  accessor?: Accessor<any, any> | string | string[];\n  transform?: (value: any) => any;\n  shaderAttributes?: Record<string, Partial<ShaderAttributeOptions>>;\n}>;\n\nexport type BinaryAttribute = Partial<BufferAccessor> & {value?: TypedArray; buffer?: Buffer};\n\ntype AttributeInternalState = {\n  startIndices: NumericArray | null;\n  /** Legacy: external binary supplied via attribute name */\n  lastExternalBuffer: TypedArray | Buffer | BinaryAttribute | null;\n  /** External binary supplied via accessor name */\n  binaryValue: TypedArray | Buffer | BinaryAttribute | null;\n  binaryAccessor: Accessor<any, any> | null;\n  needsUpdate: string | boolean;\n  needsRedraw: string | boolean;\n  updateRanges: number[][];\n};\n\nexport default class Attribute extends DataColumn<AttributeOptions, AttributeInternalState> {\n  /** Legacy approach to set attribute value - read `isConstant` instead for attribute state */\n  constant: boolean = false;\n\n  constructor(gl: WebGLRenderingContext, opts: AttributeOptions) {\n    super(gl, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL\n    });\n\n    // eslint-disable-next-line\n    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices(): NumericArray | null {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout: NumericArray | null) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate(): string | boolean {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false}: {clearChangedFlags?: boolean} = {}): string | boolean {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers(): string[] {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition(): boolean {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts: Record<string, any>): TransitionSettings | null {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? // @ts-ignore\n        opts[accessor.find(a => opts[a])]\n      : // @ts-ignore\n        opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason: string = this.id, dataRange?: {startRow?: number; endRow?: number}): void {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate(): void {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason: string = this.id): void {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  allocate(numInstances: number): boolean {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      super.allocate(numInstances, state.updateRanges !== range.FULL);\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({\n    numInstances,\n    data,\n    props,\n    context\n  }: {\n    numInstances: number;\n    data: any;\n    props: any;\n    context: any;\n  }): boolean {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        this.buffer.byteLength < (this.value as TypedArray).byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        // Setting attribute.constant in updater is a legacy approach that interferes with allocation in the next cycle\n        // Respect it here but reset after use\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n            ? this.value.length\n            : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value?: NumericArray): boolean {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer?: TypedArray | Buffer | BinaryAttribute): boolean {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(\n    buffer?: TypedArray | Buffer | BinaryAttribute,\n    startIndices: NumericArray | null = null\n  ): boolean {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {value: buffer};\n      }\n      const binaryValue = buffer as BinaryAttribute;\n      assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);\n      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n        size: binaryValue.size || this.size,\n        stride: binaryValue.stride,\n        offset: binaryValue.offset,\n        startIndices: startIndices as NumericArray,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row: number): number {\n    const {startIndices} = this;\n    const vertexIndex = startIndices ? startIndices[row] : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes(): Record<string, IShaderAttribute> {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {[this.id]: null};\n    const shaderAttributes: Record<string, IShaderAttribute> = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        shaderAttributes,\n        super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n\n    return shaderAttributes;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  private _autoUpdater(\n    attribute: Attribute,\n    {\n      data,\n      startRow,\n      endRow,\n      props,\n      numInstances\n    }: {\n      data: any;\n      startRow: number;\n      endRow: number;\n      props: any;\n      numInstances: number;\n    }\n  ): void {\n    if (attribute.constant) {\n      return;\n    }\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    const accessorFunc: Accessor<any, any> =\n      state.binaryAccessor ||\n      // @ts-ignore\n      (typeof accessor === 'function' ? accessor : props[accessor]);\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (objectInfo.index < startIndices.length - 1\n            ? startIndices[objectInfo.index + 1]\n            : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value as TypedArray, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          (value as TypedArray).set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value as TypedArray, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  private _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  private _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"],"file":"attribute.js"}