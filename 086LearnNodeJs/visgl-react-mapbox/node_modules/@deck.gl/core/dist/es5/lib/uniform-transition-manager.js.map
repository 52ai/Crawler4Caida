{"version":3,"sources":["../../../src/lib/uniform-transition-manager.js"],"names":["TRANSITION_TYPES","interpolation","CPUInterpolationTransition","spring","CPUSpringTransition","UniformTransitionManager","timeline","transitions","Map","size","key","fromValue","toValue","settings","has","transition","get","value","remove","TransitionType","type","log","error","start","set","cancel","delete","propsInTransition","update","inProgress","keys"],"mappings":";;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;;;;;;;AAEA,IAAMA,gBAAgB,GAAG;AACvBC,EAAAA,aAAa,EAAEC,mCADQ;AAEvBC,EAAAA,MAAM,EAAEC;AAFe,CAAzB;;IAKqBC,wB;AACnB,oCAAYC,QAAZ,EAAsB;AAAA;AACpB,SAAKC,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;AACA,SAAKF,QAAL,GAAgBA,QAAhB;AACD;;;;SAED,eAAa;AACX,aAAO,KAAKC,WAAL,CAAiBE,IAAjB,GAAwB,CAA/B;AACD;;;WAED,aAAIC,GAAJ,EAASC,SAAT,EAAoBC,OAApB,EAA6BC,QAA7B,EAAuC;AACrC,UAAON,WAAP,GAAsB,IAAtB,CAAOA,WAAP;;AACA,UAAIA,WAAW,CAACO,GAAZ,CAAgBJ,GAAhB,CAAJ,EAA0B;AACxB,YAAMK,WAAU,GAAGR,WAAW,CAACS,GAAZ,CAAgBN,GAAhB,CAAnB;;AAEA,gCAAgDK,WAAhD,CAAOE,KAAP;AAAA,YAAOA,KAAP,kCAAeF,WAAU,CAACF,QAAX,CAAoBF,SAAnC;AAEAA,QAAAA,SAAS,GAAGM,KAAZ;AACA,aAAKC,MAAL,CAAYR,GAAZ;AACD;;AAEDG,MAAAA,QAAQ,GAAG,2DAA4BA,QAA5B,CAAX;;AACA,UAAI,CAACA,QAAL,EAAe;AACb;AACD;;AAED,UAAMM,cAAc,GAAGnB,gBAAgB,CAACa,QAAQ,CAACO,IAAV,CAAvC;;AACA,UAAI,CAACD,cAAL,EAAqB;AACnBE,qBAAIC,KAAJ,wCAA0CT,QAAQ,CAACO,IAAnD;;AACA;AACD;;AACD,UAAML,UAAU,GAAG,IAAII,cAAJ,CAAmB,KAAKb,QAAxB,CAAnB;AACAS,MAAAA,UAAU,CAACQ,KAAX,iCACKV,QADL;AAEEF,QAAAA,SAAS,EAATA,SAFF;AAGEC,QAAAA,OAAO,EAAPA;AAHF;AAKAL,MAAAA,WAAW,CAACiB,GAAZ,CAAgBd,GAAhB,EAAqBK,UAArB;AACD;;;WAED,gBAAOL,GAAP,EAAY;AACV,UAAOH,WAAP,GAAsB,IAAtB,CAAOA,WAAP;;AACA,UAAIA,WAAW,CAACO,GAAZ,CAAgBJ,GAAhB,CAAJ,EAA0B;AACxBH,QAAAA,WAAW,CAACS,GAAZ,CAAgBN,GAAhB,EAAqBe,MAArB;AACAlB,QAAAA,WAAW,CAACmB,MAAZ,CAAmBhB,GAAnB;AACD;AACF;;;WAED,kBAAS;AACP,UAAMiB,iBAAiB,GAAG,EAA1B;;AADO,iDAGyB,KAAKpB,WAH9B;AAAA;;AAAA;AAGP,4DAAkD;AAAA;AAAA,cAAtCG,GAAsC;AAAA,cAAjCK,UAAiC;;AAChDA,UAAAA,UAAU,CAACa,MAAX;AACAD,UAAAA,iBAAiB,CAACjB,GAAD,CAAjB,GAAyBK,UAAU,CAACE,KAApC;;AACA,cAAI,CAACF,UAAU,CAACc,UAAhB,EAA4B;AAE1B,iBAAKX,MAAL,CAAYR,GAAZ;AACD;AACF;AAVM;AAAA;AAAA;AAAA;AAAA;;AAYP,aAAOiB,iBAAP;AACD;;;WAED,iBAAQ;AAAA,kDACY,KAAKpB,WAAL,CAAiBuB,IAAjB,EADZ;AAAA;;AAAA;AACN,+DAA2C;AAAA,cAAhCpB,GAAgC;AACzC,eAAKQ,MAAL,CAAYR,GAAZ;AACD;AAHK;AAAA;AAAA;AAAA;AAAA;AAIP","sourcesContent":["import {normalizeTransitionSettings} from './attribute/attribute-transition-utils';\nimport CPUInterpolationTransition from '../transitions/cpu-interpolation-transition';\nimport CPUSpringTransition from '../transitions/cpu-spring-transition';\nimport log from '../utils/log';\n\nconst TRANSITION_TYPES = {\n  interpolation: CPUInterpolationTransition,\n  spring: CPUSpringTransition\n};\n\nexport default class UniformTransitionManager {\n  constructor(timeline) {\n    this.transitions = new Map();\n    this.timeline = timeline;\n  }\n\n  get active() {\n    return this.transitions.size > 0;\n  }\n\n  add(key, fromValue, toValue, settings) {\n    const {transitions} = this;\n    if (transitions.has(key)) {\n      const transition = transitions.get(key);\n      // value may not be available if `update()` has not been called. Fallback to `fromValue`\n      const {value = transition.settings.fromValue} = transition;\n      // start from interrupted position\n      fromValue = value;\n      this.remove(key);\n    }\n\n    settings = normalizeTransitionSettings(settings);\n    if (!settings) {\n      return;\n    }\n\n    const TransitionType = TRANSITION_TYPES[settings.type];\n    if (!TransitionType) {\n      log.error(`unsupported transition type '${settings.type}'`)();\n      return;\n    }\n    const transition = new TransitionType(this.timeline);\n    transition.start({\n      ...settings,\n      fromValue,\n      toValue\n    });\n    transitions.set(key, transition);\n  }\n\n  remove(key) {\n    const {transitions} = this;\n    if (transitions.has(key)) {\n      transitions.get(key).cancel();\n      transitions.delete(key);\n    }\n  }\n\n  update() {\n    const propsInTransition = {};\n\n    for (const [key, transition] of this.transitions) {\n      transition.update();\n      propsInTransition[key] = transition.value;\n      if (!transition.inProgress) {\n        // transition ended\n        this.remove(key);\n      }\n    }\n\n    return propsInTransition;\n  }\n\n  clear() {\n    for (const key of this.transitions.keys()) {\n      this.remove(key);\n    }\n  }\n}\n"],"file":"uniform-transition-manager.js"}