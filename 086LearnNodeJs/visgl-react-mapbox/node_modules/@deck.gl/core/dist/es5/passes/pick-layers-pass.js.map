{"version":3,"sources":["../../../src/passes/pick-layers-pass.ts"],"names":["PICKING_PARAMETERS","blendFunc","blendEquation","PickLayersPass","props","pickingFBO","_drawPickingBuffer","layers","layerFilter","views","viewports","onViewportActive","deviceRect","x","y","width","height","cullRect","effects","pass","pickZ","gl","encodedColors","byLayer","Map","byAlpha","_colors","renderStatus","scissorTest","scissor","clearColor","depthMask","depthTest","depthRange","colorMask","blend","target","filter","e","useInPicking","decodePickingColor","decodeColor","bind","stats","layer","pickable","operation","OPERATION","DRAW","pickingActive","pickingAttribute","lightSources","layerIndex","viewport","pickParameters","parameters","Object","assign","blendColor","encodeColor","LayersPass","encoded","a","entry","get","push","size","set","log","warn","pickedColor","pickedLayer","pickedViewports","pickedObjectIndex"],"mappings":"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","sourcesContent":["import LayersPass, {LayersPassRenderOptions, RenderStats, Rect} from './layers-pass';\nimport {withParameters} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {OPERATION} from '../lib/constants';\nimport log from '../utils/log';\n\nimport type {Framebuffer} from '@luma.gl/core';\nimport type Viewport from '../viewports/viewport';\nimport type Layer from '../lib/layer';\n\nconst PICKING_PARAMETERS = {\n  blendFunc: [GL.ONE, GL.ZERO, GL.CONSTANT_ALPHA, GL.ZERO],\n  blendEquation: GL.FUNC_ADD\n};\n\ntype PickLayersPassRenderOptions = LayersPassRenderOptions & {\n  pickingFBO: Framebuffer;\n  deviceRect: Rect;\n  pickZ: boolean;\n};\n\ntype EncodedPickingColors = {\n  a: number;\n  layer: Layer;\n  viewports: Viewport[];\n};\n\nexport type PickingColorDecoder = (pickedColor: number[] | Uint8Array) =>\n  | {\n      pickedLayer: Layer;\n      pickedViewports: Viewport[];\n      pickedObjectIndex: number;\n    }\n  | undefined;\n\nexport default class PickLayersPass extends LayersPass {\n  private pickZ?: boolean;\n  private _colors: {\n    byLayer: Map<Layer, EncodedPickingColors>;\n    byAlpha: EncodedPickingColors[];\n  } | null = null;\n\n  render(props: PickLayersPassRenderOptions) {\n    if (props.pickingFBO) {\n      // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n      return this._drawPickingBuffer(props);\n    }\n    // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n    return super.render(props);\n  }\n\n  // Private\n  // Draws list of layers and viewports into the picking buffer\n  // Note: does not sample the buffer, that has to be done by the caller\n  _drawPickingBuffer({\n    layers,\n    layerFilter,\n    views,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    deviceRect: {x, y, width, height},\n    cullRect,\n    effects,\n    pass = 'picking',\n    pickZ\n  }: PickLayersPassRenderOptions): {\n    decodePickingColor: PickingColorDecoder | null;\n    stats: RenderStats;\n  } {\n    const gl = this.gl;\n    this.pickZ = pickZ;\n\n    // Track encoded layer indices\n    const encodedColors = pickZ\n      ? null\n      : {\n          byLayer: new Map(),\n          byAlpha: []\n        };\n    // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n    this._colors = encodedColors;\n\n    // Make sure we clear scissor test and fbo bindings in case of exceptions\n    // We are only interested in one pixel, no need to render anything else\n    // Note that the callback here is called synchronously.\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    const renderStatus = withParameters(\n      gl,\n      {\n        scissorTest: true,\n        scissor: [x, y, width, height],\n        clearColor: [0, 0, 0, 0],\n        // When used as Mapbox custom layer, the context state may be dirty\n        // TODO - Remove when mapbox fixes this issue\n        // https://github.com/mapbox/mapbox-gl-js/issues/7801\n        depthMask: true,\n        depthTest: true,\n        depthRange: [0, 1],\n        colorMask: [true, true, true, true],\n        // Blending\n        ...PICKING_PARAMETERS,\n        blend: !pickZ\n      },\n      () =>\n        super.render({\n          target: pickingFBO,\n          layers,\n          layerFilter,\n          views,\n          viewports,\n          onViewportActive,\n          cullRect,\n          effects: effects?.filter(e => e.useInPicking),\n          pass\n        })\n    );\n\n    // Clear the temp field\n    this._colors = null;\n    const decodePickingColor = encodedColors && decodeColor.bind(null, encodedColors);\n    return {decodePickingColor, stats: renderStatus};\n  }\n\n  protected shouldDrawLayer(layer: Layer): boolean {\n    return layer.props.pickable && layer.props.operation === OPERATION.DRAW;\n  }\n\n  protected getModuleParameters() {\n    return {\n      pickingActive: 1,\n      pickingAttribute: this.pickZ,\n      // turn off lighting by adding empty light source object\n      // lights shader module relies on the `lightSources` to turn on/off lighting\n      lightSources: {}\n    };\n  }\n\n  protected getLayerParameters(layer: Layer, layerIndex: number, viewport: Viewport): any {\n    const pickParameters = {...layer.props.parameters};\n\n    if (!this._colors) {\n      pickParameters.blend = false;\n    } else {\n      Object.assign(pickParameters, PICKING_PARAMETERS);\n      pickParameters.blend = true;\n      pickParameters.blendColor = encodeColor(this._colors, layer, viewport);\n    }\n\n    return pickParameters;\n  }\n}\n\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(\n  encoded: {\n    byLayer: Map<Layer, EncodedPickingColors>;\n    byAlpha: EncodedPickingColors[];\n  },\n  layer: Layer,\n  viewport: Viewport\n): number[] {\n  const {byLayer, byAlpha} = encoded;\n  let a;\n\n  // Encode layerIndex in the alpha channel\n  // TODO - combine small layers to better utilize the picking color space\n  let entry = byLayer.get(layer);\n  if (entry) {\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n    if (a <= 255) {\n      entry = {a, layer, viewports: [viewport]};\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n  return [0, 0, 0, a / 255];\n}\n\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(\n  encoded: {\n    byLayer: Map<Layer, EncodedPickingColors>;\n    byAlpha: EncodedPickingColors[];\n  },\n  pickedColor: number[] | Uint8Array\n):\n  | {\n      pickedLayer: Layer;\n      pickedViewports: Viewport[];\n      pickedObjectIndex: number;\n    }\n  | undefined {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return (\n    entry && {\n      pickedLayer: entry.layer,\n      pickedViewports: entry.viewports,\n      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n    }\n  );\n}\n"],"file":"pick-layers-pass.js"}