{"version":3,"sources":["../../../src/transitions/gpu-interpolation-transition.ts"],"names":["GPUInterpolationTransition","gl","attribute","timeline","transition","Transition","attributeInTransition","Attribute","settings","currentStartIndices","startIndices","currentLength","transform","getTransform","bufferOpts","byteLength","usage","buffers","Buffer","inProgress","transitionSettings","numInstances","duration","cancel","padBufferOpts","fromLength","fromStartIndices","getData","enter","buffer","setData","value","start","update","elementCount","Math","floor","size","sourceBuffers","aFrom","aTo","feedbackBuffers","vCurrent","updated","easing","time","t","run","uniforms","delete","length","vs","attributeType","Transform","defines","ATTRIBUTE_TYPE","varyings"],"mappings":";;;;;;;;;;;;;;;AACA;;AACA;;AACA;;AAQA;;;;;;;;;;;;IAOqBA,0B;AAanB,4CAQG;AAAA,QAPDC,EAOC,QAPDA,EAOC;AAAA,QANDC,SAMC,QANDA,SAMC;AAAA,QALDC,QAKC,QALDA,QAKC;AAAA;AAAA;AAAA,gDAnBI,eAmBJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACD,SAAKF,EAAL,GAAUA,EAAV;AACA,SAAKG,UAAL,GAAkB,IAAIC,mBAAJ,CAAeF,QAAf,CAAlB;AACA,SAAKD,SAAL,GAAiBA,SAAjB;AAKA,SAAKI,qBAAL,GAA6B,IAAIC,kBAAJ,CAAcN,EAAd,EAAkBC,SAAS,CAACM,QAA5B,CAA7B;AACA,SAAKC,mBAAL,GAA2BP,SAAS,CAACQ,YAArC;AAIA,SAAKC,aAAL,GAAqB,CAArB;AACA,SAAKC,SAAL,GAAiBC,YAAY,CAACZ,EAAD,EAAKC,SAAL,CAA7B;AACA,QAAMY,UAAU,GAAG;AACjBC,MAAAA,UAAU,EAAE,CADK;AAEjBC,MAAAA,KAAK;AAFY,KAAnB;AAIA,SAAKC,OAAL,GAAe,CACb,IAAIC,YAAJ,CAAWjB,EAAX,EAAea,UAAf,CADa,EAEb,IAAII,YAAJ,CAAWjB,EAAX,EAAea,UAAf,CAFa,CAAf;AAID;;;;SAED,eAA0B;AACxB,aAAO,KAAKV,UAAL,CAAgBe,UAAvB;AACD;;;WAOD,eAAMC,kBAAN,EAA2DC,YAA3D,EAAuF;AACrF,UAAID,kBAAkB,CAACE,QAAnB,IAA+B,CAAnC,EAAsC;AACpC,aAAKlB,UAAL,CAAgBmB,MAAhB;AACA;AACD;;AACD,WAAKf,QAAL,GAAgBY,kBAAhB;AAEA,UAAOnB,EAAP,GAAiC,IAAjC,CAAOA,EAAP;AAAA,UAAWgB,OAAX,GAAiC,IAAjC,CAAWA,OAAX;AAAA,UAAoBf,SAApB,GAAiC,IAAjC,CAAoBA,SAApB;AAIA,kDAAae,OAAb;AAEA,UAAMO,aAAa,GAAG;AACpBH,QAAAA,YAAY,EAAZA,YADoB;AAEpBnB,QAAAA,SAAS,EAATA,SAFoB;AAGpBuB,QAAAA,UAAU,EAAE,KAAKd,aAHG;AAIpBe,QAAAA,gBAAgB,EAAE,KAAKjB,mBAJH;AAKpBkB,QAAAA,OAAO,EAAEP,kBAAkB,CAACQ;AALR,OAAtB;;AAbqF,iDAqBhEX,OArBgE;AAAA;;AAAA;AAqBrF,4DAA8B;AAAA,cAAnBY,MAAmB;AAC5B;AAAWA,YAAAA,MAAM,EAANA;AAAX,aAAsBL,aAAtB;AACD;AAvBoF;AAAA;AAAA;AAAA;AAAA;;AAyBrF,WAAKf,mBAAL,GAA2BP,SAAS,CAACQ,YAArC;AACA,WAAKC,aAAL,GAAqB,wDAAyBT,SAAzB,EAAoCmB,YAApC,CAArB;AACA,WAAKf,qBAAL,CAA2BwB,OAA3B,CAAmC;AACjCD,QAAAA,MAAM,EAAEZ,OAAO,CAAC,CAAD,CADkB;AAIjCc,QAAAA,KAAK,EAAE7B,SAAS,CAAC6B;AAJgB,OAAnC;AAOA,WAAK3B,UAAL,CAAgB4B,KAAhB,CAAsBZ,kBAAtB;AAEA,WAAKR,SAAL,CAAeqB,MAAf,CAAsB;AACpBC,QAAAA,YAAY,EAAEC,IAAI,CAACC,KAAL,CAAW,KAAKzB,aAAL,GAAqBT,SAAS,CAACmC,IAA1C,CADM;AAEpBC,QAAAA,aAAa,EAAE;AACbC,UAAAA,KAAK,EAAEtB,OAAO,CAAC,CAAD,CADD;AAEbuB,UAAAA,GAAG,EAAE,wDAAyBvC,EAAzB,EAA6BC,SAA7B;AAFQ,SAFK;AAMpBuC,QAAAA,eAAe,EAAE;AACfC,UAAAA,QAAQ,EAAEzB,OAAO,CAAC,CAAD;AADF;AANG,OAAtB;AAUD;;;WAED,kBAAkB;AAChB,UAAM0B,OAAO,GAAG,KAAKvC,UAAL,CAAgB6B,MAAhB,EAAhB;;AACA,UAAIU,OAAJ,EAAa;AACX,oBAA2B,KAAKnC,QAAhC;AAAA,YAAOc,QAAP,SAAOA,QAAP;AAAA,YAAiBsB,MAAjB,SAAiBA,MAAjB;AACA,YAAOC,IAAP,GAAe,KAAKzC,UAApB,CAAOyC,IAAP;AACA,YAAIC,CAAC,GAAGD,IAAI,GAAGvB,QAAf;;AACA,YAAIsB,MAAJ,EAAY;AACVE,UAAAA,CAAC,GAAGF,MAAM,CAACE,CAAD,CAAV;AACD;;AACD,aAAKlC,SAAL,CAAemC,GAAf,CAAmB;AACjBC,UAAAA,QAAQ,EAAE;AAACH,YAAAA,IAAI,EAAEC;AAAP;AADO,SAAnB;AAGD;;AACD,aAAOH,OAAP;AACD;;;WAED,kBAAe;AACb,WAAKvC,UAAL,CAAgBmB,MAAhB;AACA,WAAKX,SAAL,CAAeqC,MAAf;;AAFa,kDAGQ,KAAKhC,OAHb;AAAA;;AAAA;AAGb,+DAAmC;AAAA,cAAxBY,MAAwB;AACjCA,UAAAA,MAAM,CAACoB,MAAP;AACD;AALY;AAAA;AAAA;AAAA;AAAA;;AAMb,WAAKhC,OAAL,CAAaiC,MAAb,GAAsB,CAAtB;AACD;;;;;;AAGH,IAAMC,EAAE,qRAAR;;AAcA,SAAStC,YAAT,CAAsBZ,EAAtB,EAAiDC,SAAjD,EAAsF;AACpF,MAAMkD,aAAa,GAAG,wDAAyBlD,SAAS,CAACmC,IAAnC,CAAtB;AACA,SAAO,IAAIgB,eAAJ,CAAcpD,EAAd,EAAkB;AACvBkD,IAAAA,EAAE,EAAFA,EADuB;AAEvBG,IAAAA,OAAO,EAAE;AACPC,MAAAA,cAAc,EAAEH;AADT,KAFc;AAKvBI,IAAAA,QAAQ,EAAE,CAAC,UAAD;AALa,GAAlB,CAAP;AAOD","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, Transform} from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport {\n  padBuffer,\n  getAttributeTypeFromSize,\n  getSourceBufferAttribute,\n  getAttributeBufferLength,\n  cycleBuffers,\n  InterpolationTransitionSettings\n} from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\n\nimport type {Timeline, Transform as LumaTransform} from '@luma.gl/engine';\nimport type {Buffer as LumaBuffer} from '@luma.gl/webgl';\nimport type {NumericArray} from '../types/types';\nimport type GPUTransition from './gpu-transition';\n\nexport default class GPUInterpolationTransition implements GPUTransition {\n  gl: WebGLRenderingContext;\n  type = 'interpolation';\n  attributeInTransition: Attribute;\n\n  private settings?: InterpolationTransitionSettings;\n  private attribute: Attribute;\n  private transition: Transition;\n  private currentStartIndices: NumericArray | null;\n  private currentLength: number;\n  private transform: LumaTransform;\n  private buffers: LumaBuffer[];\n\n  constructor({\n    gl,\n    attribute,\n    timeline\n  }: {\n    gl: WebGLRenderingContext;\n    attribute: Attribute;\n    timeline: Timeline;\n  }) {\n    this.gl = gl;\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    // this is the attribute we return during the transition - note: if it is a constant\n    // attribute, it will be converted and returned as a regular attribute\n    // `attribute.userData` is the original options passed when constructing the attribute.\n    // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    // storing currentLength because this.buffer may be larger than the actual length we want to use\n    // this is because we only reallocate buffers when they grow, not when they shrink,\n    // due to performance costs\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: GL.DYNAMIC_COPY\n    };\n    this.buffers = [\n      new Buffer(gl, bufferOpts), // from\n      new Buffer(gl, bufferOpts) // current\n    ];\n  }\n\n  get inProgress(): boolean {\n    return this.transition.inProgress;\n  }\n\n  // this is called when an attribute's values have changed and\n  // we need to start animating towards the new values\n  // this also correctly resizes / pads the transform's buffers\n  // in case the attribute's buffer has changed in length or in\n  // startIndices\n  start(transitionSettings: InterpolationTransitionSettings, numInstances: number): void {\n    if (transitionSettings.duration <= 0) {\n      this.transition.cancel();\n      return;\n    }\n    this.settings = transitionSettings;\n\n    const {gl, buffers, attribute} = this;\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the current buffer.\n    cycleBuffers(buffers);\n\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({buffer, ...padBufferOpts});\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.setData({\n      buffer: buffers[1],\n      // Hack: Float64Array is required for double-precision attributes\n      // to generate correct shader attributes\n      value: attribute.value as NumericArray\n    });\n\n    this.transition.start(transitionSettings);\n\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aFrom: buffers[0],\n        aTo: getSourceBufferAttribute(gl, attribute)\n      },\n      feedbackBuffers: {\n        vCurrent: buffers[1]\n      }\n    });\n  }\n\n  update(): boolean {\n    const updated = this.transition.update();\n    if (updated) {\n      const {duration, easing} = this.settings as InterpolationTransitionSettings;\n      const {time} = this.transition;\n      let t = time / duration;\n      if (easing) {\n        t = easing(t);\n      }\n      this.transform.run({\n        uniforms: {time: t}\n      });\n    }\n    return updated;\n  }\n\n  cancel(): void {\n    this.transition.cancel();\n    this.transform.delete();\n    for (const buffer of this.buffers) {\n      buffer.delete();\n    }\n    this.buffers.length = 0;\n  }\n}\n\nconst vs = `\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n`;\n\nfunction getTransform(gl: WebGLRenderingContext, attribute: Attribute): LumaTransform {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}\n"],"file":"gpu-interpolation-transition.js"}