{"version":3,"sources":["../../../src/utils/tesselator.ts"],"names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Buffer","Tesselator","constructor","opts","attributes","typedArrayManager","_attributeDefs","updateGeometry","Object","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","value","ArrayBuffer","isView","offset","stride","_allocate","instanceCount","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","object","index","geometry","indexStarts","vertexStarts","Infinity","normalizedData","dataIndex","normalizedGeometry","normalizeGeometry","getGeometrySize","length","byteStride","accessor","byteLength","buffer","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes","vertexCount"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/webgl';\n\nimport type {BinaryAttribute} from '../lib/attribute/attribute';\nimport type {TypedArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\nimport type {TypedArrayManager} from './typed-array-manager';\n\ntype ExternalBuffer = TypedArray | Buffer | BinaryAttribute;\n\ntype TesselatorOptions<GeometryT, ExtraOptionsT> = ExtraOptionsT & {\n  attributes?: Record<string, any>;\n  getGeometry?: AccessorFunction<any, GeometryT>;\n  data?: any;\n  buffers?: Record<string, ExternalBuffer>;\n  geometryBuffer?: ExternalBuffer;\n  positionFormat?: 'XY' | 'XYZ';\n  dataChanged?: {startRow: number; endRow?: number}[] | string | false;\n  normalize?: boolean;\n};\n\nexport type GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\nexport default abstract class Tesselator<GeometryT, NormalizedGeometryT, ExtraOptionsT> {\n  opts: TesselatorOptions<GeometryT, ExtraOptionsT>;\n  typedArrayManager: TypedArrayManager;\n  indexStarts: number[] = [0];\n  vertexStarts: number[] = [0];\n  vertexCount: number = 0;\n  instanceCount: number = 0;\n  attributes: Record<string, TypedArray | null>;\n\n  protected _attributeDefs: any;\n  protected data: any;\n  protected getGeometry?: AccessorFunction<any, GeometryT> | null;\n  protected geometryBuffer?: ExternalBuffer;\n  protected buffers!: Record<string, ExternalBuffer>;\n  protected positionSize!: number;\n  protected normalize!: boolean;\n\n  constructor(opts: TesselatorOptions<GeometryT, ExtraOptionsT>) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n  }\n\n  /* Public methods */\n  updateGeometry(opts: TesselatorOptions<GeometryT, ExtraOptionsT>): void {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged as {startRow: number; endRow?: number}[]) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}: {startRow: number; endRow: number}): void {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  // Subclass interface\n\n  /** Convert geometry to a uniform shape */\n  protected abstract normalizeGeometry(geometry: GeometryT): NormalizedGeometryT;\n\n  /** Update the positions buffer of a single geometry */\n  protected abstract updateGeometryAttributes(\n    geometry: NormalizedGeometryT | null,\n    context: GeometryUpdateContext\n  );\n\n  /** Get the number of vertices in a geometry */\n  protected abstract getGeometrySize(geometry: NormalizedGeometryT): number;\n\n  protected getGeometryFromBuffer(\n    geometryBuffer: ExternalBuffer\n  ): AccessorFunction<any, GeometryT> | null {\n    const value = (geometryBuffer as BinaryAttribute).value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: (geometryBuffer as BinaryAttribute).offset,\n      stride: (geometryBuffer as BinaryAttribute).stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  private _allocate(instanceCount: number, copy: boolean): void {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  private _forEachGeometry(\n    visitor: (geometry: GeometryT | null, index: number) => void,\n    startRow: number,\n    endRow: number\n  ): void {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _rebuildGeometry(dataRange?: {startRow: number; endRow?: number}): void {\n    if (!this.data) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData: Record<number, NormalizedGeometryT | null> = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry: GeometryT | null, dataIndex: number) => {\n          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] =\n            vertexStarts[dataIndex] +\n            (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        // @ts-expect-error (2339) accessor is not typed\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    // @ts-ignore (2739) context will be populated in the loop\n    const context: GeometryUpdateContext = {};\n\n    this._forEachGeometry(\n      (geometry: GeometryT | null, dataIndex: number) => {\n        const normalizedGeometry =\n          normalizedData[dataIndex] ||\n          // @ts-expect-error (2352) GeometryT cannot be casted to NormalizedGeometryT. We are assuming the user passed already normalized data if opts.normalize is set to false.\n          (geometry as NormalizedGeometryT);\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(normalizedGeometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"],"file":"tesselator.js"}