{"version":3,"sources":["../../../src/lib/binary-to-geojson.ts"],"names":["binaryToGeojson","data","options","globalFeatureId","undefined","getSingleFeature","parseFeatures","type","binaryToGeoJson","format","binaryToGeometry","Error","dataArray","normalizeInput","lastIndex","lastValue","featureIds","value","i","length","currValue","globalFeatureIds","parseFeature","parseFeatureCollection","startIndex","endIndex","pointToGeoJson","lineStringToGeoJson","polygonToGeoJson","unexpectedInput","isHeterogeneousType","Boolean","points","lines","polygons","parseType","features","push","geometry","properties","parseProperties","fields","parseFields","Object","assign","key","numericProps","Infinity","positions","polygonIndices","filter","x","primitivePolygonIndices","multi","coordinates","startRingIndex","endRingIndex","ringCoordinates","ringToGeoJson","startPolygonIndex","endPolygonIndex","polygonCoordinates","pathIndices","size","j","coord","Array","k","Number"],"mappings":"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","sourcesContent":["import type {\n  BinaryGeometry,\n  BinaryFeatures,\n  BinaryGeometryType,\n  BinaryPointFeatures,\n  BinaryLineFeatures,\n  BinaryPolygonFeatures,\n  BinaryAttribute\n} from '@loaders.gl/schema';\nimport type {Feature, Geometry, Position, GeoJsonProperties} from '@loaders.gl/schema';\nimport type {\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon\n} from '@loaders.gl/schema';\n\n// Note:L We do not handle GeometryCollection, define a limited Geometry type that always has coordinates.\n// type FeatureGeometry = Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon;\n\ntype BinaryToGeoJsonOptions = {\n  type?: BinaryGeometryType;\n  globalFeatureId?: number;\n};\n\n/**\n * Convert binary geometry representation to GeoJSON\n * @param data   geometry data in binary representation\n * @param options\n * @param options.type  Input data type: Point, LineString, or Polygon\n * @param options.featureId  Global feature id. If specified, only a single feature is extracted\n * @return GeoJSON objects\n */\nexport function binaryToGeojson(\n  data: BinaryFeatures,\n  options?: BinaryToGeoJsonOptions\n): Feature[] | Feature {\n  const globalFeatureId = options?.globalFeatureId;\n  if (globalFeatureId !== undefined) {\n    return getSingleFeature(data, globalFeatureId);\n  }\n  return parseFeatures(data, options?.type);\n}\n\n/** @deprecated use `binaryToGeojson` or `binaryToGeometry` instead */\nexport function binaryToGeoJson(\n  data: BinaryGeometry | BinaryFeatures,\n  type?: BinaryGeometryType,\n  format: 'feature' | 'geometry' = 'feature'\n): Geometry | Feature[] {\n  switch (format) {\n    case 'feature':\n      return parseFeatures(data as BinaryFeatures, type);\n    case 'geometry':\n      return binaryToGeometry(data as BinaryGeometry);\n    default:\n      throw new Error(format);\n  }\n}\n\n/**\n * Return a single feature from a binary geometry representation as GeoJSON\n * @param data   geometry data in binary representation\n * @return GeoJSON feature\n */\nfunction getSingleFeature(data: BinaryFeatures, globalFeatureId: number): Feature {\n  const dataArray = normalizeInput(data);\n  for (const data of dataArray) {\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Scan through data until we find matching feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n        return parseFeature(data, lastIndex, i);\n      }\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n      return parseFeature(data, lastIndex, data.featureIds.value.length);\n    }\n  }\n\n  throw new Error(`featureId:${globalFeatureId} not found`);\n}\n\nfunction parseFeatures(data: BinaryFeatures, type?: BinaryGeometryType): Feature[] {\n  const dataArray = normalizeInput(data, type);\n  return parseFeatureCollection(dataArray);\n}\n\n/** Parse input binary data and return a valid GeoJSON geometry object */\nexport function binaryToGeometry(\n  data: BinaryGeometry,\n  startIndex?: number,\n  endIndex?: number\n): Geometry {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      const unexpectedInput: never = data;\n      throw new Error(`Unsupported geometry type: ${(unexpectedInput as any)?.type}`);\n  }\n}\n\ntype BinaryFeature = BinaryPointFeatures | BinaryLineFeatures | BinaryPolygonFeatures;\ntype BinaryFeaturesArray = BinaryFeature[];\n\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data: BinaryFeatures, type?: BinaryGeometryType): BinaryFeaturesArray {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    // @ts-expect-error This is a legacy check which allowed `data` to be an instance of the values\n    // here. Aka the new data.points, data.lines, or data.polygons.\n    data.type = type || parseType(data);\n    return [data] as BinaryFeaturesArray;\n  }\n\n  const features: BinaryFeaturesArray = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n\n  return features;\n}\n\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray): Feature[] {\n  const features: Feature[] = [];\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Need to deduce start, end indices of each feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    // Last feature\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n  return features;\n}\n\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex?: number, endIndex?: number): Feature {\n  const geometry = binaryToGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  const fields = parseFields(data, startIndex, endIndex);\n  return {type: 'Feature', geometry, properties, ...fields};\n}\n\n/** Parse input binary data and return an object of fields */\nfunction parseFields(data, startIndex: number = 0, endIndex?: number): GeoJsonProperties {\n  return data.fields && data.fields[data.featureIds.value[startIndex]];\n}\n\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex: number = 0, endIndex?: number): GeoJsonProperties {\n  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\n\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(\n  data,\n  startIndex: number = -Infinity,\n  endIndex: number = Infinity\n): Polygon | MultiPolygon {\n  const {positions} = data;\n  const polygonIndices = data.polygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(\n    (x) => x >= startIndex && x <= endIndex\n  );\n  const multi = polygonIndices.length > 2;\n\n  // Polygon\n  if (!multi) {\n    const coordinates: Position[][] = [];\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {type: 'Polygon', coordinates};\n  }\n\n  // MultiPolygon\n  const coordinates: Position[][][] = [];\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(\n      data,\n      startPolygonIndex,\n      endPolygonIndex\n    ).coordinates;\n    coordinates.push(polygonCoordinates as Position[][]);\n  }\n\n  return {type: 'MultiPolygon', coordinates};\n}\n\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(\n  data,\n  startIndex: number = -Infinity,\n  endIndex: number = Infinity\n): LineString | MultiLineString {\n  const {positions} = data;\n  const pathIndices = data.pathIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {type: 'LineString', coordinates};\n  }\n\n  const coordinates: Position[][] = [];\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {type: 'MultiLineString', coordinates};\n}\n\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex): Point | MultiPoint {\n  const {positions} = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {type: 'MultiPoint', coordinates};\n  }\n\n  return {type: 'Point', coordinates: coordinates[0]};\n}\n\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param startIndex Start index to include in ring\n * @param endIndex End index to include in ring\n * @returns GeoJSON ring\n */\nfunction ringToGeoJson(\n  positions: BinaryAttribute,\n  startIndex?: number,\n  endIndex?: number\n): Position[] {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n\n  const ringCoordinates: Position[] = [];\n  for (let j = startIndex; j < endIndex; j++) {\n    const coord = Array<number>();\n    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {\n      coord.push(Number(positions.value[k]));\n    }\n    ringCoordinates.push(coord);\n  }\n  return ringCoordinates;\n}\n\n// Deduce geometry type of data object\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}\n"],"file":"binary-to-geojson.js"}