{"version":3,"sources":["../../../../src/lib/parsers/parse-crunch.ts"],"names":["CRN_FORMAT","cCRNFmtInvalid","cCRNFmtDXT1","cCRNFmtDXT3","cCRNFmtDXT5","DXT_FORMAT_MAP","pixelFormat","GL_EXTENSIONS_CONSTANTS","COMPRESSED_RGB_S3TC_DXT1_EXT","sizeFunction","getDxt1LevelSize","COMPRESSED_RGBA_S3TC_DXT3_EXT","getDxtXLevelSize","COMPRESSED_RGBA_S3TC_DXT5_EXT","cachedDstSize","dst","parseCrunch","data","options","crunchModule","srcSize","byteLength","bytes","Uint8Array","src","_malloc","arrayBufferCopy","HEAPU8","format","_crn_get_dxt_format","Boolean","mipMapLevels","_crn_get_levels","width","_crn_get_width","height","_crn_get_height","dstSize","i","_free","_crn_decompress","image","buffer","slice","internalFormat","srcData","dstData","dstByteOffset","numBytes","dst32Offset","tail","src32","Uint32Array","dst32","length"],"mappings":"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","sourcesContent":["import type {TextureLevel} from '@loaders.gl/schema';\nimport {loadCrunchModule} from './crunch-module-loader';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {assert} from '@loaders.gl/loader-utils';\nimport {getDxt1LevelSize, getDxtXLevelSize} from './parse-dds';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\n\n// Taken from crnlib.h\nconst CRN_FORMAT = {\n  cCRNFmtInvalid: -1,\n\n  cCRNFmtDXT1: 0,\n  // cCRNFmtDXT3 is not currently supported when writing to CRN - only DDS.\n  cCRNFmtDXT3: 1,\n  cCRNFmtDXT5: 2\n\n  // Crunch supports more formats than this.\n};\n\n/** Mapping of Crunch formats to DXT formats. */\nconst DXT_FORMAT_MAP = {\n  [CRN_FORMAT.cCRNFmtDXT1]: {\n    pixelFormat: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n    sizeFunction: getDxt1LevelSize\n  },\n  [CRN_FORMAT.cCRNFmtDXT3]: {\n    pixelFormat: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n    sizeFunction: getDxtXLevelSize\n  },\n  [CRN_FORMAT.cCRNFmtDXT5]: {\n    pixelFormat: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    sizeFunction: getDxtXLevelSize\n  }\n};\n\nlet cachedDstSize = 0;\nlet dst: number;\n\n/**\n * Parse texture data as \"CRN\" format.\n * Function is \"async\" as emscriptified decoder module is loaded asyncronously\n * @param data - binary data of compressed texture\n * @returns Promise of Array of the texture levels\n */\nexport async function parseCrunch(data, options: any): Promise<TextureLevel[]> {\n  const crunchModule = await loadCrunchModule(options);\n\n  // Copy the contents of the arrayBuffer into emscriptens heap.\n  const srcSize = data.byteLength;\n  const bytes = new Uint8Array(data);\n  const src = crunchModule._malloc(srcSize);\n  arrayBufferCopy(bytes, crunchModule.HEAPU8, src, srcSize);\n\n  // Determine what type of compressed data the file contains.\n  const format = crunchModule._crn_get_dxt_format(src, srcSize);\n  assert(Boolean(DXT_FORMAT_MAP[format]), 'Unsupported format');\n\n  // Gather basic metrics about the DXT data.\n  const mipMapLevels = crunchModule._crn_get_levels(src, srcSize);\n  const width = crunchModule._crn_get_width(src, srcSize);\n  const height = crunchModule._crn_get_height(src, srcSize);\n  // const bytesPerBlock = crunchModule._crn_get_bytes_per_block(src, srcSize);\n\n  // Determine the size of the decoded DXT data.\n  const sizeFunction = DXT_FORMAT_MAP[format].sizeFunction;\n  let dstSize = 0;\n  for (let i = 0; i < mipMapLevels; ++i) {\n    dstSize += sizeFunction(width >> i, height >> i);\n  }\n\n  // Allocate enough space on the emscripten heap to hold the decoded DXT data\n  // or reuse the existing allocation if a previous call to this function has\n  // already acquired a large enough buffer.\n  if (cachedDstSize < dstSize) {\n    if (dst) {\n      crunchModule._free(dst);\n    }\n    dst = crunchModule._malloc(dstSize);\n    cachedDstSize = dstSize;\n  }\n\n  // Decompress the DXT data from the Crunch file into the allocated space.\n  crunchModule._crn_decompress(src, srcSize, dst, dstSize, 0, mipMapLevels);\n\n  // Release the crunch file data from the emscripten heap.\n  crunchModule._free(src);\n\n  const image = new Uint8Array(crunchModule.HEAPU8.buffer, dst, dstSize).slice();\n  return extractMipmapImages(image, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction,\n    internalFormat: DXT_FORMAT_MAP[format].pixelFormat\n  });\n}\n\n/**\n * Copy an array of bytes into or out of the emscripten heap\n * @param {Uint8Array} srcData - Source data array\n * @param {Uint8Array} dstData - Destination data array\n * @param {number} dstByteOffset - Destination data offset\n * @param {number} numBytes - number of bytes to copy\n * @returns {void}\n */\nfunction arrayBufferCopy(srcData, dstData, dstByteOffset, numBytes) {\n  let i;\n  const dst32Offset = dstByteOffset / 4;\n  const tail = numBytes % 4;\n  const src32 = new Uint32Array(srcData.buffer, 0, (numBytes - tail) / 4);\n  const dst32 = new Uint32Array(dstData.buffer);\n  for (i = 0; i < src32.length; i++) {\n    dst32[dst32Offset + i] = src32[i];\n  }\n  for (i = numBytes - tail; i < numBytes; i++) {\n    dstData[dstByteOffset + i] = srcData[i];\n  }\n}\n"],"file":"parse-crunch.js"}