var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// ../../node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "../../node_modules/@xmldom/xmldom/lib/conventions.js"(exports2) {
    "use strict";
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    var MIME_TYPE = freeze({
      HTML: "text/html",
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      XML_APPLICATION: "application/xml",
      XML_TEXT: "text/xml",
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      HTML: "http://www.w3.org/1999/xhtml",
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      SVG: "http://www.w3.org/2000/svg",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports2.freeze = freeze;
    exports2.MIME_TYPE = MIME_TYPE;
    exports2.NAMESPACE = NAMESPACE;
  }
});

// ../../node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "../../node_modules/@xmldom/xmldom/lib/dom.js"(exports2) {
    var conventions = require_conventions();
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input)
        return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        dest[p] = src[p];
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t2 = function() {
        };
        var t = t2;
        ;
        t2.prototype = Super.prototype;
        t2 = new t2();
        copy(pt, t2);
        Class.prototype = pt = t2;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException2(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, DOMException2);
      }
      error.code = code;
      if (message)
        this.message = this.message + ": " + message;
      return error;
    }
    DOMException2.prototype = Error.prototype;
    copy(ExceptionCode, DOMException2);
    function NodeList() {
    }
    NodeList.prototype = {
      length: 0,
      item: function(index2) {
        return this[index2] || null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc != inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i];
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw DOMException2(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException2(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException2(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      hasFeature: function(feature, version) {
        return true;
      },
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        this.insertBefore(newChild, oldChild);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (map[n] == namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (prefix in map) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function _insertBefore(parentNode, newChild, nextChild) {
      var cp = newChild.parentNode;
      if (cp) {
        cp.removeChild(newChild);
      }
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = newChild.firstChild;
        if (newFirst == null) {
          return newChild;
        }
        var newLast = newChild.lastChild;
      } else {
        newFirst = newLast = newChild;
      }
      var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = nextChild;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parentNode.firstChild = newFirst;
      }
      if (nextChild == null) {
        parentNode.lastChild = newLast;
      } else {
        nextChild.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parentNode;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        newChild.firstChild = newChild.lastChild = null;
      }
      return newChild;
    }
    function _appendSingleChild(parentNode, newChild) {
      var cp = newChild.parentNode;
      if (cp) {
        var pre = parentNode.lastChild;
        cp.removeChild(newChild);
        var pre = parentNode.lastChild;
      }
      var pre = parentNode.lastChild;
      newChild.parentNode = parentNode;
      newChild.previousSibling = pre;
      newChild.nextSibling = null;
      if (pre) {
        pre.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        if (this.documentElement == null && newChild.nodeType == ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches2 = classNames === nodeClassNames;
                  if (!matches2) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches2 = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches2) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<&"]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(node.data.replace(/[<&]/g, _xmlEncoder).replace(/]]>/g, "]]&gt;"));
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        var v = node[n];
        if (typeof v != "object") {
          if (v != node2[n]) {
            node2[n] = v;
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports2.DocumentType = DocumentType;
    exports2.DOMException = DOMException2;
    exports2.DOMImplementation = DOMImplementation;
    exports2.Element = Element;
    exports2.Node = Node;
    exports2.NodeList = NodeList;
    exports2.XMLSerializer = XMLSerializer;
  }
});

// ../../node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "../../node_modules/@xmldom/xmldom/lib/entities.js"(exports2) {
    var freeze = require_conventions().freeze;
    exports2.XML_ENTITIES = freeze({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' });
    exports2.HTML_ENTITIES = freeze({
      lt: "<",
      gt: ">",
      amp: "&",
      quot: '"',
      apos: "'",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      times: "\xD7",
      divide: "\xF7",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      "int": "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      euro: "\u20AC",
      trade: "\u2122",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    });
    exports2.entityMap = exports2.HTML_ENTITIES;
  }
});

// ../../node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "../../node_modules/@xmldom/xmldom/lib/sax.js"(exports2) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (k in entityMap) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(qname, value2, startIndex);
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
              case S_ATTR_SPACE:
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value.replace(/&#?\w+;/g, entityReplacer), start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          case "\x80":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            domBuilder.endPrefixMapping(prefix);
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        target[n] = source[n];
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
    };
    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1])
          return buf;
      }
    }
    exports2.XMLReader = XMLReader;
    exports2.ParseError = ParseError;
  }
});

// ../../node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "../../node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports2) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function DOMParser2(options) {
      this.options = options || { locator: {} };
    }
    DOMParser2.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      if (source && typeof source === "string") {
        sax2.parse(source, defaultNSMap, entityMap);
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports2.__DOMHandler = DOMHandler;
    exports2.DOMParser = DOMParser2;
    exports2.DOMImplementation = dom.DOMImplementation;
    exports2.XMLSerializer = dom.XMLSerializer;
  }
});

// ../../node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/@xmldom/xmldom/lib/index.js"(exports2) {
    var dom = require_dom();
    exports2.DOMImplementation = dom.DOMImplementation;
    exports2.XMLSerializer = dom.XMLSerializer;
    exports2.DOMParser = require_dom_parser().DOMParser;
  }
});

// ../../node_modules/contentstream/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../../node_modules/contentstream/node_modules/isarray/index.js"(exports2, module2) {
    module2.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
  }
});

// ../../node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "../../node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean2;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction2;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util2 = require("util");
      if (typeof util2.inherits !== "function")
        throw "";
      module2.exports = util2.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  }
});

// ../../node_modules/string_decoder/index.js
var require_string_decoder = __commonJS({
  "../../node_modules/string_decoder/index.js"(exports2) {
    var Buffer2 = require("buffer").Buffer;
    var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error("Unknown encoding: " + encoding);
      }
    }
    var StringDecoder = exports2.StringDecoder = function(encoding) {
      this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer2(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }
});

// ../../node_modules/contentstream/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../../node_modules/contentstream/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    module2.exports = Readable2;
    var isArray = require_isarray();
    var Buffer2 = require("buffer").Buffer;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream2 = require("stream");
    var util2 = require_util();
    util2.inherits = require_inherits();
    var StringDecoder;
    util2.inherits(Readable2, Stream2);
    function ReadableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.calledRead = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!(this instanceof Readable2))
        return new Readable2(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream2.call(this);
    }
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (typeof chunk === "string" && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer2(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (chunk === null || chunk === void 0) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error("stream.push() after EOF");
          stream.emit("error", e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error("stream.unshift() after end event");
          stream.emit("error", e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
          if (state.needReadable)
            emitReadable(stream);
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    var MAX_HWM = 8388608;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (n === null || isNaN(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable2.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
      if (typeof n !== "number" || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        ret = null;
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
        if (state.length === 0)
          endReadable(this);
        return ret;
      }
      var doRead = state.needReadable;
      if (state.length - n <= state.highWaterMark)
        doRead = true;
      if (state.ended || state.reading)
        doRead = false;
      if (doRead) {
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    function emitReadable_(stream) {
      stream.emit("readable");
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        if (readable !== src)
          return;
        cleanup();
      }
      function onend() {
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      function cleanup() {
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", cleanup);
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
      function onerror(er) {
        unpipe();
        dest.removeListener("error", onerror);
        if (EE.listenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      if (!dest._events || !dest._events.error)
        dest.on("error", onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        this.on("readable", pipeOnReadable);
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (written === false) {
          state.awaitDrain++;
        }
      }
      while (state.pipesCount && (chunk = src.read()) !== null) {
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
        src.emit("data", chunk);
        if (state.awaitDrain > 0)
          return;
      }
      if (state.pipesCount === 0) {
        state.flowing = false;
        if (EE.listenerCount(src, "data") > 0)
          emitDataEvents(src);
        return;
      }
      state.ranOut = true;
    }
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      if (ev === "data" && !this._readableState.flowing)
        emitDataEvents(this);
      if (ev === "readable" && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit("resume");
    };
    Readable2.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit("pause");
    };
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
      if (state.flowing) {
        throw new Error("Cannot switch to old mode now.");
      }
      var paused = startPaused || false;
      var readable = false;
      stream.readable = true;
      stream.pipe = Stream2.prototype.pipe;
      stream.on = stream.addListener = Stream2.prototype.on;
      stream.on("readable", function() {
        readable = true;
        var c;
        while (!paused && (c = stream.read()) !== null)
          stream.emit("data", c);
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
      stream.pause = function() {
        paused = true;
        this.emit("pause");
      };
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit("readable");
          });
        else
          this.read(0);
        this.emit("resume");
      };
      stream.emit("readable");
    }
    Readable2.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (typeof stream[i] === "function" && typeof this[i] === "undefined") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable2._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join("");
        else
          ret = Buffer2.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = "";
          else
            ret = new Buffer2(n);
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error("endReadable called on non-empty stream");
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../node_modules/contentstream/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../../node_modules/contentstream/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    module2.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util2 = require_util();
    util2.inherits = require_inherits();
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    util2.inherits(Duplex, Readable2);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  }
});

// ../../node_modules/contentstream/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../../node_modules/contentstream/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    module2.exports = Writable;
    var Buffer2 = require("buffer").Buffer;
    Writable.WritableState = WritableState;
    var util2 = require_util();
    util2.inherits = require_inherits();
    var Stream2 = require("stream");
    util2.inherits(Writable, Stream2);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.objectMode = !!options.objectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require_stream_duplex();
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream2.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe. Not readable."));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
        var er = new TypeError("Invalid non-string/buffer chunk");
        stream.emit("error", er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = function() {
        };
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      return ret;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = new Buffer2(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished2 = needFinish(stream, state);
        if (!finished2 && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished2, cb);
          });
        } else {
          afterWrite(stream, state, finished2, cb);
        }
      }
    }
    function afterWrite(stream, state, finished2, cb) {
      if (!finished2)
        onwriteDrain(stream, state);
      cb();
      if (finished2)
        finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, len, chunk, encoding, cb);
        if (state.writing) {
          c++;
          break;
        }
      }
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (typeof chunk !== "undefined" && chunk !== null)
        this.write(chunk, encoding);
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit("finish");
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
    }
  }
});

// ../../node_modules/contentstream/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../../node_modules/contentstream/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util2 = require_util();
    util2.inherits = require_inherits();
    util2.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== void 0)
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      var ts = this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once("finish", function() {
        if (typeof this._flush === "function")
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit("error", er);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error("calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../../node_modules/contentstream/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../../node_modules/contentstream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util2 = require_util();
    util2.inherits = require_inherits();
    util2.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/contentstream/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "../../node_modules/contentstream/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream2 = require("stream");
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = Stream2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    if (!process.browser && process.env.READABLE_STREAM === "disable") {
      module2.exports = require("stream");
    }
  }
});

// ../../node_modules/contentstream/index.js
var require_contentstream = __commonJS({
  "../../node_modules/contentstream/index.js"(exports2, module2) {
    "use strict";
    var Readable2 = require_readable().Readable;
    var util2 = require("util");
    module2.exports = ContentStream;
    function ContentStream(obj, options) {
      if (!(this instanceof ContentStream)) {
        return new ContentStream(obj, options);
      }
      Readable2.call(this, options);
      if (obj === null || obj === void 0) {
        obj = String(obj);
      }
      this._obj = obj;
    }
    util2.inherits(ContentStream, Readable2);
    ContentStream.prototype._read = function(n) {
      var obj = this._obj;
      if (typeof obj === "string") {
        this.push(new Buffer(obj));
      } else if (Buffer.isBuffer(obj)) {
        this.push(obj);
      } else {
        this.push(new Buffer(JSON.stringify(obj)));
      }
      this.push(null);
    };
  }
});

// ../../node_modules/gif-encoder/node_modules/isarray/index.js
var require_isarray2 = __commonJS({
  "../../node_modules/gif-encoder/node_modules/isarray/index.js"(exports2, module2) {
    module2.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
  }
});

// ../../node_modules/gif-encoder/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "../../node_modules/gif-encoder/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    module2.exports = Writable;
    var Buffer2 = require("buffer").Buffer;
    Writable.WritableState = WritableState;
    var util2 = require_util();
    util2.inherits = require_inherits();
    var Stream2 = require("stream");
    util2.inherits(Writable, Stream2);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      var Duplex = require_stream_duplex2();
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require_stream_duplex2();
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream2.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe. Not readable."));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!util2.isBuffer(chunk) && !util2.isString(chunk) && !util2.isNullOrUndefined(chunk) && !state.objectMode) {
        var er = new TypeError("Invalid non-string/buffer chunk");
        stream.emit("error", er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (util2.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (util2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (!util2.isFunction(cb))
        cb = function() {
        };
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(this, state);
      }
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && util2.isString(chunk)) {
        chunk = new Buffer2(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (util2.isBuffer(chunk))
        encoding = "buffer";
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, false, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          state.pendingcb--;
          cb(er);
        });
      else {
        state.pendingcb--;
        cb(er);
      }
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished2 = needFinish(stream, state);
        if (!finished2 && !state.corked && !state.bufferProcessing && state.buffer.length) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished2, cb);
          });
        } else {
          afterWrite(stream, state, finished2, cb);
        }
      }
    }
    function afterWrite(stream, state, finished2, cb) {
      if (!finished2)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      if (stream._writev && state.buffer.length > 1) {
        var cbs = [];
        for (var c = 0; c < state.buffer.length; c++)
          cbs.push(state.buffer[c].callback);
        state.pendingcb++;
        doWrite(stream, state, true, state.length, state.buffer, "", function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
        state.buffer = [];
      } else {
        for (var c = 0; c < state.buffer.length; c++) {
          var entry = state.buffer[c];
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          if (state.writing) {
            c++;
            break;
          }
        }
        if (c < state.buffer.length)
          state.buffer = state.buffer.slice(c);
        else
          state.buffer.length = 0;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (util2.isFunction(chunk)) {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (util2.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (!util2.isNullOrUndefined(chunk))
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit("finish");
        } else
          prefinish(stream, state);
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
    }
  }
});

// ../../node_modules/gif-encoder/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "../../node_modules/gif-encoder/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    module2.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util2 = require_util();
    util2.inherits = require_inherits();
    var Readable2 = require_stream_readable2();
    var Writable = require_stream_writable2();
    util2.inherits(Duplex, Readable2);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  }
});

// ../../node_modules/gif-encoder/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "../../node_modules/gif-encoder/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    module2.exports = Readable2;
    var isArray = require_isarray2();
    var Buffer2 = require("buffer").Buffer;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream2 = require("stream");
    var util2 = require_util();
    util2.inherits = require_inherits();
    var StringDecoder;
    var debug = require("util");
    if (debug && debug.debuglog) {
      debug = debug.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    util2.inherits(Readable2, Stream2);
    function ReadableState(options, stream) {
      var Duplex = require_stream_duplex2();
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      var Duplex = require_stream_duplex2();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream2.call(this);
    }
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (util2.isString(chunk) && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer2(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (util2.isNullOrUndefined(chunk)) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error("stream.push() after EOF");
          stream.emit("error", e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error("stream.unshift() after end event");
          stream.emit("error", e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          if (!addToFront)
            state.reading = false;
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit("data", chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (isNaN(n) || util2.isNull(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      var state = this._readableState;
      var nOrig = n;
      if (!util2.isNumber(n) || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      }
      if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (util2.isNull(ret)) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
      if (!util2.isNull(ret))
        this.emit("data", ret);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!util2.isBuffer(chunk) && !util2.isString(chunk) && !util2.isNullOrUndefined(chunk) && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          process.nextTick(function() {
            emitReadable_(stream);
          });
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        if (ret === false) {
          debug("false write response, pause", src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EE.listenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      if (!dest._events || !dest._events.error)
        dest.on("error", onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      if (ev === "data" && this._readableState.flowing !== false) {
        this.resume();
      }
      if (ev === "readable" && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            var self2 = this;
            process.nextTick(function() {
              debug("readable nexttick read 0");
              self2.read(0);
            });
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        if (!state.reading) {
          debug("resume read 0");
          this.read(0);
        }
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(function() {
          resume_(stream, state);
        });
      }
    }
    function resume_(stream, state) {
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (chunk !== null && state.flowing);
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (!chunk || !state.objectMode && !chunk.length)
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (util2.isFunction(stream[i]) && util2.isUndefined(this[i])) {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable2._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join("");
        else
          ret = Buffer2.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = "";
          else
            ret = new Buffer2(n);
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error("endReadable called on non-empty stream");
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../node_modules/gif-encoder/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "../../node_modules/gif-encoder/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    module2.exports = Transform;
    var Duplex = require_stream_duplex2();
    var util2 = require_util();
    util2.inherits = require_inherits();
    util2.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (!util2.isNullOrUndefined(data))
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once("prefinish", function() {
        if (util2.isFunction(this._flush))
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (!util2.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit("error", er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error("calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../../node_modules/gif-encoder/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "../../node_modules/gif-encoder/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    module2.exports = PassThrough;
    var Transform = require_stream_transform2();
    var util2 = require_util();
    util2.inherits = require_inherits();
    util2.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/gif-encoder/node_modules/readable-stream/readable.js
var require_readable2 = __commonJS({
  "../../node_modules/gif-encoder/node_modules/readable-stream/readable.js"(exports2, module2) {
    exports2 = module2.exports = require_stream_readable2();
    exports2.Stream = require("stream");
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable2();
    exports2.Duplex = require_stream_duplex2();
    exports2.Transform = require_stream_transform2();
    exports2.PassThrough = require_stream_passthrough2();
    if (!process.browser && process.env.READABLE_STREAM === "disable") {
      module2.exports = require("stream");
    }
  }
});

// ../../node_modules/gif-encoder/lib/TypedNeuQuant.js
var require_TypedNeuQuant = __commonJS({
  "../../node_modules/gif-encoder/lib/TypedNeuQuant.js"(exports2, module2) {
    var ncycles = 100;
    var netsize = 256;
    var maxnetpos = netsize - 1;
    var netbiasshift = 4;
    var intbiasshift = 16;
    var intbias = 1 << intbiasshift;
    var gammashift = 10;
    var gamma = 1 << gammashift;
    var betashift = 10;
    var beta = intbias >> betashift;
    var betagamma = intbias << gammashift - betashift;
    var initrad = netsize >> 3;
    var radiusbiasshift = 6;
    var radiusbias = 1 << radiusbiasshift;
    var initradius = initrad * radiusbias;
    var radiusdec = 30;
    var alphabiasshift = 10;
    var initalpha = 1 << alphabiasshift;
    var radbiasshift = 8;
    var radbias = 1 << radbiasshift;
    var alpharadbshift = alphabiasshift + radbiasshift;
    var alpharadbias = 1 << alpharadbshift;
    var prime1 = 499;
    var prime2 = 491;
    var prime3 = 487;
    var prime4 = 503;
    var minpicturebytes = 3 * prime4;
    function NeuQuant(pixels, samplefac) {
      var network;
      var netindex;
      var bias;
      var freq;
      var radpower;
      function init() {
        network = [];
        netindex = new Int32Array(256);
        bias = new Int32Array(netsize);
        freq = new Int32Array(netsize);
        radpower = new Int32Array(netsize >> 3);
        var i, v;
        for (i = 0; i < netsize; i++) {
          v = (i << netbiasshift + 8) / netsize;
          network[i] = new Float64Array([v, v, v, 0]);
          freq[i] = intbias / netsize;
          bias[i] = 0;
        }
      }
      function unbiasnet() {
        for (var i = 0; i < netsize; i++) {
          network[i][0] >>= netbiasshift;
          network[i][1] >>= netbiasshift;
          network[i][2] >>= netbiasshift;
          network[i][3] = i;
        }
      }
      function altersingle(alpha, i, b, g, r) {
        network[i][0] -= alpha * (network[i][0] - b) / initalpha;
        network[i][1] -= alpha * (network[i][1] - g) / initalpha;
        network[i][2] -= alpha * (network[i][2] - r) / initalpha;
      }
      function alterneigh(radius, i, b, g, r) {
        var lo = Math.abs(i - radius);
        var hi = Math.min(i + radius, netsize);
        var j = i + 1;
        var k = i - 1;
        var m = 1;
        var p, a;
        while (j < hi || k > lo) {
          a = radpower[m++];
          if (j < hi) {
            p = network[j++];
            p[0] -= a * (p[0] - b) / alpharadbias;
            p[1] -= a * (p[1] - g) / alpharadbias;
            p[2] -= a * (p[2] - r) / alpharadbias;
          }
          if (k > lo) {
            p = network[k--];
            p[0] -= a * (p[0] - b) / alpharadbias;
            p[1] -= a * (p[1] - g) / alpharadbias;
            p[2] -= a * (p[2] - r) / alpharadbias;
          }
        }
      }
      function contest(b, g, r) {
        var bestd = ~(1 << 31);
        var bestbiasd = bestd;
        var bestpos = -1;
        var bestbiaspos = bestpos;
        var i, n, dist, biasdist, betafreq;
        for (i = 0; i < netsize; i++) {
          n = network[i];
          dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);
          if (dist < bestd) {
            bestd = dist;
            bestpos = i;
          }
          biasdist = dist - (bias[i] >> intbiasshift - netbiasshift);
          if (biasdist < bestbiasd) {
            bestbiasd = biasdist;
            bestbiaspos = i;
          }
          betafreq = freq[i] >> betashift;
          freq[i] -= betafreq;
          bias[i] += betafreq << gammashift;
        }
        freq[bestpos] += beta;
        bias[bestpos] -= betagamma;
        return bestbiaspos;
      }
      function inxbuild() {
        var i, j, p, q2, smallpos, smallval, previouscol = 0, startpos = 0;
        for (i = 0; i < netsize; i++) {
          p = network[i];
          smallpos = i;
          smallval = p[1];
          for (j = i + 1; j < netsize; j++) {
            q2 = network[j];
            if (q2[1] < smallval) {
              smallpos = j;
              smallval = q2[1];
            }
          }
          q2 = network[smallpos];
          if (i != smallpos) {
            j = q2[0];
            q2[0] = p[0];
            p[0] = j;
            j = q2[1];
            q2[1] = p[1];
            p[1] = j;
            j = q2[2];
            q2[2] = p[2];
            p[2] = j;
            j = q2[3];
            q2[3] = p[3];
            p[3] = j;
          }
          if (smallval != previouscol) {
            netindex[previouscol] = startpos + i >> 1;
            for (j = previouscol + 1; j < smallval; j++)
              netindex[j] = i;
            previouscol = smallval;
            startpos = i;
          }
        }
        netindex[previouscol] = startpos + maxnetpos >> 1;
        for (j = previouscol + 1; j < 256; j++)
          netindex[j] = maxnetpos;
      }
      function inxsearch(b, g, r) {
        var a, p, dist;
        var bestd = 1e3;
        var best = -1;
        var i = netindex[g];
        var j = i - 1;
        while (i < netsize || j >= 0) {
          if (i < netsize) {
            p = network[i];
            dist = p[1] - g;
            if (dist >= bestd)
              i = netsize;
            else {
              i++;
              if (dist < 0)
                dist = -dist;
              a = p[0] - b;
              if (a < 0)
                a = -a;
              dist += a;
              if (dist < bestd) {
                a = p[2] - r;
                if (a < 0)
                  a = -a;
                dist += a;
                if (dist < bestd) {
                  bestd = dist;
                  best = p[3];
                }
              }
            }
          }
          if (j >= 0) {
            p = network[j];
            dist = g - p[1];
            if (dist >= bestd)
              j = -1;
            else {
              j--;
              if (dist < 0)
                dist = -dist;
              a = p[0] - b;
              if (a < 0)
                a = -a;
              dist += a;
              if (dist < bestd) {
                a = p[2] - r;
                if (a < 0)
                  a = -a;
                dist += a;
                if (dist < bestd) {
                  bestd = dist;
                  best = p[3];
                }
              }
            }
          }
        }
        return best;
      }
      function learn() {
        var i;
        var lengthcount = pixels.length;
        var alphadec2 = 30 + (samplefac - 1) / 3;
        var samplepixels = lengthcount / (3 * samplefac);
        var delta = ~~(samplepixels / ncycles);
        var alpha = initalpha;
        var radius = initradius;
        var rad = radius >> radiusbiasshift;
        if (rad <= 1)
          rad = 0;
        for (i = 0; i < rad; i++)
          radpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));
        var step;
        if (lengthcount < minpicturebytes) {
          samplefac = 1;
          step = 3;
        } else if (lengthcount % prime1 !== 0) {
          step = 3 * prime1;
        } else if (lengthcount % prime2 !== 0) {
          step = 3 * prime2;
        } else if (lengthcount % prime3 !== 0) {
          step = 3 * prime3;
        } else {
          step = 3 * prime4;
        }
        var b, g, r, j;
        var pix = 0;
        i = 0;
        while (i < samplepixels) {
          b = (pixels[pix] & 255) << netbiasshift;
          g = (pixels[pix + 1] & 255) << netbiasshift;
          r = (pixels[pix + 2] & 255) << netbiasshift;
          j = contest(b, g, r);
          altersingle(alpha, j, b, g, r);
          if (rad !== 0)
            alterneigh(rad, j, b, g, r);
          pix += step;
          if (pix >= lengthcount)
            pix -= lengthcount;
          i++;
          if (delta === 0)
            delta = 1;
          if (i % delta === 0) {
            alpha -= alpha / alphadec2;
            radius -= radius / radiusdec;
            rad = radius >> radiusbiasshift;
            if (rad <= 1)
              rad = 0;
            for (j = 0; j < rad; j++)
              radpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));
          }
        }
      }
      function buildColormap() {
        init();
        learn();
        unbiasnet();
        inxbuild();
      }
      this.buildColormap = buildColormap;
      function getColormap() {
        var map = [];
        var index2 = [];
        for (var i = 0; i < netsize; i++)
          index2[network[i][3]] = i;
        var k = 0;
        for (var l = 0; l < netsize; l++) {
          var j = index2[l];
          map[k++] = network[j][0];
          map[k++] = network[j][1];
          map[k++] = network[j][2];
        }
        return map;
      }
      this.getColormap = getColormap;
      this.lookupRGB = inxsearch;
    }
    module2.exports = NeuQuant;
  }
});

// ../../node_modules/gif-encoder/lib/LZWEncoder.js
var require_LZWEncoder = __commonJS({
  "../../node_modules/gif-encoder/lib/LZWEncoder.js"(exports2, module2) {
    var EOF = -1;
    var BITS = 12;
    var HSIZE = 5003;
    var masks = [
      0,
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255,
      511,
      1023,
      2047,
      4095,
      8191,
      16383,
      32767,
      65535
    ];
    function LZWEncoder(width, height, pixels, colorDepth) {
      var initCodeSize = Math.max(2, colorDepth);
      var accum = new Uint8Array(256);
      var htab = new Int32Array(HSIZE);
      var codetab = new Int32Array(HSIZE);
      var cur_accum, cur_bits = 0;
      var a_count;
      var free_ent = 0;
      var maxcode;
      var remaining;
      var curPixel;
      var n_bits;
      var clear_flg = false;
      var g_init_bits, ClearCode, EOFCode;
      function char_out(c, outs) {
        accum[a_count++] = c;
        if (a_count >= 254)
          flush_char(outs);
      }
      function cl_block(outs) {
        cl_hash(HSIZE);
        free_ent = ClearCode + 2;
        clear_flg = true;
        output(ClearCode, outs);
      }
      function cl_hash(hsize) {
        for (var i = 0; i < hsize; ++i)
          htab[i] = -1;
      }
      function compress(init_bits, outs) {
        var fcode, c, i, ent, disp, hsize_reg, hshift;
        g_init_bits = init_bits;
        clear_flg = false;
        n_bits = g_init_bits;
        maxcode = MAXCODE(n_bits);
        ClearCode = 1 << init_bits - 1;
        EOFCode = ClearCode + 1;
        free_ent = ClearCode + 2;
        a_count = 0;
        ent = nextPixel();
        hshift = 0;
        for (fcode = HSIZE; fcode < 65536; fcode *= 2)
          ++hshift;
        hshift = 8 - hshift;
        hsize_reg = HSIZE;
        cl_hash(hsize_reg);
        output(ClearCode, outs);
        outer_loop:
          while ((c = nextPixel()) != EOF) {
            fcode = (c << BITS) + ent;
            i = c << hshift ^ ent;
            if (htab[i] === fcode) {
              ent = codetab[i];
              continue;
            } else if (htab[i] >= 0) {
              disp = hsize_reg - i;
              if (i === 0)
                disp = 1;
              do {
                if ((i -= disp) < 0)
                  i += hsize_reg;
                if (htab[i] === fcode) {
                  ent = codetab[i];
                  continue outer_loop;
                }
              } while (htab[i] >= 0);
            }
            output(ent, outs);
            ent = c;
            if (free_ent < 1 << BITS) {
              codetab[i] = free_ent++;
              htab[i] = fcode;
            } else {
              cl_block(outs);
            }
          }
        output(ent, outs);
        output(EOFCode, outs);
      }
      function encode2(outs) {
        outs.writeByte(initCodeSize);
        remaining = width * height;
        curPixel = 0;
        compress(initCodeSize + 1, outs);
        outs.writeByte(0);
      }
      function flush_char(outs) {
        if (a_count > 0) {
          outs.writeByte(a_count);
          outs.writeBytes(accum, 0, a_count);
          a_count = 0;
        }
      }
      function MAXCODE(n_bits2) {
        return (1 << n_bits2) - 1;
      }
      function nextPixel() {
        if (remaining === 0)
          return EOF;
        --remaining;
        var pix = pixels[curPixel++];
        return pix & 255;
      }
      function output(code, outs) {
        cur_accum &= masks[cur_bits];
        if (cur_bits > 0)
          cur_accum |= code << cur_bits;
        else
          cur_accum = code;
        cur_bits += n_bits;
        while (cur_bits >= 8) {
          char_out(cur_accum & 255, outs);
          cur_accum >>= 8;
          cur_bits -= 8;
        }
        if (free_ent > maxcode || clear_flg) {
          if (clear_flg) {
            maxcode = MAXCODE(n_bits = g_init_bits);
            clear_flg = false;
          } else {
            ++n_bits;
            if (n_bits == BITS)
              maxcode = 1 << BITS;
            else
              maxcode = MAXCODE(n_bits);
          }
        }
        if (code == EOFCode) {
          while (cur_bits > 0) {
            char_out(cur_accum & 255, outs);
            cur_accum >>= 8;
            cur_bits -= 8;
          }
          flush_char(outs);
        }
      }
      this.encode = encode2;
    }
    module2.exports = LZWEncoder;
  }
});

// ../../node_modules/gif-encoder/lib/GIFEncoder.js
var require_GIFEncoder = __commonJS({
  "../../node_modules/gif-encoder/lib/GIFEncoder.js"(exports2, module2) {
    var assert3 = require("assert");
    var EventEmitter = require("events").EventEmitter;
    var ReadableStream2 = require_readable2();
    var util2 = require("util");
    var NeuQuant = require_TypedNeuQuant();
    var LZWEncoder = require_LZWEncoder();
    function ByteCapacitor(options) {
      ReadableStream2.call(this, options);
      this.okayToPush = true;
      this.resetData();
    }
    util2.inherits(ByteCapacitor, ReadableStream2);
    ByteCapacitor.prototype._read = function() {
      this.okayToPush = true;
    };
    ByteCapacitor.prototype.resetData = function() {
      this.data = [];
    };
    ByteCapacitor.prototype.flushData = function() {
      if (!this.okayToPush) {
        var err = new Error("GIF memory limit exceeded. Please `read` from GIF before writing additional frames/information.");
        return this.emit("error", err);
      }
      var buff = new Buffer(this.data);
      this.resetData();
      this.okayToPush = this.push(buff);
    };
    ByteCapacitor.prototype.writeByte = function(val) {
      this.data.push(val);
    };
    ByteCapacitor.prototype.writeUTFBytes = function(string) {
      for (var l = string.length, i = 0; i < l; i++) {
        this.writeByte(string.charCodeAt(i));
      }
    };
    ByteCapacitor.prototype.writeBytes = function(array, offset, length) {
      for (var l = length || array.length, i = offset || 0; i < l; i++) {
        this.writeByte(array[i]);
      }
    };
    function GIFEncoder(width, height, options) {
      options = options || {};
      var hwm = options.highWaterMark;
      ByteCapacitor.call(this, {
        highWaterMark: hwm || hwm === 0 ? hwm : 64 * 1024
      });
      this.width = ~~width;
      this.height = ~~height;
      this.transparent = null;
      this.transIndex = 0;
      this.repeat = -1;
      this.delay = 0;
      this.pixels = null;
      this.indexedPixels = null;
      this.colorDepth = null;
      this.colorTab = null;
      this.usedEntry = [];
      this.palSize = 7;
      this.dispose = -1;
      this.firstFrame = true;
      this.sample = 10;
      var that = this;
      function flushData() {
        that.flushData();
      }
      this.on("writeHeader#stop", flushData);
      this.on("frame#stop", flushData);
      this.on("finish#stop", function finishGif() {
        flushData();
        that.push(null);
      });
    }
    util2.inherits(GIFEncoder, ByteCapacitor);
    GIFEncoder.prototype.setDelay = function(milliseconds) {
      this.delay = Math.round(milliseconds / 10);
    };
    GIFEncoder.prototype.setFrameRate = function(fps) {
      this.delay = Math.round(100 / fps);
    };
    GIFEncoder.prototype.setDispose = function(disposalCode) {
      if (disposalCode >= 0)
        this.dispose = disposalCode;
    };
    GIFEncoder.prototype.setRepeat = function(repeat) {
      this.repeat = repeat;
    };
    GIFEncoder.prototype.setTransparent = function(color) {
      this.transparent = color;
    };
    GIFEncoder.prototype.analyzeImage = function(imageData) {
      this.setImagePixels(this.removeAlphaChannel(imageData));
      this.analyzePixels();
    };
    GIFEncoder.prototype.writeImageInfo = function() {
      if (this.firstFrame) {
        this.writeLSD();
        this.writePalette();
        if (this.repeat >= 0) {
          this.writeNetscapeExt();
        }
      }
      this.writeGraphicCtrlExt();
      this.writeImageDesc();
      if (!this.firstFrame)
        this.writePalette();
      this.firstFrame = false;
    };
    GIFEncoder.prototype.outputImage = function() {
      this.writePixels();
    };
    GIFEncoder.prototype.addFrame = function(imageData) {
      this.emit("frame#start");
      this.analyzeImage(imageData);
      this.writeImageInfo();
      this.outputImage();
      this.emit("frame#stop");
    };
    GIFEncoder.prototype.finish = function() {
      this.emit("finish#start");
      this.writeByte(59);
      this.emit("finish#stop");
    };
    GIFEncoder.prototype.setQuality = function(quality) {
      if (quality < 1)
        quality = 1;
      this.sample = quality;
    };
    GIFEncoder.prototype.writeHeader = function() {
      this.emit("writeHeader#start");
      this.writeUTFBytes("GIF89a");
      this.emit("writeHeader#stop");
    };
    GIFEncoder.prototype.analyzePixels = function() {
      var len = this.pixels.length;
      var nPix = len / 3;
      this.indexedPixels = new Uint8Array(nPix);
      var imgq = new NeuQuant(this.pixels, this.sample);
      imgq.buildColormap();
      this.colorTab = imgq.getColormap();
      var k = 0;
      for (var j = 0; j < nPix; j++) {
        var index2 = imgq.lookupRGB(this.pixels[k++] & 255, this.pixels[k++] & 255, this.pixels[k++] & 255);
        this.usedEntry[index2] = true;
        this.indexedPixels[j] = index2;
      }
      this.pixels = null;
      this.colorDepth = 8;
      this.palSize = 7;
      if (this.transparent !== null) {
        this.transIndex = this.findClosest(this.transparent);
      }
    };
    GIFEncoder.prototype.findClosest = function(c) {
      if (this.colorTab === null)
        return -1;
      var r = (c & 16711680) >> 16;
      var g = (c & 65280) >> 8;
      var b = c & 255;
      var minpos = 0;
      var dmin = 256 * 256 * 256;
      var len = this.colorTab.length;
      for (var i = 0; i < len; ) {
        var dr = r - (this.colorTab[i++] & 255);
        var dg = g - (this.colorTab[i++] & 255);
        var db = b - (this.colorTab[i] & 255);
        var d = dr * dr + dg * dg + db * db;
        var index2 = i / 3;
        if (this.usedEntry[index2] && d < dmin) {
          dmin = d;
          minpos = index2;
        }
        i++;
      }
      return minpos;
    };
    GIFEncoder.prototype.removeAlphaChannel = function(data) {
      var w = this.width;
      var h = this.height;
      var pixels = new Uint8Array(w * h * 3);
      var count = 0;
      for (var i = 0; i < h; i++) {
        for (var j = 0; j < w; j++) {
          var b = i * w * 4 + j * 4;
          pixels[count++] = data[b];
          pixels[count++] = data[b + 1];
          pixels[count++] = data[b + 2];
        }
      }
      return pixels;
    };
    GIFEncoder.prototype.setImagePixels = function(pixels) {
      this.pixels = pixels;
    };
    GIFEncoder.prototype.writeGraphicCtrlExt = function() {
      this.writeByte(33);
      this.writeByte(249);
      this.writeByte(4);
      var transp, disp;
      if (this.transparent === null) {
        transp = 0;
        disp = 0;
      } else {
        transp = 1;
        disp = 2;
      }
      if (this.dispose >= 0) {
        disp = dispose & 7;
      }
      disp <<= 2;
      this.writeByte(0 | disp | 0 | transp);
      this.writeShort(this.delay);
      this.writeByte(this.transIndex);
      this.writeByte(0);
    };
    GIFEncoder.prototype.writeImageDesc = function() {
      this.writeByte(44);
      this.writeShort(0);
      this.writeShort(0);
      this.writeShort(this.width);
      this.writeShort(this.height);
      if (this.firstFrame) {
        this.writeByte(0);
      } else {
        this.writeByte(128 | 0 | 0 | 0 | this.palSize);
      }
    };
    GIFEncoder.prototype.writeLSD = function() {
      this.writeShort(this.width);
      this.writeShort(this.height);
      this.writeByte(128 | 112 | 0 | this.palSize);
      this.writeByte(0);
      this.writeByte(0);
    };
    GIFEncoder.prototype.writeNetscapeExt = function() {
      this.writeByte(33);
      this.writeByte(255);
      this.writeByte(11);
      this.writeUTFBytes("NETSCAPE2.0");
      this.writeByte(3);
      this.writeByte(1);
      this.writeShort(this.repeat);
      this.writeByte(0);
    };
    GIFEncoder.prototype.writePalette = function() {
      this.writeBytes(this.colorTab);
      var n = 3 * 256 - this.colorTab.length;
      for (var i = 0; i < n; i++)
        this.writeByte(0);
    };
    GIFEncoder.prototype.writeShort = function(pValue) {
      this.writeByte(pValue & 255);
      this.writeByte(pValue >> 8 & 255);
    };
    GIFEncoder.prototype.writePixels = function() {
      var enc = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth);
      enc.encode(this);
    };
    GIFEncoder.prototype.stream = function() {
      return this;
    };
    GIFEncoder.ByteCapacitor = ByteCapacitor;
    module2.exports = GIFEncoder;
  }
});

// ../../node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS({
  "../../node_modules/jpeg-js/lib/encoder.js"(exports2, module2) {
    var btoa2 = btoa2 || function(buf) {
      return new Buffer(buf).toString("base64");
    };
    function JPEGEncoder(quality) {
      var self2 = this;
      var fround = Math.round;
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        const I8 = 8;
        const I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        const I16 = 16;
        const I63 = 63;
        const I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        ;
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      this.encode = function(image, quality2) {
        var time_start = new Date().getTime();
        if (quality2)
          setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var tripleWidth = width * 3;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        return new Buffer(byteout);
        var jpegDataUri = "data:image/jpeg;base64," + btoa2(byteout.join(""));
        byteout = [];
        var duration = new Date().getTime() - time_start;
        return jpegDataUri;
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2)
          return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init() {
        var time_start = new Date().getTime();
        if (!quality)
          quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        var duration = new Date().getTime() - time_start;
      }
      init();
    }
    module2.exports = encode2;
    function encode2(imgData, qu) {
      if (typeof qu === "undefined")
        qu = 50;
      var encoder = new JPEGEncoder(qu);
      var data = encoder.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
  }
});

// ../../node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS({
  "../../node_modules/jpeg-js/lib/decoder.js"(exports2, module2) {
    var JpegImage = function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q2;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q2 = { children: [], index: 0 });
              p.children[p.index] = q2.children;
              p = q2;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q2 = { children: [], index: 0 });
            p.children[p.index] = q2.children;
            p = q2;
          }
        }
        return code[0].children;
      }
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw "unexpected marker: " + (bitsData << 8 | nextByte).toString(16);
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw "invalid huffman sequence";
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null)
              return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s !== 1)
                    throw "invalid ACn encoding";
                  successiveACNextValue = receiveAndExtend(s);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                if (zz[z])
                  zz[z] += readBit() << successive;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += readBit() << successive;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += readBit() << successive;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode3, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          decode3(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode3, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          decode3(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval)
          resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected)
                break;
            }
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw "marker was not found";
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load(path2) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path2, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse(data) {
          var offset = 0, length = data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length2 = readUint16();
            var array = data.subarray(offset, offset + length2 - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH2 = 0, maxV2 = 0;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH2 < component2.h)
                  maxH2 = component2.h;
                if (maxV2 < component2.v)
                  maxV2 = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocks = [];
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH2;
            frame2.maxV = maxV2;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          if (fileMarker != 65496) {
            throw "SOI not found";
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j, l;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw "DQT: invalid table spec";
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationTable: quantizationTables[qId]
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++)
                    codeLengthSum += codeLengths[j] = data[offset];
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65498:
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);
                offset += processed;
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                }
                throw "unknown JPEG marker " + fileMarker.toString(16);
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw "only single frame JPEGs supported";
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.colorTransform !== "undefined")
                colorTransform = !!this.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw "Unsupported color mode (4 components)";
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.colorTransform !== "undefined")
                colorTransform = !!this.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = C;
                  data[offset++] = M;
                  data[offset++] = Ye;
                  data[offset++] = K;
                }
              }
              break;
            default:
              throw "Unsupported color mode";
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = 255;
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  imageDataArray[j++] = 255;
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  imageDataArray[j++] = 255;
                }
              }
              break;
            default:
              throw "Unsupported color mode";
          }
        }
      };
      return constructor;
    }();
    module2.exports = decode2;
    function decode2(jpegData) {
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.parse(arr);
      var data = decoder.getData(decoder.width, decoder.height);
      var buf = new Buffer(decoder.width * decoder.height * 4);
      var n = 0;
      for (var i = 0; i < buf.length; i++) {
        buf[i + (i / 3 | 0)] = data[n++];
        if (i % 4 == 3)
          buf[i] = 255;
      }
      return {
        data: buf,
        width: decoder.width,
        height: decoder.height
      };
    }
  }
});

// ../../node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS({
  "../../node_modules/jpeg-js/index.js"(exports2, module2) {
    var encode2 = require_encoder();
    var decode2 = require_decoder();
    module2.exports = {
      encode: encode2,
      decode: decode2
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/chunkstream.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var Stream2 = require("stream");
    var ChunkStream = module2.exports = function() {
      Stream2.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util2.inherits(ChunkStream, Stream2);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      var dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = new Buffer(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("There are some read requests waitng on finished stream"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read) {
      this._reads.shift();
      var smallerBuf = this._buffers[0];
      if (smallerBuf.length > read.length) {
        this._buffered -= read.length;
        this._buffers[0] = smallerBuf.slice(read.length);
        read.func.call(this, smallerBuf.slice(0, read.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read) {
      this._reads.shift();
      var pos = 0;
      var count = 0;
      var data = new Buffer(read.length);
      while (pos < read.length) {
        var buf = this._buffers[count++];
        var len = Math.min(buf.length, read.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read.length;
      read.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          var read = this._reads[0];
          if (read.allowLess) {
            this._processReadAllowingLess(read);
          } else if (this._buffered >= read.length) {
            this._processRead(read);
          } else {
            break;
          }
        }
        if (this._buffers && this._buffers.length > 0 && this._buffers[0] === null) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/interlace.js
var require_interlace = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/interlace.js"(exports2) {
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports2.getImagePasses = function(width, height) {
      var images = [];
      var xLeftOver = width % 8;
      var yLeftOver = height % 8;
      var xRepeats = (width - xLeftOver) / 8;
      var yRepeats = (height - yLeftOver) / 8;
      for (var i = 0; i < imagePasses.length; i++) {
        var pass = imagePasses[i];
        var passWidth = xRepeats * pass.x.length;
        var passHeight = yRepeats * pass.y.length;
        for (var j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i });
        }
      }
      return images;
    };
    exports2.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        var outerXLeftOver = x % imagePasses[pass].x.length;
        var outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        var outerYLeftOver = y % imagePasses[pass].y.length;
        var outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/paeth-predictor.js"(exports2, module2) {
    "use strict";
    module2.exports = function paethPredictor(left, above, upLeft) {
      var paeth = left + above - upLeft;
      var pLeft = Math.abs(paeth - left);
      var pAbove = Math.abs(paeth - above);
      var pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/filter-parse.js"(exports2, module2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      var byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module2.exports = function(bitmapInfo, dependencies) {
      var width = bitmapInfo.width;
      var height = bitmapInfo.height;
      var interlace = bitmapInfo.interlace;
      var bpp = bitmapInfo.bpp;
      var depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        var passes = interlaceUtils.getImagePasses(width, height);
        for (var i = 0; i < passes.length; i++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i].width, bpp, depth),
            height: passes[i].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f3Up = lastLine ? lastLine[x] : 0;
        var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        var f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f4Up = lastLine ? lastLine[x] : 0;
        var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      var filter = rawData[0];
      var unfilteredLine;
      var currentImage = this._images[this._imageIndex];
      var byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = new Buffer(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/filter-parse-async.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module2.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      var buffers = [];
      var that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util2.inherits(FilterAsync, ChunkStream);
  }
});

// ../../node_modules/pngjs-nozlib/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/crc.js
var require_crc = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/crc.js"(exports2, module2) {
    "use strict";
    var crcTable = [];
    (function() {
      for (var i = 0; i < 256; i++) {
        var currentCrc = i;
        for (var j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i] = currentCrc;
      }
    })();
    var CrcCalculator = module2.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (var i = 0; i < data.length; i++) {
        this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      var crc = -1;
      for (var i = 0; i < buf.length; i++) {
        crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/parser.js
var require_parser = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/parser.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var CrcCalculator = require_crc();
    var Parser = module2.exports = function(options, dependencies) {
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      var signature = constants.PNG_SIGNATURE;
      for (var i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      var length = data.readUInt32BE(0);
      var type = data.readUInt32BE(4);
      var name = "";
      for (var i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }
      var ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(new Buffer(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      var fileCrc = data.readInt32BE(0);
      var calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      var width = data.readUInt32BE(0);
      var height = data.readUInt32BE(4);
      var depth = data[8];
      var colorType = data[9];
      var compr = data[10];
      var filter = data[11];
      var interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      var entries = Math.floor(data.length / 3);
      for (var i = 0; i < entries; i++) {
        this._palette.push([
          data[i * 3],
          data[i * 3 + 1],
          data[i * 3 + 2],
          255
        ]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (var i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      var leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/bitmapper.js"(exports2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMap = {
      1: {
        0: 0,
        1: 0,
        2: 0,
        3: 255
      },
      2: {
        0: 0,
        1: 0,
        2: 0,
        3: 1
      },
      3: {
        0: 0,
        1: 1,
        2: 2,
        3: 255
      },
      4: {
        0: 0,
        1: 1,
        2: 2,
        3: 3
      }
    };
    function bitRetriever(data, depth) {
      var leftOver = [];
      var i = 0;
      function split() {
        if (i === data.length) {
          throw new Error("Ran out of data");
        }
        var byte = data[i];
        i++;
        var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i];
            i++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          var returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
      var imageWidth = image.width;
      var imageHeight = image.height;
      var imagePass = image.index;
      for (var y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
          var pxPos = getPxPos(x, y, imagePass);
          for (var i = 0; i < 4; i++) {
            var idx = pixelBppMap[bpp][i];
            if (i === data.length) {
              throw new Error("Ran out of data");
            }
            pxData[pxPos + i] = idx !== 255 ? data[idx + rawPos] : 255;
          }
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
      var imageWidth = image.width;
      var imageHeight = image.height;
      var imagePass = image.index;
      for (var y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
          var pixelData = bits.get(bpp);
          var pxPos = getPxPos(x, y, imagePass);
          for (var i = 0; i < 4; i++) {
            var idx = pixelBppMap[bpp][i];
            pxData[pxPos + i] = idx !== 255 ? pixelData[idx] : maxBit;
          }
        }
        bits.resetAfterLine();
      }
    }
    exports2.dataToBitMap = function(data, bitmapInfo) {
      var width = bitmapInfo.width;
      var height = bitmapInfo.height;
      var depth = bitmapInfo.depth;
      var bpp = bitmapInfo.bpp;
      var interlace = bitmapInfo.interlace;
      if (depth !== 8) {
        var bits = bitRetriever(data, depth);
      }
      var pxData;
      if (depth <= 8) {
        pxData = new Buffer(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      var maxBit = Math.pow(2, depth) - 1;
      var rawPos = 0;
      var images;
      var getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        var nonInterlacedPxPos = 0;
        getPxPos = function() {
          var returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/format-normaliser.js"(exports2, module2) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = color[i];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (var i = 0; i < 4; i++) {
              outdata[pxPos + i] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      var maxOutSample = 255;
      var maxInSample = Math.pow(2, depth) - 1;
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module2.exports = function(indata, imageData) {
      var depth = imageData.depth;
      var width = imageData.width;
      var height = imageData.height;
      var colorType = imageData.colorType;
      var transColor = imageData.transColor;
      var palette = imageData.palette;
      var outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = new Buffer(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/parser-async.js
var require_parser_async = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/parser-async.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var zlib2 = require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module2.exports = function(options) {
      ChunkStream.call(this);
      this._parser = new Parser(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this)
      });
      this._options = options;
      this.writable = true;
      this._parser.start();
    };
    util2.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        this._inflate = zlib2.createInflate();
        this._inflate.on("error", this.emit.bind(this, "error"));
        this._filter.on("complete", this._complete.bind(this));
        this._inflate.pipe(this._filter);
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this.emit("metadata", metaData);
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
      this.destroySoon();
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      try {
        var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/bitpacker.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    module2.exports = function(data, width, height, options) {
      var outHasAlpha = options.colorType === constants.COLORTYPE_COLOR_ALPHA;
      if (options.inputHasAlpha && outHasAlpha) {
        return data;
      }
      if (!options.inputHasAlpha && !outHasAlpha) {
        return data;
      }
      var outBpp = outHasAlpha ? 4 : 3;
      var outData = new Buffer(width * height * outBpp);
      var inBpp = options.inputHasAlpha ? 4 : 3;
      var inIndex = 0;
      var outIndex = 0;
      var bgColor = options.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = 255;
      }
      if (bgColor.green === void 0) {
        bgColor.green = 255;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = 255;
      }
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var red = data[inIndex];
          var green = data[inIndex + 1];
          var blue = data[inIndex + 2];
          var alpha;
          if (options.inputHasAlpha) {
            alpha = data[inIndex + 3];
            if (!outHasAlpha) {
              alpha /= 255;
              red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), 255);
              green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), 255);
              blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), 255);
            }
          } else {
            alpha = 255;
          }
          outData[outIndex] = red;
          outData[outIndex + 1] = green;
          outData[outIndex + 2] = blue;
          if (outHasAlpha) {
            outData[outIndex + 3] = alpha;
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/filter-pack.js"(exports2, module2) {
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      pxData.copy(rawData, rawPos, pxPos, pxPos + byteWidth);
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      var sum = 0;
      var length = pxPos + byteWidth;
      for (var i = pxPos; i < length; i++) {
        sum += Math.abs(pxData[i]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var val = pxData[pxPos + x] - left;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var val = pxData[pxPos + x] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (var x = 0; x < byteWidth; x++) {
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - up;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      var sum = 0;
      var length = pxPos + byteWidth;
      for (var x = pxPos; x < length; x++) {
        var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        var val = pxData[x] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - (left + up >> 1);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module2.exports = function(pxData, width, height, options, bpp) {
      var filterTypes;
      if (!("filterType" in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options.filterType === "number") {
        filterTypes = [options.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      var byteWidth = width * bpp;
      var rawPos = 0;
      var pxPos = 0;
      var rawData = new Buffer((byteWidth + 1) * height);
      var sel = filterTypes[0];
      for (var y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          var min = Infinity;
          for (var i = 0; i < filterTypes.length; i++) {
            var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/packer.js
var require_packer = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/packer.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib2 = require("zlib");
    var Packer = module2.exports = function(options) {
      this._options = options;
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib2.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
      if (options.colorType !== constants.COLORTYPE_COLOR && options.colorType !== constants.COLORTYPE_COLOR_ALPHA) {
        throw new Error("option color type:" + options.colorType + " is not supported at present");
      }
      if (options.bitDepth !== 8) {
        throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      var packedData = bitPacker(data, width, height, this._options);
      var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      var filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      var len = data ? data.length : 0;
      var buf = new Buffer(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      var buf = new Buffer(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      var buf = new Buffer(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/packer-async.js
var require_packer_async = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/packer-async.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var Stream2 = require("stream");
    var constants = require_constants();
    var Packer = require_packer();
    var PackerAsync = module2.exports = function(opt) {
      Stream2.call(this);
      var options = opt || {};
      this._packer = new Packer(options);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util2.inherits(PackerAsync, Stream2);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", new Buffer(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      var filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/sync-reader.js"(exports2, module2) {
    "use strict";
    var SyncReader = module2.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        var read = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
          this._reads.shift();
          var buf = this._buffer;
          this._buffer = buf.slice(read.length);
          read.func.call(this, buf.slice(0, read.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/filter-parse-sync.js"(exports2) {
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports2.process = function(inBuffer, bitmapInfo) {
      var outBuffers = [];
      var reader = new SyncReader(inBuffer);
      var filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/parser-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module2.exports = function(buffer, options) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please also add a dependency on node-zlb-backport");
      }
      var err;
      function handleError(_err_) {
        err = _err_;
      }
      var metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      var gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      var inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      var reader = new SyncReader(buffer);
      var parser = new Parser(options, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      var inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      var inflatedData = zlib2.inflateSync(inflateData);
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      var unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      var normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/packer-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants();
    var Packer = require_packer();
    module2.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please also add a dependency on node-zlb-backport");
      }
      var options = opt || {};
      var packer = new Packer(options);
      var chunks = [];
      chunks.push(new Buffer(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      var compressedData = zlib2.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/png-sync.js
var require_png_sync = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/png-sync.js"(exports2) {
    "use strict";
    var parse = require_parser_sync();
    var pack = require_packer_sync();
    exports2.read = function(buffer, options) {
      return parse(buffer, options || {});
    };
    exports2.write = function(png) {
      return pack(png);
    };
  }
});

// ../../node_modules/pngjs-nozlib/lib/png.js
var require_png = __commonJS({
  "../../node_modules/pngjs-nozlib/lib/png.js"(exports2) {
    "use strict";
    var util2 = require("util");
    var Stream2 = require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports2.PNG = function(options) {
      Stream2.call(this);
      options = options || {};
      this.width = options.width || 0;
      this.height = options.height || 0;
      this.data = this.width > 0 && this.height > 0 ? new Buffer(4 * this.width * this.height) : null;
      if (options.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util2.inherits(PNG, Stream2);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        var onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (var y = 0; y < height; y++) {
        src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src) {
      if (src.gamma) {
        for (var y = 0; y < src.height; y++) {
          for (var x = 0; x < src.width; x++) {
            var idx = src.width * y + x << 2;
            for (var i = 0; i < 3; i++) {
              var sample = src.data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// ../../node_modules/iota-array/iota.js
var require_iota = __commonJS({
  "../../node_modules/iota-array/iota.js"(exports2, module2) {
    "use strict";
    function iota(n) {
      var result = new Array(n);
      for (var i = 0; i < n; ++i) {
        result[i] = i;
      }
      return result;
    }
    module2.exports = iota;
  }
});

// ../../node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "../../node_modules/is-buffer/index.js"(exports2, module2) {
    module2.exports = function(obj) {
      return obj != null && (isBuffer2(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer2(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer2(obj.slice(0, 0));
    }
  }
});

// ../../node_modules/ndarray/ndarray.js
var require_ndarray = __commonJS({
  "../../node_modules/ndarray/ndarray.js"(exports2, module2) {
    var iota = require_iota();
    var isBuffer2 = require_is_buffer();
    var hasTypedArrays = typeof Float64Array !== "undefined";
    function compare1st(a, b) {
      return a[0] - b[0];
    }
    function order() {
      var stride = this.stride;
      var terms = new Array(stride.length);
      var i;
      for (i = 0; i < terms.length; ++i) {
        terms[i] = [Math.abs(stride[i]), i];
      }
      terms.sort(compare1st);
      var result = new Array(terms.length);
      for (i = 0; i < result.length; ++i) {
        result[i] = terms[i][1];
      }
      return result;
    }
    function compileConstructor(dtype, dimension) {
      var className = ["View", dimension, "d", dtype].join("");
      if (dimension < 0) {
        className = "View_Nil" + dtype;
      }
      var useGetters = dtype === "generic";
      if (dimension === -1) {
        var code = "function " + className + "(a){this.data=a;};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + className + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + className + "(a){return new " + className + "(a);}";
        var procedure = new Function(code);
        return procedure();
      } else if (dimension === 0) {
        var code = "function " + className + "(a,d) {this.data = a;this.offset = d};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + className + "_copy() {return new " + className + "(this.data,this.offset)};proto.pick=function " + className + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + className + "_get(){return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + className + "_set(v){return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
        var procedure = new Function("TrivialArray", code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
      }
      var code = ["'use strict'"];
      var indices = iota(dimension);
      var args = indices.map(function(i2) {
        return "i" + i2;
      });
      var index_str = "this.offset+" + indices.map(function(i2) {
        return "this.stride[" + i2 + "]*i" + i2;
      }).join("+");
      var shapeArg = indices.map(function(i2) {
        return "b" + i2;
      }).join(",");
      var strideArg = indices.map(function(i2) {
        return "c" + i2;
      }).join(",");
      code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension);
      code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){return " + indices.map(function(i2) {
        return "this.shape[" + i2 + "]";
      }).join("*"), "}})");
      if (dimension === 1) {
        code.push("proto.order=[0]");
      } else {
        code.push("Object.defineProperty(proto,'order',{get:");
        if (dimension < 4) {
          code.push("function " + className + "_order(){");
          if (dimension === 2) {
            code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
          } else if (dimension === 3) {
            code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})");
          }
        } else {
          code.push("ORDER})");
        }
      }
      code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");
      if (useGetters) {
        code.push("return this.data.set(" + index_str + ",v)}");
      } else {
        code.push("return this.data[" + index_str + "]=v}");
      }
      code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
      if (useGetters) {
        code.push("return this.data.get(" + index_str + ")}");
      } else {
        code.push("return this.data[" + index_str + "]}");
      }
      code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}");
      code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i2) {
        return ["(typeof i", i2, "!=='number'||i", i2, "<0)?this.shape[", i2, "]:i", i2, "|0"].join("");
      }).join(",") + "," + indices.map(function(i2) {
        return "this.stride[" + i2 + "]";
      }).join(",") + ",this.offset)}");
      var a_vars = indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      });
      var c_vars = indices.map(function(i2) {
        return "c" + i2 + "=this.stride[" + i2 + "]";
      });
      code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
      for (var i = 0; i < dimension; ++i) {
        code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){d=i" + i + "|0;b+=c" + i + "*d;a" + i + "-=d}");
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "c" + i2;
      }).join(",") + ",b)}");
      code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2 + "=this.stride[" + i2 + "]";
      }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
      for (var i = 0; i < dimension; ++i) {
        code.push("if(typeof i" + i + "==='number'){d=i" + i + "|0;if(d<0){c+=b" + i + "*(a" + i + "-1);a" + i + "=ceil(-a" + i + "/d)}else{a" + i + "=ceil(a" + i + "/d)}b" + i + "*=d}");
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2;
      }).join(",") + ",c)}");
      var tShape = new Array(dimension);
      var tStride = new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
        tShape[i] = "a[i" + i + "]";
        tStride[i] = "b[i" + i + "]";
      }
      code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
        return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
      }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}");
      code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
      for (var i = 0; i < dimension; ++i) {
        code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
      }
      code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
      code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i2) {
        return "shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "stride[" + i2 + "]";
      }).join(",") + ",offset)}");
      var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
      return procedure(CACHED_CONSTRUCTORS[dtype], order);
    }
    function arrayDType(data) {
      if (isBuffer2(data)) {
        return "buffer";
      }
      if (hasTypedArrays) {
        switch (Object.prototype.toString.call(data)) {
          case "[object Float64Array]":
            return "float64";
          case "[object Float32Array]":
            return "float32";
          case "[object Int8Array]":
            return "int8";
          case "[object Int16Array]":
            return "int16";
          case "[object Int32Array]":
            return "int32";
          case "[object Uint8Array]":
            return "uint8";
          case "[object Uint16Array]":
            return "uint16";
          case "[object Uint32Array]":
            return "uint32";
          case "[object Uint8ClampedArray]":
            return "uint8_clamped";
          case "[object BigInt64Array]":
            return "bigint64";
          case "[object BigUint64Array]":
            return "biguint64";
        }
      }
      if (Array.isArray(data)) {
        return "array";
      }
      return "generic";
    }
    var CACHED_CONSTRUCTORS = {
      "float32": [],
      "float64": [],
      "int8": [],
      "int16": [],
      "int32": [],
      "uint8": [],
      "uint16": [],
      "uint32": [],
      "array": [],
      "uint8_clamped": [],
      "bigint64": [],
      "biguint64": [],
      "buffer": [],
      "generic": []
    };
    function wrappedNDArrayCtor(data, shape, stride, offset) {
      if (data === void 0) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
      } else if (typeof data === "number") {
        data = [data];
      }
      if (shape === void 0) {
        shape = [data.length];
      }
      var d = shape.length;
      if (stride === void 0) {
        stride = new Array(d);
        for (var i = d - 1, sz = 1; i >= 0; --i) {
          stride[i] = sz;
          sz *= shape[i];
        }
      }
      if (offset === void 0) {
        offset = 0;
        for (var i = 0; i < d; ++i) {
          if (stride[i] < 0) {
            offset -= (shape[i] - 1) * stride[i];
          }
        }
      }
      var dtype = arrayDType(data);
      var ctor_list = CACHED_CONSTRUCTORS[dtype];
      while (ctor_list.length <= d + 1) {
        ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
      }
      var ctor = ctor_list[d + 1];
      return ctor(data, shape, stride, offset);
    }
    module2.exports = wrappedNDArrayCtor;
  }
});

// ../../node_modules/uniq/uniq.js
var require_uniq = __commonJS({
  "../../node_modules/uniq/uniq.js"(exports2, module2) {
    "use strict";
    function unique_pred(list, compare) {
      var ptr = 1, len = list.length, a = list[0], b = list[0];
      for (var i = 1; i < len; ++i) {
        b = a;
        a = list[i];
        if (compare(a, b)) {
          if (i === ptr) {
            ptr++;
            continue;
          }
          list[ptr++] = a;
        }
      }
      list.length = ptr;
      return list;
    }
    function unique_eq(list) {
      var ptr = 1, len = list.length, a = list[0], b = list[0];
      for (var i = 1; i < len; ++i, b = a) {
        b = a;
        a = list[i];
        if (a !== b) {
          if (i === ptr) {
            ptr++;
            continue;
          }
          list[ptr++] = a;
        }
      }
      list.length = ptr;
      return list;
    }
    function unique(list, compare, sorted) {
      if (list.length === 0) {
        return list;
      }
      if (compare) {
        if (!sorted) {
          list.sort(compare);
        }
        return unique_pred(list, compare);
      }
      if (!sorted) {
        list.sort();
      }
      return unique_eq(list);
    }
    module2.exports = unique;
  }
});

// ../../node_modules/cwise-compiler/lib/compile.js
var require_compile = __commonJS({
  "../../node_modules/cwise-compiler/lib/compile.js"(exports2, module2) {
    "use strict";
    var uniq = require_uniq();
    function innerFill(order, proc, body) {
      var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
      for (i = 0; i < dimension; ++i) {
        vars.push(["i", i, "=0"].join(""));
      }
      for (j = 0; j < nargs; ++j) {
        for (i = 0; i < dimension; ++i) {
          pidx = idx;
          idx = order[i];
          if (i === 0) {
            vars.push(["d", j, "s", i, "=t", j, "p", idx].join(""));
          } else {
            vars.push(["d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")"].join(""));
          }
        }
      }
      if (vars.length > 0) {
        code.push("var " + vars.join(","));
      }
      for (i = dimension - 1; i >= 0; --i) {
        idx = order[i];
        code.push(["for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){"].join(""));
      }
      code.push(body);
      for (i = 0; i < dimension; ++i) {
        pidx = idx;
        idx = order[i];
        for (j = 0; j < nargs; ++j) {
          code.push(["p", j, "+=d", j, "s", i].join(""));
        }
        if (has_index) {
          if (i > 0) {
            code.push(["index[", pidx, "]-=s", pidx].join(""));
          }
          code.push(["++index[", idx, "]"].join(""));
        }
        code.push("}");
      }
      return code.join("\n");
    }
    function outerFill(matched, order, proc, body) {
      var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
      for (var i = 0; i < nargs; ++i) {
        code.push(["var offset", i, "=p", i].join(""));
      }
      for (var i = matched; i < dimension; ++i) {
        code.push(["for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){"].join(""));
        code.push(["if(j", i, "<", blockSize, "){"].join(""));
        code.push(["s", order[i], "=j", i].join(""));
        code.push(["j", i, "=0"].join(""));
        code.push(["}else{s", order[i], "=", blockSize].join(""));
        code.push(["j", i, "-=", blockSize, "}"].join(""));
        if (has_index) {
          code.push(["index[", order[i], "]=j", i].join(""));
        }
      }
      for (var i = 0; i < nargs; ++i) {
        var indexStr = ["offset" + i];
        for (var j = matched; j < dimension; ++j) {
          indexStr.push(["j", j, "*t", i, "p", order[j]].join(""));
        }
        code.push(["p", i, "=(", indexStr.join("+"), ")"].join(""));
      }
      code.push(innerFill(order, proc, body));
      for (var i = matched; i < dimension; ++i) {
        code.push("}");
      }
      return code.join("\n");
    }
    function countMatches(orders) {
      var matched = 0, dimension = orders[0].length;
      while (matched < dimension) {
        for (var j = 1; j < orders.length; ++j) {
          if (orders[j][matched] !== orders[0][matched]) {
            return matched;
          }
        }
        ++matched;
      }
      return matched;
    }
    function processBlock(block, proc, dtypes) {
      var code = block.body;
      var pre = [];
      var post = [];
      for (var i = 0; i < block.args.length; ++i) {
        var carg = block.args[i];
        if (carg.count <= 0) {
          continue;
        }
        var re = new RegExp(carg.name, "g");
        var ptrStr = "";
        var arrNum = proc.arrayArgs.indexOf(i);
        switch (proc.argTypes[i]) {
          case "offset":
            var offArgIndex = proc.offsetArgIndex.indexOf(i);
            var offArg = proc.offsetArgs[offArgIndex];
            arrNum = offArg.array;
            ptrStr = "+q" + offArgIndex;
          case "array":
            ptrStr = "p" + arrNum + ptrStr;
            var localStr = "l" + i;
            var arrStr = "a" + arrNum;
            if (proc.arrayBlockIndices[arrNum] === 0) {
              if (carg.count === 1) {
                if (dtypes[arrNum] === "generic") {
                  if (carg.lvalue) {
                    pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""));
                    code = code.replace(re, localStr);
                    post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
                  } else {
                    code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
                  }
                } else {
                  code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
                }
              } else if (dtypes[arrNum] === "generic") {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""));
                code = code.replace(re, localStr);
                if (carg.lvalue) {
                  post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
                }
              } else {
                pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join(""));
                code = code.replace(re, localStr);
                if (carg.lvalue) {
                  post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
                }
              }
            } else {
              var reStrArr = [carg.name], ptrStrArr = [ptrStr];
              for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
                reStrArr.push("\\s*\\[([^\\]]+)\\]");
                ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j);
              }
              re = new RegExp(reStrArr.join(""), "g");
              ptrStr = ptrStrArr.join("+");
              if (dtypes[arrNum] === "generic") {
                throw new Error("cwise: Generic arrays not supported in combination with blocks!");
              } else {
                code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
              }
            }
            break;
          case "scalar":
            code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
            break;
          case "index":
            code = code.replace(re, "index");
            break;
          case "shape":
            code = code.replace(re, "shape");
            break;
        }
      }
      return [pre.join("\n"), code, post.join("\n")].join("\n").trim();
    }
    function typeSummary(dtypes) {
      var summary = new Array(dtypes.length);
      var allEqual = true;
      for (var i = 0; i < dtypes.length; ++i) {
        var t = dtypes[i];
        var digits = t.match(/\d+/);
        if (!digits) {
          digits = "";
        } else {
          digits = digits[0];
        }
        if (t.charAt(0) === 0) {
          summary[i] = "u" + t.charAt(1) + digits;
        } else {
          summary[i] = t.charAt(0) + digits;
        }
        if (i > 0) {
          allEqual = allEqual && summary[i] === summary[i - 1];
        }
      }
      if (allEqual) {
        return summary[0];
      }
      return summary.join("");
    }
    function generateCWiseOp(proc, typesig) {
      var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
      var orders = new Array(proc.arrayArgs.length);
      var dtypes = new Array(proc.arrayArgs.length);
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        dtypes[i] = typesig[2 * i];
        orders[i] = typesig[2 * i + 1];
      }
      var blockBegin = [], blockEnd = [];
      var loopBegin = [], loopEnd = [];
      var loopOrders = [];
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        if (proc.arrayBlockIndices[i] < 0) {
          loopBegin.push(0);
          loopEnd.push(dimension);
          blockBegin.push(dimension);
          blockEnd.push(dimension + proc.arrayBlockIndices[i]);
        } else {
          loopBegin.push(proc.arrayBlockIndices[i]);
          loopEnd.push(proc.arrayBlockIndices[i] + dimension);
          blockBegin.push(0);
          blockEnd.push(proc.arrayBlockIndices[i]);
        }
        var newOrder = [];
        for (var j = 0; j < orders[i].length; j++) {
          if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
            newOrder.push(orders[i][j] - loopBegin[i]);
          }
        }
        loopOrders.push(newOrder);
      }
      var arglist = ["SS"];
      var code = ["'use strict'"];
      var vars = [];
      for (var j = 0; j < dimension; ++j) {
        vars.push(["s", j, "=SS[", j, "]"].join(""));
      }
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        arglist.push("a" + i);
        arglist.push("t" + i);
        arglist.push("p" + i);
        for (var j = 0; j < dimension; ++j) {
          vars.push(["t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]"].join(""));
        }
        for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
          vars.push(["t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]"].join(""));
        }
      }
      for (var i = 0; i < proc.scalarArgs.length; ++i) {
        arglist.push("Y" + i);
      }
      if (proc.shapeArgs.length > 0) {
        vars.push("shape=SS.slice(0)");
      }
      if (proc.indexArgs.length > 0) {
        var zeros = new Array(dimension);
        for (var i = 0; i < dimension; ++i) {
          zeros[i] = "0";
        }
        vars.push(["index=[", zeros.join(","), "]"].join(""));
      }
      for (var i = 0; i < proc.offsetArgs.length; ++i) {
        var off_arg = proc.offsetArgs[i];
        var init_string = [];
        for (var j = 0; j < off_arg.offset.length; ++j) {
          if (off_arg.offset[j] === 0) {
            continue;
          } else if (off_arg.offset[j] === 1) {
            init_string.push(["t", off_arg.array, "p", j].join(""));
          } else {
            init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
          }
        }
        if (init_string.length === 0) {
          vars.push("q" + i + "=0");
        } else {
          vars.push(["q", i, "=", init_string.join("+")].join(""));
        }
      }
      var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
      vars = vars.concat(thisVars);
      if (vars.length > 0) {
        code.push("var " + vars.join(","));
      }
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        code.push("p" + i + "|=0");
      }
      if (proc.pre.body.length > 3) {
        code.push(processBlock(proc.pre, proc, dtypes));
      }
      var body = processBlock(proc.body, proc, dtypes);
      var matched = countMatches(loopOrders);
      if (matched < dimension) {
        code.push(outerFill(matched, loopOrders[0], proc, body));
      } else {
        code.push(innerFill(loopOrders[0], proc, body));
      }
      if (proc.post.body.length > 3) {
        code.push(processBlock(proc.post, proc, dtypes));
      }
      if (proc.debug) {
        console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
      }
      var loopName = [proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes)].join("");
      var f = new Function(["function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName].join(""));
      return f();
    }
    module2.exports = generateCWiseOp;
  }
});

// ../../node_modules/cwise-compiler/lib/thunk.js
var require_thunk = __commonJS({
  "../../node_modules/cwise-compiler/lib/thunk.js"(exports2, module2) {
    "use strict";
    var compile = require_compile();
    function createThunk(proc) {
      var code = ["'use strict'", "var CACHED={}"];
      var vars = [];
      var thunkName = proc.funcName + "_cwise_thunk";
      code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
      var typesig = [];
      var string_typesig = [];
      var proc_args = [[
        "array",
        proc.arrayArgs[0],
        ".shape.slice(",
        Math.max(0, proc.arrayBlockIndices[0]),
        proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"
      ].join("")];
      var shapeLengthConditions = [], shapeConditions = [];
      for (var i = 0; i < proc.arrayArgs.length; ++i) {
        var j = proc.arrayArgs[i];
        vars.push([
          "t",
          j,
          "=array",
          j,
          ".dtype,",
          "r",
          j,
          "=array",
          j,
          ".order"
        ].join(""));
        typesig.push("t" + j);
        typesig.push("r" + j);
        string_typesig.push("t" + j);
        string_typesig.push("r" + j + ".join()");
        proc_args.push("array" + j + ".data");
        proc_args.push("array" + j + ".stride");
        proc_args.push("array" + j + ".offset|0");
        if (i > 0) {
          shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
          shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
        }
      }
      if (proc.arrayArgs.length > 1) {
        code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
        code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
        code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
        code.push("}");
      }
      for (var i = 0; i < proc.scalarArgs.length; ++i) {
        proc_args.push("scalar" + proc.scalarArgs[i]);
      }
      vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
      vars.push("proc=CACHED[type]");
      code.push("var " + vars.join(","));
      code.push([
        "if(!proc){",
        "CACHED[type]=proc=compile([",
        typesig.join(","),
        "])}",
        "return proc(",
        proc_args.join(","),
        ")}"
      ].join(""));
      if (proc.debug) {
        console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
      }
      var thunk = new Function("compile", code.join("\n"));
      return thunk(compile.bind(void 0, proc));
    }
    module2.exports = createThunk;
  }
});

// ../../node_modules/cwise-compiler/compiler.js
var require_compiler = __commonJS({
  "../../node_modules/cwise-compiler/compiler.js"(exports2, module2) {
    "use strict";
    var createThunk = require_thunk();
    function Procedure() {
      this.argTypes = [];
      this.shimArgs = [];
      this.arrayArgs = [];
      this.arrayBlockIndices = [];
      this.scalarArgs = [];
      this.offsetArgs = [];
      this.offsetArgIndex = [];
      this.indexArgs = [];
      this.shapeArgs = [];
      this.funcName = "";
      this.pre = null;
      this.body = null;
      this.post = null;
      this.debug = false;
    }
    function compileCwise(user_args) {
      var proc = new Procedure();
      proc.pre = user_args.pre;
      proc.body = user_args.body;
      proc.post = user_args.post;
      var proc_args = user_args.args.slice(0);
      proc.argTypes = proc_args;
      for (var i = 0; i < proc_args.length; ++i) {
        var arg_type = proc_args[i];
        if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
          proc.argTypes[i] = "array";
          proc.arrayArgs.push(i);
          proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
          proc.shimArgs.push("array" + i);
          if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
            throw new Error("cwise: pre() block may not reference array args");
          }
          if (i < proc.post.args.length && proc.post.args[i].count > 0) {
            throw new Error("cwise: post() block may not reference array args");
          }
        } else if (arg_type === "scalar") {
          proc.scalarArgs.push(i);
          proc.shimArgs.push("scalar" + i);
        } else if (arg_type === "index") {
          proc.indexArgs.push(i);
          if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
            throw new Error("cwise: pre() block may not reference array index");
          }
          if (i < proc.body.args.length && proc.body.args[i].lvalue) {
            throw new Error("cwise: body() block may not write to array index");
          }
          if (i < proc.post.args.length && proc.post.args[i].count > 0) {
            throw new Error("cwise: post() block may not reference array index");
          }
        } else if (arg_type === "shape") {
          proc.shapeArgs.push(i);
          if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
            throw new Error("cwise: pre() block may not write to array shape");
          }
          if (i < proc.body.args.length && proc.body.args[i].lvalue) {
            throw new Error("cwise: body() block may not write to array shape");
          }
          if (i < proc.post.args.length && proc.post.args[i].lvalue) {
            throw new Error("cwise: post() block may not write to array shape");
          }
        } else if (typeof arg_type === "object" && arg_type.offset) {
          proc.argTypes[i] = "offset";
          proc.offsetArgs.push({ array: arg_type.array, offset: arg_type.offset });
          proc.offsetArgIndex.push(i);
        } else {
          throw new Error("cwise: Unknown argument type " + proc_args[i]);
        }
      }
      if (proc.arrayArgs.length <= 0) {
        throw new Error("cwise: No array arguments specified");
      }
      if (proc.pre.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in pre() block");
      }
      if (proc.body.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in body() block");
      }
      if (proc.post.args.length > proc_args.length) {
        throw new Error("cwise: Too many arguments in post() block");
      }
      proc.debug = !!user_args.printCode || !!user_args.debug;
      proc.funcName = user_args.funcName || "cwise";
      proc.blockSize = user_args.blockSize || 64;
      return createThunk(proc);
    }
    module2.exports = compileCwise;
  }
});

// ../../node_modules/ndarray-ops/ndarray-ops.js
var require_ndarray_ops = __commonJS({
  "../../node_modules/ndarray-ops/ndarray-ops.js"(exports2) {
    "use strict";
    var compile = require_compiler();
    var EmptyProc = {
      body: "",
      args: [],
      thisVars: [],
      localVars: []
    };
    function fixup(x) {
      if (!x) {
        return EmptyProc;
      }
      for (var i = 0; i < x.args.length; ++i) {
        var a = x.args[i];
        if (i === 0) {
          x.args[i] = { name: a, lvalue: true, rvalue: !!x.rvalue, count: x.count || 1 };
        } else {
          x.args[i] = { name: a, lvalue: false, rvalue: true, count: 1 };
        }
      }
      if (!x.thisVars) {
        x.thisVars = [];
      }
      if (!x.localVars) {
        x.localVars = [];
      }
      return x;
    }
    function pcompile(user_args) {
      return compile({
        args: user_args.args,
        pre: fixup(user_args.pre),
        body: fixup(user_args.body),
        post: fixup(user_args.proc),
        funcName: user_args.funcName
      });
    }
    function makeOp(user_args) {
      var args = [];
      for (var i = 0; i < user_args.args.length; ++i) {
        args.push("a" + i);
      }
      var wrapper = new Function("P", [
        "return function ",
        user_args.funcName,
        "_ndarrayops(",
        args.join(","),
        ") {P(",
        args.join(","),
        ");return a0}"
      ].join(""));
      return wrapper(pcompile(user_args));
    }
    var assign_ops = {
      add: "+",
      sub: "-",
      mul: "*",
      div: "/",
      mod: "%",
      band: "&",
      bor: "|",
      bxor: "^",
      lshift: "<<",
      rshift: ">>",
      rrshift: ">>>"
    };
    (function() {
      for (var id in assign_ops) {
        var op = assign_ops[id];
        exports2[id] = makeOp({
          args: ["array", "array", "array"],
          body: {
            args: ["a", "b", "c"],
            body: "a=b" + op + "c"
          },
          funcName: id
        });
        exports2[id + "eq"] = makeOp({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a" + op + "=b"
          },
          rvalue: true,
          funcName: id + "eq"
        });
        exports2[id + "s"] = makeOp({
          args: ["array", "array", "scalar"],
          body: {
            args: ["a", "b", "s"],
            body: "a=b" + op + "s"
          },
          funcName: id + "s"
        });
        exports2[id + "seq"] = makeOp({
          args: ["array", "scalar"],
          body: {
            args: ["a", "s"],
            body: "a" + op + "=s"
          },
          rvalue: true,
          funcName: id + "seq"
        });
      }
    })();
    var unary_ops = {
      not: "!",
      bnot: "~",
      neg: "-",
      recip: "1.0/"
    };
    (function() {
      for (var id in unary_ops) {
        var op = unary_ops[id];
        exports2[id] = makeOp({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a=" + op + "b"
          },
          funcName: id
        });
        exports2[id + "eq"] = makeOp({
          args: ["array"],
          body: {
            args: ["a"],
            body: "a=" + op + "a"
          },
          rvalue: true,
          count: 2,
          funcName: id + "eq"
        });
      }
    })();
    var binary_ops = {
      and: "&&",
      or: "||",
      eq: "===",
      neq: "!==",
      lt: "<",
      gt: ">",
      leq: "<=",
      geq: ">="
    };
    (function() {
      for (var id in binary_ops) {
        var op = binary_ops[id];
        exports2[id] = makeOp({
          args: ["array", "array", "array"],
          body: {
            args: ["a", "b", "c"],
            body: "a=b" + op + "c"
          },
          funcName: id
        });
        exports2[id + "s"] = makeOp({
          args: ["array", "array", "scalar"],
          body: {
            args: ["a", "b", "s"],
            body: "a=b" + op + "s"
          },
          funcName: id + "s"
        });
        exports2[id + "eq"] = makeOp({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a=a" + op + "b"
          },
          rvalue: true,
          count: 2,
          funcName: id + "eq"
        });
        exports2[id + "seq"] = makeOp({
          args: ["array", "scalar"],
          body: {
            args: ["a", "s"],
            body: "a=a" + op + "s"
          },
          rvalue: true,
          count: 2,
          funcName: id + "seq"
        });
      }
    })();
    var math_unary = [
      "abs",
      "acos",
      "asin",
      "atan",
      "ceil",
      "cos",
      "exp",
      "floor",
      "log",
      "round",
      "sin",
      "sqrt",
      "tan"
    ];
    (function() {
      for (var i = 0; i < math_unary.length; ++i) {
        var f = math_unary[i];
        exports2[f] = makeOp({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b)", thisVars: ["this_f"] },
          funcName: f
        });
        exports2[f + "eq"] = makeOp({
          args: ["array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a"], body: "a=this_f(a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "eq"
        });
      }
    })();
    var math_comm = [
      "max",
      "min",
      "atan2",
      "pow"
    ];
    (function() {
      for (var i = 0; i < math_comm.length; ++i) {
        var f = math_comm[i];
        exports2[f] = makeOp({
          args: ["array", "array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"] },
          funcName: f
        });
        exports2[f + "s"] = makeOp({
          args: ["array", "array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"] },
          funcName: f + "s"
        });
        exports2[f + "eq"] = makeOp({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "eq"
        });
        exports2[f + "seq"] = makeOp({
          args: ["array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "seq"
        });
      }
    })();
    var math_noncomm = [
      "atan2",
      "pow"
    ];
    (function() {
      for (var i = 0; i < math_noncomm.length; ++i) {
        var f = math_noncomm[i];
        exports2[f + "op"] = makeOp({
          args: ["array", "array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"] },
          funcName: f + "op"
        });
        exports2[f + "ops"] = makeOp({
          args: ["array", "array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"] },
          funcName: f + "ops"
        });
        exports2[f + "opeq"] = makeOp({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "opeq"
        });
        exports2[f + "opseq"] = makeOp({
          args: ["array", "scalar"],
          pre: { args: [], body: "this_f=Math." + f, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: f + "opseq"
        });
      }
    })();
    exports2.any = compile({
      args: ["array"],
      pre: EmptyProc,
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "if(a){return true}", localVars: [], thisVars: [] },
      post: { args: [], localVars: [], thisVars: [], body: "return false" },
      funcName: "any"
    });
    exports2.all = compile({
      args: ["array"],
      pre: EmptyProc,
      body: { args: [{ name: "x", lvalue: false, rvalue: true, count: 1 }], body: "if(!x){return false}", localVars: [], thisVars: [] },
      post: { args: [], localVars: [], thisVars: [], body: "return true" },
      funcName: "all"
    });
    exports2.sum = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "this_s+=a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "sum"
    });
    exports2.prod = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=1" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "this_s*=a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "prod"
    });
    exports2.norm2squared = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 2 }], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norm2squared"
    });
    exports2.norm2 = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 2 }], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return Math.sqrt(this_s)" },
      funcName: "norm2"
    });
    exports2.norminf = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 4 }], body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norminf"
    });
    exports2.norm1 = compile({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 3 }], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norm1"
    });
    exports2.sup = compile({
      args: ["array"],
      pre: {
        body: "this_h=-Infinity",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      },
      body: {
        body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
        args: [{ "name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 2 }],
        thisVars: ["this_h"],
        localVars: []
      },
      post: {
        body: "return this_h",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      }
    });
    exports2.inf = compile({
      args: ["array"],
      pre: {
        body: "this_h=Infinity",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      },
      body: {
        body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
        args: [{ "name": "_inline_1_arg0_", "lvalue": false, "rvalue": true, "count": 2 }],
        thisVars: ["this_h"],
        localVars: []
      },
      post: {
        body: "return this_h",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      }
    });
    exports2.argmin = compile({
      args: ["index", "array", "shape"],
      pre: {
        body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
          { name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: []
      },
      body: {
        body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
          { name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 },
          { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: ["_inline_1_k"]
      },
      post: {
        body: "{return this_i}",
        args: [],
        thisVars: ["this_i"],
        localVars: []
      }
    });
    exports2.argmax = compile({
      args: ["index", "array", "shape"],
      pre: {
        body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
          { name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: []
      },
      body: {
        body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
          { name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 },
          { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: ["_inline_1_k"]
      },
      post: {
        body: "{return this_i}",
        args: [],
        thisVars: ["this_i"],
        localVars: []
      }
    });
    exports2.random = makeOp({
      args: ["array"],
      pre: { args: [], body: "this_f=Math.random", thisVars: ["this_f"] },
      body: { args: ["a"], body: "a=this_f()", thisVars: ["this_f"] },
      funcName: "random"
    });
    exports2.assign = makeOp({
      args: ["array", "array"],
      body: { args: ["a", "b"], body: "a=b" },
      funcName: "assign"
    });
    exports2.assigns = makeOp({
      args: ["array", "scalar"],
      body: { args: ["a", "b"], body: "a=b" },
      funcName: "assigns"
    });
    exports2.equals = compile({
      args: ["array", "array"],
      pre: EmptyProc,
      body: {
        args: [
          { name: "x", lvalue: false, rvalue: true, count: 1 },
          { name: "y", lvalue: false, rvalue: true, count: 1 }
        ],
        body: "if(x!==y){return false}",
        localVars: [],
        thisVars: []
      },
      post: { args: [], localVars: [], thisVars: [], body: "return true" },
      funcName: "equals"
    });
  }
});

// ../../node_modules/through/index.js
var require_through = __commonJS({
  "../../node_modules/through/index.js"(exports2, module2) {
    var Stream2 = require("stream");
    exports2 = module2.exports = through;
    through.through = through;
    function through(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      };
      end = end || function() {
        this.queue(null);
      };
      var ended = false, destroyed = false, buffer = [], _ended = false;
      var stream = new Stream2();
      stream.readable = stream.writable = true;
      stream.paused = false;
      stream.autoDestroy = !(opts && opts.autoDestroy === false);
      stream.write = function(data) {
        write.call(this, data);
        return !stream.paused;
      };
      function drain() {
        while (buffer.length && !stream.paused) {
          var data = buffer.shift();
          if (data === null)
            return stream.emit("end");
          else
            stream.emit("data", data);
        }
      }
      stream.queue = stream.push = function(data) {
        if (_ended)
          return stream;
        if (data === null)
          _ended = true;
        buffer.push(data);
        drain();
        return stream;
      };
      stream.on("end", function() {
        stream.readable = false;
        if (!stream.writable && stream.autoDestroy)
          process.nextTick(function() {
            stream.destroy();
          });
      });
      function _end() {
        stream.writable = false;
        end.call(stream);
        if (!stream.readable && stream.autoDestroy)
          stream.destroy();
      }
      stream.end = function(data) {
        if (ended)
          return;
        ended = true;
        if (arguments.length)
          stream.write(data);
        _end();
        return stream;
      };
      stream.destroy = function() {
        if (destroyed)
          return;
        destroyed = true;
        ended = true;
        buffer.length = 0;
        stream.writable = stream.readable = false;
        stream.emit("close");
        return stream;
      };
      stream.pause = function() {
        if (stream.paused)
          return;
        stream.paused = true;
        return stream;
      };
      stream.resume = function() {
        if (stream.paused) {
          stream.paused = false;
          stream.emit("resume");
        }
        drain();
        if (!stream.paused)
          stream.emit("drain");
        return stream;
      };
      return stream;
    }
  }
});

// ../../node_modules/save-pixels/save-pixels.js
var require_save_pixels = __commonJS({
  "../../node_modules/save-pixels/save-pixels.js"(exports2, module2) {
    "use strict";
    var ContentStream = require_contentstream();
    var GifEncoder = require_GIFEncoder();
    var jpegJs = require_jpeg_js();
    var PNG = require_png().PNG;
    var ndarray2 = require_ndarray();
    var ops = require_ndarray_ops();
    var through = require_through();
    function handleData(array, data, frame) {
      var i, j, ptr = 0, c;
      if (array.shape.length === 4) {
        return handleData(array.pick(frame), data, 0);
      } else if (array.shape.length === 3) {
        if (array.shape[2] === 3) {
          ops.assign(ndarray2(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]), array);
          ops.assigns(ndarray2(data, [array.shape[0] * array.shape[1]], [4], 3), 255);
        } else if (array.shape[2] === 4) {
          ops.assign(ndarray2(data, [array.shape[0], array.shape[1], 4], [4, array.shape[0] * 4, 1]), array);
        } else if (array.shape[2] === 1) {
          ops.assign(ndarray2(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]), ndarray2(array.data, [array.shape[0], array.shape[1], 3], [array.stride[0], array.stride[1], 0], array.offset));
          ops.assigns(ndarray2(data, [array.shape[0] * array.shape[1]], [4], 3), 255);
        } else {
          return new Error("Incompatible array shape");
        }
      } else if (array.shape.length === 2) {
        ops.assign(ndarray2(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]), ndarray2(array.data, [array.shape[0], array.shape[1], 3], [array.stride[0], array.stride[1], 0], array.offset));
        ops.assigns(ndarray2(data, [array.shape[0] * array.shape[1]], [4], 3), 255);
      } else {
        return new Error("Incompatible array shape");
      }
      return data;
    }
    function haderror(err) {
      var result = through();
      result.emit("error", err);
      return result;
    }
    module2.exports = function savePixels2(array, type, options) {
      options = options || {};
      switch (type.toUpperCase()) {
        case "JPG":
        case ".JPG":
        case "JPEG":
        case ".JPEG":
        case "JPE":
        case ".JPE":
          var width = array.shape[0];
          var height = array.shape[1];
          var data = new Buffer(width * height * 4);
          data = handleData(array, data);
          var rawImageData = {
            data,
            width,
            height
          };
          var jpegImageData = jpegJs.encode(rawImageData, options.quality);
          return new ContentStream(jpegImageData.data);
        case "GIF":
        case ".GIF":
          var frames = array.shape.length === 4 ? array.shape[0] : 1;
          var width = array.shape.length === 4 ? array.shape[1] : array.shape[0];
          var height = array.shape.length === 4 ? array.shape[2] : array.shape[1];
          var data = new Buffer(width * height * 4);
          var gif = new GifEncoder(width, height);
          gif.writeHeader();
          for (var i = 0; i < frames; i++) {
            data = handleData(array, data, i);
            gif.addFrame(data);
          }
          gif.finish();
          return gif;
        case "PNG":
        case ".PNG":
          var png = new PNG({
            width: array.shape[0],
            height: array.shape[1]
          });
          var data = handleData(array, png.data);
          if (typeof data === "Error")
            return haderror(data);
          png.data = data;
          return png.pack();
        case "CANVAS":
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          canvas.width = array.shape[0];
          canvas.height = array.shape[1];
          var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          var data = imageData.data;
          data = handleData(array, data);
          if (typeof data === "Error")
            return haderror(data);
          context.putImageData(imageData, 0, 0);
          return canvas;
        default:
          return haderror(new Error("Unsupported file type: " + type));
      }
    };
  }
});

// ../../node_modules/pngjs/lib/chunkstream.js
var require_chunkstream2 = __commonJS({
  "../../node_modules/pngjs/lib/chunkstream.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var Stream2 = require("stream");
    var ChunkStream = module2.exports = function() {
      Stream2.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util2.inherits(ChunkStream, Stream2);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      var dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = new Buffer(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read) {
      this._reads.shift();
      var smallerBuf = this._buffers[0];
      if (smallerBuf.length > read.length) {
        this._buffered -= read.length;
        this._buffers[0] = smallerBuf.slice(read.length);
        read.func.call(this, smallerBuf.slice(0, read.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read) {
      this._reads.shift();
      var pos = 0;
      var count = 0;
      var data = new Buffer(read.length);
      while (pos < read.length) {
        var buf = this._buffers[count++];
        var len = Math.min(buf.length, read.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read.length;
      read.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          var read = this._reads[0];
          if (read.allowLess) {
            this._processReadAllowingLess(read);
          } else if (this._buffered >= read.length) {
            this._processRead(read);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// ../../node_modules/pngjs/lib/interlace.js
var require_interlace2 = __commonJS({
  "../../node_modules/pngjs/lib/interlace.js"(exports2) {
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports2.getImagePasses = function(width, height) {
      var images = [];
      var xLeftOver = width % 8;
      var yLeftOver = height % 8;
      var xRepeats = (width - xLeftOver) / 8;
      var yRepeats = (height - yLeftOver) / 8;
      for (var i = 0; i < imagePasses.length; i++) {
        var pass = imagePasses[i];
        var passWidth = xRepeats * pass.x.length;
        var passHeight = yRepeats * pass.y.length;
        for (var j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i });
        }
      }
      return images;
    };
    exports2.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        var outerXLeftOver = x % imagePasses[pass].x.length;
        var outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        var outerYLeftOver = y % imagePasses[pass].y.length;
        var outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// ../../node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor2 = __commonJS({
  "../../node_modules/pngjs/lib/paeth-predictor.js"(exports2, module2) {
    "use strict";
    module2.exports = function paethPredictor(left, above, upLeft) {
      var paeth = left + above - upLeft;
      var pLeft = Math.abs(paeth - left);
      var pAbove = Math.abs(paeth - above);
      var pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// ../../node_modules/pngjs/lib/filter-parse.js
var require_filter_parse2 = __commonJS({
  "../../node_modules/pngjs/lib/filter-parse.js"(exports2, module2) {
    "use strict";
    var interlaceUtils = require_interlace2();
    var paethPredictor = require_paeth_predictor2();
    function getByteWidth(width, bpp, depth) {
      var byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module2.exports = function(bitmapInfo, dependencies) {
      var width = bitmapInfo.width;
      var height = bitmapInfo.height;
      var interlace = bitmapInfo.interlace;
      var bpp = bitmapInfo.bpp;
      var depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        var passes = interlaceUtils.getImagePasses(width, height);
        for (var i = 0; i < passes.length; i++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i].width, bpp, depth),
            height: passes[i].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f3Up = lastLine ? lastLine[x] : 0;
        var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        var f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f4Up = lastLine ? lastLine[x] : 0;
        var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      var filter = rawData[0];
      var unfilteredLine;
      var currentImage = this._images[this._imageIndex];
      var byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = new Buffer(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// ../../node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async2 = __commonJS({
  "../../node_modules/pngjs/lib/filter-parse-async.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var ChunkStream = require_chunkstream2();
    var Filter = require_filter_parse2();
    var FilterAsync = module2.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      var buffers = [];
      var that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util2.inherits(FilterAsync, ChunkStream);
  }
});

// ../../node_modules/pngjs/lib/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/pngjs/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// ../../node_modules/pngjs/lib/crc.js
var require_crc2 = __commonJS({
  "../../node_modules/pngjs/lib/crc.js"(exports2, module2) {
    "use strict";
    var crcTable = [];
    (function() {
      for (var i = 0; i < 256; i++) {
        var currentCrc = i;
        for (var j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i] = currentCrc;
      }
    })();
    var CrcCalculator = module2.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (var i = 0; i < data.length; i++) {
        this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      var crc = -1;
      for (var i = 0; i < buf.length; i++) {
        crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// ../../node_modules/pngjs/lib/parser.js
var require_parser2 = __commonJS({
  "../../node_modules/pngjs/lib/parser.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var CrcCalculator = require_crc2();
    var Parser = module2.exports = function(options, dependencies) {
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      var signature = constants.PNG_SIGNATURE;
      for (var i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      var length = data.readUInt32BE(0);
      var type = data.readUInt32BE(4);
      var name = "";
      for (var i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }
      var ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(new Buffer(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      var fileCrc = data.readInt32BE(0);
      var calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      var width = data.readUInt32BE(0);
      var height = data.readUInt32BE(4);
      var depth = data[8];
      var colorType = data[9];
      var compr = data[10];
      var filter = data[11];
      var interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      var entries = Math.floor(data.length / 3);
      for (var i = 0; i < entries; i++) {
        this._palette.push([
          data[i * 3],
          data[i * 3 + 1],
          data[i * 3 + 2],
          255
        ]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (var i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      var leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// ../../node_modules/pngjs/lib/bitmapper.js
var require_bitmapper2 = __commonJS({
  "../../node_modules/pngjs/lib/bitmapper.js"(exports2) {
    "use strict";
    var interlaceUtils = require_interlace2();
    var pixelBppMapper = [
      function() {
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        var pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        var pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      function() {
      },
      function(pxData, pixelData, pxPos, maxBit) {
        var pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        var pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      var leftOver = [];
      var i = 0;
      function split() {
        if (i === data.length) {
          throw new Error("Ran out of data");
        }
        var byte = data[i];
        i++;
        var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i];
            i++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          var returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
      var imageWidth = image.width;
      var imageHeight = image.height;
      var imagePass = image.index;
      for (var y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
          var pxPos = getPxPos(x, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
      var imageWidth = image.width;
      var imageHeight = image.height;
      var imagePass = image.index;
      for (var y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
          var pixelData = bits.get(bpp);
          var pxPos = getPxPos(x, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports2.dataToBitMap = function(data, bitmapInfo) {
      var width = bitmapInfo.width;
      var height = bitmapInfo.height;
      var depth = bitmapInfo.depth;
      var bpp = bitmapInfo.bpp;
      var interlace = bitmapInfo.interlace;
      if (depth !== 8) {
        var bits = bitRetriever(data, depth);
      }
      var pxData;
      if (depth <= 8) {
        pxData = new Buffer(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      var maxBit = Math.pow(2, depth) - 1;
      var rawPos = 0;
      var images;
      var getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        var nonInterlacedPxPos = 0;
        getPxPos = function() {
          var returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// ../../node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser2 = __commonJS({
  "../../node_modules/pngjs/lib/format-normaliser.js"(exports2, module2) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = color[i];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (var i = 0; i < 4; i++) {
              outdata[pxPos + i] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      var maxOutSample = 255;
      var maxInSample = Math.pow(2, depth) - 1;
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module2.exports = function(indata, imageData) {
      var depth = imageData.depth;
      var width = imageData.width;
      var height = imageData.height;
      var colorType = imageData.colorType;
      var transColor = imageData.transColor;
      var palette = imageData.palette;
      var outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = new Buffer(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// ../../node_modules/pngjs/lib/parser-async.js
var require_parser_async2 = __commonJS({
  "../../node_modules/pngjs/lib/parser-async.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var zlib2 = require("zlib");
    var ChunkStream = require_chunkstream2();
    var FilterAsync = require_filter_parse_async2();
    var Parser = require_parser2();
    var bitmapper = require_bitmapper2();
    var formatNormaliser = require_format_normaliser2();
    var ParserAsync = module2.exports = function(options) {
      ChunkStream.call(this);
      this._parser = new Parser(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options;
      this.writable = true;
      this._parser.start();
    };
    util2.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib2.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          var rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          var imageSize = rowSize * this._bitmapInfo.height;
          var chunkSize = Math.max(imageSize, zlib2.Z_MIN_CHUNK);
          this._inflate = zlib2.createInflate({ chunkSize });
          var leftToInflate = imageSize;
          var emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          var filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
      this.destroySoon();
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      try {
        var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// ../../node_modules/pngjs/lib/bitpacker.js
var require_bitpacker2 = __commonJS({
  "../../node_modules/pngjs/lib/bitpacker.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    module2.exports = function(dataIn, width, height, options) {
      var outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
      if (options.colorType === options.inputColorType) {
        var bigEndian = function() {
          var buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      var data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      var maxValue = 255;
      var inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
      if (inBpp === 4 && !options.inputHasAlpha) {
        inBpp = 3;
      }
      var outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
      if (options.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      var outData = new Buffer(width * height * outBpp);
      var inIndex = 0;
      var outIndex = 0;
      var bgColor = options.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        var red;
        var green;
        var blue;
        var alpha = maxValue;
        switch (options.inputColorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error("input color type:" + options.inputColorType + " is not supported at present");
        }
        if (options.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
          }
        }
        return { red, green, blue, alpha };
      }
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var rgba = getRGBA(data, inIndex);
          switch (options.colorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
            case constants.COLORTYPE_COLOR:
              if (options.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants.COLORTYPE_ALPHA:
            case constants.COLORTYPE_GRAYSCALE:
              var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            default:
              throw new Error("unrecognised color Type " + options.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// ../../node_modules/pngjs/lib/filter-pack.js
var require_filter_pack2 = __commonJS({
  "../../node_modules/pngjs/lib/filter-pack.js"(exports2, module2) {
    "use strict";
    var paethPredictor = require_paeth_predictor2();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (var x = 0; x < byteWidth; x++) {
        rawData[rawPos + x] = pxData[pxPos + x];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      var sum = 0;
      var length = pxPos + byteWidth;
      for (var i = pxPos; i < length; i++) {
        sum += Math.abs(pxData[i]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var val = pxData[pxPos + x] - left;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var val = pxData[pxPos + x] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (var x = 0; x < byteWidth; x++) {
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - up;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      var sum = 0;
      var length = pxPos + byteWidth;
      for (var x = pxPos; x < length; x++) {
        var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        var val = pxData[x] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - (left + up >> 1);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module2.exports = function(pxData, width, height, options, bpp) {
      var filterTypes;
      if (!("filterType" in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options.filterType === "number") {
        filterTypes = [options.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options.bitDepth === 16) {
        bpp *= 2;
      }
      var byteWidth = width * bpp;
      var rawPos = 0;
      var pxPos = 0;
      var rawData = new Buffer((byteWidth + 1) * height);
      var sel = filterTypes[0];
      for (var y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          var min = Infinity;
          for (var i = 0; i < filterTypes.length; i++) {
            var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// ../../node_modules/pngjs/lib/packer.js
var require_packer2 = __commonJS({
  "../../node_modules/pngjs/lib/packer.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var CrcStream = require_crc2();
    var bitPacker = require_bitpacker2();
    var filter = require_filter_pack2();
    var zlib2 = require("zlib");
    var Packer = module2.exports = function(options) {
      this._options = options;
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib2.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
      options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.colorType) === -1) {
        throw new Error("option color type:" + options.colorType + " is not supported at present");
      }
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.inputColorType) === -1) {
        throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.bitDepth !== 8 && options.bitDepth !== 16) {
        throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      var packedData = bitPacker(data, width, height, this._options);
      var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      var filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      var len = data ? data.length : 0;
      var buf = new Buffer(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      var buf = new Buffer(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      var buf = new Buffer(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// ../../node_modules/pngjs/lib/packer-async.js
var require_packer_async2 = __commonJS({
  "../../node_modules/pngjs/lib/packer-async.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var Stream2 = require("stream");
    var constants = require_constants2();
    var Packer = require_packer2();
    var PackerAsync = module2.exports = function(opt) {
      Stream2.call(this);
      var options = opt || {};
      this._packer = new Packer(options);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util2.inherits(PackerAsync, Stream2);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", new Buffer(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      var filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// ../../node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "../../node_modules/pngjs/lib/sync-inflate.js"(exports2, module2) {
    "use strict";
    var assert3 = require("assert").ok;
    var zlib2 = require("zlib");
    var util2 = require("util");
    var kMaxLength = require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib2.Z_MIN_CHUNK) {
        opts.chunkSize = zlib2.Z_MIN_CHUNK;
      }
      zlib2.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      var self2 = this;
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var leftToInflate = this._maxLength;
      var inOff = 0;
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(err) {
        error = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        var have = availOutBefore - availOutAfter;
        assert3(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert3(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      var buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util2.inherits(Inflate, zlib2.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      var flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib2.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module2.exports = exports2 = inflateSync;
    exports2.Inflate = Inflate;
    exports2.createInflate = createInflate;
    exports2.inflateSync = inflateSync;
  }
});

// ../../node_modules/pngjs/lib/sync-reader.js
var require_sync_reader2 = __commonJS({
  "../../node_modules/pngjs/lib/sync-reader.js"(exports2, module2) {
    "use strict";
    var SyncReader = module2.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        var read = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
          this._reads.shift();
          var buf = this._buffer;
          this._buffer = buf.slice(read.length);
          read.func.call(this, buf.slice(0, read.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// ../../node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync2 = __commonJS({
  "../../node_modules/pngjs/lib/filter-parse-sync.js"(exports2) {
    "use strict";
    var SyncReader = require_sync_reader2();
    var Filter = require_filter_parse2();
    exports2.process = function(inBuffer, bitmapInfo) {
      var outBuffers = [];
      var reader = new SyncReader(inBuffer);
      var filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// ../../node_modules/pngjs/lib/parser-sync.js
var require_parser_sync2 = __commonJS({
  "../../node_modules/pngjs/lib/parser-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader2();
    var FilterSync = require_filter_parse_sync2();
    var Parser = require_parser2();
    var bitmapper = require_bitmapper2();
    var formatNormaliser = require_format_normaliser2();
    module2.exports = function(buffer, options) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      var err;
      function handleError(_err_) {
        err = _err_;
      }
      var metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      var gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      var inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      var reader = new SyncReader(buffer);
      var parser = new Parser(options, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      var inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      var inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib2.inflateSync(inflateData);
      } else {
        var rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        var imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, { chunkSize: imageSize, maxLength: imageSize });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      var unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      var normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// ../../node_modules/pngjs/lib/packer-sync.js
var require_packer_sync2 = __commonJS({
  "../../node_modules/pngjs/lib/packer-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants2();
    var Packer = require_packer2();
    module2.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      var options = opt || {};
      var packer = new Packer(options);
      var chunks = [];
      chunks.push(new Buffer(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      var compressedData = zlib2.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// ../../node_modules/pngjs/lib/png-sync.js
var require_png_sync2 = __commonJS({
  "../../node_modules/pngjs/lib/png-sync.js"(exports2) {
    "use strict";
    var parse = require_parser_sync2();
    var pack = require_packer_sync2();
    exports2.read = function(buffer, options) {
      return parse(buffer, options || {});
    };
    exports2.write = function(png, options) {
      return pack(png, options);
    };
  }
});

// ../../node_modules/pngjs/lib/png.js
var require_png2 = __commonJS({
  "../../node_modules/pngjs/lib/png.js"(exports2) {
    "use strict";
    var util2 = require("util");
    var Stream2 = require("stream");
    var Parser = require_parser_async2();
    var Packer = require_packer_async2();
    var PNGSync = require_png_sync2();
    var PNG = exports2.PNG = function(options) {
      Stream2.call(this);
      options = options || {};
      this.width = options.width | 0;
      this.height = options.height | 0;
      this.data = this.width > 0 && this.height > 0 ? new Buffer(4 * this.width * this.height) : null;
      if (options.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util2.inherits(PNG, Stream2);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        var onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (var y = 0; y < height; y++) {
        src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src) {
      if (src.gamma) {
        for (var y = 0; y < src.height; y++) {
          for (var x = 0; x < src.width; x++) {
            var idx = src.width * y + x << 2;
            for (var i = 0; i < 3; i++) {
              var sample = src.data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// ../../node_modules/get-pixels/node_modules/jpeg-js/lib/encoder.js
var require_encoder2 = __commonJS({
  "../../node_modules/get-pixels/node_modules/jpeg-js/lib/encoder.js"(exports2, module2) {
    var btoa2 = btoa2 || function(buf) {
      return new Buffer(buf).toString("base64");
    };
    function JPEGEncoder(quality) {
      var self2 = this;
      var fround = Math.round;
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        ;
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      this.encode = function(image, quality2) {
        var time_start = new Date().getTime();
        if (quality2)
          setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var tripleWidth = width * 3;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        return new Buffer(byteout);
        var jpegDataUri = "data:image/jpeg;base64," + btoa2(byteout.join(""));
        byteout = [];
        var duration = new Date().getTime() - time_start;
        return jpegDataUri;
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2)
          return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init() {
        var time_start = new Date().getTime();
        if (!quality)
          quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        var duration = new Date().getTime() - time_start;
      }
      init();
    }
    if (typeof module2 !== void 0) {
      module2.exports = encode2;
    }
    function encode2(imgData, qu) {
      if (typeof qu === "undefined")
        qu = 50;
      var encoder = new JPEGEncoder(qu);
      var data = encoder.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
  }
});

// ../../node_modules/get-pixels/node_modules/jpeg-js/lib/decoder.js
var require_decoder2 = __commonJS({
  "../../node_modules/get-pixels/node_modules/jpeg-js/lib/decoder.js"(exports2, module2) {
    var JpegImage = function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q2;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q2 = { children: [], index: 0 });
              p.children[p.index] = q2.children;
              p = q2;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q2 = { children: [], index: 0 });
            p.children[p.index] = q2.children;
            p = q2;
          }
        }
        return code[0].children;
      }
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null)
              return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode3, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          decode3(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode3, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          decode3(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval)
          resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected)
                break;
            }
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load(path2) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path2, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse(data) {
          var offset = 0, length = data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length2 = readUint16();
            var array = data.subarray(offset, offset + length2 - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH2 = 0, maxV2 = 0;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH2 < component2.h)
                  maxH2 = component2.h;
                if (maxV2 < component2.v)
                  maxV2 = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocks = [];
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH2;
            frame2.maxV = maxV2;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j, l;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++)
                    codeLengthSum += codeLengths[j] = data[offset];
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65498:
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.colorTransform !== "undefined")
                colorTransform = !!this.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.colorTransform !== "undefined")
                colorTransform = !!this.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C;
                  data[offset++] = 255 - M;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      return constructor;
    }();
    module2.exports = decode2;
    function decode2(jpegData, opts) {
      var defaultOpts = {
        useTArray: false,
        colorTransform: void 0,
        formatAsRGBA: true
      };
      if (opts) {
        if (typeof opts === "object") {
          opts = {
            useTArray: typeof opts.useTArray === "undefined" ? defaultOpts.useTArray : opts.useTArray,
            colorTransform: typeof opts.colorTransform === "undefined" ? defaultOpts.colorTransform : opts.colorTransform,
            formatAsRGBA: typeof opts.formatAsRGBA === "undefined" ? defaultOpts.formatAsRGBA : opts.formatAsRGBA
          };
        } else {
          opts = defaultOpts;
          opts.useTArray = true;
        }
      } else {
        opts = defaultOpts;
      }
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.parse(arr);
      decoder.colorTransform = opts.colorTransform;
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder.width * decoder.height * channels;
      try {
        var image = {
          width: decoder.width,
          height: decoder.height,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : new Buffer(bytesNeeded)
        };
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        } else {
          throw err;
        }
      }
      decoder.copyToImageData(image, opts.formatAsRGBA);
      return image;
    }
  }
});

// ../../node_modules/get-pixels/node_modules/jpeg-js/index.js
var require_jpeg_js2 = __commonJS({
  "../../node_modules/get-pixels/node_modules/jpeg-js/index.js"(exports2, module2) {
    var encode2 = require_encoder2();
    var decode2 = require_decoder2();
    module2.exports = {
      encode: encode2,
      decode: decode2
    };
  }
});

// ../../node_modules/ndarray-pack/doConvert.js
var require_doConvert = __commonJS({
  "../../node_modules/ndarray-pack/doConvert.js"(exports2, module2) {
    module2.exports = require_compiler()({ "args": ["array", "scalar", "index"], "pre": { "body": "{}", "args": [], "thisVars": [], "localVars": [] }, "body": { "body": "{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}", "args": [{ "name": "_inline_1_arg0_", "lvalue": true, "rvalue": false, "count": 1 }, { "name": "_inline_1_arg1_", "lvalue": false, "rvalue": true, "count": 1 }, { "name": "_inline_1_arg2_", "lvalue": false, "rvalue": true, "count": 4 }], "thisVars": [], "localVars": ["_inline_1_i", "_inline_1_v"] }, "post": { "body": "{}", "args": [], "thisVars": [], "localVars": [] }, "funcName": "convert", "blockSize": 64 });
  }
});

// ../../node_modules/ndarray-pack/convert.js
var require_convert = __commonJS({
  "../../node_modules/ndarray-pack/convert.js"(exports2, module2) {
    "use strict";
    var ndarray2 = require_ndarray();
    var do_convert = require_doConvert();
    module2.exports = function convert(arr, result) {
      var shape = [], c = arr, sz = 1;
      while (Array.isArray(c)) {
        shape.push(c.length);
        sz *= c.length;
        c = c[0];
      }
      if (shape.length === 0) {
        return ndarray2();
      }
      if (!result) {
        result = ndarray2(new Float64Array(sz), shape);
      }
      do_convert(result, arr);
      return result;
    };
  }
});

// ../../node_modules/omggif/omggif.js
var require_omggif = __commonJS({
  "../../node_modules/omggif/omggif.js"(exports2) {
    "use strict";
    function GifWriter(buf, width, height, gopts) {
      var p = 0;
      var gopts = gopts === void 0 ? {} : gopts;
      var loop_count = gopts.loop === void 0 ? null : gopts.loop;
      var global_palette = gopts.palette === void 0 ? null : gopts.palette;
      if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
        throw new Error("Width/Height invalid.");
      function check_palette_and_num_colors(palette) {
        var num_colors = palette.length;
        if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
          throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
        }
        return num_colors;
      }
      buf[p++] = 71;
      buf[p++] = 73;
      buf[p++] = 70;
      buf[p++] = 56;
      buf[p++] = 57;
      buf[p++] = 97;
      var gp_num_colors_pow2 = 0;
      var background = 0;
      if (global_palette !== null) {
        var gp_num_colors = check_palette_and_num_colors(global_palette);
        while (gp_num_colors >>= 1)
          ++gp_num_colors_pow2;
        gp_num_colors = 1 << gp_num_colors_pow2;
        --gp_num_colors_pow2;
        if (gopts.background !== void 0) {
          background = gopts.background;
          if (background >= gp_num_colors)
            throw new Error("Background index out of range.");
          if (background === 0)
            throw new Error("Background index explicitly passed as 0.");
        }
      }
      buf[p++] = width & 255;
      buf[p++] = width >> 8 & 255;
      buf[p++] = height & 255;
      buf[p++] = height >> 8 & 255;
      buf[p++] = (global_palette !== null ? 128 : 0) | gp_num_colors_pow2;
      buf[p++] = background;
      buf[p++] = 0;
      if (global_palette !== null) {
        for (var i = 0, il = global_palette.length; i < il; ++i) {
          var rgb = global_palette[i];
          buf[p++] = rgb >> 16 & 255;
          buf[p++] = rgb >> 8 & 255;
          buf[p++] = rgb & 255;
        }
      }
      if (loop_count !== null) {
        if (loop_count < 0 || loop_count > 65535)
          throw new Error("Loop count invalid.");
        buf[p++] = 33;
        buf[p++] = 255;
        buf[p++] = 11;
        buf[p++] = 78;
        buf[p++] = 69;
        buf[p++] = 84;
        buf[p++] = 83;
        buf[p++] = 67;
        buf[p++] = 65;
        buf[p++] = 80;
        buf[p++] = 69;
        buf[p++] = 50;
        buf[p++] = 46;
        buf[p++] = 48;
        buf[p++] = 3;
        buf[p++] = 1;
        buf[p++] = loop_count & 255;
        buf[p++] = loop_count >> 8 & 255;
        buf[p++] = 0;
      }
      var ended = false;
      this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
        if (ended === true) {
          --p;
          ended = false;
        }
        opts = opts === void 0 ? {} : opts;
        if (x < 0 || y < 0 || x > 65535 || y > 65535)
          throw new Error("x/y invalid.");
        if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
          throw new Error("Width/Height invalid.");
        if (indexed_pixels.length < w * h)
          throw new Error("Not enough pixels for the frame size.");
        var using_local_palette = true;
        var palette = opts.palette;
        if (palette === void 0 || palette === null) {
          using_local_palette = false;
          palette = global_palette;
        }
        if (palette === void 0 || palette === null)
          throw new Error("Must supply either a local or global palette.");
        var num_colors = check_palette_and_num_colors(palette);
        var min_code_size = 0;
        while (num_colors >>= 1)
          ++min_code_size;
        num_colors = 1 << min_code_size;
        var delay = opts.delay === void 0 ? 0 : opts.delay;
        var disposal = opts.disposal === void 0 ? 0 : opts.disposal;
        if (disposal < 0 || disposal > 3)
          throw new Error("Disposal out of range.");
        var use_transparency = false;
        var transparent_index = 0;
        if (opts.transparent !== void 0 && opts.transparent !== null) {
          use_transparency = true;
          transparent_index = opts.transparent;
          if (transparent_index < 0 || transparent_index >= num_colors)
            throw new Error("Transparent color index.");
        }
        if (disposal !== 0 || use_transparency || delay !== 0) {
          buf[p++] = 33;
          buf[p++] = 249;
          buf[p++] = 4;
          buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
          buf[p++] = delay & 255;
          buf[p++] = delay >> 8 & 255;
          buf[p++] = transparent_index;
          buf[p++] = 0;
        }
        buf[p++] = 44;
        buf[p++] = x & 255;
        buf[p++] = x >> 8 & 255;
        buf[p++] = y & 255;
        buf[p++] = y >> 8 & 255;
        buf[p++] = w & 255;
        buf[p++] = w >> 8 & 255;
        buf[p++] = h & 255;
        buf[p++] = h >> 8 & 255;
        buf[p++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
        if (using_local_palette === true) {
          for (var i2 = 0, il2 = palette.length; i2 < il2; ++i2) {
            var rgb2 = palette[i2];
            buf[p++] = rgb2 >> 16 & 255;
            buf[p++] = rgb2 >> 8 & 255;
            buf[p++] = rgb2 & 255;
          }
        }
        p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
        return p;
      };
      this.end = function() {
        if (ended === false) {
          buf[p++] = 59;
          ended = true;
        }
        return p;
      };
      this.getOutputBuffer = function() {
        return buf;
      };
      this.setOutputBuffer = function(v) {
        buf = v;
      };
      this.getOutputBufferPosition = function() {
        return p;
      };
      this.setOutputBufferPosition = function(v) {
        p = v;
      };
    }
    function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
      buf[p++] = min_code_size;
      var cur_subblock = p++;
      var clear_code = 1 << min_code_size;
      var code_mask = clear_code - 1;
      var eoi_code = clear_code + 1;
      var next_code = eoi_code + 1;
      var cur_code_size = min_code_size + 1;
      var cur_shift = 0;
      var cur = 0;
      function emit_bytes_to_buffer(bit_block_size) {
        while (cur_shift >= bit_block_size) {
          buf[p++] = cur & 255;
          cur >>= 8;
          cur_shift -= 8;
          if (p === cur_subblock + 256) {
            buf[cur_subblock] = 255;
            cur_subblock = p++;
          }
        }
      }
      function emit_code(c) {
        cur |= c << cur_shift;
        cur_shift += cur_code_size;
        emit_bytes_to_buffer(8);
      }
      var ib_code = index_stream[0] & code_mask;
      var code_table = {};
      emit_code(clear_code);
      for (var i = 1, il = index_stream.length; i < il; ++i) {
        var k = index_stream[i] & code_mask;
        var cur_key = ib_code << 8 | k;
        var cur_code = code_table[cur_key];
        if (cur_code === void 0) {
          cur |= ib_code << cur_shift;
          cur_shift += cur_code_size;
          while (cur_shift >= 8) {
            buf[p++] = cur & 255;
            cur >>= 8;
            cur_shift -= 8;
            if (p === cur_subblock + 256) {
              buf[cur_subblock] = 255;
              cur_subblock = p++;
            }
          }
          if (next_code === 4096) {
            emit_code(clear_code);
            next_code = eoi_code + 1;
            cur_code_size = min_code_size + 1;
            code_table = {};
          } else {
            if (next_code >= 1 << cur_code_size)
              ++cur_code_size;
            code_table[cur_key] = next_code++;
          }
          ib_code = k;
        } else {
          ib_code = cur_code;
        }
      }
      emit_code(ib_code);
      emit_code(eoi_code);
      emit_bytes_to_buffer(1);
      if (cur_subblock + 1 === p) {
        buf[cur_subblock] = 0;
      } else {
        buf[cur_subblock] = p - cur_subblock - 1;
        buf[p++] = 0;
      }
      return p;
    }
    function GifReader(buf) {
      var p = 0;
      if (buf[p++] !== 71 || buf[p++] !== 73 || buf[p++] !== 70 || buf[p++] !== 56 || (buf[p++] + 1 & 253) !== 56 || buf[p++] !== 97) {
        throw new Error("Invalid GIF 87a/89a header.");
      }
      var width = buf[p++] | buf[p++] << 8;
      var height = buf[p++] | buf[p++] << 8;
      var pf0 = buf[p++];
      var global_palette_flag = pf0 >> 7;
      var num_global_colors_pow2 = pf0 & 7;
      var num_global_colors = 1 << num_global_colors_pow2 + 1;
      var background = buf[p++];
      buf[p++];
      var global_palette_offset = null;
      var global_palette_size = null;
      if (global_palette_flag) {
        global_palette_offset = p;
        global_palette_size = num_global_colors;
        p += num_global_colors * 3;
      }
      var no_eof = true;
      var frames = [];
      var delay = 0;
      var transparent_index = null;
      var disposal = 0;
      var loop_count = null;
      this.width = width;
      this.height = height;
      while (no_eof && p < buf.length) {
        switch (buf[p++]) {
          case 33:
            switch (buf[p++]) {
              case 255:
                if (buf[p] !== 11 || buf[p + 1] == 78 && buf[p + 2] == 69 && buf[p + 3] == 84 && buf[p + 4] == 83 && buf[p + 5] == 67 && buf[p + 6] == 65 && buf[p + 7] == 80 && buf[p + 8] == 69 && buf[p + 9] == 50 && buf[p + 10] == 46 && buf[p + 11] == 48 && buf[p + 12] == 3 && buf[p + 13] == 1 && buf[p + 16] == 0) {
                  p += 14;
                  loop_count = buf[p++] | buf[p++] << 8;
                  p++;
                } else {
                  p += 12;
                  while (true) {
                    var block_size = buf[p++];
                    if (!(block_size >= 0))
                      throw Error("Invalid block size");
                    if (block_size === 0)
                      break;
                    p += block_size;
                  }
                }
                break;
              case 249:
                if (buf[p++] !== 4 || buf[p + 4] !== 0)
                  throw new Error("Invalid graphics extension block.");
                var pf1 = buf[p++];
                delay = buf[p++] | buf[p++] << 8;
                transparent_index = buf[p++];
                if ((pf1 & 1) === 0)
                  transparent_index = null;
                disposal = pf1 >> 2 & 7;
                p++;
                break;
              case 254:
                while (true) {
                  var block_size = buf[p++];
                  if (!(block_size >= 0))
                    throw Error("Invalid block size");
                  if (block_size === 0)
                    break;
                  p += block_size;
                }
                break;
              default:
                throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
            }
            break;
          case 44:
            var x = buf[p++] | buf[p++] << 8;
            var y = buf[p++] | buf[p++] << 8;
            var w = buf[p++] | buf[p++] << 8;
            var h = buf[p++] | buf[p++] << 8;
            var pf2 = buf[p++];
            var local_palette_flag = pf2 >> 7;
            var interlace_flag = pf2 >> 6 & 1;
            var num_local_colors_pow2 = pf2 & 7;
            var num_local_colors = 1 << num_local_colors_pow2 + 1;
            var palette_offset = global_palette_offset;
            var palette_size = global_palette_size;
            var has_local_palette = false;
            if (local_palette_flag) {
              var has_local_palette = true;
              palette_offset = p;
              palette_size = num_local_colors;
              p += num_local_colors * 3;
            }
            var data_offset = p;
            p++;
            while (true) {
              var block_size = buf[p++];
              if (!(block_size >= 0))
                throw Error("Invalid block size");
              if (block_size === 0)
                break;
              p += block_size;
            }
            frames.push({
              x,
              y,
              width: w,
              height: h,
              has_local_palette,
              palette_offset,
              palette_size,
              data_offset,
              data_length: p - data_offset,
              transparent_index,
              interlaced: !!interlace_flag,
              delay,
              disposal
            });
            break;
          case 59:
            no_eof = false;
            break;
          default:
            throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
            break;
        }
      }
      this.numFrames = function() {
        return frames.length;
      };
      this.loopCount = function() {
        return loop_count;
      };
      this.frameInfo = function(frame_num) {
        if (frame_num < 0 || frame_num >= frames.length)
          throw new Error("Frame index out of range.");
        return frames[frame_num];
      };
      this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
        var frame = this.frameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels);
        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
        var palette_offset2 = frame.palette_offset;
        var trans = frame.transparent_index;
        if (trans === null)
          trans = 256;
        var framewidth = frame.width;
        var framestride = width - framewidth;
        var xleft = framewidth;
        var opbeg = (frame.y * width + frame.x) * 4;
        var opend = ((frame.y + frame.height) * width + frame.x) * 4;
        var op = opbeg;
        var scanstride = framestride * 4;
        if (frame.interlaced === true) {
          scanstride += width * 4 * 7;
        }
        var interlaceskip = 8;
        for (var i = 0, il = index_stream.length; i < il; ++i) {
          var index2 = index_stream[i];
          if (xleft === 0) {
            op += scanstride;
            xleft = framewidth;
            if (op >= opend) {
              scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
              interlaceskip >>= 1;
            }
          }
          if (index2 === trans) {
            op += 4;
          } else {
            var r = buf[palette_offset2 + index2 * 3];
            var g = buf[palette_offset2 + index2 * 3 + 1];
            var b = buf[palette_offset2 + index2 * 3 + 2];
            pixels[op++] = b;
            pixels[op++] = g;
            pixels[op++] = r;
            pixels[op++] = 255;
          }
          --xleft;
        }
      };
      this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
        var frame = this.frameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels);
        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
        var palette_offset2 = frame.palette_offset;
        var trans = frame.transparent_index;
        if (trans === null)
          trans = 256;
        var framewidth = frame.width;
        var framestride = width - framewidth;
        var xleft = framewidth;
        var opbeg = (frame.y * width + frame.x) * 4;
        var opend = ((frame.y + frame.height) * width + frame.x) * 4;
        var op = opbeg;
        var scanstride = framestride * 4;
        if (frame.interlaced === true) {
          scanstride += width * 4 * 7;
        }
        var interlaceskip = 8;
        for (var i = 0, il = index_stream.length; i < il; ++i) {
          var index2 = index_stream[i];
          if (xleft === 0) {
            op += scanstride;
            xleft = framewidth;
            if (op >= opend) {
              scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
              interlaceskip >>= 1;
            }
          }
          if (index2 === trans) {
            op += 4;
          } else {
            var r = buf[palette_offset2 + index2 * 3];
            var g = buf[palette_offset2 + index2 * 3 + 1];
            var b = buf[palette_offset2 + index2 * 3 + 2];
            pixels[op++] = r;
            pixels[op++] = g;
            pixels[op++] = b;
            pixels[op++] = 255;
          }
          --xleft;
        }
      };
    }
    function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
      var min_code_size = code_stream[p++];
      var clear_code = 1 << min_code_size;
      var eoi_code = clear_code + 1;
      var next_code = eoi_code + 1;
      var cur_code_size = min_code_size + 1;
      var code_mask = (1 << cur_code_size) - 1;
      var cur_shift = 0;
      var cur = 0;
      var op = 0;
      var subblock_size = code_stream[p++];
      var code_table = new Int32Array(4096);
      var prev_code = null;
      while (true) {
        while (cur_shift < 16) {
          if (subblock_size === 0)
            break;
          cur |= code_stream[p++] << cur_shift;
          cur_shift += 8;
          if (subblock_size === 1) {
            subblock_size = code_stream[p++];
          } else {
            --subblock_size;
          }
        }
        if (cur_shift < cur_code_size)
          break;
        var code = cur & code_mask;
        cur >>= cur_code_size;
        cur_shift -= cur_code_size;
        if (code === clear_code) {
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_mask = (1 << cur_code_size) - 1;
          prev_code = null;
          continue;
        } else if (code === eoi_code) {
          break;
        }
        var chase_code = code < next_code ? code : prev_code;
        var chase_length = 0;
        var chase = chase_code;
        while (chase > clear_code) {
          chase = code_table[chase] >> 8;
          ++chase_length;
        }
        var k = chase;
        var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
        if (op_end > output_length) {
          console.log("Warning, gif stream longer than expected.");
          return;
        }
        output[op++] = k;
        op += chase_length;
        var b = op;
        if (chase_code !== code)
          output[op++] = k;
        chase = chase_code;
        while (chase_length--) {
          chase = code_table[chase];
          output[--b] = chase & 255;
          chase >>= 8;
        }
        if (prev_code !== null && next_code < 4096) {
          code_table[next_code++] = prev_code << 8 | k;
          if (next_code >= code_mask + 1 && cur_code_size < 12) {
            ++cur_code_size;
            code_mask = code_mask << 1 | 1;
          }
        }
        prev_code = code;
      }
      if (op !== output_length) {
        console.log("Warning, gif stream shorter than expected.");
      }
      return output;
    }
    try {
      exports2.GifWriter = GifWriter;
      exports2.GifReader = GifReader;
    } catch (e) {
    }
  }
});

// ../../node_modules/node-bitmap/lib/bitmap.js
var require_bitmap = __commonJS({
  "../../node_modules/node-bitmap/lib/bitmap.js"(exports2, module2) {
    var Bitmap = module2.exports = exports2 = function(buffer) {
      this.buffer = buffer;
      this.initialized = false;
      this.fileHeader = null;
      this.infoHeader = null;
      this.coreHeader = null;
      this.colorPalette = null;
      this.dataPos = -1;
    };
    Bitmap.prototype.CORE_TYPE_WINDOWS_V3 = 40;
    Bitmap.prototype.CORE_TYPE_WINDOWS_V4 = 108;
    Bitmap.prototype.CORE_TYPE_WINDOWS_V5 = 124;
    Bitmap.prototype.CORE_TYPE_OS2_V1 = 12;
    Bitmap.prototype.CORE_TYPE_OS2_V2 = 64;
    Bitmap.prototype.BITMAPCOREHEADER = Bitmap.prototype.CORE_TYPE_OS2_V1;
    Bitmap.prototype.BITMAPINFOHEADER = Bitmap.prototype.CORE_TYPE_WINDOWS_V3;
    Bitmap.prototype.BITMAPINFOHEADER2 = Bitmap.prototype.CORE_TYPE_OS2_V2;
    Bitmap.prototype.BITMAPV4HEADER = Bitmap.prototype.CORE_TYPE_WINDOWS_V4;
    Bitmap.prototype.BITMAPV5HEADER = Bitmap.prototype.CORE_TYPE_WINDOWS_V5;
    Bitmap.prototype.COMPRESSION_BI_RGB = 0;
    Bitmap.prototype.COMPRESSION_BI_RLE8 = 1;
    Bitmap.prototype.COMPRESSION_BI_RLE4 = 2;
    Bitmap.prototype.COMPRESSION_BI_BITFIELDS = 3;
    Bitmap.prototype.COMPRESSION_BI_JPEG = 4;
    Bitmap.prototype.COMPRESSION_BI_PNG = 5;
    Bitmap.prototype.BITCOUNT_2 = 1;
    Bitmap.prototype.BITCOUNT_16 = 4;
    Bitmap.prototype.BITCOUNT_256 = 8;
    Bitmap.prototype.BITCOUNT_16bit = 16;
    Bitmap.prototype.BITCOUNT_24bit = 24;
    Bitmap.prototype.BITCOUNT_32bit = 32;
    Bitmap.prototype.init = function() {
      this.readFileHeader();
      this.readInfoHeader();
      this.readCoreHeader();
      this.readColorPalette();
      this.initDataPos();
      this.initialized = true;
    };
    Bitmap.prototype.checkInit = function() {
      if (!this.initialized) {
        throw new Error("not initialized");
      }
    };
    Bitmap.prototype.isBitmap = function() {
      this.checkInit();
      if (this.fileHeader.bfType == "BM") {
        return true;
      }
      return false;
    };
    Bitmap.prototype.getData = function() {
      this.checkInit();
      if (this.COMPRESSION_BI_RGB !== this.coreHeader.__copmression__) {
        throw new Error("not supported compression: " + this.coreHeader.__copmression__);
      }
      var bitCount = this.coreHeader.__bitCount__;
      var width = this.getWidth();
      var height = this.getHeight();
      var line = width * bitCount / 8;
      if (line % 4 != 0) {
        line = (line / 4 + 1) * 4;
      }
      var rgbaData = [];
      var dataPos = this.dataPos;
      for (var i = 0; i < height; ++i) {
        var pos = dataPos + line * (height - (i + 1));
        var buf = this.buffer.slice(pos, pos + line);
        var color = this.mapColor(buf, bitCount);
        rgbaData.push(color);
      }
      return rgbaData;
    };
    Bitmap.prototype.getWidth = function() {
      this.checkInit();
      return this.coreHeader.__width__;
    };
    Bitmap.prototype.getHeight = function() {
      this.checkInit();
      return this.coreHeader.__height__;
    };
    Bitmap.prototype.read = function(buf, offset, limit) {
      var read = [];
      for (var i = offset, len = offset + limit; i < len; ++i) {
        read.push(buf.readInt8(i));
      }
      return new Buffer(read);
    };
    Bitmap.prototype.readFileHeader = function() {
      var bfType = this.read(this.buffer, 0, 2);
      var bfSize = this.read(this.buffer, 2, 4);
      var bfReserved1 = this.read(this.buffer, 6, 2);
      var bfReserved2 = this.read(this.buffer, 8, 2);
      var bfOffBits = this.read(this.buffer, 10, 4);
      this.fileHeader = {
        bfType: bfType.toString("ascii"),
        _bfType: bfType,
        bfSize: bfSize.readUInt16LE(0),
        _bfSize: bfSize,
        bfReserved1: 0,
        bfReserved2: 0,
        bfOffBits: bfOffBits.readUInt16LE(0),
        _bfOffBits: bfOffBits
      };
    };
    Bitmap.prototype.readInfoHeader = function() {
      this.infoHeader = this.read(this.buffer, 14, 4);
    };
    Bitmap.prototype.readCoreHeader = function() {
      var coreType = this.infoHeader.readUInt16LE(0);
      switch (coreType) {
        case this.BITMAPCOREHEADER:
          return this.readCoreHeaderOS2_V1();
        case this.BITMAPINFOHEADER2:
          return this.readCoreHeaderOS2_V2();
        case this.BITMAPV4HEADER:
          return this.readCoreHeaderWINDOWS_V4();
        case this.BITMAPV5HEADER:
          return this.readCoreHeaderWINDOWS_V5();
        case this.BITMAPINFOHEADER:
          return this.readCoreHeaderWINDOWS_V3();
        default:
          throw new Error("unknown coreType: " + coreType);
      }
    };
    Bitmap.prototype.readCoreHeaderWINDOWS_V3 = function() {
      var biWidth = this.read(this.buffer, 18, 4);
      var biHeight = this.read(this.buffer, 22, 4);
      var biPlanes = this.read(this.buffer, 26, 2);
      var biBitCount = this.read(this.buffer, 28, 2);
      var biCopmression = this.read(this.buffer, 30, 4);
      var biSizeImage = this.read(this.buffer, 34, 4);
      var biXPixPerMeter = this.read(this.buffer, 38, 4);
      var biYPixPerMeter = this.read(this.buffer, 42, 4);
      var biClrUsed = this.read(this.buffer, 46, 4);
      var biCirImportant = this.read(this.buffer, 50, 4);
      this.coreHeader = {
        __copmression__: biCopmression.readUInt16LE(0),
        __bitCount__: biBitCount.readUInt8(0),
        __width__: biWidth.readUInt16LE(0),
        __height__: biHeight.readUInt16LE(0),
        biWidth: biWidth.readUInt16LE(0),
        _biWidth: biWidth,
        biHeight: biHeight.readUInt16LE(0),
        _biHeight: biHeight,
        biPlanes: biPlanes.readUInt8(0),
        _biPlanes: biPlanes,
        biBitCount: biBitCount.readUInt8(0),
        _biBitCount: biBitCount,
        biCopmression: biCopmression.readUInt16LE(0),
        _biCopmression: biCopmression,
        biSizeImage: biSizeImage.readUInt16LE(0),
        _biSizeImage: biSizeImage,
        biXPixPerMeter: biXPixPerMeter.readUInt16LE(0),
        _biXPixPerMeter: biXPixPerMeter,
        biYPixPerMeter: biYPixPerMeter.readUInt16LE(0),
        _biYPixPerMeter: biYPixPerMeter,
        biClrUsed: biClrUsed.readUInt16LE(0),
        _biClrUsed: biClrUsed,
        biCirImportant: biCirImportant.readUInt16LE(0),
        _biCirImportant: biCirImportant
      };
    };
    Bitmap.prototype.readCoreHeaderWINDOWS_V4 = function() {
      throw new Error("not yet impl");
      var bV4Width = this.read(this.buffer, 18, 4);
      var bV4Height = this.read(this.buffer, 22, 4);
      var bV4Planes = this.read(this.buffer, 26, 2);
      var bV4BitCount = this.read(this.buffer, 28, 2);
      var bV4Compression = this.read(this.buffer, 30, 4);
      var bV4SizeImage = this.read(this.buffer, 34, 4);
      var bV4XPelsPerMeter = this.read(this.buffer, 38, 4);
      var bV4YPelsPerMeter = this.read(this.buffer, 42, 4);
      var bV4ClrUsed = this.read(this.buffer, 46, 4);
      var bV4ClrImportant = this.read(this.buffer, 50, 4);
      var bV4RedMask = this.read(this.buffer, 54, 4);
      var bV4GreenMask = this.read(this.buffer, 58, 4);
      var bV4BlueMask = this.read(this.buffer, 62, 4);
      var bV4AlphaMask = this.read(this.buffer, 66, 4);
      var bV4CSType = this.read(this.buffer, 70, 4);
      var bV4Endpoints = this.read(this.buffer, 106, 36);
      var bV4GammaRed = this.read(this.buffer, 110, 4);
      var bV4GammaGreen = this.read(this.buffer, 114, 4);
      var bV4GammaBlue = this.read(this.buffer, 118, 4);
      this.coreHeader = {
        __compression__: bV4Compression.readUInt16LE(0),
        __bitCount__: bV4BitCount.readUInt8(0),
        __width__: bV4Width.readUInt16LE(0),
        __height__: bV4Height.readUInt16LE(0),
        bV4Width: bV4Width.readUInt16LE(0),
        _bV4Width: bV4Width,
        bV4Height: bV4Height.readUInt16LE(0),
        _bV4Height: bV4Height,
        bV4Planes: bV4Planes.readUInt8(0),
        _bV4Planes: bV4Planes,
        bV4BitCount: bV4BitCount.readUInt8(0),
        _bV4BitCount: bV4BitCount,
        bV4Compression: bV4Compression.readUInt16LE(0),
        _bV4Compression: bV4Compression,
        bV4SizeImage: bV4SizeImage.readUInt16LE(0),
        _bV4SizeImage: bV4SizeImage,
        bV4XPelsPerMeter: bV4XPelsPerMeter.readUInt16LE(0),
        _bV4XPelsPerMeter: bV4XPelsPerMeter,
        bV4YPelsPerMeter: bV4YPelsPerMeter.readUInt16LE(0),
        _bV4YPelsPerMeter: bV4YPelsPerMeter,
        bV4ClrUsed: bV4ClrUsed.readUInt16LE(0),
        _bV4ClrUsed: bV4ClrUsed,
        bV4ClrImportant: bV4ClrImportant.readUInt16LE(0),
        _bV4ClrImportant: bV4ClrImportant,
        bV4RedMask: bV4RedMask.readUInt16LE(0),
        _bV4RedMask: bV4RedMask,
        bV4GreenMask: bV4GreenMask.readUInt16LE(0),
        _bV4GreenMask: bV4GreenMask,
        bV4BlueMask: bV4BlueMask.readUInt16LE(0),
        _bV4BlueMask: bV4BlueMask,
        bV4AlphaMask: bV4AlphaMask.readUInt16LE(0),
        _bV4AlphaMask: bV4AlphaMask,
        bV4CSType: bV4CSType.readUInt16LE(0),
        _bV4CSType: bV4CSType,
        bV4Endpoints: null,
        _bV4Endpoints: bV4Endpoints,
        bV4GammaRed: bV4GammaRed.readUInt16LE(0),
        _bV4GammaRed: bV4GammaRed,
        bV4GammaGreen: bV4GammaGreen.readUInt16LE(0),
        _bV4GammaGreen: bV4GammaGreen,
        bV4GammaBlue: bV4GammaBlue.readUInt16LE(0),
        _bV4GammaBlue: bV4GammaBlue
      };
    };
    Bitmap.prototype.readCoreHeaderWINDOWS_V5 = function() {
      throw new Error("not yet impl");
      var bV5Width = this.read(this.buffer, 18, 4);
      var bV5Height = this.read(this.buffer, 22, 4);
      var bV5Planes = this.read(this.buffer, 26, 2);
      var bV5BitCount = this.read(this.buffer, 28, 2);
      var bV5Compression = this.read(this.buffer, 30, 4);
      var bV5SizeImage = this.read(this.buffer, 34, 4);
      var bV5XPelsPerMeter = this.read(this.buffer, 38, 4);
      var bV5YPelsPerMeter = this.read(this.buffer, 42, 4);
      var bV5ClrUsed = this.read(this.buffer, 46, 4);
      var bV5ClrImportant = this.read(this.buffer, 50, 4);
      var bV5RedMask = this.read(this.buffer, 54, 4);
      var bV5GreenMask = this.read(this.buffer, 58, 4);
      var bV5BlueMask = this.read(this.buffer, 62, 4);
      var bV5AlphaMask = this.read(this.buffer, 66, 4);
      var bV5CSType = this.read(this.buffer, 70, 4);
      var bV5Endpoints = this.read(this.buffer, 106, 36);
      var bV5GammaRed = this.read(this.buffer, 110, 4);
      var bV5GammaGreen = this.read(this.buffer, 114, 4);
      var bV5GammaBlue = this.read(this.buffer, 118, 4);
      var bV5Intent = this.read(this.buffer, 122, 4);
      var bV5ProfileData = this.read(this.buffer, 126, 4);
      var bV5ProfileSize = this.read(this.buffer, 130, 4);
      var bV5Reserved = this.read(this.buffer, 134, 4);
      this.coreHeader = {
        __compression__: bV5Compression.readUInt16LE(0),
        __bitCount__: bV5BitCount.readUInt8(0),
        __width__: bV5Width.readUInt16LE(0),
        __height__: bV5Height.readUInt16LE(0),
        bV5Width: bV5Width.readUInt16LE(0),
        _bV5Width: bV5Width,
        bV5Height: bV5Height.readUInt16LE(0),
        _bV5Height: bV5Height,
        bV5Planes: bV5Planes.readUInt8(0),
        _bV5Planes: bV5Planes,
        bV5BitCount: bV5BitCount.readUInt8(0),
        _bV5BitCount: bV5BitCount,
        bV5Compression: bV5Compression.readUInt16LE(0),
        _bV5Compression: bV5Compression,
        bV5SizeImage: bV5SizeImage.readUInt16LE(0),
        _bV5SizeImage: bV5SizeImage,
        bV5XPelsPerMeter: bV5XPelsPerMeter.readUInt16LE(0),
        _bV5XPelsPerMeter: bV5XPelsPerMeter,
        bV5YPelsPerMeter: bV5YPelsPerMeter.readUInt16LE(0),
        _bV5YPelsPerMeter: bV5YPelsPerMeter,
        bV5ClrUsed: bV5ClrUsed.readUInt16LE(0),
        _bV5ClrUsed: bV5ClrUsed,
        bV5ClrImportant: bV5ClrImportant.readUInt16LE(0),
        _bV5ClrImportant: bV5ClrImportant,
        bV5RedMask: bV5RedMask.readUInt16LE(0),
        _bV5RedMask: bV5RedMask,
        bV5GreenMask: bV5GreenMask.readUInt16LE(0),
        _bV5GreenMask: bV5GreenMask,
        bV5BlueMask: bV5BlueMask.readUInt16LE(0),
        _bV5BlueMask: bV5BlueMask,
        bV5AlphaMask: bV5AlphaMask.readUInt16LE(0),
        _bV5AlphaMask: bV5AlphaMask,
        bV5CSType: bV5CSType.readUInt16LE(0),
        _bV5CSType: bV5CSType,
        bV5Endpoints: null,
        _bV5Endpoints: bV5Endpoints,
        bV5GammaRed: bV5GammaRed.readUInt16LE(0),
        _bV5GammaRed: bV5GammaRed,
        bV5GammaGreen: bV5GammaGreen.readUInt16LE(0),
        _bV5GammaGreen: bV5GammaGreen,
        bV5GammaBlue: bV5GammaBlue.readUInt16LE(0),
        _bV5GammaBlue: bV5GammaBlue,
        bV5Intent: bV5Intent.readUInt16LE(0),
        _bV5Intent: bV5Intent,
        bV5ProfileData: bV5ProfileData.readUInt16LE(0),
        _bV5ProfileData: bV5ProfileData,
        bV5ProfileSize: bV5ProfileSize.readUInt16LE(0),
        _bV5ProfileSize: bV5ProfileSize,
        bV5Reserved: 0,
        _bV5Reserved: bV5Reserved
      };
    };
    Bitmap.prototype.readCoreHeaderOS2_V1 = function() {
      throw new Error("not yet impl");
      var bcWidth = this.read(this.buffer, 18, 2);
      var bcHeight = this.read(this.buffer, 20, 2);
      var bcPlanes = this.read(this.buffer, 22, 2);
      var bcBitCount = this.read(this.buffer, 24, 2);
      this.coreHeader = {
        __compression__: 0,
        __bitCount__: bcBitCount.readUInt8(0),
        __width__: bcWidth.readUInt8(0),
        __height__: bcHeight.readUInt8(0),
        bcWidth: bcWidth.readUInt8(0),
        _bcWidth: bcWidth,
        bcHeight: bcHeight.readUInt8(0),
        _bcHeight: bcHeight,
        bcPlanes: bcPlanes.readUInt8(0),
        _bcPlanes: bcPlanes,
        bcBitCount: bcBitCount.readUInt8(0),
        _bcBitCount: bcBitCount
      };
    };
    Bitmap.prototype.readCoreHeaderOS2_V2 = function() {
      throw new Error("not yet impl");
      var cx = this.read(this.buffer, 18, 4);
      var cy = this.read(this.buffer, 22, 4);
      var cPlanes = this.read(this.buffer, 26, 2);
      var cBitCount = this.read(this.buffer, 28, 2);
      var ulCompression = this.read(this.buffer, 30, 4);
      var cbImage = this.read(this.buffer, 34, 4);
      var cxResolution = this.read(this.buffer, 38, 4);
      var cyResolution = this.read(this.buffer, 42, 4);
      var cclrUsed = this.read(this.buffer, 46, 4);
      var cclrImportant = this.read(this.buffer, 50, 4);
      var usUnits = this.read(this.buffer, 54, 2);
      var usReserved = this.read(this.buffer, 56, 2);
      var usRecording = this.read(this.buffer, 58, 2);
      var usRendering = this.read(this.buffer, 60, 2);
      var cSize1 = this.read(this.buffer, 62, 4);
      var cSize2 = this.read(this.buffer, 66, 4);
      var ulColorEncoding = this.read(this.buffer, 70, 4);
      var ulIdentifier = this.read(this.buffer, 74, 4);
      this.coreHeader = {
        __compression__: ulCompression.readUInt16LE(0),
        __bitCount__: cBitCount.readUInt8(0),
        __width__: cx.readUInt16LE(0),
        __height__: cy.readUInt16LE(0),
        cx: cx.readUInt16LE(0),
        _cx: cx,
        cy: cy.readUInt16LE(0),
        _cy: cy,
        cPlanes: cPlanes.readUInt8(0),
        _cPlanes: cPlanes,
        cBitCount: cBitCount.readUInt8(0),
        _cBitCount: cBitCount,
        ulCompression: ulCompression.readUInt16LE(0),
        _ulCompression: ulCompression,
        cbImage: cbImage.readUInt16LE(0),
        _cbImage: cbImage,
        cxResolution: cxResolution.readUInt16LE(0),
        _cxResolution: cxResolution,
        cyResolution: cyResolution.readUInt16LE(0),
        _cyResolution: cyResolution,
        cclrUsed: cclrUsed.readUInt16LE(0),
        _cclrUsed: cclrUsed,
        cclrImportant: cclrImportant.readUInt16LE(0),
        _cclrImportant: cclrImportant,
        usUnits: usUnits.readUInt8(0),
        _usUnits: usUnits,
        usReserved: usReserved.readUInt8(0),
        _usReserved: usReserved,
        usRecording: usRecording.readUInt8(0),
        _usRecording: usRecording,
        usRendering: usRendering.readUInt8(0),
        _usRendering: usRendering,
        cSize1: cSize1.readUInt16LE(0),
        _cSize1: cSize1,
        cSize2: cSize2.readUInt16LE(0),
        _cSize1: cSize1,
        ulColorEncoding: ulColorEncoding.readUInt16LE(0),
        _ulColorEncoding: ulColorEncoding,
        ulIdentifier: ulIdentifier.readUInt16LE(0),
        _ulIdentifier: ulIdentifier
      };
    };
    Bitmap.prototype.readColorPalette = function() {
      var bitCount = this.coreHeader.__bitCount__;
      if (this.BITCOUNT_16bit == bitCount) {
        return;
      }
      if (this.BITCOUNT_24bit == bitCount) {
        return;
      }
      if (this.BITCOUNT_32bit == bitCount) {
        return;
      }
      var coreType = this.infoHeader.readUInt16LE(0);
      switch (coreType) {
        case this.BITMAPCOREHEADER:
          return this.readColorPalette_RGBTRIPLE(bitCount, 26);
        case this.BITMAPINFOHEADER2:
          return this.readColorPalette_RGBTRIPLE(bitCount, 78);
        case this.BITMAPV4HEADER:
          return this.readColorPalette_RGBQUAD(bitCount, 122);
        case this.BITMAPV5HEADER:
          return this.readColorPalette_RGBQUAD(bitCount, 138);
        case this.BITMAPINFOHEADER:
          return this.readColorPalette_RGBQUAD(bitCount, 54);
        default:
          throw new Error("unknown colorPalette: " + coreType + "," + bitCount);
      }
    };
    Bitmap.prototype.readColorPalette_RGBTRIPLE = function(bitCount, startPos) {
      throw new Error("not yet impl");
    };
    Bitmap.prototype.readColorPalette_RGBQUAD = function(bitCount, startPos) {
      if (this.BITCOUNT_2 == bitCount) {
        return this.readRGBQUAD(1 << this.BITCOUNT_2, startPos);
      }
      if (this.BITCOUNT_16 == bitCount) {
        return this.readRGBQUAD(1 << this.BITCOUNT_16, startPos);
      }
      if (this.BITCOUNT_256 == bitCount) {
        return this.readRGBQUAD(1 << this.BITCOUNT_256, startPos);
      }
      throw new Error("unknown bitCount: " + bitCount);
    };
    Bitmap.prototype.readRGBQUAD = function(count, startPos) {
      var palette = [];
      for (var i = startPos, len = startPos + 4 * count; i < len; i += 4) {
        palette.push({
          rgbBlue: this.read(this.buffer, i, 1).readUInt8(0),
          rgbGreen: this.read(this.buffer, i + 1, 1).readUInt8(0),
          rgbRed: this.read(this.buffer, i + 2, 1).readUInt8(0),
          rgbReserved: this.read(this.buffer, i + 3, 1).readUInt8(0)
        });
      }
      this.colorPalette = palette;
    };
    Bitmap.prototype.initDataPos = function() {
      var bitCount = this.coreHeader.__bitCount__;
      var hasPalette = true;
      if (this.BITCOUNT_16bit == bitCount) {
        hasPalette = true;
      }
      if (this.BITCOUNT_24bit == bitCount) {
        hasPalette = true;
      }
      if (this.BITCOUNT_32bit == bitCount) {
        hasPalette = true;
      }
      var coreType = this.infoHeader.readUInt16LE(0);
      switch (coreType) {
        case this.BITMAPCOREHEADER:
          this.dataPos = 26;
          if (hasPalette) {
            this.dataPos = this.dataPos + 3 * (1 << bitCount);
          }
          break;
        case this.BITMAPINFOHEADER2:
          this.dataPos = 78;
          if (hasPalette) {
            this.dataPos = this.dataPos + 3 * (1 << bitCount);
          }
          break;
        case this.BITMAPV4HEADER:
          this.dataPos = 122;
          if (hasPalette) {
            this.dataPos = this.dataPos + 4 * (1 << bitCount);
          }
          break;
        case this.BITMAPV5HEADER:
          this.dataPos = 138;
          if (hasPalette) {
            this.dataPos = this.dataPos + 4 * (1 << bitCount);
          }
        case this.BITMAPINFOHEADER:
          this.dataPos = 54;
          if (hasPalette) {
            this.dataPos = this.dataPos + 4 * (1 << bitCount);
          }
          break;
        default:
          throw new Error("unknown colorPalette: " + coreType + "," + bitCount);
      }
    };
    Bitmap.prototype.mapRGBA = function(r, g, b, a) {
      var hex = [];
      var padHex = function(value) {
        var h = value.toString(16);
        if (value < 15) {
          return "0" + h;
        }
        return h;
      };
      hex.push(padHex(r));
      hex.push(padHex(g));
      hex.push(padHex(b));
      return "#" + hex.join("");
    };
    Bitmap.prototype.mapColor = function(bmpBuf, bitCount) {
      var b, g, r, a;
      var length = bmpBuf.length;
      var colorData = [];
      if (this.BITCOUNT_2 == bitCount) {
        for (var i = 0; i < length; ++i) {
          var paletteValue = bmpBuf[i];
          var bin = paletteValue.toString(2);
          bin = new Array(8 - bin.length).join("0") + bin;
          for (var j = 0; j < bin.length; ++j) {
            var paletteIndex = parseInt(bin.substring(j, j + 1), 10);
            var palette = this.colorPalette[paletteIndex];
            colorData.push(this.mapRGBA(palette.rgbRed, palette.rgbGreen, palette.rgbBlue, -1));
          }
        }
        return colorData;
      }
      if (this.BITCOUNT_16 == bitCount) {
        for (var i = 0; i < length; i += 2) {
          var paletteHigh = bmpBuf.readUInt8(i);
          var paletteLow = bmpBuf.readUInt8(i + 1);
          var indexes = [paletteHigh, paletteLow];
          indexes.forEach(function(paletteIndex2) {
            var palette2 = this.colorPalette[paletteIndex2];
            colorData.push(this.mapRGBA(palette2.rgbRed, palette2.rgbGreen, palette2.rgbBlue, -1));
          });
        }
        return colorData;
      }
      if (this.BITCOUNT_256 == bitCount) {
        for (var i = 0; i < length; ++i) {
          var paletteIndex = bmpBuf.readUInt16LE(i);
          var palette = this.colorPalette[paletteIndex];
          colorData.push(this.mapRGBA(palette.rgbRed, palette.rgbGreen, palette.rgbBlue, -1));
        }
        return colorData;
      }
      if (this.BITCOUNT_16bit == bitCount) {
        for (var i = 0; i < length; i += 3) {
          b = bmpBuf[i];
          g = bmpBuf[i + 1];
          r = bmpBuf[i + 2];
          colorData.push(this.mapRGBA(r, g, b, -1));
        }
        return colorData;
      }
      if (this.BITCOUNT_24bit == bitCount) {
        for (var i = 0; i < length; i += 3) {
          b = bmpBuf[i];
          g = bmpBuf[i + 1];
          r = bmpBuf[i + 2];
          colorData.push(this.mapRGBA(r, g, b, -1));
        }
        return colorData;
      }
      if (this.BITCOUNT_32bit == bitCount) {
        for (var i = 0; i < length; i += 4) {
          b = bmpBuf[i];
          g = bmpBuf[i + 1];
          r = bmpBuf[i + 2];
          a = bmpBuf[i + 3];
          colorData.push(this.mapRGBA(r, g, b, a));
        }
        return colorData;
      }
      throw new Error("unknown bitCount: " + bitCount);
    };
  }
});

// ../../node_modules/node-bitmap/index.js
var require_node_bitmap = __commonJS({
  "../../node_modules/node-bitmap/index.js"(exports2, module2) {
    module2.exports = require_bitmap();
  }
});

// ../../node_modules/extend/index.js
var require_extend = __commonJS({
  "../../node_modules/extend/index.js"(exports2, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module2.exports = function extend() {
      var options, name, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// ../../node_modules/psl/data/rules.json
var require_rules = __commonJS({
  "../../node_modules/psl/data/rules.json"(exports2, module2) {
    module2.exports = [
      "ac",
      "com.ac",
      "edu.ac",
      "gov.ac",
      "net.ac",
      "mil.ac",
      "org.ac",
      "ad",
      "nom.ad",
      "ae",
      "co.ae",
      "net.ae",
      "org.ae",
      "sch.ae",
      "ac.ae",
      "gov.ae",
      "mil.ae",
      "aero",
      "accident-investigation.aero",
      "accident-prevention.aero",
      "aerobatic.aero",
      "aeroclub.aero",
      "aerodrome.aero",
      "agents.aero",
      "aircraft.aero",
      "airline.aero",
      "airport.aero",
      "air-surveillance.aero",
      "airtraffic.aero",
      "air-traffic-control.aero",
      "ambulance.aero",
      "amusement.aero",
      "association.aero",
      "author.aero",
      "ballooning.aero",
      "broker.aero",
      "caa.aero",
      "cargo.aero",
      "catering.aero",
      "certification.aero",
      "championship.aero",
      "charter.aero",
      "civilaviation.aero",
      "club.aero",
      "conference.aero",
      "consultant.aero",
      "consulting.aero",
      "control.aero",
      "council.aero",
      "crew.aero",
      "design.aero",
      "dgca.aero",
      "educator.aero",
      "emergency.aero",
      "engine.aero",
      "engineer.aero",
      "entertainment.aero",
      "equipment.aero",
      "exchange.aero",
      "express.aero",
      "federation.aero",
      "flight.aero",
      "freight.aero",
      "fuel.aero",
      "gliding.aero",
      "government.aero",
      "groundhandling.aero",
      "group.aero",
      "hanggliding.aero",
      "homebuilt.aero",
      "insurance.aero",
      "journal.aero",
      "journalist.aero",
      "leasing.aero",
      "logistics.aero",
      "magazine.aero",
      "maintenance.aero",
      "media.aero",
      "microlight.aero",
      "modelling.aero",
      "navigation.aero",
      "parachuting.aero",
      "paragliding.aero",
      "passenger-association.aero",
      "pilot.aero",
      "press.aero",
      "production.aero",
      "recreation.aero",
      "repbody.aero",
      "res.aero",
      "research.aero",
      "rotorcraft.aero",
      "safety.aero",
      "scientist.aero",
      "services.aero",
      "show.aero",
      "skydiving.aero",
      "software.aero",
      "student.aero",
      "trader.aero",
      "trading.aero",
      "trainer.aero",
      "union.aero",
      "workinggroup.aero",
      "works.aero",
      "af",
      "gov.af",
      "com.af",
      "org.af",
      "net.af",
      "edu.af",
      "ag",
      "com.ag",
      "org.ag",
      "net.ag",
      "co.ag",
      "nom.ag",
      "ai",
      "off.ai",
      "com.ai",
      "net.ai",
      "org.ai",
      "al",
      "com.al",
      "edu.al",
      "gov.al",
      "mil.al",
      "net.al",
      "org.al",
      "am",
      "co.am",
      "com.am",
      "commune.am",
      "net.am",
      "org.am",
      "ao",
      "ed.ao",
      "gv.ao",
      "og.ao",
      "co.ao",
      "pb.ao",
      "it.ao",
      "aq",
      "ar",
      "com.ar",
      "edu.ar",
      "gob.ar",
      "gov.ar",
      "int.ar",
      "mil.ar",
      "musica.ar",
      "net.ar",
      "org.ar",
      "tur.ar",
      "arpa",
      "e164.arpa",
      "in-addr.arpa",
      "ip6.arpa",
      "iris.arpa",
      "uri.arpa",
      "urn.arpa",
      "as",
      "gov.as",
      "asia",
      "at",
      "ac.at",
      "co.at",
      "gv.at",
      "or.at",
      "au",
      "com.au",
      "net.au",
      "org.au",
      "edu.au",
      "gov.au",
      "asn.au",
      "id.au",
      "info.au",
      "conf.au",
      "oz.au",
      "act.au",
      "nsw.au",
      "nt.au",
      "qld.au",
      "sa.au",
      "tas.au",
      "vic.au",
      "wa.au",
      "act.edu.au",
      "catholic.edu.au",
      "nsw.edu.au",
      "nt.edu.au",
      "qld.edu.au",
      "sa.edu.au",
      "tas.edu.au",
      "vic.edu.au",
      "wa.edu.au",
      "qld.gov.au",
      "sa.gov.au",
      "tas.gov.au",
      "vic.gov.au",
      "wa.gov.au",
      "education.tas.edu.au",
      "schools.nsw.edu.au",
      "aw",
      "com.aw",
      "ax",
      "az",
      "com.az",
      "net.az",
      "int.az",
      "gov.az",
      "org.az",
      "edu.az",
      "info.az",
      "pp.az",
      "mil.az",
      "name.az",
      "pro.az",
      "biz.az",
      "ba",
      "com.ba",
      "edu.ba",
      "gov.ba",
      "mil.ba",
      "net.ba",
      "org.ba",
      "bb",
      "biz.bb",
      "co.bb",
      "com.bb",
      "edu.bb",
      "gov.bb",
      "info.bb",
      "net.bb",
      "org.bb",
      "store.bb",
      "tv.bb",
      "*.bd",
      "be",
      "ac.be",
      "bf",
      "gov.bf",
      "bg",
      "a.bg",
      "b.bg",
      "c.bg",
      "d.bg",
      "e.bg",
      "f.bg",
      "g.bg",
      "h.bg",
      "i.bg",
      "j.bg",
      "k.bg",
      "l.bg",
      "m.bg",
      "n.bg",
      "o.bg",
      "p.bg",
      "q.bg",
      "r.bg",
      "s.bg",
      "t.bg",
      "u.bg",
      "v.bg",
      "w.bg",
      "x.bg",
      "y.bg",
      "z.bg",
      "0.bg",
      "1.bg",
      "2.bg",
      "3.bg",
      "4.bg",
      "5.bg",
      "6.bg",
      "7.bg",
      "8.bg",
      "9.bg",
      "bh",
      "com.bh",
      "edu.bh",
      "net.bh",
      "org.bh",
      "gov.bh",
      "bi",
      "co.bi",
      "com.bi",
      "edu.bi",
      "or.bi",
      "org.bi",
      "biz",
      "bj",
      "asso.bj",
      "barreau.bj",
      "gouv.bj",
      "bm",
      "com.bm",
      "edu.bm",
      "gov.bm",
      "net.bm",
      "org.bm",
      "bn",
      "com.bn",
      "edu.bn",
      "gov.bn",
      "net.bn",
      "org.bn",
      "bo",
      "com.bo",
      "edu.bo",
      "gob.bo",
      "int.bo",
      "org.bo",
      "net.bo",
      "mil.bo",
      "tv.bo",
      "web.bo",
      "academia.bo",
      "agro.bo",
      "arte.bo",
      "blog.bo",
      "bolivia.bo",
      "ciencia.bo",
      "cooperativa.bo",
      "democracia.bo",
      "deporte.bo",
      "ecologia.bo",
      "economia.bo",
      "empresa.bo",
      "indigena.bo",
      "industria.bo",
      "info.bo",
      "medicina.bo",
      "movimiento.bo",
      "musica.bo",
      "natural.bo",
      "nombre.bo",
      "noticias.bo",
      "patria.bo",
      "politica.bo",
      "profesional.bo",
      "plurinacional.bo",
      "pueblo.bo",
      "revista.bo",
      "salud.bo",
      "tecnologia.bo",
      "tksat.bo",
      "transporte.bo",
      "wiki.bo",
      "br",
      "9guacu.br",
      "abc.br",
      "adm.br",
      "adv.br",
      "agr.br",
      "aju.br",
      "am.br",
      "anani.br",
      "aparecida.br",
      "arq.br",
      "art.br",
      "ato.br",
      "b.br",
      "barueri.br",
      "belem.br",
      "bhz.br",
      "bio.br",
      "blog.br",
      "bmd.br",
      "boavista.br",
      "bsb.br",
      "campinagrande.br",
      "campinas.br",
      "caxias.br",
      "cim.br",
      "cng.br",
      "cnt.br",
      "com.br",
      "contagem.br",
      "coop.br",
      "cri.br",
      "cuiaba.br",
      "curitiba.br",
      "def.br",
      "ecn.br",
      "eco.br",
      "edu.br",
      "emp.br",
      "eng.br",
      "esp.br",
      "etc.br",
      "eti.br",
      "far.br",
      "feira.br",
      "flog.br",
      "floripa.br",
      "fm.br",
      "fnd.br",
      "fortal.br",
      "fot.br",
      "foz.br",
      "fst.br",
      "g12.br",
      "ggf.br",
      "goiania.br",
      "gov.br",
      "ac.gov.br",
      "al.gov.br",
      "am.gov.br",
      "ap.gov.br",
      "ba.gov.br",
      "ce.gov.br",
      "df.gov.br",
      "es.gov.br",
      "go.gov.br",
      "ma.gov.br",
      "mg.gov.br",
      "ms.gov.br",
      "mt.gov.br",
      "pa.gov.br",
      "pb.gov.br",
      "pe.gov.br",
      "pi.gov.br",
      "pr.gov.br",
      "rj.gov.br",
      "rn.gov.br",
      "ro.gov.br",
      "rr.gov.br",
      "rs.gov.br",
      "sc.gov.br",
      "se.gov.br",
      "sp.gov.br",
      "to.gov.br",
      "gru.br",
      "imb.br",
      "ind.br",
      "inf.br",
      "jab.br",
      "jampa.br",
      "jdf.br",
      "joinville.br",
      "jor.br",
      "jus.br",
      "leg.br",
      "lel.br",
      "londrina.br",
      "macapa.br",
      "maceio.br",
      "manaus.br",
      "maringa.br",
      "mat.br",
      "med.br",
      "mil.br",
      "morena.br",
      "mp.br",
      "mus.br",
      "natal.br",
      "net.br",
      "niteroi.br",
      "*.nom.br",
      "not.br",
      "ntr.br",
      "odo.br",
      "ong.br",
      "org.br",
      "osasco.br",
      "palmas.br",
      "poa.br",
      "ppg.br",
      "pro.br",
      "psc.br",
      "psi.br",
      "pvh.br",
      "qsl.br",
      "radio.br",
      "rec.br",
      "recife.br",
      "ribeirao.br",
      "rio.br",
      "riobranco.br",
      "riopreto.br",
      "salvador.br",
      "sampa.br",
      "santamaria.br",
      "santoandre.br",
      "saobernardo.br",
      "saogonca.br",
      "sjc.br",
      "slg.br",
      "slz.br",
      "sorocaba.br",
      "srv.br",
      "taxi.br",
      "tc.br",
      "teo.br",
      "the.br",
      "tmp.br",
      "trd.br",
      "tur.br",
      "tv.br",
      "udi.br",
      "vet.br",
      "vix.br",
      "vlog.br",
      "wiki.br",
      "zlg.br",
      "bs",
      "com.bs",
      "net.bs",
      "org.bs",
      "edu.bs",
      "gov.bs",
      "bt",
      "com.bt",
      "edu.bt",
      "gov.bt",
      "net.bt",
      "org.bt",
      "bv",
      "bw",
      "co.bw",
      "org.bw",
      "by",
      "gov.by",
      "mil.by",
      "com.by",
      "of.by",
      "bz",
      "com.bz",
      "net.bz",
      "org.bz",
      "edu.bz",
      "gov.bz",
      "ca",
      "ab.ca",
      "bc.ca",
      "mb.ca",
      "nb.ca",
      "nf.ca",
      "nl.ca",
      "ns.ca",
      "nt.ca",
      "nu.ca",
      "on.ca",
      "pe.ca",
      "qc.ca",
      "sk.ca",
      "yk.ca",
      "gc.ca",
      "cat",
      "cc",
      "cd",
      "gov.cd",
      "cf",
      "cg",
      "ch",
      "ci",
      "org.ci",
      "or.ci",
      "com.ci",
      "co.ci",
      "edu.ci",
      "ed.ci",
      "ac.ci",
      "net.ci",
      "go.ci",
      "asso.ci",
      "a\xE9roport.ci",
      "int.ci",
      "presse.ci",
      "md.ci",
      "gouv.ci",
      "*.ck",
      "!www.ck",
      "cl",
      "aprendemas.cl",
      "co.cl",
      "gob.cl",
      "gov.cl",
      "mil.cl",
      "cm",
      "co.cm",
      "com.cm",
      "gov.cm",
      "net.cm",
      "cn",
      "ac.cn",
      "com.cn",
      "edu.cn",
      "gov.cn",
      "net.cn",
      "org.cn",
      "mil.cn",
      "\u516C\u53F8.cn",
      "\u7F51\u7EDC.cn",
      "\u7DB2\u7D61.cn",
      "ah.cn",
      "bj.cn",
      "cq.cn",
      "fj.cn",
      "gd.cn",
      "gs.cn",
      "gz.cn",
      "gx.cn",
      "ha.cn",
      "hb.cn",
      "he.cn",
      "hi.cn",
      "hl.cn",
      "hn.cn",
      "jl.cn",
      "js.cn",
      "jx.cn",
      "ln.cn",
      "nm.cn",
      "nx.cn",
      "qh.cn",
      "sc.cn",
      "sd.cn",
      "sh.cn",
      "sn.cn",
      "sx.cn",
      "tj.cn",
      "xj.cn",
      "xz.cn",
      "yn.cn",
      "zj.cn",
      "hk.cn",
      "mo.cn",
      "tw.cn",
      "co",
      "arts.co",
      "com.co",
      "edu.co",
      "firm.co",
      "gov.co",
      "info.co",
      "int.co",
      "mil.co",
      "net.co",
      "nom.co",
      "org.co",
      "rec.co",
      "web.co",
      "com",
      "coop",
      "cr",
      "ac.cr",
      "co.cr",
      "ed.cr",
      "fi.cr",
      "go.cr",
      "or.cr",
      "sa.cr",
      "cu",
      "com.cu",
      "edu.cu",
      "org.cu",
      "net.cu",
      "gov.cu",
      "inf.cu",
      "cv",
      "cw",
      "com.cw",
      "edu.cw",
      "net.cw",
      "org.cw",
      "cx",
      "gov.cx",
      "cy",
      "ac.cy",
      "biz.cy",
      "com.cy",
      "ekloges.cy",
      "gov.cy",
      "ltd.cy",
      "name.cy",
      "net.cy",
      "org.cy",
      "parliament.cy",
      "press.cy",
      "pro.cy",
      "tm.cy",
      "cz",
      "de",
      "dj",
      "dk",
      "dm",
      "com.dm",
      "net.dm",
      "org.dm",
      "edu.dm",
      "gov.dm",
      "do",
      "art.do",
      "com.do",
      "edu.do",
      "gob.do",
      "gov.do",
      "mil.do",
      "net.do",
      "org.do",
      "sld.do",
      "web.do",
      "dz",
      "com.dz",
      "org.dz",
      "net.dz",
      "gov.dz",
      "edu.dz",
      "asso.dz",
      "pol.dz",
      "art.dz",
      "ec",
      "com.ec",
      "info.ec",
      "net.ec",
      "fin.ec",
      "k12.ec",
      "med.ec",
      "pro.ec",
      "org.ec",
      "edu.ec",
      "gov.ec",
      "gob.ec",
      "mil.ec",
      "edu",
      "ee",
      "edu.ee",
      "gov.ee",
      "riik.ee",
      "lib.ee",
      "med.ee",
      "com.ee",
      "pri.ee",
      "aip.ee",
      "org.ee",
      "fie.ee",
      "eg",
      "com.eg",
      "edu.eg",
      "eun.eg",
      "gov.eg",
      "mil.eg",
      "name.eg",
      "net.eg",
      "org.eg",
      "sci.eg",
      "*.er",
      "es",
      "com.es",
      "nom.es",
      "org.es",
      "gob.es",
      "edu.es",
      "et",
      "com.et",
      "gov.et",
      "org.et",
      "edu.et",
      "biz.et",
      "name.et",
      "info.et",
      "net.et",
      "eu",
      "fi",
      "aland.fi",
      "fj",
      "ac.fj",
      "biz.fj",
      "com.fj",
      "gov.fj",
      "info.fj",
      "mil.fj",
      "name.fj",
      "net.fj",
      "org.fj",
      "pro.fj",
      "*.fk",
      "fm",
      "fo",
      "fr",
      "asso.fr",
      "com.fr",
      "gouv.fr",
      "nom.fr",
      "prd.fr",
      "tm.fr",
      "aeroport.fr",
      "avocat.fr",
      "avoues.fr",
      "cci.fr",
      "chambagri.fr",
      "chirurgiens-dentistes.fr",
      "experts-comptables.fr",
      "geometre-expert.fr",
      "greta.fr",
      "huissier-justice.fr",
      "medecin.fr",
      "notaires.fr",
      "pharmacien.fr",
      "port.fr",
      "veterinaire.fr",
      "ga",
      "gb",
      "gd",
      "ge",
      "com.ge",
      "edu.ge",
      "gov.ge",
      "org.ge",
      "mil.ge",
      "net.ge",
      "pvt.ge",
      "gf",
      "gg",
      "co.gg",
      "net.gg",
      "org.gg",
      "gh",
      "com.gh",
      "edu.gh",
      "gov.gh",
      "org.gh",
      "mil.gh",
      "gi",
      "com.gi",
      "ltd.gi",
      "gov.gi",
      "mod.gi",
      "edu.gi",
      "org.gi",
      "gl",
      "co.gl",
      "com.gl",
      "edu.gl",
      "net.gl",
      "org.gl",
      "gm",
      "gn",
      "ac.gn",
      "com.gn",
      "edu.gn",
      "gov.gn",
      "org.gn",
      "net.gn",
      "gov",
      "gp",
      "com.gp",
      "net.gp",
      "mobi.gp",
      "edu.gp",
      "org.gp",
      "asso.gp",
      "gq",
      "gr",
      "com.gr",
      "edu.gr",
      "net.gr",
      "org.gr",
      "gov.gr",
      "gs",
      "gt",
      "com.gt",
      "edu.gt",
      "gob.gt",
      "ind.gt",
      "mil.gt",
      "net.gt",
      "org.gt",
      "gu",
      "com.gu",
      "edu.gu",
      "gov.gu",
      "guam.gu",
      "info.gu",
      "net.gu",
      "org.gu",
      "web.gu",
      "gw",
      "gy",
      "co.gy",
      "com.gy",
      "edu.gy",
      "gov.gy",
      "net.gy",
      "org.gy",
      "hk",
      "com.hk",
      "edu.hk",
      "gov.hk",
      "idv.hk",
      "net.hk",
      "org.hk",
      "\u516C\u53F8.hk",
      "\u6559\u80B2.hk",
      "\u654E\u80B2.hk",
      "\u653F\u5E9C.hk",
      "\u500B\u4EBA.hk",
      "\u4E2A\u4EBA.hk",
      "\u7B87\u4EBA.hk",
      "\u7DB2\u7EDC.hk",
      "\u7F51\u7EDC.hk",
      "\u7EC4\u7E54.hk",
      "\u7DB2\u7D61.hk",
      "\u7F51\u7D61.hk",
      "\u7EC4\u7EC7.hk",
      "\u7D44\u7E54.hk",
      "\u7D44\u7EC7.hk",
      "hm",
      "hn",
      "com.hn",
      "edu.hn",
      "org.hn",
      "net.hn",
      "mil.hn",
      "gob.hn",
      "hr",
      "iz.hr",
      "from.hr",
      "name.hr",
      "com.hr",
      "ht",
      "com.ht",
      "shop.ht",
      "firm.ht",
      "info.ht",
      "adult.ht",
      "net.ht",
      "pro.ht",
      "org.ht",
      "med.ht",
      "art.ht",
      "coop.ht",
      "pol.ht",
      "asso.ht",
      "edu.ht",
      "rel.ht",
      "gouv.ht",
      "perso.ht",
      "hu",
      "co.hu",
      "info.hu",
      "org.hu",
      "priv.hu",
      "sport.hu",
      "tm.hu",
      "2000.hu",
      "agrar.hu",
      "bolt.hu",
      "casino.hu",
      "city.hu",
      "erotica.hu",
      "erotika.hu",
      "film.hu",
      "forum.hu",
      "games.hu",
      "hotel.hu",
      "ingatlan.hu",
      "jogasz.hu",
      "konyvelo.hu",
      "lakas.hu",
      "media.hu",
      "news.hu",
      "reklam.hu",
      "sex.hu",
      "shop.hu",
      "suli.hu",
      "szex.hu",
      "tozsde.hu",
      "utazas.hu",
      "video.hu",
      "id",
      "ac.id",
      "biz.id",
      "co.id",
      "desa.id",
      "go.id",
      "mil.id",
      "my.id",
      "net.id",
      "or.id",
      "ponpes.id",
      "sch.id",
      "web.id",
      "ie",
      "gov.ie",
      "il",
      "ac.il",
      "co.il",
      "gov.il",
      "idf.il",
      "k12.il",
      "muni.il",
      "net.il",
      "org.il",
      "im",
      "ac.im",
      "co.im",
      "com.im",
      "ltd.co.im",
      "net.im",
      "org.im",
      "plc.co.im",
      "tt.im",
      "tv.im",
      "in",
      "co.in",
      "firm.in",
      "net.in",
      "org.in",
      "gen.in",
      "ind.in",
      "nic.in",
      "ac.in",
      "edu.in",
      "res.in",
      "gov.in",
      "mil.in",
      "info",
      "int",
      "eu.int",
      "io",
      "com.io",
      "iq",
      "gov.iq",
      "edu.iq",
      "mil.iq",
      "com.iq",
      "org.iq",
      "net.iq",
      "ir",
      "ac.ir",
      "co.ir",
      "gov.ir",
      "id.ir",
      "net.ir",
      "org.ir",
      "sch.ir",
      "\u0627\u06CC\u0631\u0627\u0646.ir",
      "\u0627\u064A\u0631\u0627\u0646.ir",
      "is",
      "net.is",
      "com.is",
      "edu.is",
      "gov.is",
      "org.is",
      "int.is",
      "it",
      "gov.it",
      "edu.it",
      "abr.it",
      "abruzzo.it",
      "aosta-valley.it",
      "aostavalley.it",
      "bas.it",
      "basilicata.it",
      "cal.it",
      "calabria.it",
      "cam.it",
      "campania.it",
      "emilia-romagna.it",
      "emiliaromagna.it",
      "emr.it",
      "friuli-v-giulia.it",
      "friuli-ve-giulia.it",
      "friuli-vegiulia.it",
      "friuli-venezia-giulia.it",
      "friuli-veneziagiulia.it",
      "friuli-vgiulia.it",
      "friuliv-giulia.it",
      "friulive-giulia.it",
      "friulivegiulia.it",
      "friulivenezia-giulia.it",
      "friuliveneziagiulia.it",
      "friulivgiulia.it",
      "fvg.it",
      "laz.it",
      "lazio.it",
      "lig.it",
      "liguria.it",
      "lom.it",
      "lombardia.it",
      "lombardy.it",
      "lucania.it",
      "mar.it",
      "marche.it",
      "mol.it",
      "molise.it",
      "piedmont.it",
      "piemonte.it",
      "pmn.it",
      "pug.it",
      "puglia.it",
      "sar.it",
      "sardegna.it",
      "sardinia.it",
      "sic.it",
      "sicilia.it",
      "sicily.it",
      "taa.it",
      "tos.it",
      "toscana.it",
      "trentin-sud-tirol.it",
      "trentin-s\xFCd-tirol.it",
      "trentin-sudtirol.it",
      "trentin-s\xFCdtirol.it",
      "trentin-sued-tirol.it",
      "trentin-suedtirol.it",
      "trentino-a-adige.it",
      "trentino-aadige.it",
      "trentino-alto-adige.it",
      "trentino-altoadige.it",
      "trentino-s-tirol.it",
      "trentino-stirol.it",
      "trentino-sud-tirol.it",
      "trentino-s\xFCd-tirol.it",
      "trentino-sudtirol.it",
      "trentino-s\xFCdtirol.it",
      "trentino-sued-tirol.it",
      "trentino-suedtirol.it",
      "trentino.it",
      "trentinoa-adige.it",
      "trentinoaadige.it",
      "trentinoalto-adige.it",
      "trentinoaltoadige.it",
      "trentinos-tirol.it",
      "trentinostirol.it",
      "trentinosud-tirol.it",
      "trentinos\xFCd-tirol.it",
      "trentinosudtirol.it",
      "trentinos\xFCdtirol.it",
      "trentinosued-tirol.it",
      "trentinosuedtirol.it",
      "trentinsud-tirol.it",
      "trentins\xFCd-tirol.it",
      "trentinsudtirol.it",
      "trentins\xFCdtirol.it",
      "trentinsued-tirol.it",
      "trentinsuedtirol.it",
      "tuscany.it",
      "umb.it",
      "umbria.it",
      "val-d-aosta.it",
      "val-daosta.it",
      "vald-aosta.it",
      "valdaosta.it",
      "valle-aosta.it",
      "valle-d-aosta.it",
      "valle-daosta.it",
      "valleaosta.it",
      "valled-aosta.it",
      "valledaosta.it",
      "vallee-aoste.it",
      "vall\xE9e-aoste.it",
      "vallee-d-aoste.it",
      "vall\xE9e-d-aoste.it",
      "valleeaoste.it",
      "vall\xE9eaoste.it",
      "valleedaoste.it",
      "vall\xE9edaoste.it",
      "vao.it",
      "vda.it",
      "ven.it",
      "veneto.it",
      "ag.it",
      "agrigento.it",
      "al.it",
      "alessandria.it",
      "alto-adige.it",
      "altoadige.it",
      "an.it",
      "ancona.it",
      "andria-barletta-trani.it",
      "andria-trani-barletta.it",
      "andriabarlettatrani.it",
      "andriatranibarletta.it",
      "ao.it",
      "aosta.it",
      "aoste.it",
      "ap.it",
      "aq.it",
      "aquila.it",
      "ar.it",
      "arezzo.it",
      "ascoli-piceno.it",
      "ascolipiceno.it",
      "asti.it",
      "at.it",
      "av.it",
      "avellino.it",
      "ba.it",
      "balsan-sudtirol.it",
      "balsan-s\xFCdtirol.it",
      "balsan-suedtirol.it",
      "balsan.it",
      "bari.it",
      "barletta-trani-andria.it",
      "barlettatraniandria.it",
      "belluno.it",
      "benevento.it",
      "bergamo.it",
      "bg.it",
      "bi.it",
      "biella.it",
      "bl.it",
      "bn.it",
      "bo.it",
      "bologna.it",
      "bolzano-altoadige.it",
      "bolzano.it",
      "bozen-sudtirol.it",
      "bozen-s\xFCdtirol.it",
      "bozen-suedtirol.it",
      "bozen.it",
      "br.it",
      "brescia.it",
      "brindisi.it",
      "bs.it",
      "bt.it",
      "bulsan-sudtirol.it",
      "bulsan-s\xFCdtirol.it",
      "bulsan-suedtirol.it",
      "bulsan.it",
      "bz.it",
      "ca.it",
      "cagliari.it",
      "caltanissetta.it",
      "campidano-medio.it",
      "campidanomedio.it",
      "campobasso.it",
      "carbonia-iglesias.it",
      "carboniaiglesias.it",
      "carrara-massa.it",
      "carraramassa.it",
      "caserta.it",
      "catania.it",
      "catanzaro.it",
      "cb.it",
      "ce.it",
      "cesena-forli.it",
      "cesena-forl\xEC.it",
      "cesenaforli.it",
      "cesenaforl\xEC.it",
      "ch.it",
      "chieti.it",
      "ci.it",
      "cl.it",
      "cn.it",
      "co.it",
      "como.it",
      "cosenza.it",
      "cr.it",
      "cremona.it",
      "crotone.it",
      "cs.it",
      "ct.it",
      "cuneo.it",
      "cz.it",
      "dell-ogliastra.it",
      "dellogliastra.it",
      "en.it",
      "enna.it",
      "fc.it",
      "fe.it",
      "fermo.it",
      "ferrara.it",
      "fg.it",
      "fi.it",
      "firenze.it",
      "florence.it",
      "fm.it",
      "foggia.it",
      "forli-cesena.it",
      "forl\xEC-cesena.it",
      "forlicesena.it",
      "forl\xECcesena.it",
      "fr.it",
      "frosinone.it",
      "ge.it",
      "genoa.it",
      "genova.it",
      "go.it",
      "gorizia.it",
      "gr.it",
      "grosseto.it",
      "iglesias-carbonia.it",
      "iglesiascarbonia.it",
      "im.it",
      "imperia.it",
      "is.it",
      "isernia.it",
      "kr.it",
      "la-spezia.it",
      "laquila.it",
      "laspezia.it",
      "latina.it",
      "lc.it",
      "le.it",
      "lecce.it",
      "lecco.it",
      "li.it",
      "livorno.it",
      "lo.it",
      "lodi.it",
      "lt.it",
      "lu.it",
      "lucca.it",
      "macerata.it",
      "mantova.it",
      "massa-carrara.it",
      "massacarrara.it",
      "matera.it",
      "mb.it",
      "mc.it",
      "me.it",
      "medio-campidano.it",
      "mediocampidano.it",
      "messina.it",
      "mi.it",
      "milan.it",
      "milano.it",
      "mn.it",
      "mo.it",
      "modena.it",
      "monza-brianza.it",
      "monza-e-della-brianza.it",
      "monza.it",
      "monzabrianza.it",
      "monzaebrianza.it",
      "monzaedellabrianza.it",
      "ms.it",
      "mt.it",
      "na.it",
      "naples.it",
      "napoli.it",
      "no.it",
      "novara.it",
      "nu.it",
      "nuoro.it",
      "og.it",
      "ogliastra.it",
      "olbia-tempio.it",
      "olbiatempio.it",
      "or.it",
      "oristano.it",
      "ot.it",
      "pa.it",
      "padova.it",
      "padua.it",
      "palermo.it",
      "parma.it",
      "pavia.it",
      "pc.it",
      "pd.it",
      "pe.it",
      "perugia.it",
      "pesaro-urbino.it",
      "pesarourbino.it",
      "pescara.it",
      "pg.it",
      "pi.it",
      "piacenza.it",
      "pisa.it",
      "pistoia.it",
      "pn.it",
      "po.it",
      "pordenone.it",
      "potenza.it",
      "pr.it",
      "prato.it",
      "pt.it",
      "pu.it",
      "pv.it",
      "pz.it",
      "ra.it",
      "ragusa.it",
      "ravenna.it",
      "rc.it",
      "re.it",
      "reggio-calabria.it",
      "reggio-emilia.it",
      "reggiocalabria.it",
      "reggioemilia.it",
      "rg.it",
      "ri.it",
      "rieti.it",
      "rimini.it",
      "rm.it",
      "rn.it",
      "ro.it",
      "roma.it",
      "rome.it",
      "rovigo.it",
      "sa.it",
      "salerno.it",
      "sassari.it",
      "savona.it",
      "si.it",
      "siena.it",
      "siracusa.it",
      "so.it",
      "sondrio.it",
      "sp.it",
      "sr.it",
      "ss.it",
      "suedtirol.it",
      "s\xFCdtirol.it",
      "sv.it",
      "ta.it",
      "taranto.it",
      "te.it",
      "tempio-olbia.it",
      "tempioolbia.it",
      "teramo.it",
      "terni.it",
      "tn.it",
      "to.it",
      "torino.it",
      "tp.it",
      "tr.it",
      "trani-andria-barletta.it",
      "trani-barletta-andria.it",
      "traniandriabarletta.it",
      "tranibarlettaandria.it",
      "trapani.it",
      "trento.it",
      "treviso.it",
      "trieste.it",
      "ts.it",
      "turin.it",
      "tv.it",
      "ud.it",
      "udine.it",
      "urbino-pesaro.it",
      "urbinopesaro.it",
      "va.it",
      "varese.it",
      "vb.it",
      "vc.it",
      "ve.it",
      "venezia.it",
      "venice.it",
      "verbania.it",
      "vercelli.it",
      "verona.it",
      "vi.it",
      "vibo-valentia.it",
      "vibovalentia.it",
      "vicenza.it",
      "viterbo.it",
      "vr.it",
      "vs.it",
      "vt.it",
      "vv.it",
      "je",
      "co.je",
      "net.je",
      "org.je",
      "*.jm",
      "jo",
      "com.jo",
      "org.jo",
      "net.jo",
      "edu.jo",
      "sch.jo",
      "gov.jo",
      "mil.jo",
      "name.jo",
      "jobs",
      "jp",
      "ac.jp",
      "ad.jp",
      "co.jp",
      "ed.jp",
      "go.jp",
      "gr.jp",
      "lg.jp",
      "ne.jp",
      "or.jp",
      "aichi.jp",
      "akita.jp",
      "aomori.jp",
      "chiba.jp",
      "ehime.jp",
      "fukui.jp",
      "fukuoka.jp",
      "fukushima.jp",
      "gifu.jp",
      "gunma.jp",
      "hiroshima.jp",
      "hokkaido.jp",
      "hyogo.jp",
      "ibaraki.jp",
      "ishikawa.jp",
      "iwate.jp",
      "kagawa.jp",
      "kagoshima.jp",
      "kanagawa.jp",
      "kochi.jp",
      "kumamoto.jp",
      "kyoto.jp",
      "mie.jp",
      "miyagi.jp",
      "miyazaki.jp",
      "nagano.jp",
      "nagasaki.jp",
      "nara.jp",
      "niigata.jp",
      "oita.jp",
      "okayama.jp",
      "okinawa.jp",
      "osaka.jp",
      "saga.jp",
      "saitama.jp",
      "shiga.jp",
      "shimane.jp",
      "shizuoka.jp",
      "tochigi.jp",
      "tokushima.jp",
      "tokyo.jp",
      "tottori.jp",
      "toyama.jp",
      "wakayama.jp",
      "yamagata.jp",
      "yamaguchi.jp",
      "yamanashi.jp",
      "\u6803\u6728.jp",
      "\u611B\u77E5.jp",
      "\u611B\u5A9B.jp",
      "\u5175\u5EAB.jp",
      "\u718A\u672C.jp",
      "\u8328\u57CE.jp",
      "\u5317\u6D77\u9053.jp",
      "\u5343\u8449.jp",
      "\u548C\u6B4C\u5C71.jp",
      "\u9577\u5D0E.jp",
      "\u9577\u91CE.jp",
      "\u65B0\u6F5F.jp",
      "\u9752\u68EE.jp",
      "\u9759\u5CA1.jp",
      "\u6771\u4EAC.jp",
      "\u77F3\u5DDD.jp",
      "\u57FC\u7389.jp",
      "\u4E09\u91CD.jp",
      "\u4EAC\u90FD.jp",
      "\u4F50\u8CC0.jp",
      "\u5927\u5206.jp",
      "\u5927\u962A.jp",
      "\u5948\u826F.jp",
      "\u5BAE\u57CE.jp",
      "\u5BAE\u5D0E.jp",
      "\u5BCC\u5C71.jp",
      "\u5C71\u53E3.jp",
      "\u5C71\u5F62.jp",
      "\u5C71\u68A8.jp",
      "\u5CA9\u624B.jp",
      "\u5C90\u961C.jp",
      "\u5CA1\u5C71.jp",
      "\u5CF6\u6839.jp",
      "\u5E83\u5CF6.jp",
      "\u5FB3\u5CF6.jp",
      "\u6C96\u7E04.jp",
      "\u6ECB\u8CC0.jp",
      "\u795E\u5948\u5DDD.jp",
      "\u798F\u4E95.jp",
      "\u798F\u5CA1.jp",
      "\u798F\u5CF6.jp",
      "\u79CB\u7530.jp",
      "\u7FA4\u99AC.jp",
      "\u9999\u5DDD.jp",
      "\u9AD8\u77E5.jp",
      "\u9CE5\u53D6.jp",
      "\u9E7F\u5150\u5CF6.jp",
      "*.kawasaki.jp",
      "*.kitakyushu.jp",
      "*.kobe.jp",
      "*.nagoya.jp",
      "*.sapporo.jp",
      "*.sendai.jp",
      "*.yokohama.jp",
      "!city.kawasaki.jp",
      "!city.kitakyushu.jp",
      "!city.kobe.jp",
      "!city.nagoya.jp",
      "!city.sapporo.jp",
      "!city.sendai.jp",
      "!city.yokohama.jp",
      "aisai.aichi.jp",
      "ama.aichi.jp",
      "anjo.aichi.jp",
      "asuke.aichi.jp",
      "chiryu.aichi.jp",
      "chita.aichi.jp",
      "fuso.aichi.jp",
      "gamagori.aichi.jp",
      "handa.aichi.jp",
      "hazu.aichi.jp",
      "hekinan.aichi.jp",
      "higashiura.aichi.jp",
      "ichinomiya.aichi.jp",
      "inazawa.aichi.jp",
      "inuyama.aichi.jp",
      "isshiki.aichi.jp",
      "iwakura.aichi.jp",
      "kanie.aichi.jp",
      "kariya.aichi.jp",
      "kasugai.aichi.jp",
      "kira.aichi.jp",
      "kiyosu.aichi.jp",
      "komaki.aichi.jp",
      "konan.aichi.jp",
      "kota.aichi.jp",
      "mihama.aichi.jp",
      "miyoshi.aichi.jp",
      "nishio.aichi.jp",
      "nisshin.aichi.jp",
      "obu.aichi.jp",
      "oguchi.aichi.jp",
      "oharu.aichi.jp",
      "okazaki.aichi.jp",
      "owariasahi.aichi.jp",
      "seto.aichi.jp",
      "shikatsu.aichi.jp",
      "shinshiro.aichi.jp",
      "shitara.aichi.jp",
      "tahara.aichi.jp",
      "takahama.aichi.jp",
      "tobishima.aichi.jp",
      "toei.aichi.jp",
      "togo.aichi.jp",
      "tokai.aichi.jp",
      "tokoname.aichi.jp",
      "toyoake.aichi.jp",
      "toyohashi.aichi.jp",
      "toyokawa.aichi.jp",
      "toyone.aichi.jp",
      "toyota.aichi.jp",
      "tsushima.aichi.jp",
      "yatomi.aichi.jp",
      "akita.akita.jp",
      "daisen.akita.jp",
      "fujisato.akita.jp",
      "gojome.akita.jp",
      "hachirogata.akita.jp",
      "happou.akita.jp",
      "higashinaruse.akita.jp",
      "honjo.akita.jp",
      "honjyo.akita.jp",
      "ikawa.akita.jp",
      "kamikoani.akita.jp",
      "kamioka.akita.jp",
      "katagami.akita.jp",
      "kazuno.akita.jp",
      "kitaakita.akita.jp",
      "kosaka.akita.jp",
      "kyowa.akita.jp",
      "misato.akita.jp",
      "mitane.akita.jp",
      "moriyoshi.akita.jp",
      "nikaho.akita.jp",
      "noshiro.akita.jp",
      "odate.akita.jp",
      "oga.akita.jp",
      "ogata.akita.jp",
      "semboku.akita.jp",
      "yokote.akita.jp",
      "yurihonjo.akita.jp",
      "aomori.aomori.jp",
      "gonohe.aomori.jp",
      "hachinohe.aomori.jp",
      "hashikami.aomori.jp",
      "hiranai.aomori.jp",
      "hirosaki.aomori.jp",
      "itayanagi.aomori.jp",
      "kuroishi.aomori.jp",
      "misawa.aomori.jp",
      "mutsu.aomori.jp",
      "nakadomari.aomori.jp",
      "noheji.aomori.jp",
      "oirase.aomori.jp",
      "owani.aomori.jp",
      "rokunohe.aomori.jp",
      "sannohe.aomori.jp",
      "shichinohe.aomori.jp",
      "shingo.aomori.jp",
      "takko.aomori.jp",
      "towada.aomori.jp",
      "tsugaru.aomori.jp",
      "tsuruta.aomori.jp",
      "abiko.chiba.jp",
      "asahi.chiba.jp",
      "chonan.chiba.jp",
      "chosei.chiba.jp",
      "choshi.chiba.jp",
      "chuo.chiba.jp",
      "funabashi.chiba.jp",
      "futtsu.chiba.jp",
      "hanamigawa.chiba.jp",
      "ichihara.chiba.jp",
      "ichikawa.chiba.jp",
      "ichinomiya.chiba.jp",
      "inzai.chiba.jp",
      "isumi.chiba.jp",
      "kamagaya.chiba.jp",
      "kamogawa.chiba.jp",
      "kashiwa.chiba.jp",
      "katori.chiba.jp",
      "katsuura.chiba.jp",
      "kimitsu.chiba.jp",
      "kisarazu.chiba.jp",
      "kozaki.chiba.jp",
      "kujukuri.chiba.jp",
      "kyonan.chiba.jp",
      "matsudo.chiba.jp",
      "midori.chiba.jp",
      "mihama.chiba.jp",
      "minamiboso.chiba.jp",
      "mobara.chiba.jp",
      "mutsuzawa.chiba.jp",
      "nagara.chiba.jp",
      "nagareyama.chiba.jp",
      "narashino.chiba.jp",
      "narita.chiba.jp",
      "noda.chiba.jp",
      "oamishirasato.chiba.jp",
      "omigawa.chiba.jp",
      "onjuku.chiba.jp",
      "otaki.chiba.jp",
      "sakae.chiba.jp",
      "sakura.chiba.jp",
      "shimofusa.chiba.jp",
      "shirako.chiba.jp",
      "shiroi.chiba.jp",
      "shisui.chiba.jp",
      "sodegaura.chiba.jp",
      "sosa.chiba.jp",
      "tako.chiba.jp",
      "tateyama.chiba.jp",
      "togane.chiba.jp",
      "tohnosho.chiba.jp",
      "tomisato.chiba.jp",
      "urayasu.chiba.jp",
      "yachimata.chiba.jp",
      "yachiyo.chiba.jp",
      "yokaichiba.chiba.jp",
      "yokoshibahikari.chiba.jp",
      "yotsukaido.chiba.jp",
      "ainan.ehime.jp",
      "honai.ehime.jp",
      "ikata.ehime.jp",
      "imabari.ehime.jp",
      "iyo.ehime.jp",
      "kamijima.ehime.jp",
      "kihoku.ehime.jp",
      "kumakogen.ehime.jp",
      "masaki.ehime.jp",
      "matsuno.ehime.jp",
      "matsuyama.ehime.jp",
      "namikata.ehime.jp",
      "niihama.ehime.jp",
      "ozu.ehime.jp",
      "saijo.ehime.jp",
      "seiyo.ehime.jp",
      "shikokuchuo.ehime.jp",
      "tobe.ehime.jp",
      "toon.ehime.jp",
      "uchiko.ehime.jp",
      "uwajima.ehime.jp",
      "yawatahama.ehime.jp",
      "echizen.fukui.jp",
      "eiheiji.fukui.jp",
      "fukui.fukui.jp",
      "ikeda.fukui.jp",
      "katsuyama.fukui.jp",
      "mihama.fukui.jp",
      "minamiechizen.fukui.jp",
      "obama.fukui.jp",
      "ohi.fukui.jp",
      "ono.fukui.jp",
      "sabae.fukui.jp",
      "sakai.fukui.jp",
      "takahama.fukui.jp",
      "tsuruga.fukui.jp",
      "wakasa.fukui.jp",
      "ashiya.fukuoka.jp",
      "buzen.fukuoka.jp",
      "chikugo.fukuoka.jp",
      "chikuho.fukuoka.jp",
      "chikujo.fukuoka.jp",
      "chikushino.fukuoka.jp",
      "chikuzen.fukuoka.jp",
      "chuo.fukuoka.jp",
      "dazaifu.fukuoka.jp",
      "fukuchi.fukuoka.jp",
      "hakata.fukuoka.jp",
      "higashi.fukuoka.jp",
      "hirokawa.fukuoka.jp",
      "hisayama.fukuoka.jp",
      "iizuka.fukuoka.jp",
      "inatsuki.fukuoka.jp",
      "kaho.fukuoka.jp",
      "kasuga.fukuoka.jp",
      "kasuya.fukuoka.jp",
      "kawara.fukuoka.jp",
      "keisen.fukuoka.jp",
      "koga.fukuoka.jp",
      "kurate.fukuoka.jp",
      "kurogi.fukuoka.jp",
      "kurume.fukuoka.jp",
      "minami.fukuoka.jp",
      "miyako.fukuoka.jp",
      "miyama.fukuoka.jp",
      "miyawaka.fukuoka.jp",
      "mizumaki.fukuoka.jp",
      "munakata.fukuoka.jp",
      "nakagawa.fukuoka.jp",
      "nakama.fukuoka.jp",
      "nishi.fukuoka.jp",
      "nogata.fukuoka.jp",
      "ogori.fukuoka.jp",
      "okagaki.fukuoka.jp",
      "okawa.fukuoka.jp",
      "oki.fukuoka.jp",
      "omuta.fukuoka.jp",
      "onga.fukuoka.jp",
      "onojo.fukuoka.jp",
      "oto.fukuoka.jp",
      "saigawa.fukuoka.jp",
      "sasaguri.fukuoka.jp",
      "shingu.fukuoka.jp",
      "shinyoshitomi.fukuoka.jp",
      "shonai.fukuoka.jp",
      "soeda.fukuoka.jp",
      "sue.fukuoka.jp",
      "tachiarai.fukuoka.jp",
      "tagawa.fukuoka.jp",
      "takata.fukuoka.jp",
      "toho.fukuoka.jp",
      "toyotsu.fukuoka.jp",
      "tsuiki.fukuoka.jp",
      "ukiha.fukuoka.jp",
      "umi.fukuoka.jp",
      "usui.fukuoka.jp",
      "yamada.fukuoka.jp",
      "yame.fukuoka.jp",
      "yanagawa.fukuoka.jp",
      "yukuhashi.fukuoka.jp",
      "aizubange.fukushima.jp",
      "aizumisato.fukushima.jp",
      "aizuwakamatsu.fukushima.jp",
      "asakawa.fukushima.jp",
      "bandai.fukushima.jp",
      "date.fukushima.jp",
      "fukushima.fukushima.jp",
      "furudono.fukushima.jp",
      "futaba.fukushima.jp",
      "hanawa.fukushima.jp",
      "higashi.fukushima.jp",
      "hirata.fukushima.jp",
      "hirono.fukushima.jp",
      "iitate.fukushima.jp",
      "inawashiro.fukushima.jp",
      "ishikawa.fukushima.jp",
      "iwaki.fukushima.jp",
      "izumizaki.fukushima.jp",
      "kagamiishi.fukushima.jp",
      "kaneyama.fukushima.jp",
      "kawamata.fukushima.jp",
      "kitakata.fukushima.jp",
      "kitashiobara.fukushima.jp",
      "koori.fukushima.jp",
      "koriyama.fukushima.jp",
      "kunimi.fukushima.jp",
      "miharu.fukushima.jp",
      "mishima.fukushima.jp",
      "namie.fukushima.jp",
      "nango.fukushima.jp",
      "nishiaizu.fukushima.jp",
      "nishigo.fukushima.jp",
      "okuma.fukushima.jp",
      "omotego.fukushima.jp",
      "ono.fukushima.jp",
      "otama.fukushima.jp",
      "samegawa.fukushima.jp",
      "shimogo.fukushima.jp",
      "shirakawa.fukushima.jp",
      "showa.fukushima.jp",
      "soma.fukushima.jp",
      "sukagawa.fukushima.jp",
      "taishin.fukushima.jp",
      "tamakawa.fukushima.jp",
      "tanagura.fukushima.jp",
      "tenei.fukushima.jp",
      "yabuki.fukushima.jp",
      "yamato.fukushima.jp",
      "yamatsuri.fukushima.jp",
      "yanaizu.fukushima.jp",
      "yugawa.fukushima.jp",
      "anpachi.gifu.jp",
      "ena.gifu.jp",
      "gifu.gifu.jp",
      "ginan.gifu.jp",
      "godo.gifu.jp",
      "gujo.gifu.jp",
      "hashima.gifu.jp",
      "hichiso.gifu.jp",
      "hida.gifu.jp",
      "higashishirakawa.gifu.jp",
      "ibigawa.gifu.jp",
      "ikeda.gifu.jp",
      "kakamigahara.gifu.jp",
      "kani.gifu.jp",
      "kasahara.gifu.jp",
      "kasamatsu.gifu.jp",
      "kawaue.gifu.jp",
      "kitagata.gifu.jp",
      "mino.gifu.jp",
      "minokamo.gifu.jp",
      "mitake.gifu.jp",
      "mizunami.gifu.jp",
      "motosu.gifu.jp",
      "nakatsugawa.gifu.jp",
      "ogaki.gifu.jp",
      "sakahogi.gifu.jp",
      "seki.gifu.jp",
      "sekigahara.gifu.jp",
      "shirakawa.gifu.jp",
      "tajimi.gifu.jp",
      "takayama.gifu.jp",
      "tarui.gifu.jp",
      "toki.gifu.jp",
      "tomika.gifu.jp",
      "wanouchi.gifu.jp",
      "yamagata.gifu.jp",
      "yaotsu.gifu.jp",
      "yoro.gifu.jp",
      "annaka.gunma.jp",
      "chiyoda.gunma.jp",
      "fujioka.gunma.jp",
      "higashiagatsuma.gunma.jp",
      "isesaki.gunma.jp",
      "itakura.gunma.jp",
      "kanna.gunma.jp",
      "kanra.gunma.jp",
      "katashina.gunma.jp",
      "kawaba.gunma.jp",
      "kiryu.gunma.jp",
      "kusatsu.gunma.jp",
      "maebashi.gunma.jp",
      "meiwa.gunma.jp",
      "midori.gunma.jp",
      "minakami.gunma.jp",
      "naganohara.gunma.jp",
      "nakanojo.gunma.jp",
      "nanmoku.gunma.jp",
      "numata.gunma.jp",
      "oizumi.gunma.jp",
      "ora.gunma.jp",
      "ota.gunma.jp",
      "shibukawa.gunma.jp",
      "shimonita.gunma.jp",
      "shinto.gunma.jp",
      "showa.gunma.jp",
      "takasaki.gunma.jp",
      "takayama.gunma.jp",
      "tamamura.gunma.jp",
      "tatebayashi.gunma.jp",
      "tomioka.gunma.jp",
      "tsukiyono.gunma.jp",
      "tsumagoi.gunma.jp",
      "ueno.gunma.jp",
      "yoshioka.gunma.jp",
      "asaminami.hiroshima.jp",
      "daiwa.hiroshima.jp",
      "etajima.hiroshima.jp",
      "fuchu.hiroshima.jp",
      "fukuyama.hiroshima.jp",
      "hatsukaichi.hiroshima.jp",
      "higashihiroshima.hiroshima.jp",
      "hongo.hiroshima.jp",
      "jinsekikogen.hiroshima.jp",
      "kaita.hiroshima.jp",
      "kui.hiroshima.jp",
      "kumano.hiroshima.jp",
      "kure.hiroshima.jp",
      "mihara.hiroshima.jp",
      "miyoshi.hiroshima.jp",
      "naka.hiroshima.jp",
      "onomichi.hiroshima.jp",
      "osakikamijima.hiroshima.jp",
      "otake.hiroshima.jp",
      "saka.hiroshima.jp",
      "sera.hiroshima.jp",
      "seranishi.hiroshima.jp",
      "shinichi.hiroshima.jp",
      "shobara.hiroshima.jp",
      "takehara.hiroshima.jp",
      "abashiri.hokkaido.jp",
      "abira.hokkaido.jp",
      "aibetsu.hokkaido.jp",
      "akabira.hokkaido.jp",
      "akkeshi.hokkaido.jp",
      "asahikawa.hokkaido.jp",
      "ashibetsu.hokkaido.jp",
      "ashoro.hokkaido.jp",
      "assabu.hokkaido.jp",
      "atsuma.hokkaido.jp",
      "bibai.hokkaido.jp",
      "biei.hokkaido.jp",
      "bifuka.hokkaido.jp",
      "bihoro.hokkaido.jp",
      "biratori.hokkaido.jp",
      "chippubetsu.hokkaido.jp",
      "chitose.hokkaido.jp",
      "date.hokkaido.jp",
      "ebetsu.hokkaido.jp",
      "embetsu.hokkaido.jp",
      "eniwa.hokkaido.jp",
      "erimo.hokkaido.jp",
      "esan.hokkaido.jp",
      "esashi.hokkaido.jp",
      "fukagawa.hokkaido.jp",
      "fukushima.hokkaido.jp",
      "furano.hokkaido.jp",
      "furubira.hokkaido.jp",
      "haboro.hokkaido.jp",
      "hakodate.hokkaido.jp",
      "hamatonbetsu.hokkaido.jp",
      "hidaka.hokkaido.jp",
      "higashikagura.hokkaido.jp",
      "higashikawa.hokkaido.jp",
      "hiroo.hokkaido.jp",
      "hokuryu.hokkaido.jp",
      "hokuto.hokkaido.jp",
      "honbetsu.hokkaido.jp",
      "horokanai.hokkaido.jp",
      "horonobe.hokkaido.jp",
      "ikeda.hokkaido.jp",
      "imakane.hokkaido.jp",
      "ishikari.hokkaido.jp",
      "iwamizawa.hokkaido.jp",
      "iwanai.hokkaido.jp",
      "kamifurano.hokkaido.jp",
      "kamikawa.hokkaido.jp",
      "kamishihoro.hokkaido.jp",
      "kamisunagawa.hokkaido.jp",
      "kamoenai.hokkaido.jp",
      "kayabe.hokkaido.jp",
      "kembuchi.hokkaido.jp",
      "kikonai.hokkaido.jp",
      "kimobetsu.hokkaido.jp",
      "kitahiroshima.hokkaido.jp",
      "kitami.hokkaido.jp",
      "kiyosato.hokkaido.jp",
      "koshimizu.hokkaido.jp",
      "kunneppu.hokkaido.jp",
      "kuriyama.hokkaido.jp",
      "kuromatsunai.hokkaido.jp",
      "kushiro.hokkaido.jp",
      "kutchan.hokkaido.jp",
      "kyowa.hokkaido.jp",
      "mashike.hokkaido.jp",
      "matsumae.hokkaido.jp",
      "mikasa.hokkaido.jp",
      "minamifurano.hokkaido.jp",
      "mombetsu.hokkaido.jp",
      "moseushi.hokkaido.jp",
      "mukawa.hokkaido.jp",
      "muroran.hokkaido.jp",
      "naie.hokkaido.jp",
      "nakagawa.hokkaido.jp",
      "nakasatsunai.hokkaido.jp",
      "nakatombetsu.hokkaido.jp",
      "nanae.hokkaido.jp",
      "nanporo.hokkaido.jp",
      "nayoro.hokkaido.jp",
      "nemuro.hokkaido.jp",
      "niikappu.hokkaido.jp",
      "niki.hokkaido.jp",
      "nishiokoppe.hokkaido.jp",
      "noboribetsu.hokkaido.jp",
      "numata.hokkaido.jp",
      "obihiro.hokkaido.jp",
      "obira.hokkaido.jp",
      "oketo.hokkaido.jp",
      "okoppe.hokkaido.jp",
      "otaru.hokkaido.jp",
      "otobe.hokkaido.jp",
      "otofuke.hokkaido.jp",
      "otoineppu.hokkaido.jp",
      "oumu.hokkaido.jp",
      "ozora.hokkaido.jp",
      "pippu.hokkaido.jp",
      "rankoshi.hokkaido.jp",
      "rebun.hokkaido.jp",
      "rikubetsu.hokkaido.jp",
      "rishiri.hokkaido.jp",
      "rishirifuji.hokkaido.jp",
      "saroma.hokkaido.jp",
      "sarufutsu.hokkaido.jp",
      "shakotan.hokkaido.jp",
      "shari.hokkaido.jp",
      "shibecha.hokkaido.jp",
      "shibetsu.hokkaido.jp",
      "shikabe.hokkaido.jp",
      "shikaoi.hokkaido.jp",
      "shimamaki.hokkaido.jp",
      "shimizu.hokkaido.jp",
      "shimokawa.hokkaido.jp",
      "shinshinotsu.hokkaido.jp",
      "shintoku.hokkaido.jp",
      "shiranuka.hokkaido.jp",
      "shiraoi.hokkaido.jp",
      "shiriuchi.hokkaido.jp",
      "sobetsu.hokkaido.jp",
      "sunagawa.hokkaido.jp",
      "taiki.hokkaido.jp",
      "takasu.hokkaido.jp",
      "takikawa.hokkaido.jp",
      "takinoue.hokkaido.jp",
      "teshikaga.hokkaido.jp",
      "tobetsu.hokkaido.jp",
      "tohma.hokkaido.jp",
      "tomakomai.hokkaido.jp",
      "tomari.hokkaido.jp",
      "toya.hokkaido.jp",
      "toyako.hokkaido.jp",
      "toyotomi.hokkaido.jp",
      "toyoura.hokkaido.jp",
      "tsubetsu.hokkaido.jp",
      "tsukigata.hokkaido.jp",
      "urakawa.hokkaido.jp",
      "urausu.hokkaido.jp",
      "uryu.hokkaido.jp",
      "utashinai.hokkaido.jp",
      "wakkanai.hokkaido.jp",
      "wassamu.hokkaido.jp",
      "yakumo.hokkaido.jp",
      "yoichi.hokkaido.jp",
      "aioi.hyogo.jp",
      "akashi.hyogo.jp",
      "ako.hyogo.jp",
      "amagasaki.hyogo.jp",
      "aogaki.hyogo.jp",
      "asago.hyogo.jp",
      "ashiya.hyogo.jp",
      "awaji.hyogo.jp",
      "fukusaki.hyogo.jp",
      "goshiki.hyogo.jp",
      "harima.hyogo.jp",
      "himeji.hyogo.jp",
      "ichikawa.hyogo.jp",
      "inagawa.hyogo.jp",
      "itami.hyogo.jp",
      "kakogawa.hyogo.jp",
      "kamigori.hyogo.jp",
      "kamikawa.hyogo.jp",
      "kasai.hyogo.jp",
      "kasuga.hyogo.jp",
      "kawanishi.hyogo.jp",
      "miki.hyogo.jp",
      "minamiawaji.hyogo.jp",
      "nishinomiya.hyogo.jp",
      "nishiwaki.hyogo.jp",
      "ono.hyogo.jp",
      "sanda.hyogo.jp",
      "sannan.hyogo.jp",
      "sasayama.hyogo.jp",
      "sayo.hyogo.jp",
      "shingu.hyogo.jp",
      "shinonsen.hyogo.jp",
      "shiso.hyogo.jp",
      "sumoto.hyogo.jp",
      "taishi.hyogo.jp",
      "taka.hyogo.jp",
      "takarazuka.hyogo.jp",
      "takasago.hyogo.jp",
      "takino.hyogo.jp",
      "tamba.hyogo.jp",
      "tatsuno.hyogo.jp",
      "toyooka.hyogo.jp",
      "yabu.hyogo.jp",
      "yashiro.hyogo.jp",
      "yoka.hyogo.jp",
      "yokawa.hyogo.jp",
      "ami.ibaraki.jp",
      "asahi.ibaraki.jp",
      "bando.ibaraki.jp",
      "chikusei.ibaraki.jp",
      "daigo.ibaraki.jp",
      "fujishiro.ibaraki.jp",
      "hitachi.ibaraki.jp",
      "hitachinaka.ibaraki.jp",
      "hitachiomiya.ibaraki.jp",
      "hitachiota.ibaraki.jp",
      "ibaraki.ibaraki.jp",
      "ina.ibaraki.jp",
      "inashiki.ibaraki.jp",
      "itako.ibaraki.jp",
      "iwama.ibaraki.jp",
      "joso.ibaraki.jp",
      "kamisu.ibaraki.jp",
      "kasama.ibaraki.jp",
      "kashima.ibaraki.jp",
      "kasumigaura.ibaraki.jp",
      "koga.ibaraki.jp",
      "miho.ibaraki.jp",
      "mito.ibaraki.jp",
      "moriya.ibaraki.jp",
      "naka.ibaraki.jp",
      "namegata.ibaraki.jp",
      "oarai.ibaraki.jp",
      "ogawa.ibaraki.jp",
      "omitama.ibaraki.jp",
      "ryugasaki.ibaraki.jp",
      "sakai.ibaraki.jp",
      "sakuragawa.ibaraki.jp",
      "shimodate.ibaraki.jp",
      "shimotsuma.ibaraki.jp",
      "shirosato.ibaraki.jp",
      "sowa.ibaraki.jp",
      "suifu.ibaraki.jp",
      "takahagi.ibaraki.jp",
      "tamatsukuri.ibaraki.jp",
      "tokai.ibaraki.jp",
      "tomobe.ibaraki.jp",
      "tone.ibaraki.jp",
      "toride.ibaraki.jp",
      "tsuchiura.ibaraki.jp",
      "tsukuba.ibaraki.jp",
      "uchihara.ibaraki.jp",
      "ushiku.ibaraki.jp",
      "yachiyo.ibaraki.jp",
      "yamagata.ibaraki.jp",
      "yawara.ibaraki.jp",
      "yuki.ibaraki.jp",
      "anamizu.ishikawa.jp",
      "hakui.ishikawa.jp",
      "hakusan.ishikawa.jp",
      "kaga.ishikawa.jp",
      "kahoku.ishikawa.jp",
      "kanazawa.ishikawa.jp",
      "kawakita.ishikawa.jp",
      "komatsu.ishikawa.jp",
      "nakanoto.ishikawa.jp",
      "nanao.ishikawa.jp",
      "nomi.ishikawa.jp",
      "nonoichi.ishikawa.jp",
      "noto.ishikawa.jp",
      "shika.ishikawa.jp",
      "suzu.ishikawa.jp",
      "tsubata.ishikawa.jp",
      "tsurugi.ishikawa.jp",
      "uchinada.ishikawa.jp",
      "wajima.ishikawa.jp",
      "fudai.iwate.jp",
      "fujisawa.iwate.jp",
      "hanamaki.iwate.jp",
      "hiraizumi.iwate.jp",
      "hirono.iwate.jp",
      "ichinohe.iwate.jp",
      "ichinoseki.iwate.jp",
      "iwaizumi.iwate.jp",
      "iwate.iwate.jp",
      "joboji.iwate.jp",
      "kamaishi.iwate.jp",
      "kanegasaki.iwate.jp",
      "karumai.iwate.jp",
      "kawai.iwate.jp",
      "kitakami.iwate.jp",
      "kuji.iwate.jp",
      "kunohe.iwate.jp",
      "kuzumaki.iwate.jp",
      "miyako.iwate.jp",
      "mizusawa.iwate.jp",
      "morioka.iwate.jp",
      "ninohe.iwate.jp",
      "noda.iwate.jp",
      "ofunato.iwate.jp",
      "oshu.iwate.jp",
      "otsuchi.iwate.jp",
      "rikuzentakata.iwate.jp",
      "shiwa.iwate.jp",
      "shizukuishi.iwate.jp",
      "sumita.iwate.jp",
      "tanohata.iwate.jp",
      "tono.iwate.jp",
      "yahaba.iwate.jp",
      "yamada.iwate.jp",
      "ayagawa.kagawa.jp",
      "higashikagawa.kagawa.jp",
      "kanonji.kagawa.jp",
      "kotohira.kagawa.jp",
      "manno.kagawa.jp",
      "marugame.kagawa.jp",
      "mitoyo.kagawa.jp",
      "naoshima.kagawa.jp",
      "sanuki.kagawa.jp",
      "tadotsu.kagawa.jp",
      "takamatsu.kagawa.jp",
      "tonosho.kagawa.jp",
      "uchinomi.kagawa.jp",
      "utazu.kagawa.jp",
      "zentsuji.kagawa.jp",
      "akune.kagoshima.jp",
      "amami.kagoshima.jp",
      "hioki.kagoshima.jp",
      "isa.kagoshima.jp",
      "isen.kagoshima.jp",
      "izumi.kagoshima.jp",
      "kagoshima.kagoshima.jp",
      "kanoya.kagoshima.jp",
      "kawanabe.kagoshima.jp",
      "kinko.kagoshima.jp",
      "kouyama.kagoshima.jp",
      "makurazaki.kagoshima.jp",
      "matsumoto.kagoshima.jp",
      "minamitane.kagoshima.jp",
      "nakatane.kagoshima.jp",
      "nishinoomote.kagoshima.jp",
      "satsumasendai.kagoshima.jp",
      "soo.kagoshima.jp",
      "tarumizu.kagoshima.jp",
      "yusui.kagoshima.jp",
      "aikawa.kanagawa.jp",
      "atsugi.kanagawa.jp",
      "ayase.kanagawa.jp",
      "chigasaki.kanagawa.jp",
      "ebina.kanagawa.jp",
      "fujisawa.kanagawa.jp",
      "hadano.kanagawa.jp",
      "hakone.kanagawa.jp",
      "hiratsuka.kanagawa.jp",
      "isehara.kanagawa.jp",
      "kaisei.kanagawa.jp",
      "kamakura.kanagawa.jp",
      "kiyokawa.kanagawa.jp",
      "matsuda.kanagawa.jp",
      "minamiashigara.kanagawa.jp",
      "miura.kanagawa.jp",
      "nakai.kanagawa.jp",
      "ninomiya.kanagawa.jp",
      "odawara.kanagawa.jp",
      "oi.kanagawa.jp",
      "oiso.kanagawa.jp",
      "sagamihara.kanagawa.jp",
      "samukawa.kanagawa.jp",
      "tsukui.kanagawa.jp",
      "yamakita.kanagawa.jp",
      "yamato.kanagawa.jp",
      "yokosuka.kanagawa.jp",
      "yugawara.kanagawa.jp",
      "zama.kanagawa.jp",
      "zushi.kanagawa.jp",
      "aki.kochi.jp",
      "geisei.kochi.jp",
      "hidaka.kochi.jp",
      "higashitsuno.kochi.jp",
      "ino.kochi.jp",
      "kagami.kochi.jp",
      "kami.kochi.jp",
      "kitagawa.kochi.jp",
      "kochi.kochi.jp",
      "mihara.kochi.jp",
      "motoyama.kochi.jp",
      "muroto.kochi.jp",
      "nahari.kochi.jp",
      "nakamura.kochi.jp",
      "nankoku.kochi.jp",
      "nishitosa.kochi.jp",
      "niyodogawa.kochi.jp",
      "ochi.kochi.jp",
      "okawa.kochi.jp",
      "otoyo.kochi.jp",
      "otsuki.kochi.jp",
      "sakawa.kochi.jp",
      "sukumo.kochi.jp",
      "susaki.kochi.jp",
      "tosa.kochi.jp",
      "tosashimizu.kochi.jp",
      "toyo.kochi.jp",
      "tsuno.kochi.jp",
      "umaji.kochi.jp",
      "yasuda.kochi.jp",
      "yusuhara.kochi.jp",
      "amakusa.kumamoto.jp",
      "arao.kumamoto.jp",
      "aso.kumamoto.jp",
      "choyo.kumamoto.jp",
      "gyokuto.kumamoto.jp",
      "kamiamakusa.kumamoto.jp",
      "kikuchi.kumamoto.jp",
      "kumamoto.kumamoto.jp",
      "mashiki.kumamoto.jp",
      "mifune.kumamoto.jp",
      "minamata.kumamoto.jp",
      "minamioguni.kumamoto.jp",
      "nagasu.kumamoto.jp",
      "nishihara.kumamoto.jp",
      "oguni.kumamoto.jp",
      "ozu.kumamoto.jp",
      "sumoto.kumamoto.jp",
      "takamori.kumamoto.jp",
      "uki.kumamoto.jp",
      "uto.kumamoto.jp",
      "yamaga.kumamoto.jp",
      "yamato.kumamoto.jp",
      "yatsushiro.kumamoto.jp",
      "ayabe.kyoto.jp",
      "fukuchiyama.kyoto.jp",
      "higashiyama.kyoto.jp",
      "ide.kyoto.jp",
      "ine.kyoto.jp",
      "joyo.kyoto.jp",
      "kameoka.kyoto.jp",
      "kamo.kyoto.jp",
      "kita.kyoto.jp",
      "kizu.kyoto.jp",
      "kumiyama.kyoto.jp",
      "kyotamba.kyoto.jp",
      "kyotanabe.kyoto.jp",
      "kyotango.kyoto.jp",
      "maizuru.kyoto.jp",
      "minami.kyoto.jp",
      "minamiyamashiro.kyoto.jp",
      "miyazu.kyoto.jp",
      "muko.kyoto.jp",
      "nagaokakyo.kyoto.jp",
      "nakagyo.kyoto.jp",
      "nantan.kyoto.jp",
      "oyamazaki.kyoto.jp",
      "sakyo.kyoto.jp",
      "seika.kyoto.jp",
      "tanabe.kyoto.jp",
      "uji.kyoto.jp",
      "ujitawara.kyoto.jp",
      "wazuka.kyoto.jp",
      "yamashina.kyoto.jp",
      "yawata.kyoto.jp",
      "asahi.mie.jp",
      "inabe.mie.jp",
      "ise.mie.jp",
      "kameyama.mie.jp",
      "kawagoe.mie.jp",
      "kiho.mie.jp",
      "kisosaki.mie.jp",
      "kiwa.mie.jp",
      "komono.mie.jp",
      "kumano.mie.jp",
      "kuwana.mie.jp",
      "matsusaka.mie.jp",
      "meiwa.mie.jp",
      "mihama.mie.jp",
      "minamiise.mie.jp",
      "misugi.mie.jp",
      "miyama.mie.jp",
      "nabari.mie.jp",
      "shima.mie.jp",
      "suzuka.mie.jp",
      "tado.mie.jp",
      "taiki.mie.jp",
      "taki.mie.jp",
      "tamaki.mie.jp",
      "toba.mie.jp",
      "tsu.mie.jp",
      "udono.mie.jp",
      "ureshino.mie.jp",
      "watarai.mie.jp",
      "yokkaichi.mie.jp",
      "furukawa.miyagi.jp",
      "higashimatsushima.miyagi.jp",
      "ishinomaki.miyagi.jp",
      "iwanuma.miyagi.jp",
      "kakuda.miyagi.jp",
      "kami.miyagi.jp",
      "kawasaki.miyagi.jp",
      "marumori.miyagi.jp",
      "matsushima.miyagi.jp",
      "minamisanriku.miyagi.jp",
      "misato.miyagi.jp",
      "murata.miyagi.jp",
      "natori.miyagi.jp",
      "ogawara.miyagi.jp",
      "ohira.miyagi.jp",
      "onagawa.miyagi.jp",
      "osaki.miyagi.jp",
      "rifu.miyagi.jp",
      "semine.miyagi.jp",
      "shibata.miyagi.jp",
      "shichikashuku.miyagi.jp",
      "shikama.miyagi.jp",
      "shiogama.miyagi.jp",
      "shiroishi.miyagi.jp",
      "tagajo.miyagi.jp",
      "taiwa.miyagi.jp",
      "tome.miyagi.jp",
      "tomiya.miyagi.jp",
      "wakuya.miyagi.jp",
      "watari.miyagi.jp",
      "yamamoto.miyagi.jp",
      "zao.miyagi.jp",
      "aya.miyazaki.jp",
      "ebino.miyazaki.jp",
      "gokase.miyazaki.jp",
      "hyuga.miyazaki.jp",
      "kadogawa.miyazaki.jp",
      "kawaminami.miyazaki.jp",
      "kijo.miyazaki.jp",
      "kitagawa.miyazaki.jp",
      "kitakata.miyazaki.jp",
      "kitaura.miyazaki.jp",
      "kobayashi.miyazaki.jp",
      "kunitomi.miyazaki.jp",
      "kushima.miyazaki.jp",
      "mimata.miyazaki.jp",
      "miyakonojo.miyazaki.jp",
      "miyazaki.miyazaki.jp",
      "morotsuka.miyazaki.jp",
      "nichinan.miyazaki.jp",
      "nishimera.miyazaki.jp",
      "nobeoka.miyazaki.jp",
      "saito.miyazaki.jp",
      "shiiba.miyazaki.jp",
      "shintomi.miyazaki.jp",
      "takaharu.miyazaki.jp",
      "takanabe.miyazaki.jp",
      "takazaki.miyazaki.jp",
      "tsuno.miyazaki.jp",
      "achi.nagano.jp",
      "agematsu.nagano.jp",
      "anan.nagano.jp",
      "aoki.nagano.jp",
      "asahi.nagano.jp",
      "azumino.nagano.jp",
      "chikuhoku.nagano.jp",
      "chikuma.nagano.jp",
      "chino.nagano.jp",
      "fujimi.nagano.jp",
      "hakuba.nagano.jp",
      "hara.nagano.jp",
      "hiraya.nagano.jp",
      "iida.nagano.jp",
      "iijima.nagano.jp",
      "iiyama.nagano.jp",
      "iizuna.nagano.jp",
      "ikeda.nagano.jp",
      "ikusaka.nagano.jp",
      "ina.nagano.jp",
      "karuizawa.nagano.jp",
      "kawakami.nagano.jp",
      "kiso.nagano.jp",
      "kisofukushima.nagano.jp",
      "kitaaiki.nagano.jp",
      "komagane.nagano.jp",
      "komoro.nagano.jp",
      "matsukawa.nagano.jp",
      "matsumoto.nagano.jp",
      "miasa.nagano.jp",
      "minamiaiki.nagano.jp",
      "minamimaki.nagano.jp",
      "minamiminowa.nagano.jp",
      "minowa.nagano.jp",
      "miyada.nagano.jp",
      "miyota.nagano.jp",
      "mochizuki.nagano.jp",
      "nagano.nagano.jp",
      "nagawa.nagano.jp",
      "nagiso.nagano.jp",
      "nakagawa.nagano.jp",
      "nakano.nagano.jp",
      "nozawaonsen.nagano.jp",
      "obuse.nagano.jp",
      "ogawa.nagano.jp",
      "okaya.nagano.jp",
      "omachi.nagano.jp",
      "omi.nagano.jp",
      "ookuwa.nagano.jp",
      "ooshika.nagano.jp",
      "otaki.nagano.jp",
      "otari.nagano.jp",
      "sakae.nagano.jp",
      "sakaki.nagano.jp",
      "saku.nagano.jp",
      "sakuho.nagano.jp",
      "shimosuwa.nagano.jp",
      "shinanomachi.nagano.jp",
      "shiojiri.nagano.jp",
      "suwa.nagano.jp",
      "suzaka.nagano.jp",
      "takagi.nagano.jp",
      "takamori.nagano.jp",
      "takayama.nagano.jp",
      "tateshina.nagano.jp",
      "tatsuno.nagano.jp",
      "togakushi.nagano.jp",
      "togura.nagano.jp",
      "tomi.nagano.jp",
      "ueda.nagano.jp",
      "wada.nagano.jp",
      "yamagata.nagano.jp",
      "yamanouchi.nagano.jp",
      "yasaka.nagano.jp",
      "yasuoka.nagano.jp",
      "chijiwa.nagasaki.jp",
      "futsu.nagasaki.jp",
      "goto.nagasaki.jp",
      "hasami.nagasaki.jp",
      "hirado.nagasaki.jp",
      "iki.nagasaki.jp",
      "isahaya.nagasaki.jp",
      "kawatana.nagasaki.jp",
      "kuchinotsu.nagasaki.jp",
      "matsuura.nagasaki.jp",
      "nagasaki.nagasaki.jp",
      "obama.nagasaki.jp",
      "omura.nagasaki.jp",
      "oseto.nagasaki.jp",
      "saikai.nagasaki.jp",
      "sasebo.nagasaki.jp",
      "seihi.nagasaki.jp",
      "shimabara.nagasaki.jp",
      "shinkamigoto.nagasaki.jp",
      "togitsu.nagasaki.jp",
      "tsushima.nagasaki.jp",
      "unzen.nagasaki.jp",
      "ando.nara.jp",
      "gose.nara.jp",
      "heguri.nara.jp",
      "higashiyoshino.nara.jp",
      "ikaruga.nara.jp",
      "ikoma.nara.jp",
      "kamikitayama.nara.jp",
      "kanmaki.nara.jp",
      "kashiba.nara.jp",
      "kashihara.nara.jp",
      "katsuragi.nara.jp",
      "kawai.nara.jp",
      "kawakami.nara.jp",
      "kawanishi.nara.jp",
      "koryo.nara.jp",
      "kurotaki.nara.jp",
      "mitsue.nara.jp",
      "miyake.nara.jp",
      "nara.nara.jp",
      "nosegawa.nara.jp",
      "oji.nara.jp",
      "ouda.nara.jp",
      "oyodo.nara.jp",
      "sakurai.nara.jp",
      "sango.nara.jp",
      "shimoichi.nara.jp",
      "shimokitayama.nara.jp",
      "shinjo.nara.jp",
      "soni.nara.jp",
      "takatori.nara.jp",
      "tawaramoto.nara.jp",
      "tenkawa.nara.jp",
      "tenri.nara.jp",
      "uda.nara.jp",
      "yamatokoriyama.nara.jp",
      "yamatotakada.nara.jp",
      "yamazoe.nara.jp",
      "yoshino.nara.jp",
      "aga.niigata.jp",
      "agano.niigata.jp",
      "gosen.niigata.jp",
      "itoigawa.niigata.jp",
      "izumozaki.niigata.jp",
      "joetsu.niigata.jp",
      "kamo.niigata.jp",
      "kariwa.niigata.jp",
      "kashiwazaki.niigata.jp",
      "minamiuonuma.niigata.jp",
      "mitsuke.niigata.jp",
      "muika.niigata.jp",
      "murakami.niigata.jp",
      "myoko.niigata.jp",
      "nagaoka.niigata.jp",
      "niigata.niigata.jp",
      "ojiya.niigata.jp",
      "omi.niigata.jp",
      "sado.niigata.jp",
      "sanjo.niigata.jp",
      "seiro.niigata.jp",
      "seirou.niigata.jp",
      "sekikawa.niigata.jp",
      "shibata.niigata.jp",
      "tagami.niigata.jp",
      "tainai.niigata.jp",
      "tochio.niigata.jp",
      "tokamachi.niigata.jp",
      "tsubame.niigata.jp",
      "tsunan.niigata.jp",
      "uonuma.niigata.jp",
      "yahiko.niigata.jp",
      "yoita.niigata.jp",
      "yuzawa.niigata.jp",
      "beppu.oita.jp",
      "bungoono.oita.jp",
      "bungotakada.oita.jp",
      "hasama.oita.jp",
      "hiji.oita.jp",
      "himeshima.oita.jp",
      "hita.oita.jp",
      "kamitsue.oita.jp",
      "kokonoe.oita.jp",
      "kuju.oita.jp",
      "kunisaki.oita.jp",
      "kusu.oita.jp",
      "oita.oita.jp",
      "saiki.oita.jp",
      "taketa.oita.jp",
      "tsukumi.oita.jp",
      "usa.oita.jp",
      "usuki.oita.jp",
      "yufu.oita.jp",
      "akaiwa.okayama.jp",
      "asakuchi.okayama.jp",
      "bizen.okayama.jp",
      "hayashima.okayama.jp",
      "ibara.okayama.jp",
      "kagamino.okayama.jp",
      "kasaoka.okayama.jp",
      "kibichuo.okayama.jp",
      "kumenan.okayama.jp",
      "kurashiki.okayama.jp",
      "maniwa.okayama.jp",
      "misaki.okayama.jp",
      "nagi.okayama.jp",
      "niimi.okayama.jp",
      "nishiawakura.okayama.jp",
      "okayama.okayama.jp",
      "satosho.okayama.jp",
      "setouchi.okayama.jp",
      "shinjo.okayama.jp",
      "shoo.okayama.jp",
      "soja.okayama.jp",
      "takahashi.okayama.jp",
      "tamano.okayama.jp",
      "tsuyama.okayama.jp",
      "wake.okayama.jp",
      "yakage.okayama.jp",
      "aguni.okinawa.jp",
      "ginowan.okinawa.jp",
      "ginoza.okinawa.jp",
      "gushikami.okinawa.jp",
      "haebaru.okinawa.jp",
      "higashi.okinawa.jp",
      "hirara.okinawa.jp",
      "iheya.okinawa.jp",
      "ishigaki.okinawa.jp",
      "ishikawa.okinawa.jp",
      "itoman.okinawa.jp",
      "izena.okinawa.jp",
      "kadena.okinawa.jp",
      "kin.okinawa.jp",
      "kitadaito.okinawa.jp",
      "kitanakagusuku.okinawa.jp",
      "kumejima.okinawa.jp",
      "kunigami.okinawa.jp",
      "minamidaito.okinawa.jp",
      "motobu.okinawa.jp",
      "nago.okinawa.jp",
      "naha.okinawa.jp",
      "nakagusuku.okinawa.jp",
      "nakijin.okinawa.jp",
      "nanjo.okinawa.jp",
      "nishihara.okinawa.jp",
      "ogimi.okinawa.jp",
      "okinawa.okinawa.jp",
      "onna.okinawa.jp",
      "shimoji.okinawa.jp",
      "taketomi.okinawa.jp",
      "tarama.okinawa.jp",
      "tokashiki.okinawa.jp",
      "tomigusuku.okinawa.jp",
      "tonaki.okinawa.jp",
      "urasoe.okinawa.jp",
      "uruma.okinawa.jp",
      "yaese.okinawa.jp",
      "yomitan.okinawa.jp",
      "yonabaru.okinawa.jp",
      "yonaguni.okinawa.jp",
      "zamami.okinawa.jp",
      "abeno.osaka.jp",
      "chihayaakasaka.osaka.jp",
      "chuo.osaka.jp",
      "daito.osaka.jp",
      "fujiidera.osaka.jp",
      "habikino.osaka.jp",
      "hannan.osaka.jp",
      "higashiosaka.osaka.jp",
      "higashisumiyoshi.osaka.jp",
      "higashiyodogawa.osaka.jp",
      "hirakata.osaka.jp",
      "ibaraki.osaka.jp",
      "ikeda.osaka.jp",
      "izumi.osaka.jp",
      "izumiotsu.osaka.jp",
      "izumisano.osaka.jp",
      "kadoma.osaka.jp",
      "kaizuka.osaka.jp",
      "kanan.osaka.jp",
      "kashiwara.osaka.jp",
      "katano.osaka.jp",
      "kawachinagano.osaka.jp",
      "kishiwada.osaka.jp",
      "kita.osaka.jp",
      "kumatori.osaka.jp",
      "matsubara.osaka.jp",
      "minato.osaka.jp",
      "minoh.osaka.jp",
      "misaki.osaka.jp",
      "moriguchi.osaka.jp",
      "neyagawa.osaka.jp",
      "nishi.osaka.jp",
      "nose.osaka.jp",
      "osakasayama.osaka.jp",
      "sakai.osaka.jp",
      "sayama.osaka.jp",
      "sennan.osaka.jp",
      "settsu.osaka.jp",
      "shijonawate.osaka.jp",
      "shimamoto.osaka.jp",
      "suita.osaka.jp",
      "tadaoka.osaka.jp",
      "taishi.osaka.jp",
      "tajiri.osaka.jp",
      "takaishi.osaka.jp",
      "takatsuki.osaka.jp",
      "tondabayashi.osaka.jp",
      "toyonaka.osaka.jp",
      "toyono.osaka.jp",
      "yao.osaka.jp",
      "ariake.saga.jp",
      "arita.saga.jp",
      "fukudomi.saga.jp",
      "genkai.saga.jp",
      "hamatama.saga.jp",
      "hizen.saga.jp",
      "imari.saga.jp",
      "kamimine.saga.jp",
      "kanzaki.saga.jp",
      "karatsu.saga.jp",
      "kashima.saga.jp",
      "kitagata.saga.jp",
      "kitahata.saga.jp",
      "kiyama.saga.jp",
      "kouhoku.saga.jp",
      "kyuragi.saga.jp",
      "nishiarita.saga.jp",
      "ogi.saga.jp",
      "omachi.saga.jp",
      "ouchi.saga.jp",
      "saga.saga.jp",
      "shiroishi.saga.jp",
      "taku.saga.jp",
      "tara.saga.jp",
      "tosu.saga.jp",
      "yoshinogari.saga.jp",
      "arakawa.saitama.jp",
      "asaka.saitama.jp",
      "chichibu.saitama.jp",
      "fujimi.saitama.jp",
      "fujimino.saitama.jp",
      "fukaya.saitama.jp",
      "hanno.saitama.jp",
      "hanyu.saitama.jp",
      "hasuda.saitama.jp",
      "hatogaya.saitama.jp",
      "hatoyama.saitama.jp",
      "hidaka.saitama.jp",
      "higashichichibu.saitama.jp",
      "higashimatsuyama.saitama.jp",
      "honjo.saitama.jp",
      "ina.saitama.jp",
      "iruma.saitama.jp",
      "iwatsuki.saitama.jp",
      "kamiizumi.saitama.jp",
      "kamikawa.saitama.jp",
      "kamisato.saitama.jp",
      "kasukabe.saitama.jp",
      "kawagoe.saitama.jp",
      "kawaguchi.saitama.jp",
      "kawajima.saitama.jp",
      "kazo.saitama.jp",
      "kitamoto.saitama.jp",
      "koshigaya.saitama.jp",
      "kounosu.saitama.jp",
      "kuki.saitama.jp",
      "kumagaya.saitama.jp",
      "matsubushi.saitama.jp",
      "minano.saitama.jp",
      "misato.saitama.jp",
      "miyashiro.saitama.jp",
      "miyoshi.saitama.jp",
      "moroyama.saitama.jp",
      "nagatoro.saitama.jp",
      "namegawa.saitama.jp",
      "niiza.saitama.jp",
      "ogano.saitama.jp",
      "ogawa.saitama.jp",
      "ogose.saitama.jp",
      "okegawa.saitama.jp",
      "omiya.saitama.jp",
      "otaki.saitama.jp",
      "ranzan.saitama.jp",
      "ryokami.saitama.jp",
      "saitama.saitama.jp",
      "sakado.saitama.jp",
      "satte.saitama.jp",
      "sayama.saitama.jp",
      "shiki.saitama.jp",
      "shiraoka.saitama.jp",
      "soka.saitama.jp",
      "sugito.saitama.jp",
      "toda.saitama.jp",
      "tokigawa.saitama.jp",
      "tokorozawa.saitama.jp",
      "tsurugashima.saitama.jp",
      "urawa.saitama.jp",
      "warabi.saitama.jp",
      "yashio.saitama.jp",
      "yokoze.saitama.jp",
      "yono.saitama.jp",
      "yorii.saitama.jp",
      "yoshida.saitama.jp",
      "yoshikawa.saitama.jp",
      "yoshimi.saitama.jp",
      "aisho.shiga.jp",
      "gamo.shiga.jp",
      "higashiomi.shiga.jp",
      "hikone.shiga.jp",
      "koka.shiga.jp",
      "konan.shiga.jp",
      "kosei.shiga.jp",
      "koto.shiga.jp",
      "kusatsu.shiga.jp",
      "maibara.shiga.jp",
      "moriyama.shiga.jp",
      "nagahama.shiga.jp",
      "nishiazai.shiga.jp",
      "notogawa.shiga.jp",
      "omihachiman.shiga.jp",
      "otsu.shiga.jp",
      "ritto.shiga.jp",
      "ryuoh.shiga.jp",
      "takashima.shiga.jp",
      "takatsuki.shiga.jp",
      "torahime.shiga.jp",
      "toyosato.shiga.jp",
      "yasu.shiga.jp",
      "akagi.shimane.jp",
      "ama.shimane.jp",
      "gotsu.shimane.jp",
      "hamada.shimane.jp",
      "higashiizumo.shimane.jp",
      "hikawa.shimane.jp",
      "hikimi.shimane.jp",
      "izumo.shimane.jp",
      "kakinoki.shimane.jp",
      "masuda.shimane.jp",
      "matsue.shimane.jp",
      "misato.shimane.jp",
      "nishinoshima.shimane.jp",
      "ohda.shimane.jp",
      "okinoshima.shimane.jp",
      "okuizumo.shimane.jp",
      "shimane.shimane.jp",
      "tamayu.shimane.jp",
      "tsuwano.shimane.jp",
      "unnan.shimane.jp",
      "yakumo.shimane.jp",
      "yasugi.shimane.jp",
      "yatsuka.shimane.jp",
      "arai.shizuoka.jp",
      "atami.shizuoka.jp",
      "fuji.shizuoka.jp",
      "fujieda.shizuoka.jp",
      "fujikawa.shizuoka.jp",
      "fujinomiya.shizuoka.jp",
      "fukuroi.shizuoka.jp",
      "gotemba.shizuoka.jp",
      "haibara.shizuoka.jp",
      "hamamatsu.shizuoka.jp",
      "higashiizu.shizuoka.jp",
      "ito.shizuoka.jp",
      "iwata.shizuoka.jp",
      "izu.shizuoka.jp",
      "izunokuni.shizuoka.jp",
      "kakegawa.shizuoka.jp",
      "kannami.shizuoka.jp",
      "kawanehon.shizuoka.jp",
      "kawazu.shizuoka.jp",
      "kikugawa.shizuoka.jp",
      "kosai.shizuoka.jp",
      "makinohara.shizuoka.jp",
      "matsuzaki.shizuoka.jp",
      "minamiizu.shizuoka.jp",
      "mishima.shizuoka.jp",
      "morimachi.shizuoka.jp",
      "nishiizu.shizuoka.jp",
      "numazu.shizuoka.jp",
      "omaezaki.shizuoka.jp",
      "shimada.shizuoka.jp",
      "shimizu.shizuoka.jp",
      "shimoda.shizuoka.jp",
      "shizuoka.shizuoka.jp",
      "susono.shizuoka.jp",
      "yaizu.shizuoka.jp",
      "yoshida.shizuoka.jp",
      "ashikaga.tochigi.jp",
      "bato.tochigi.jp",
      "haga.tochigi.jp",
      "ichikai.tochigi.jp",
      "iwafune.tochigi.jp",
      "kaminokawa.tochigi.jp",
      "kanuma.tochigi.jp",
      "karasuyama.tochigi.jp",
      "kuroiso.tochigi.jp",
      "mashiko.tochigi.jp",
      "mibu.tochigi.jp",
      "moka.tochigi.jp",
      "motegi.tochigi.jp",
      "nasu.tochigi.jp",
      "nasushiobara.tochigi.jp",
      "nikko.tochigi.jp",
      "nishikata.tochigi.jp",
      "nogi.tochigi.jp",
      "ohira.tochigi.jp",
      "ohtawara.tochigi.jp",
      "oyama.tochigi.jp",
      "sakura.tochigi.jp",
      "sano.tochigi.jp",
      "shimotsuke.tochigi.jp",
      "shioya.tochigi.jp",
      "takanezawa.tochigi.jp",
      "tochigi.tochigi.jp",
      "tsuga.tochigi.jp",
      "ujiie.tochigi.jp",
      "utsunomiya.tochigi.jp",
      "yaita.tochigi.jp",
      "aizumi.tokushima.jp",
      "anan.tokushima.jp",
      "ichiba.tokushima.jp",
      "itano.tokushima.jp",
      "kainan.tokushima.jp",
      "komatsushima.tokushima.jp",
      "matsushige.tokushima.jp",
      "mima.tokushima.jp",
      "minami.tokushima.jp",
      "miyoshi.tokushima.jp",
      "mugi.tokushima.jp",
      "nakagawa.tokushima.jp",
      "naruto.tokushima.jp",
      "sanagochi.tokushima.jp",
      "shishikui.tokushima.jp",
      "tokushima.tokushima.jp",
      "wajiki.tokushima.jp",
      "adachi.tokyo.jp",
      "akiruno.tokyo.jp",
      "akishima.tokyo.jp",
      "aogashima.tokyo.jp",
      "arakawa.tokyo.jp",
      "bunkyo.tokyo.jp",
      "chiyoda.tokyo.jp",
      "chofu.tokyo.jp",
      "chuo.tokyo.jp",
      "edogawa.tokyo.jp",
      "fuchu.tokyo.jp",
      "fussa.tokyo.jp",
      "hachijo.tokyo.jp",
      "hachioji.tokyo.jp",
      "hamura.tokyo.jp",
      "higashikurume.tokyo.jp",
      "higashimurayama.tokyo.jp",
      "higashiyamato.tokyo.jp",
      "hino.tokyo.jp",
      "hinode.tokyo.jp",
      "hinohara.tokyo.jp",
      "inagi.tokyo.jp",
      "itabashi.tokyo.jp",
      "katsushika.tokyo.jp",
      "kita.tokyo.jp",
      "kiyose.tokyo.jp",
      "kodaira.tokyo.jp",
      "koganei.tokyo.jp",
      "kokubunji.tokyo.jp",
      "komae.tokyo.jp",
      "koto.tokyo.jp",
      "kouzushima.tokyo.jp",
      "kunitachi.tokyo.jp",
      "machida.tokyo.jp",
      "meguro.tokyo.jp",
      "minato.tokyo.jp",
      "mitaka.tokyo.jp",
      "mizuho.tokyo.jp",
      "musashimurayama.tokyo.jp",
      "musashino.tokyo.jp",
      "nakano.tokyo.jp",
      "nerima.tokyo.jp",
      "ogasawara.tokyo.jp",
      "okutama.tokyo.jp",
      "ome.tokyo.jp",
      "oshima.tokyo.jp",
      "ota.tokyo.jp",
      "setagaya.tokyo.jp",
      "shibuya.tokyo.jp",
      "shinagawa.tokyo.jp",
      "shinjuku.tokyo.jp",
      "suginami.tokyo.jp",
      "sumida.tokyo.jp",
      "tachikawa.tokyo.jp",
      "taito.tokyo.jp",
      "tama.tokyo.jp",
      "toshima.tokyo.jp",
      "chizu.tottori.jp",
      "hino.tottori.jp",
      "kawahara.tottori.jp",
      "koge.tottori.jp",
      "kotoura.tottori.jp",
      "misasa.tottori.jp",
      "nanbu.tottori.jp",
      "nichinan.tottori.jp",
      "sakaiminato.tottori.jp",
      "tottori.tottori.jp",
      "wakasa.tottori.jp",
      "yazu.tottori.jp",
      "yonago.tottori.jp",
      "asahi.toyama.jp",
      "fuchu.toyama.jp",
      "fukumitsu.toyama.jp",
      "funahashi.toyama.jp",
      "himi.toyama.jp",
      "imizu.toyama.jp",
      "inami.toyama.jp",
      "johana.toyama.jp",
      "kamiichi.toyama.jp",
      "kurobe.toyama.jp",
      "nakaniikawa.toyama.jp",
      "namerikawa.toyama.jp",
      "nanto.toyama.jp",
      "nyuzen.toyama.jp",
      "oyabe.toyama.jp",
      "taira.toyama.jp",
      "takaoka.toyama.jp",
      "tateyama.toyama.jp",
      "toga.toyama.jp",
      "tonami.toyama.jp",
      "toyama.toyama.jp",
      "unazuki.toyama.jp",
      "uozu.toyama.jp",
      "yamada.toyama.jp",
      "arida.wakayama.jp",
      "aridagawa.wakayama.jp",
      "gobo.wakayama.jp",
      "hashimoto.wakayama.jp",
      "hidaka.wakayama.jp",
      "hirogawa.wakayama.jp",
      "inami.wakayama.jp",
      "iwade.wakayama.jp",
      "kainan.wakayama.jp",
      "kamitonda.wakayama.jp",
      "katsuragi.wakayama.jp",
      "kimino.wakayama.jp",
      "kinokawa.wakayama.jp",
      "kitayama.wakayama.jp",
      "koya.wakayama.jp",
      "koza.wakayama.jp",
      "kozagawa.wakayama.jp",
      "kudoyama.wakayama.jp",
      "kushimoto.wakayama.jp",
      "mihama.wakayama.jp",
      "misato.wakayama.jp",
      "nachikatsuura.wakayama.jp",
      "shingu.wakayama.jp",
      "shirahama.wakayama.jp",
      "taiji.wakayama.jp",
      "tanabe.wakayama.jp",
      "wakayama.wakayama.jp",
      "yuasa.wakayama.jp",
      "yura.wakayama.jp",
      "asahi.yamagata.jp",
      "funagata.yamagata.jp",
      "higashine.yamagata.jp",
      "iide.yamagata.jp",
      "kahoku.yamagata.jp",
      "kaminoyama.yamagata.jp",
      "kaneyama.yamagata.jp",
      "kawanishi.yamagata.jp",
      "mamurogawa.yamagata.jp",
      "mikawa.yamagata.jp",
      "murayama.yamagata.jp",
      "nagai.yamagata.jp",
      "nakayama.yamagata.jp",
      "nanyo.yamagata.jp",
      "nishikawa.yamagata.jp",
      "obanazawa.yamagata.jp",
      "oe.yamagata.jp",
      "oguni.yamagata.jp",
      "ohkura.yamagata.jp",
      "oishida.yamagata.jp",
      "sagae.yamagata.jp",
      "sakata.yamagata.jp",
      "sakegawa.yamagata.jp",
      "shinjo.yamagata.jp",
      "shirataka.yamagata.jp",
      "shonai.yamagata.jp",
      "takahata.yamagata.jp",
      "tendo.yamagata.jp",
      "tozawa.yamagata.jp",
      "tsuruoka.yamagata.jp",
      "yamagata.yamagata.jp",
      "yamanobe.yamagata.jp",
      "yonezawa.yamagata.jp",
      "yuza.yamagata.jp",
      "abu.yamaguchi.jp",
      "hagi.yamaguchi.jp",
      "hikari.yamaguchi.jp",
      "hofu.yamaguchi.jp",
      "iwakuni.yamaguchi.jp",
      "kudamatsu.yamaguchi.jp",
      "mitou.yamaguchi.jp",
      "nagato.yamaguchi.jp",
      "oshima.yamaguchi.jp",
      "shimonoseki.yamaguchi.jp",
      "shunan.yamaguchi.jp",
      "tabuse.yamaguchi.jp",
      "tokuyama.yamaguchi.jp",
      "toyota.yamaguchi.jp",
      "ube.yamaguchi.jp",
      "yuu.yamaguchi.jp",
      "chuo.yamanashi.jp",
      "doshi.yamanashi.jp",
      "fuefuki.yamanashi.jp",
      "fujikawa.yamanashi.jp",
      "fujikawaguchiko.yamanashi.jp",
      "fujiyoshida.yamanashi.jp",
      "hayakawa.yamanashi.jp",
      "hokuto.yamanashi.jp",
      "ichikawamisato.yamanashi.jp",
      "kai.yamanashi.jp",
      "kofu.yamanashi.jp",
      "koshu.yamanashi.jp",
      "kosuge.yamanashi.jp",
      "minami-alps.yamanashi.jp",
      "minobu.yamanashi.jp",
      "nakamichi.yamanashi.jp",
      "nanbu.yamanashi.jp",
      "narusawa.yamanashi.jp",
      "nirasaki.yamanashi.jp",
      "nishikatsura.yamanashi.jp",
      "oshino.yamanashi.jp",
      "otsuki.yamanashi.jp",
      "showa.yamanashi.jp",
      "tabayama.yamanashi.jp",
      "tsuru.yamanashi.jp",
      "uenohara.yamanashi.jp",
      "yamanakako.yamanashi.jp",
      "yamanashi.yamanashi.jp",
      "ke",
      "ac.ke",
      "co.ke",
      "go.ke",
      "info.ke",
      "me.ke",
      "mobi.ke",
      "ne.ke",
      "or.ke",
      "sc.ke",
      "kg",
      "org.kg",
      "net.kg",
      "com.kg",
      "edu.kg",
      "gov.kg",
      "mil.kg",
      "*.kh",
      "ki",
      "edu.ki",
      "biz.ki",
      "net.ki",
      "org.ki",
      "gov.ki",
      "info.ki",
      "com.ki",
      "km",
      "org.km",
      "nom.km",
      "gov.km",
      "prd.km",
      "tm.km",
      "edu.km",
      "mil.km",
      "ass.km",
      "com.km",
      "coop.km",
      "asso.km",
      "presse.km",
      "medecin.km",
      "notaires.km",
      "pharmaciens.km",
      "veterinaire.km",
      "gouv.km",
      "kn",
      "net.kn",
      "org.kn",
      "edu.kn",
      "gov.kn",
      "kp",
      "com.kp",
      "edu.kp",
      "gov.kp",
      "org.kp",
      "rep.kp",
      "tra.kp",
      "kr",
      "ac.kr",
      "co.kr",
      "es.kr",
      "go.kr",
      "hs.kr",
      "kg.kr",
      "mil.kr",
      "ms.kr",
      "ne.kr",
      "or.kr",
      "pe.kr",
      "re.kr",
      "sc.kr",
      "busan.kr",
      "chungbuk.kr",
      "chungnam.kr",
      "daegu.kr",
      "daejeon.kr",
      "gangwon.kr",
      "gwangju.kr",
      "gyeongbuk.kr",
      "gyeonggi.kr",
      "gyeongnam.kr",
      "incheon.kr",
      "jeju.kr",
      "jeonbuk.kr",
      "jeonnam.kr",
      "seoul.kr",
      "ulsan.kr",
      "kw",
      "com.kw",
      "edu.kw",
      "emb.kw",
      "gov.kw",
      "ind.kw",
      "net.kw",
      "org.kw",
      "ky",
      "edu.ky",
      "gov.ky",
      "com.ky",
      "org.ky",
      "net.ky",
      "kz",
      "org.kz",
      "edu.kz",
      "net.kz",
      "gov.kz",
      "mil.kz",
      "com.kz",
      "la",
      "int.la",
      "net.la",
      "info.la",
      "edu.la",
      "gov.la",
      "per.la",
      "com.la",
      "org.la",
      "lb",
      "com.lb",
      "edu.lb",
      "gov.lb",
      "net.lb",
      "org.lb",
      "lc",
      "com.lc",
      "net.lc",
      "co.lc",
      "org.lc",
      "edu.lc",
      "gov.lc",
      "li",
      "lk",
      "gov.lk",
      "sch.lk",
      "net.lk",
      "int.lk",
      "com.lk",
      "org.lk",
      "edu.lk",
      "ngo.lk",
      "soc.lk",
      "web.lk",
      "ltd.lk",
      "assn.lk",
      "grp.lk",
      "hotel.lk",
      "ac.lk",
      "lr",
      "com.lr",
      "edu.lr",
      "gov.lr",
      "org.lr",
      "net.lr",
      "ls",
      "ac.ls",
      "biz.ls",
      "co.ls",
      "edu.ls",
      "gov.ls",
      "info.ls",
      "net.ls",
      "org.ls",
      "sc.ls",
      "lt",
      "gov.lt",
      "lu",
      "lv",
      "com.lv",
      "edu.lv",
      "gov.lv",
      "org.lv",
      "mil.lv",
      "id.lv",
      "net.lv",
      "asn.lv",
      "conf.lv",
      "ly",
      "com.ly",
      "net.ly",
      "gov.ly",
      "plc.ly",
      "edu.ly",
      "sch.ly",
      "med.ly",
      "org.ly",
      "id.ly",
      "ma",
      "co.ma",
      "net.ma",
      "gov.ma",
      "org.ma",
      "ac.ma",
      "press.ma",
      "mc",
      "tm.mc",
      "asso.mc",
      "md",
      "me",
      "co.me",
      "net.me",
      "org.me",
      "edu.me",
      "ac.me",
      "gov.me",
      "its.me",
      "priv.me",
      "mg",
      "org.mg",
      "nom.mg",
      "gov.mg",
      "prd.mg",
      "tm.mg",
      "edu.mg",
      "mil.mg",
      "com.mg",
      "co.mg",
      "mh",
      "mil",
      "mk",
      "com.mk",
      "org.mk",
      "net.mk",
      "edu.mk",
      "gov.mk",
      "inf.mk",
      "name.mk",
      "ml",
      "com.ml",
      "edu.ml",
      "gouv.ml",
      "gov.ml",
      "net.ml",
      "org.ml",
      "presse.ml",
      "*.mm",
      "mn",
      "gov.mn",
      "edu.mn",
      "org.mn",
      "mo",
      "com.mo",
      "net.mo",
      "org.mo",
      "edu.mo",
      "gov.mo",
      "mobi",
      "mp",
      "mq",
      "mr",
      "gov.mr",
      "ms",
      "com.ms",
      "edu.ms",
      "gov.ms",
      "net.ms",
      "org.ms",
      "mt",
      "com.mt",
      "edu.mt",
      "net.mt",
      "org.mt",
      "mu",
      "com.mu",
      "net.mu",
      "org.mu",
      "gov.mu",
      "ac.mu",
      "co.mu",
      "or.mu",
      "museum",
      "academy.museum",
      "agriculture.museum",
      "air.museum",
      "airguard.museum",
      "alabama.museum",
      "alaska.museum",
      "amber.museum",
      "ambulance.museum",
      "american.museum",
      "americana.museum",
      "americanantiques.museum",
      "americanart.museum",
      "amsterdam.museum",
      "and.museum",
      "annefrank.museum",
      "anthro.museum",
      "anthropology.museum",
      "antiques.museum",
      "aquarium.museum",
      "arboretum.museum",
      "archaeological.museum",
      "archaeology.museum",
      "architecture.museum",
      "art.museum",
      "artanddesign.museum",
      "artcenter.museum",
      "artdeco.museum",
      "arteducation.museum",
      "artgallery.museum",
      "arts.museum",
      "artsandcrafts.museum",
      "asmatart.museum",
      "assassination.museum",
      "assisi.museum",
      "association.museum",
      "astronomy.museum",
      "atlanta.museum",
      "austin.museum",
      "australia.museum",
      "automotive.museum",
      "aviation.museum",
      "axis.museum",
      "badajoz.museum",
      "baghdad.museum",
      "bahn.museum",
      "bale.museum",
      "baltimore.museum",
      "barcelona.museum",
      "baseball.museum",
      "basel.museum",
      "baths.museum",
      "bauern.museum",
      "beauxarts.museum",
      "beeldengeluid.museum",
      "bellevue.museum",
      "bergbau.museum",
      "berkeley.museum",
      "berlin.museum",
      "bern.museum",
      "bible.museum",
      "bilbao.museum",
      "bill.museum",
      "birdart.museum",
      "birthplace.museum",
      "bonn.museum",
      "boston.museum",
      "botanical.museum",
      "botanicalgarden.museum",
      "botanicgarden.museum",
      "botany.museum",
      "brandywinevalley.museum",
      "brasil.museum",
      "bristol.museum",
      "british.museum",
      "britishcolumbia.museum",
      "broadcast.museum",
      "brunel.museum",
      "brussel.museum",
      "brussels.museum",
      "bruxelles.museum",
      "building.museum",
      "burghof.museum",
      "bus.museum",
      "bushey.museum",
      "cadaques.museum",
      "california.museum",
      "cambridge.museum",
      "can.museum",
      "canada.museum",
      "capebreton.museum",
      "carrier.museum",
      "cartoonart.museum",
      "casadelamoneda.museum",
      "castle.museum",
      "castres.museum",
      "celtic.museum",
      "center.museum",
      "chattanooga.museum",
      "cheltenham.museum",
      "chesapeakebay.museum",
      "chicago.museum",
      "children.museum",
      "childrens.museum",
      "childrensgarden.museum",
      "chiropractic.museum",
      "chocolate.museum",
      "christiansburg.museum",
      "cincinnati.museum",
      "cinema.museum",
      "circus.museum",
      "civilisation.museum",
      "civilization.museum",
      "civilwar.museum",
      "clinton.museum",
      "clock.museum",
      "coal.museum",
      "coastaldefence.museum",
      "cody.museum",
      "coldwar.museum",
      "collection.museum",
      "colonialwilliamsburg.museum",
      "coloradoplateau.museum",
      "columbia.museum",
      "columbus.museum",
      "communication.museum",
      "communications.museum",
      "community.museum",
      "computer.museum",
      "computerhistory.museum",
      "comunica\xE7\xF5es.museum",
      "contemporary.museum",
      "contemporaryart.museum",
      "convent.museum",
      "copenhagen.museum",
      "corporation.museum",
      "correios-e-telecomunica\xE7\xF5es.museum",
      "corvette.museum",
      "costume.museum",
      "countryestate.museum",
      "county.museum",
      "crafts.museum",
      "cranbrook.museum",
      "creation.museum",
      "cultural.museum",
      "culturalcenter.museum",
      "culture.museum",
      "cyber.museum",
      "cymru.museum",
      "dali.museum",
      "dallas.museum",
      "database.museum",
      "ddr.museum",
      "decorativearts.museum",
      "delaware.museum",
      "delmenhorst.museum",
      "denmark.museum",
      "depot.museum",
      "design.museum",
      "detroit.museum",
      "dinosaur.museum",
      "discovery.museum",
      "dolls.museum",
      "donostia.museum",
      "durham.museum",
      "eastafrica.museum",
      "eastcoast.museum",
      "education.museum",
      "educational.museum",
      "egyptian.museum",
      "eisenbahn.museum",
      "elburg.museum",
      "elvendrell.museum",
      "embroidery.museum",
      "encyclopedic.museum",
      "england.museum",
      "entomology.museum",
      "environment.museum",
      "environmentalconservation.museum",
      "epilepsy.museum",
      "essex.museum",
      "estate.museum",
      "ethnology.museum",
      "exeter.museum",
      "exhibition.museum",
      "family.museum",
      "farm.museum",
      "farmequipment.museum",
      "farmers.museum",
      "farmstead.museum",
      "field.museum",
      "figueres.museum",
      "filatelia.museum",
      "film.museum",
      "fineart.museum",
      "finearts.museum",
      "finland.museum",
      "flanders.museum",
      "florida.museum",
      "force.museum",
      "fortmissoula.museum",
      "fortworth.museum",
      "foundation.museum",
      "francaise.museum",
      "frankfurt.museum",
      "franziskaner.museum",
      "freemasonry.museum",
      "freiburg.museum",
      "fribourg.museum",
      "frog.museum",
      "fundacio.museum",
      "furniture.museum",
      "gallery.museum",
      "garden.museum",
      "gateway.museum",
      "geelvinck.museum",
      "gemological.museum",
      "geology.museum",
      "georgia.museum",
      "giessen.museum",
      "glas.museum",
      "glass.museum",
      "gorge.museum",
      "grandrapids.museum",
      "graz.museum",
      "guernsey.museum",
      "halloffame.museum",
      "hamburg.museum",
      "handson.museum",
      "harvestcelebration.museum",
      "hawaii.museum",
      "health.museum",
      "heimatunduhren.museum",
      "hellas.museum",
      "helsinki.museum",
      "hembygdsforbund.museum",
      "heritage.museum",
      "histoire.museum",
      "historical.museum",
      "historicalsociety.museum",
      "historichouses.museum",
      "historisch.museum",
      "historisches.museum",
      "history.museum",
      "historyofscience.museum",
      "horology.museum",
      "house.museum",
      "humanities.museum",
      "illustration.museum",
      "imageandsound.museum",
      "indian.museum",
      "indiana.museum",
      "indianapolis.museum",
      "indianmarket.museum",
      "intelligence.museum",
      "interactive.museum",
      "iraq.museum",
      "iron.museum",
      "isleofman.museum",
      "jamison.museum",
      "jefferson.museum",
      "jerusalem.museum",
      "jewelry.museum",
      "jewish.museum",
      "jewishart.museum",
      "jfk.museum",
      "journalism.museum",
      "judaica.museum",
      "judygarland.museum",
      "juedisches.museum",
      "juif.museum",
      "karate.museum",
      "karikatur.museum",
      "kids.museum",
      "koebenhavn.museum",
      "koeln.museum",
      "kunst.museum",
      "kunstsammlung.museum",
      "kunstunddesign.museum",
      "labor.museum",
      "labour.museum",
      "lajolla.museum",
      "lancashire.museum",
      "landes.museum",
      "lans.museum",
      "l\xE4ns.museum",
      "larsson.museum",
      "lewismiller.museum",
      "lincoln.museum",
      "linz.museum",
      "living.museum",
      "livinghistory.museum",
      "localhistory.museum",
      "london.museum",
      "losangeles.museum",
      "louvre.museum",
      "loyalist.museum",
      "lucerne.museum",
      "luxembourg.museum",
      "luzern.museum",
      "mad.museum",
      "madrid.museum",
      "mallorca.museum",
      "manchester.museum",
      "mansion.museum",
      "mansions.museum",
      "manx.museum",
      "marburg.museum",
      "maritime.museum",
      "maritimo.museum",
      "maryland.museum",
      "marylhurst.museum",
      "media.museum",
      "medical.museum",
      "medizinhistorisches.museum",
      "meeres.museum",
      "memorial.museum",
      "mesaverde.museum",
      "michigan.museum",
      "midatlantic.museum",
      "military.museum",
      "mill.museum",
      "miners.museum",
      "mining.museum",
      "minnesota.museum",
      "missile.museum",
      "missoula.museum",
      "modern.museum",
      "moma.museum",
      "money.museum",
      "monmouth.museum",
      "monticello.museum",
      "montreal.museum",
      "moscow.museum",
      "motorcycle.museum",
      "muenchen.museum",
      "muenster.museum",
      "mulhouse.museum",
      "muncie.museum",
      "museet.museum",
      "museumcenter.museum",
      "museumvereniging.museum",
      "music.museum",
      "national.museum",
      "nationalfirearms.museum",
      "nationalheritage.museum",
      "nativeamerican.museum",
      "naturalhistory.museum",
      "naturalhistorymuseum.museum",
      "naturalsciences.museum",
      "nature.museum",
      "naturhistorisches.museum",
      "natuurwetenschappen.museum",
      "naumburg.museum",
      "naval.museum",
      "nebraska.museum",
      "neues.museum",
      "newhampshire.museum",
      "newjersey.museum",
      "newmexico.museum",
      "newport.museum",
      "newspaper.museum",
      "newyork.museum",
      "niepce.museum",
      "norfolk.museum",
      "north.museum",
      "nrw.museum",
      "nyc.museum",
      "nyny.museum",
      "oceanographic.museum",
      "oceanographique.museum",
      "omaha.museum",
      "online.museum",
      "ontario.museum",
      "openair.museum",
      "oregon.museum",
      "oregontrail.museum",
      "otago.museum",
      "oxford.museum",
      "pacific.museum",
      "paderborn.museum",
      "palace.museum",
      "paleo.museum",
      "palmsprings.museum",
      "panama.museum",
      "paris.museum",
      "pasadena.museum",
      "pharmacy.museum",
      "philadelphia.museum",
      "philadelphiaarea.museum",
      "philately.museum",
      "phoenix.museum",
      "photography.museum",
      "pilots.museum",
      "pittsburgh.museum",
      "planetarium.museum",
      "plantation.museum",
      "plants.museum",
      "plaza.museum",
      "portal.museum",
      "portland.museum",
      "portlligat.museum",
      "posts-and-telecommunications.museum",
      "preservation.museum",
      "presidio.museum",
      "press.museum",
      "project.museum",
      "public.museum",
      "pubol.museum",
      "quebec.museum",
      "railroad.museum",
      "railway.museum",
      "research.museum",
      "resistance.museum",
      "riodejaneiro.museum",
      "rochester.museum",
      "rockart.museum",
      "roma.museum",
      "russia.museum",
      "saintlouis.museum",
      "salem.museum",
      "salvadordali.museum",
      "salzburg.museum",
      "sandiego.museum",
      "sanfrancisco.museum",
      "santabarbara.museum",
      "santacruz.museum",
      "santafe.museum",
      "saskatchewan.museum",
      "satx.museum",
      "savannahga.museum",
      "schlesisches.museum",
      "schoenbrunn.museum",
      "schokoladen.museum",
      "school.museum",
      "schweiz.museum",
      "science.museum",
      "scienceandhistory.museum",
      "scienceandindustry.museum",
      "sciencecenter.museum",
      "sciencecenters.museum",
      "science-fiction.museum",
      "sciencehistory.museum",
      "sciences.museum",
      "sciencesnaturelles.museum",
      "scotland.museum",
      "seaport.museum",
      "settlement.museum",
      "settlers.museum",
      "shell.museum",
      "sherbrooke.museum",
      "sibenik.museum",
      "silk.museum",
      "ski.museum",
      "skole.museum",
      "society.museum",
      "sologne.museum",
      "soundandvision.museum",
      "southcarolina.museum",
      "southwest.museum",
      "space.museum",
      "spy.museum",
      "square.museum",
      "stadt.museum",
      "stalbans.museum",
      "starnberg.museum",
      "state.museum",
      "stateofdelaware.museum",
      "station.museum",
      "steam.museum",
      "steiermark.museum",
      "stjohn.museum",
      "stockholm.museum",
      "stpetersburg.museum",
      "stuttgart.museum",
      "suisse.museum",
      "surgeonshall.museum",
      "surrey.museum",
      "svizzera.museum",
      "sweden.museum",
      "sydney.museum",
      "tank.museum",
      "tcm.museum",
      "technology.museum",
      "telekommunikation.museum",
      "television.museum",
      "texas.museum",
      "textile.museum",
      "theater.museum",
      "time.museum",
      "timekeeping.museum",
      "topology.museum",
      "torino.museum",
      "touch.museum",
      "town.museum",
      "transport.museum",
      "tree.museum",
      "trolley.museum",
      "trust.museum",
      "trustee.museum",
      "uhren.museum",
      "ulm.museum",
      "undersea.museum",
      "university.museum",
      "usa.museum",
      "usantiques.museum",
      "usarts.museum",
      "uscountryestate.museum",
      "usculture.museum",
      "usdecorativearts.museum",
      "usgarden.museum",
      "ushistory.museum",
      "ushuaia.museum",
      "uslivinghistory.museum",
      "utah.museum",
      "uvic.museum",
      "valley.museum",
      "vantaa.museum",
      "versailles.museum",
      "viking.museum",
      "village.museum",
      "virginia.museum",
      "virtual.museum",
      "virtuel.museum",
      "vlaanderen.museum",
      "volkenkunde.museum",
      "wales.museum",
      "wallonie.museum",
      "war.museum",
      "washingtondc.museum",
      "watchandclock.museum",
      "watch-and-clock.museum",
      "western.museum",
      "westfalen.museum",
      "whaling.museum",
      "wildlife.museum",
      "williamsburg.museum",
      "windmill.museum",
      "workshop.museum",
      "york.museum",
      "yorkshire.museum",
      "yosemite.museum",
      "youth.museum",
      "zoological.museum",
      "zoology.museum",
      "\u05D9\u05E8\u05D5\u05E9\u05DC\u05D9\u05DD.museum",
      "\u0438\u043A\u043E\u043C.museum",
      "mv",
      "aero.mv",
      "biz.mv",
      "com.mv",
      "coop.mv",
      "edu.mv",
      "gov.mv",
      "info.mv",
      "int.mv",
      "mil.mv",
      "museum.mv",
      "name.mv",
      "net.mv",
      "org.mv",
      "pro.mv",
      "mw",
      "ac.mw",
      "biz.mw",
      "co.mw",
      "com.mw",
      "coop.mw",
      "edu.mw",
      "gov.mw",
      "int.mw",
      "museum.mw",
      "net.mw",
      "org.mw",
      "mx",
      "com.mx",
      "org.mx",
      "gob.mx",
      "edu.mx",
      "net.mx",
      "my",
      "com.my",
      "net.my",
      "org.my",
      "gov.my",
      "edu.my",
      "mil.my",
      "name.my",
      "mz",
      "ac.mz",
      "adv.mz",
      "co.mz",
      "edu.mz",
      "gov.mz",
      "mil.mz",
      "net.mz",
      "org.mz",
      "na",
      "info.na",
      "pro.na",
      "name.na",
      "school.na",
      "or.na",
      "dr.na",
      "us.na",
      "mx.na",
      "ca.na",
      "in.na",
      "cc.na",
      "tv.na",
      "ws.na",
      "mobi.na",
      "co.na",
      "com.na",
      "org.na",
      "name",
      "nc",
      "asso.nc",
      "nom.nc",
      "ne",
      "net",
      "nf",
      "com.nf",
      "net.nf",
      "per.nf",
      "rec.nf",
      "web.nf",
      "arts.nf",
      "firm.nf",
      "info.nf",
      "other.nf",
      "store.nf",
      "ng",
      "com.ng",
      "edu.ng",
      "gov.ng",
      "i.ng",
      "mil.ng",
      "mobi.ng",
      "name.ng",
      "net.ng",
      "org.ng",
      "sch.ng",
      "ni",
      "ac.ni",
      "biz.ni",
      "co.ni",
      "com.ni",
      "edu.ni",
      "gob.ni",
      "in.ni",
      "info.ni",
      "int.ni",
      "mil.ni",
      "net.ni",
      "nom.ni",
      "org.ni",
      "web.ni",
      "nl",
      "no",
      "fhs.no",
      "vgs.no",
      "fylkesbibl.no",
      "folkebibl.no",
      "museum.no",
      "idrett.no",
      "priv.no",
      "mil.no",
      "stat.no",
      "dep.no",
      "kommune.no",
      "herad.no",
      "aa.no",
      "ah.no",
      "bu.no",
      "fm.no",
      "hl.no",
      "hm.no",
      "jan-mayen.no",
      "mr.no",
      "nl.no",
      "nt.no",
      "of.no",
      "ol.no",
      "oslo.no",
      "rl.no",
      "sf.no",
      "st.no",
      "svalbard.no",
      "tm.no",
      "tr.no",
      "va.no",
      "vf.no",
      "gs.aa.no",
      "gs.ah.no",
      "gs.bu.no",
      "gs.fm.no",
      "gs.hl.no",
      "gs.hm.no",
      "gs.jan-mayen.no",
      "gs.mr.no",
      "gs.nl.no",
      "gs.nt.no",
      "gs.of.no",
      "gs.ol.no",
      "gs.oslo.no",
      "gs.rl.no",
      "gs.sf.no",
      "gs.st.no",
      "gs.svalbard.no",
      "gs.tm.no",
      "gs.tr.no",
      "gs.va.no",
      "gs.vf.no",
      "akrehamn.no",
      "\xE5krehamn.no",
      "algard.no",
      "\xE5lg\xE5rd.no",
      "arna.no",
      "brumunddal.no",
      "bryne.no",
      "bronnoysund.no",
      "br\xF8nn\xF8ysund.no",
      "drobak.no",
      "dr\xF8bak.no",
      "egersund.no",
      "fetsund.no",
      "floro.no",
      "flor\xF8.no",
      "fredrikstad.no",
      "hokksund.no",
      "honefoss.no",
      "h\xF8nefoss.no",
      "jessheim.no",
      "jorpeland.no",
      "j\xF8rpeland.no",
      "kirkenes.no",
      "kopervik.no",
      "krokstadelva.no",
      "langevag.no",
      "langev\xE5g.no",
      "leirvik.no",
      "mjondalen.no",
      "mj\xF8ndalen.no",
      "mo-i-rana.no",
      "mosjoen.no",
      "mosj\xF8en.no",
      "nesoddtangen.no",
      "orkanger.no",
      "osoyro.no",
      "os\xF8yro.no",
      "raholt.no",
      "r\xE5holt.no",
      "sandnessjoen.no",
      "sandnessj\xF8en.no",
      "skedsmokorset.no",
      "slattum.no",
      "spjelkavik.no",
      "stathelle.no",
      "stavern.no",
      "stjordalshalsen.no",
      "stj\xF8rdalshalsen.no",
      "tananger.no",
      "tranby.no",
      "vossevangen.no",
      "afjord.no",
      "\xE5fjord.no",
      "agdenes.no",
      "al.no",
      "\xE5l.no",
      "alesund.no",
      "\xE5lesund.no",
      "alstahaug.no",
      "alta.no",
      "\xE1lt\xE1.no",
      "alaheadju.no",
      "\xE1laheadju.no",
      "alvdal.no",
      "amli.no",
      "\xE5mli.no",
      "amot.no",
      "\xE5mot.no",
      "andebu.no",
      "andoy.no",
      "and\xF8y.no",
      "andasuolo.no",
      "ardal.no",
      "\xE5rdal.no",
      "aremark.no",
      "arendal.no",
      "\xE5s.no",
      "aseral.no",
      "\xE5seral.no",
      "asker.no",
      "askim.no",
      "askvoll.no",
      "askoy.no",
      "ask\xF8y.no",
      "asnes.no",
      "\xE5snes.no",
      "audnedaln.no",
      "aukra.no",
      "aure.no",
      "aurland.no",
      "aurskog-holand.no",
      "aurskog-h\xF8land.no",
      "austevoll.no",
      "austrheim.no",
      "averoy.no",
      "aver\xF8y.no",
      "balestrand.no",
      "ballangen.no",
      "balat.no",
      "b\xE1l\xE1t.no",
      "balsfjord.no",
      "bahccavuotna.no",
      "b\xE1hccavuotna.no",
      "bamble.no",
      "bardu.no",
      "beardu.no",
      "beiarn.no",
      "bajddar.no",
      "b\xE1jddar.no",
      "baidar.no",
      "b\xE1id\xE1r.no",
      "berg.no",
      "bergen.no",
      "berlevag.no",
      "berlev\xE5g.no",
      "bearalvahki.no",
      "bearalv\xE1hki.no",
      "bindal.no",
      "birkenes.no",
      "bjarkoy.no",
      "bjark\xF8y.no",
      "bjerkreim.no",
      "bjugn.no",
      "bodo.no",
      "bod\xF8.no",
      "badaddja.no",
      "b\xE5d\xE5ddj\xE5.no",
      "budejju.no",
      "bokn.no",
      "bremanger.no",
      "bronnoy.no",
      "br\xF8nn\xF8y.no",
      "bygland.no",
      "bykle.no",
      "barum.no",
      "b\xE6rum.no",
      "bo.telemark.no",
      "b\xF8.telemark.no",
      "bo.nordland.no",
      "b\xF8.nordland.no",
      "bievat.no",
      "biev\xE1t.no",
      "bomlo.no",
      "b\xF8mlo.no",
      "batsfjord.no",
      "b\xE5tsfjord.no",
      "bahcavuotna.no",
      "b\xE1hcavuotna.no",
      "dovre.no",
      "drammen.no",
      "drangedal.no",
      "dyroy.no",
      "dyr\xF8y.no",
      "donna.no",
      "d\xF8nna.no",
      "eid.no",
      "eidfjord.no",
      "eidsberg.no",
      "eidskog.no",
      "eidsvoll.no",
      "eigersund.no",
      "elverum.no",
      "enebakk.no",
      "engerdal.no",
      "etne.no",
      "etnedal.no",
      "evenes.no",
      "evenassi.no",
      "even\xE1\u0161\u0161i.no",
      "evje-og-hornnes.no",
      "farsund.no",
      "fauske.no",
      "fuossko.no",
      "fuoisku.no",
      "fedje.no",
      "fet.no",
      "finnoy.no",
      "finn\xF8y.no",
      "fitjar.no",
      "fjaler.no",
      "fjell.no",
      "flakstad.no",
      "flatanger.no",
      "flekkefjord.no",
      "flesberg.no",
      "flora.no",
      "fla.no",
      "fl\xE5.no",
      "folldal.no",
      "forsand.no",
      "fosnes.no",
      "frei.no",
      "frogn.no",
      "froland.no",
      "frosta.no",
      "frana.no",
      "fr\xE6na.no",
      "froya.no",
      "fr\xF8ya.no",
      "fusa.no",
      "fyresdal.no",
      "forde.no",
      "f\xF8rde.no",
      "gamvik.no",
      "gangaviika.no",
      "g\xE1\u014Bgaviika.no",
      "gaular.no",
      "gausdal.no",
      "gildeskal.no",
      "gildesk\xE5l.no",
      "giske.no",
      "gjemnes.no",
      "gjerdrum.no",
      "gjerstad.no",
      "gjesdal.no",
      "gjovik.no",
      "gj\xF8vik.no",
      "gloppen.no",
      "gol.no",
      "gran.no",
      "grane.no",
      "granvin.no",
      "gratangen.no",
      "grimstad.no",
      "grong.no",
      "kraanghke.no",
      "kr\xE5anghke.no",
      "grue.no",
      "gulen.no",
      "hadsel.no",
      "halden.no",
      "halsa.no",
      "hamar.no",
      "hamaroy.no",
      "habmer.no",
      "h\xE1bmer.no",
      "hapmir.no",
      "h\xE1pmir.no",
      "hammerfest.no",
      "hammarfeasta.no",
      "h\xE1mm\xE1rfeasta.no",
      "haram.no",
      "hareid.no",
      "harstad.no",
      "hasvik.no",
      "aknoluokta.no",
      "\xE1k\u014Boluokta.no",
      "hattfjelldal.no",
      "aarborte.no",
      "haugesund.no",
      "hemne.no",
      "hemnes.no",
      "hemsedal.no",
      "heroy.more-og-romsdal.no",
      "her\xF8y.m\xF8re-og-romsdal.no",
      "heroy.nordland.no",
      "her\xF8y.nordland.no",
      "hitra.no",
      "hjartdal.no",
      "hjelmeland.no",
      "hobol.no",
      "hob\xF8l.no",
      "hof.no",
      "hol.no",
      "hole.no",
      "holmestrand.no",
      "holtalen.no",
      "holt\xE5len.no",
      "hornindal.no",
      "horten.no",
      "hurdal.no",
      "hurum.no",
      "hvaler.no",
      "hyllestad.no",
      "hagebostad.no",
      "h\xE6gebostad.no",
      "hoyanger.no",
      "h\xF8yanger.no",
      "hoylandet.no",
      "h\xF8ylandet.no",
      "ha.no",
      "h\xE5.no",
      "ibestad.no",
      "inderoy.no",
      "inder\xF8y.no",
      "iveland.no",
      "jevnaker.no",
      "jondal.no",
      "jolster.no",
      "j\xF8lster.no",
      "karasjok.no",
      "karasjohka.no",
      "k\xE1r\xE1\u0161johka.no",
      "karlsoy.no",
      "galsa.no",
      "g\xE1ls\xE1.no",
      "karmoy.no",
      "karm\xF8y.no",
      "kautokeino.no",
      "guovdageaidnu.no",
      "klepp.no",
      "klabu.no",
      "kl\xE6bu.no",
      "kongsberg.no",
      "kongsvinger.no",
      "kragero.no",
      "krager\xF8.no",
      "kristiansand.no",
      "kristiansund.no",
      "krodsherad.no",
      "kr\xF8dsherad.no",
      "kvalsund.no",
      "rahkkeravju.no",
      "r\xE1hkker\xE1vju.no",
      "kvam.no",
      "kvinesdal.no",
      "kvinnherad.no",
      "kviteseid.no",
      "kvitsoy.no",
      "kvits\xF8y.no",
      "kvafjord.no",
      "kv\xE6fjord.no",
      "giehtavuoatna.no",
      "kvanangen.no",
      "kv\xE6nangen.no",
      "navuotna.no",
      "n\xE1vuotna.no",
      "kafjord.no",
      "k\xE5fjord.no",
      "gaivuotna.no",
      "g\xE1ivuotna.no",
      "larvik.no",
      "lavangen.no",
      "lavagis.no",
      "loabat.no",
      "loab\xE1t.no",
      "lebesby.no",
      "davvesiida.no",
      "leikanger.no",
      "leirfjord.no",
      "leka.no",
      "leksvik.no",
      "lenvik.no",
      "leangaviika.no",
      "lea\u014Bgaviika.no",
      "lesja.no",
      "levanger.no",
      "lier.no",
      "lierne.no",
      "lillehammer.no",
      "lillesand.no",
      "lindesnes.no",
      "lindas.no",
      "lind\xE5s.no",
      "lom.no",
      "loppa.no",
      "lahppi.no",
      "l\xE1hppi.no",
      "lund.no",
      "lunner.no",
      "luroy.no",
      "lur\xF8y.no",
      "luster.no",
      "lyngdal.no",
      "lyngen.no",
      "ivgu.no",
      "lardal.no",
      "lerdal.no",
      "l\xE6rdal.no",
      "lodingen.no",
      "l\xF8dingen.no",
      "lorenskog.no",
      "l\xF8renskog.no",
      "loten.no",
      "l\xF8ten.no",
      "malvik.no",
      "masoy.no",
      "m\xE5s\xF8y.no",
      "muosat.no",
      "muos\xE1t.no",
      "mandal.no",
      "marker.no",
      "marnardal.no",
      "masfjorden.no",
      "meland.no",
      "meldal.no",
      "melhus.no",
      "meloy.no",
      "mel\xF8y.no",
      "meraker.no",
      "mer\xE5ker.no",
      "moareke.no",
      "mo\xE5reke.no",
      "midsund.no",
      "midtre-gauldal.no",
      "modalen.no",
      "modum.no",
      "molde.no",
      "moskenes.no",
      "moss.no",
      "mosvik.no",
      "malselv.no",
      "m\xE5lselv.no",
      "malatvuopmi.no",
      "m\xE1latvuopmi.no",
      "namdalseid.no",
      "aejrie.no",
      "namsos.no",
      "namsskogan.no",
      "naamesjevuemie.no",
      "n\xE5\xE5mesjevuemie.no",
      "laakesvuemie.no",
      "nannestad.no",
      "narvik.no",
      "narviika.no",
      "naustdal.no",
      "nedre-eiker.no",
      "nes.akershus.no",
      "nes.buskerud.no",
      "nesna.no",
      "nesodden.no",
      "nesseby.no",
      "unjarga.no",
      "unj\xE1rga.no",
      "nesset.no",
      "nissedal.no",
      "nittedal.no",
      "nord-aurdal.no",
      "nord-fron.no",
      "nord-odal.no",
      "norddal.no",
      "nordkapp.no",
      "davvenjarga.no",
      "davvenj\xE1rga.no",
      "nordre-land.no",
      "nordreisa.no",
      "raisa.no",
      "r\xE1isa.no",
      "nore-og-uvdal.no",
      "notodden.no",
      "naroy.no",
      "n\xE6r\xF8y.no",
      "notteroy.no",
      "n\xF8tter\xF8y.no",
      "odda.no",
      "oksnes.no",
      "\xF8ksnes.no",
      "oppdal.no",
      "oppegard.no",
      "oppeg\xE5rd.no",
      "orkdal.no",
      "orland.no",
      "\xF8rland.no",
      "orskog.no",
      "\xF8rskog.no",
      "orsta.no",
      "\xF8rsta.no",
      "os.hedmark.no",
      "os.hordaland.no",
      "osen.no",
      "osteroy.no",
      "oster\xF8y.no",
      "ostre-toten.no",
      "\xF8stre-toten.no",
      "overhalla.no",
      "ovre-eiker.no",
      "\xF8vre-eiker.no",
      "oyer.no",
      "\xF8yer.no",
      "oygarden.no",
      "\xF8ygarden.no",
      "oystre-slidre.no",
      "\xF8ystre-slidre.no",
      "porsanger.no",
      "porsangu.no",
      "pors\xE1\u014Bgu.no",
      "porsgrunn.no",
      "radoy.no",
      "rad\xF8y.no",
      "rakkestad.no",
      "rana.no",
      "ruovat.no",
      "randaberg.no",
      "rauma.no",
      "rendalen.no",
      "rennebu.no",
      "rennesoy.no",
      "rennes\xF8y.no",
      "rindal.no",
      "ringebu.no",
      "ringerike.no",
      "ringsaker.no",
      "rissa.no",
      "risor.no",
      "ris\xF8r.no",
      "roan.no",
      "rollag.no",
      "rygge.no",
      "ralingen.no",
      "r\xE6lingen.no",
      "rodoy.no",
      "r\xF8d\xF8y.no",
      "romskog.no",
      "r\xF8mskog.no",
      "roros.no",
      "r\xF8ros.no",
      "rost.no",
      "r\xF8st.no",
      "royken.no",
      "r\xF8yken.no",
      "royrvik.no",
      "r\xF8yrvik.no",
      "rade.no",
      "r\xE5de.no",
      "salangen.no",
      "siellak.no",
      "saltdal.no",
      "salat.no",
      "s\xE1l\xE1t.no",
      "s\xE1lat.no",
      "samnanger.no",
      "sande.more-og-romsdal.no",
      "sande.m\xF8re-og-romsdal.no",
      "sande.vestfold.no",
      "sandefjord.no",
      "sandnes.no",
      "sandoy.no",
      "sand\xF8y.no",
      "sarpsborg.no",
      "sauda.no",
      "sauherad.no",
      "sel.no",
      "selbu.no",
      "selje.no",
      "seljord.no",
      "sigdal.no",
      "siljan.no",
      "sirdal.no",
      "skaun.no",
      "skedsmo.no",
      "ski.no",
      "skien.no",
      "skiptvet.no",
      "skjervoy.no",
      "skjerv\xF8y.no",
      "skierva.no",
      "skierv\xE1.no",
      "skjak.no",
      "skj\xE5k.no",
      "skodje.no",
      "skanland.no",
      "sk\xE5nland.no",
      "skanit.no",
      "sk\xE1nit.no",
      "smola.no",
      "sm\xF8la.no",
      "snillfjord.no",
      "snasa.no",
      "sn\xE5sa.no",
      "snoasa.no",
      "snaase.no",
      "sn\xE5ase.no",
      "sogndal.no",
      "sokndal.no",
      "sola.no",
      "solund.no",
      "songdalen.no",
      "sortland.no",
      "spydeberg.no",
      "stange.no",
      "stavanger.no",
      "steigen.no",
      "steinkjer.no",
      "stjordal.no",
      "stj\xF8rdal.no",
      "stokke.no",
      "stor-elvdal.no",
      "stord.no",
      "stordal.no",
      "storfjord.no",
      "omasvuotna.no",
      "strand.no",
      "stranda.no",
      "stryn.no",
      "sula.no",
      "suldal.no",
      "sund.no",
      "sunndal.no",
      "surnadal.no",
      "sveio.no",
      "svelvik.no",
      "sykkylven.no",
      "sogne.no",
      "s\xF8gne.no",
      "somna.no",
      "s\xF8mna.no",
      "sondre-land.no",
      "s\xF8ndre-land.no",
      "sor-aurdal.no",
      "s\xF8r-aurdal.no",
      "sor-fron.no",
      "s\xF8r-fron.no",
      "sor-odal.no",
      "s\xF8r-odal.no",
      "sor-varanger.no",
      "s\xF8r-varanger.no",
      "matta-varjjat.no",
      "m\xE1tta-v\xE1rjjat.no",
      "sorfold.no",
      "s\xF8rfold.no",
      "sorreisa.no",
      "s\xF8rreisa.no",
      "sorum.no",
      "s\xF8rum.no",
      "tana.no",
      "deatnu.no",
      "time.no",
      "tingvoll.no",
      "tinn.no",
      "tjeldsund.no",
      "dielddanuorri.no",
      "tjome.no",
      "tj\xF8me.no",
      "tokke.no",
      "tolga.no",
      "torsken.no",
      "tranoy.no",
      "tran\xF8y.no",
      "tromso.no",
      "troms\xF8.no",
      "tromsa.no",
      "romsa.no",
      "trondheim.no",
      "troandin.no",
      "trysil.no",
      "trana.no",
      "tr\xE6na.no",
      "trogstad.no",
      "tr\xF8gstad.no",
      "tvedestrand.no",
      "tydal.no",
      "tynset.no",
      "tysfjord.no",
      "divtasvuodna.no",
      "divttasvuotna.no",
      "tysnes.no",
      "tysvar.no",
      "tysv\xE6r.no",
      "tonsberg.no",
      "t\xF8nsberg.no",
      "ullensaker.no",
      "ullensvang.no",
      "ulvik.no",
      "utsira.no",
      "vadso.no",
      "vads\xF8.no",
      "cahcesuolo.no",
      "\u010D\xE1hcesuolo.no",
      "vaksdal.no",
      "valle.no",
      "vang.no",
      "vanylven.no",
      "vardo.no",
      "vard\xF8.no",
      "varggat.no",
      "v\xE1rgg\xE1t.no",
      "vefsn.no",
      "vaapste.no",
      "vega.no",
      "vegarshei.no",
      "veg\xE5rshei.no",
      "vennesla.no",
      "verdal.no",
      "verran.no",
      "vestby.no",
      "vestnes.no",
      "vestre-slidre.no",
      "vestre-toten.no",
      "vestvagoy.no",
      "vestv\xE5g\xF8y.no",
      "vevelstad.no",
      "vik.no",
      "vikna.no",
      "vindafjord.no",
      "volda.no",
      "voss.no",
      "varoy.no",
      "v\xE6r\xF8y.no",
      "vagan.no",
      "v\xE5gan.no",
      "voagat.no",
      "vagsoy.no",
      "v\xE5gs\xF8y.no",
      "vaga.no",
      "v\xE5g\xE5.no",
      "valer.ostfold.no",
      "v\xE5ler.\xF8stfold.no",
      "valer.hedmark.no",
      "v\xE5ler.hedmark.no",
      "*.np",
      "nr",
      "biz.nr",
      "info.nr",
      "gov.nr",
      "edu.nr",
      "org.nr",
      "net.nr",
      "com.nr",
      "nu",
      "nz",
      "ac.nz",
      "co.nz",
      "cri.nz",
      "geek.nz",
      "gen.nz",
      "govt.nz",
      "health.nz",
      "iwi.nz",
      "kiwi.nz",
      "maori.nz",
      "mil.nz",
      "m\u0101ori.nz",
      "net.nz",
      "org.nz",
      "parliament.nz",
      "school.nz",
      "om",
      "co.om",
      "com.om",
      "edu.om",
      "gov.om",
      "med.om",
      "museum.om",
      "net.om",
      "org.om",
      "pro.om",
      "onion",
      "org",
      "pa",
      "ac.pa",
      "gob.pa",
      "com.pa",
      "org.pa",
      "sld.pa",
      "edu.pa",
      "net.pa",
      "ing.pa",
      "abo.pa",
      "med.pa",
      "nom.pa",
      "pe",
      "edu.pe",
      "gob.pe",
      "nom.pe",
      "mil.pe",
      "org.pe",
      "com.pe",
      "net.pe",
      "pf",
      "com.pf",
      "org.pf",
      "edu.pf",
      "*.pg",
      "ph",
      "com.ph",
      "net.ph",
      "org.ph",
      "gov.ph",
      "edu.ph",
      "ngo.ph",
      "mil.ph",
      "i.ph",
      "pk",
      "com.pk",
      "net.pk",
      "edu.pk",
      "org.pk",
      "fam.pk",
      "biz.pk",
      "web.pk",
      "gov.pk",
      "gob.pk",
      "gok.pk",
      "gon.pk",
      "gop.pk",
      "gos.pk",
      "info.pk",
      "pl",
      "com.pl",
      "net.pl",
      "org.pl",
      "aid.pl",
      "agro.pl",
      "atm.pl",
      "auto.pl",
      "biz.pl",
      "edu.pl",
      "gmina.pl",
      "gsm.pl",
      "info.pl",
      "mail.pl",
      "miasta.pl",
      "media.pl",
      "mil.pl",
      "nieruchomosci.pl",
      "nom.pl",
      "pc.pl",
      "powiat.pl",
      "priv.pl",
      "realestate.pl",
      "rel.pl",
      "sex.pl",
      "shop.pl",
      "sklep.pl",
      "sos.pl",
      "szkola.pl",
      "targi.pl",
      "tm.pl",
      "tourism.pl",
      "travel.pl",
      "turystyka.pl",
      "gov.pl",
      "ap.gov.pl",
      "ic.gov.pl",
      "is.gov.pl",
      "us.gov.pl",
      "kmpsp.gov.pl",
      "kppsp.gov.pl",
      "kwpsp.gov.pl",
      "psp.gov.pl",
      "wskr.gov.pl",
      "kwp.gov.pl",
      "mw.gov.pl",
      "ug.gov.pl",
      "um.gov.pl",
      "umig.gov.pl",
      "ugim.gov.pl",
      "upow.gov.pl",
      "uw.gov.pl",
      "starostwo.gov.pl",
      "pa.gov.pl",
      "po.gov.pl",
      "psse.gov.pl",
      "pup.gov.pl",
      "rzgw.gov.pl",
      "sa.gov.pl",
      "so.gov.pl",
      "sr.gov.pl",
      "wsa.gov.pl",
      "sko.gov.pl",
      "uzs.gov.pl",
      "wiih.gov.pl",
      "winb.gov.pl",
      "pinb.gov.pl",
      "wios.gov.pl",
      "witd.gov.pl",
      "wzmiuw.gov.pl",
      "piw.gov.pl",
      "wiw.gov.pl",
      "griw.gov.pl",
      "wif.gov.pl",
      "oum.gov.pl",
      "sdn.gov.pl",
      "zp.gov.pl",
      "uppo.gov.pl",
      "mup.gov.pl",
      "wuoz.gov.pl",
      "konsulat.gov.pl",
      "oirm.gov.pl",
      "augustow.pl",
      "babia-gora.pl",
      "bedzin.pl",
      "beskidy.pl",
      "bialowieza.pl",
      "bialystok.pl",
      "bielawa.pl",
      "bieszczady.pl",
      "boleslawiec.pl",
      "bydgoszcz.pl",
      "bytom.pl",
      "cieszyn.pl",
      "czeladz.pl",
      "czest.pl",
      "dlugoleka.pl",
      "elblag.pl",
      "elk.pl",
      "glogow.pl",
      "gniezno.pl",
      "gorlice.pl",
      "grajewo.pl",
      "ilawa.pl",
      "jaworzno.pl",
      "jelenia-gora.pl",
      "jgora.pl",
      "kalisz.pl",
      "kazimierz-dolny.pl",
      "karpacz.pl",
      "kartuzy.pl",
      "kaszuby.pl",
      "katowice.pl",
      "kepno.pl",
      "ketrzyn.pl",
      "klodzko.pl",
      "kobierzyce.pl",
      "kolobrzeg.pl",
      "konin.pl",
      "konskowola.pl",
      "kutno.pl",
      "lapy.pl",
      "lebork.pl",
      "legnica.pl",
      "lezajsk.pl",
      "limanowa.pl",
      "lomza.pl",
      "lowicz.pl",
      "lubin.pl",
      "lukow.pl",
      "malbork.pl",
      "malopolska.pl",
      "mazowsze.pl",
      "mazury.pl",
      "mielec.pl",
      "mielno.pl",
      "mragowo.pl",
      "naklo.pl",
      "nowaruda.pl",
      "nysa.pl",
      "olawa.pl",
      "olecko.pl",
      "olkusz.pl",
      "olsztyn.pl",
      "opoczno.pl",
      "opole.pl",
      "ostroda.pl",
      "ostroleka.pl",
      "ostrowiec.pl",
      "ostrowwlkp.pl",
      "pila.pl",
      "pisz.pl",
      "podhale.pl",
      "podlasie.pl",
      "polkowice.pl",
      "pomorze.pl",
      "pomorskie.pl",
      "prochowice.pl",
      "pruszkow.pl",
      "przeworsk.pl",
      "pulawy.pl",
      "radom.pl",
      "rawa-maz.pl",
      "rybnik.pl",
      "rzeszow.pl",
      "sanok.pl",
      "sejny.pl",
      "slask.pl",
      "slupsk.pl",
      "sosnowiec.pl",
      "stalowa-wola.pl",
      "skoczow.pl",
      "starachowice.pl",
      "stargard.pl",
      "suwalki.pl",
      "swidnica.pl",
      "swiebodzin.pl",
      "swinoujscie.pl",
      "szczecin.pl",
      "szczytno.pl",
      "tarnobrzeg.pl",
      "tgory.pl",
      "turek.pl",
      "tychy.pl",
      "ustka.pl",
      "walbrzych.pl",
      "warmia.pl",
      "warszawa.pl",
      "waw.pl",
      "wegrow.pl",
      "wielun.pl",
      "wlocl.pl",
      "wloclawek.pl",
      "wodzislaw.pl",
      "wolomin.pl",
      "wroclaw.pl",
      "zachpomor.pl",
      "zagan.pl",
      "zarow.pl",
      "zgora.pl",
      "zgorzelec.pl",
      "pm",
      "pn",
      "gov.pn",
      "co.pn",
      "org.pn",
      "edu.pn",
      "net.pn",
      "post",
      "pr",
      "com.pr",
      "net.pr",
      "org.pr",
      "gov.pr",
      "edu.pr",
      "isla.pr",
      "pro.pr",
      "biz.pr",
      "info.pr",
      "name.pr",
      "est.pr",
      "prof.pr",
      "ac.pr",
      "pro",
      "aaa.pro",
      "aca.pro",
      "acct.pro",
      "avocat.pro",
      "bar.pro",
      "cpa.pro",
      "eng.pro",
      "jur.pro",
      "law.pro",
      "med.pro",
      "recht.pro",
      "ps",
      "edu.ps",
      "gov.ps",
      "sec.ps",
      "plo.ps",
      "com.ps",
      "org.ps",
      "net.ps",
      "pt",
      "net.pt",
      "gov.pt",
      "org.pt",
      "edu.pt",
      "int.pt",
      "publ.pt",
      "com.pt",
      "nome.pt",
      "pw",
      "co.pw",
      "ne.pw",
      "or.pw",
      "ed.pw",
      "go.pw",
      "belau.pw",
      "py",
      "com.py",
      "coop.py",
      "edu.py",
      "gov.py",
      "mil.py",
      "net.py",
      "org.py",
      "qa",
      "com.qa",
      "edu.qa",
      "gov.qa",
      "mil.qa",
      "name.qa",
      "net.qa",
      "org.qa",
      "sch.qa",
      "re",
      "asso.re",
      "com.re",
      "nom.re",
      "ro",
      "arts.ro",
      "com.ro",
      "firm.ro",
      "info.ro",
      "nom.ro",
      "nt.ro",
      "org.ro",
      "rec.ro",
      "store.ro",
      "tm.ro",
      "www.ro",
      "rs",
      "ac.rs",
      "co.rs",
      "edu.rs",
      "gov.rs",
      "in.rs",
      "org.rs",
      "ru",
      "rw",
      "ac.rw",
      "co.rw",
      "coop.rw",
      "gov.rw",
      "mil.rw",
      "net.rw",
      "org.rw",
      "sa",
      "com.sa",
      "net.sa",
      "org.sa",
      "gov.sa",
      "med.sa",
      "pub.sa",
      "edu.sa",
      "sch.sa",
      "sb",
      "com.sb",
      "edu.sb",
      "gov.sb",
      "net.sb",
      "org.sb",
      "sc",
      "com.sc",
      "gov.sc",
      "net.sc",
      "org.sc",
      "edu.sc",
      "sd",
      "com.sd",
      "net.sd",
      "org.sd",
      "edu.sd",
      "med.sd",
      "tv.sd",
      "gov.sd",
      "info.sd",
      "se",
      "a.se",
      "ac.se",
      "b.se",
      "bd.se",
      "brand.se",
      "c.se",
      "d.se",
      "e.se",
      "f.se",
      "fh.se",
      "fhsk.se",
      "fhv.se",
      "g.se",
      "h.se",
      "i.se",
      "k.se",
      "komforb.se",
      "kommunalforbund.se",
      "komvux.se",
      "l.se",
      "lanbib.se",
      "m.se",
      "n.se",
      "naturbruksgymn.se",
      "o.se",
      "org.se",
      "p.se",
      "parti.se",
      "pp.se",
      "press.se",
      "r.se",
      "s.se",
      "t.se",
      "tm.se",
      "u.se",
      "w.se",
      "x.se",
      "y.se",
      "z.se",
      "sg",
      "com.sg",
      "net.sg",
      "org.sg",
      "gov.sg",
      "edu.sg",
      "per.sg",
      "sh",
      "com.sh",
      "net.sh",
      "gov.sh",
      "org.sh",
      "mil.sh",
      "si",
      "sj",
      "sk",
      "sl",
      "com.sl",
      "net.sl",
      "edu.sl",
      "gov.sl",
      "org.sl",
      "sm",
      "sn",
      "art.sn",
      "com.sn",
      "edu.sn",
      "gouv.sn",
      "org.sn",
      "perso.sn",
      "univ.sn",
      "so",
      "com.so",
      "edu.so",
      "gov.so",
      "me.so",
      "net.so",
      "org.so",
      "sr",
      "ss",
      "biz.ss",
      "com.ss",
      "edu.ss",
      "gov.ss",
      "net.ss",
      "org.ss",
      "st",
      "co.st",
      "com.st",
      "consulado.st",
      "edu.st",
      "embaixada.st",
      "gov.st",
      "mil.st",
      "net.st",
      "org.st",
      "principe.st",
      "saotome.st",
      "store.st",
      "su",
      "sv",
      "com.sv",
      "edu.sv",
      "gob.sv",
      "org.sv",
      "red.sv",
      "sx",
      "gov.sx",
      "sy",
      "edu.sy",
      "gov.sy",
      "net.sy",
      "mil.sy",
      "com.sy",
      "org.sy",
      "sz",
      "co.sz",
      "ac.sz",
      "org.sz",
      "tc",
      "td",
      "tel",
      "tf",
      "tg",
      "th",
      "ac.th",
      "co.th",
      "go.th",
      "in.th",
      "mi.th",
      "net.th",
      "or.th",
      "tj",
      "ac.tj",
      "biz.tj",
      "co.tj",
      "com.tj",
      "edu.tj",
      "go.tj",
      "gov.tj",
      "int.tj",
      "mil.tj",
      "name.tj",
      "net.tj",
      "nic.tj",
      "org.tj",
      "test.tj",
      "web.tj",
      "tk",
      "tl",
      "gov.tl",
      "tm",
      "com.tm",
      "co.tm",
      "org.tm",
      "net.tm",
      "nom.tm",
      "gov.tm",
      "mil.tm",
      "edu.tm",
      "tn",
      "com.tn",
      "ens.tn",
      "fin.tn",
      "gov.tn",
      "ind.tn",
      "intl.tn",
      "nat.tn",
      "net.tn",
      "org.tn",
      "info.tn",
      "perso.tn",
      "tourism.tn",
      "edunet.tn",
      "rnrt.tn",
      "rns.tn",
      "rnu.tn",
      "mincom.tn",
      "agrinet.tn",
      "defense.tn",
      "turen.tn",
      "to",
      "com.to",
      "gov.to",
      "net.to",
      "org.to",
      "edu.to",
      "mil.to",
      "tr",
      "av.tr",
      "bbs.tr",
      "bel.tr",
      "biz.tr",
      "com.tr",
      "dr.tr",
      "edu.tr",
      "gen.tr",
      "gov.tr",
      "info.tr",
      "mil.tr",
      "k12.tr",
      "kep.tr",
      "name.tr",
      "net.tr",
      "org.tr",
      "pol.tr",
      "tel.tr",
      "tsk.tr",
      "tv.tr",
      "web.tr",
      "nc.tr",
      "gov.nc.tr",
      "tt",
      "co.tt",
      "com.tt",
      "org.tt",
      "net.tt",
      "biz.tt",
      "info.tt",
      "pro.tt",
      "int.tt",
      "coop.tt",
      "jobs.tt",
      "mobi.tt",
      "travel.tt",
      "museum.tt",
      "aero.tt",
      "name.tt",
      "gov.tt",
      "edu.tt",
      "tv",
      "tw",
      "edu.tw",
      "gov.tw",
      "mil.tw",
      "com.tw",
      "net.tw",
      "org.tw",
      "idv.tw",
      "game.tw",
      "ebiz.tw",
      "club.tw",
      "\u7DB2\u8DEF.tw",
      "\u7D44\u7E54.tw",
      "\u5546\u696D.tw",
      "tz",
      "ac.tz",
      "co.tz",
      "go.tz",
      "hotel.tz",
      "info.tz",
      "me.tz",
      "mil.tz",
      "mobi.tz",
      "ne.tz",
      "or.tz",
      "sc.tz",
      "tv.tz",
      "ua",
      "com.ua",
      "edu.ua",
      "gov.ua",
      "in.ua",
      "net.ua",
      "org.ua",
      "cherkassy.ua",
      "cherkasy.ua",
      "chernigov.ua",
      "chernihiv.ua",
      "chernivtsi.ua",
      "chernovtsy.ua",
      "ck.ua",
      "cn.ua",
      "cr.ua",
      "crimea.ua",
      "cv.ua",
      "dn.ua",
      "dnepropetrovsk.ua",
      "dnipropetrovsk.ua",
      "dominic.ua",
      "donetsk.ua",
      "dp.ua",
      "if.ua",
      "ivano-frankivsk.ua",
      "kh.ua",
      "kharkiv.ua",
      "kharkov.ua",
      "kherson.ua",
      "khmelnitskiy.ua",
      "khmelnytskyi.ua",
      "kiev.ua",
      "kirovograd.ua",
      "km.ua",
      "kr.ua",
      "krym.ua",
      "ks.ua",
      "kv.ua",
      "kyiv.ua",
      "lg.ua",
      "lt.ua",
      "lugansk.ua",
      "lutsk.ua",
      "lv.ua",
      "lviv.ua",
      "mk.ua",
      "mykolaiv.ua",
      "nikolaev.ua",
      "od.ua",
      "odesa.ua",
      "odessa.ua",
      "pl.ua",
      "poltava.ua",
      "rivne.ua",
      "rovno.ua",
      "rv.ua",
      "sb.ua",
      "sebastopol.ua",
      "sevastopol.ua",
      "sm.ua",
      "sumy.ua",
      "te.ua",
      "ternopil.ua",
      "uz.ua",
      "uzhgorod.ua",
      "vinnica.ua",
      "vinnytsia.ua",
      "vn.ua",
      "volyn.ua",
      "yalta.ua",
      "zaporizhzhe.ua",
      "zaporizhzhia.ua",
      "zhitomir.ua",
      "zhytomyr.ua",
      "zp.ua",
      "zt.ua",
      "ug",
      "co.ug",
      "or.ug",
      "ac.ug",
      "sc.ug",
      "go.ug",
      "ne.ug",
      "com.ug",
      "org.ug",
      "uk",
      "ac.uk",
      "co.uk",
      "gov.uk",
      "ltd.uk",
      "me.uk",
      "net.uk",
      "nhs.uk",
      "org.uk",
      "plc.uk",
      "police.uk",
      "*.sch.uk",
      "us",
      "dni.us",
      "fed.us",
      "isa.us",
      "kids.us",
      "nsn.us",
      "ak.us",
      "al.us",
      "ar.us",
      "as.us",
      "az.us",
      "ca.us",
      "co.us",
      "ct.us",
      "dc.us",
      "de.us",
      "fl.us",
      "ga.us",
      "gu.us",
      "hi.us",
      "ia.us",
      "id.us",
      "il.us",
      "in.us",
      "ks.us",
      "ky.us",
      "la.us",
      "ma.us",
      "md.us",
      "me.us",
      "mi.us",
      "mn.us",
      "mo.us",
      "ms.us",
      "mt.us",
      "nc.us",
      "nd.us",
      "ne.us",
      "nh.us",
      "nj.us",
      "nm.us",
      "nv.us",
      "ny.us",
      "oh.us",
      "ok.us",
      "or.us",
      "pa.us",
      "pr.us",
      "ri.us",
      "sc.us",
      "sd.us",
      "tn.us",
      "tx.us",
      "ut.us",
      "vi.us",
      "vt.us",
      "va.us",
      "wa.us",
      "wi.us",
      "wv.us",
      "wy.us",
      "k12.ak.us",
      "k12.al.us",
      "k12.ar.us",
      "k12.as.us",
      "k12.az.us",
      "k12.ca.us",
      "k12.co.us",
      "k12.ct.us",
      "k12.dc.us",
      "k12.de.us",
      "k12.fl.us",
      "k12.ga.us",
      "k12.gu.us",
      "k12.ia.us",
      "k12.id.us",
      "k12.il.us",
      "k12.in.us",
      "k12.ks.us",
      "k12.ky.us",
      "k12.la.us",
      "k12.ma.us",
      "k12.md.us",
      "k12.me.us",
      "k12.mi.us",
      "k12.mn.us",
      "k12.mo.us",
      "k12.ms.us",
      "k12.mt.us",
      "k12.nc.us",
      "k12.ne.us",
      "k12.nh.us",
      "k12.nj.us",
      "k12.nm.us",
      "k12.nv.us",
      "k12.ny.us",
      "k12.oh.us",
      "k12.ok.us",
      "k12.or.us",
      "k12.pa.us",
      "k12.pr.us",
      "k12.ri.us",
      "k12.sc.us",
      "k12.tn.us",
      "k12.tx.us",
      "k12.ut.us",
      "k12.vi.us",
      "k12.vt.us",
      "k12.va.us",
      "k12.wa.us",
      "k12.wi.us",
      "k12.wy.us",
      "cc.ak.us",
      "cc.al.us",
      "cc.ar.us",
      "cc.as.us",
      "cc.az.us",
      "cc.ca.us",
      "cc.co.us",
      "cc.ct.us",
      "cc.dc.us",
      "cc.de.us",
      "cc.fl.us",
      "cc.ga.us",
      "cc.gu.us",
      "cc.hi.us",
      "cc.ia.us",
      "cc.id.us",
      "cc.il.us",
      "cc.in.us",
      "cc.ks.us",
      "cc.ky.us",
      "cc.la.us",
      "cc.ma.us",
      "cc.md.us",
      "cc.me.us",
      "cc.mi.us",
      "cc.mn.us",
      "cc.mo.us",
      "cc.ms.us",
      "cc.mt.us",
      "cc.nc.us",
      "cc.nd.us",
      "cc.ne.us",
      "cc.nh.us",
      "cc.nj.us",
      "cc.nm.us",
      "cc.nv.us",
      "cc.ny.us",
      "cc.oh.us",
      "cc.ok.us",
      "cc.or.us",
      "cc.pa.us",
      "cc.pr.us",
      "cc.ri.us",
      "cc.sc.us",
      "cc.sd.us",
      "cc.tn.us",
      "cc.tx.us",
      "cc.ut.us",
      "cc.vi.us",
      "cc.vt.us",
      "cc.va.us",
      "cc.wa.us",
      "cc.wi.us",
      "cc.wv.us",
      "cc.wy.us",
      "lib.ak.us",
      "lib.al.us",
      "lib.ar.us",
      "lib.as.us",
      "lib.az.us",
      "lib.ca.us",
      "lib.co.us",
      "lib.ct.us",
      "lib.dc.us",
      "lib.fl.us",
      "lib.ga.us",
      "lib.gu.us",
      "lib.hi.us",
      "lib.ia.us",
      "lib.id.us",
      "lib.il.us",
      "lib.in.us",
      "lib.ks.us",
      "lib.ky.us",
      "lib.la.us",
      "lib.ma.us",
      "lib.md.us",
      "lib.me.us",
      "lib.mi.us",
      "lib.mn.us",
      "lib.mo.us",
      "lib.ms.us",
      "lib.mt.us",
      "lib.nc.us",
      "lib.nd.us",
      "lib.ne.us",
      "lib.nh.us",
      "lib.nj.us",
      "lib.nm.us",
      "lib.nv.us",
      "lib.ny.us",
      "lib.oh.us",
      "lib.ok.us",
      "lib.or.us",
      "lib.pa.us",
      "lib.pr.us",
      "lib.ri.us",
      "lib.sc.us",
      "lib.sd.us",
      "lib.tn.us",
      "lib.tx.us",
      "lib.ut.us",
      "lib.vi.us",
      "lib.vt.us",
      "lib.va.us",
      "lib.wa.us",
      "lib.wi.us",
      "lib.wy.us",
      "pvt.k12.ma.us",
      "chtr.k12.ma.us",
      "paroch.k12.ma.us",
      "ann-arbor.mi.us",
      "cog.mi.us",
      "dst.mi.us",
      "eaton.mi.us",
      "gen.mi.us",
      "mus.mi.us",
      "tec.mi.us",
      "washtenaw.mi.us",
      "uy",
      "com.uy",
      "edu.uy",
      "gub.uy",
      "mil.uy",
      "net.uy",
      "org.uy",
      "uz",
      "co.uz",
      "com.uz",
      "net.uz",
      "org.uz",
      "va",
      "vc",
      "com.vc",
      "net.vc",
      "org.vc",
      "gov.vc",
      "mil.vc",
      "edu.vc",
      "ve",
      "arts.ve",
      "co.ve",
      "com.ve",
      "e12.ve",
      "edu.ve",
      "firm.ve",
      "gob.ve",
      "gov.ve",
      "info.ve",
      "int.ve",
      "mil.ve",
      "net.ve",
      "org.ve",
      "rec.ve",
      "store.ve",
      "tec.ve",
      "web.ve",
      "vg",
      "vi",
      "co.vi",
      "com.vi",
      "k12.vi",
      "net.vi",
      "org.vi",
      "vn",
      "com.vn",
      "net.vn",
      "org.vn",
      "edu.vn",
      "gov.vn",
      "int.vn",
      "ac.vn",
      "biz.vn",
      "info.vn",
      "name.vn",
      "pro.vn",
      "health.vn",
      "vu",
      "com.vu",
      "edu.vu",
      "net.vu",
      "org.vu",
      "wf",
      "ws",
      "com.ws",
      "net.ws",
      "org.ws",
      "gov.ws",
      "edu.ws",
      "yt",
      "\u0627\u0645\u0627\u0631\u0627\u062A",
      "\u0570\u0561\u0575",
      "\u09AC\u09BE\u0982\u09B2\u09BE",
      "\u0431\u0433",
      "\u0431\u0435\u043B",
      "\u4E2D\u56FD",
      "\u4E2D\u570B",
      "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
      "\u0645\u0635\u0631",
      "\u0435\u044E",
      "\u03B5\u03C5",
      "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627",
      "\u10D2\u10D4",
      "\u03B5\u03BB",
      "\u9999\u6E2F",
      "\u516C\u53F8.\u9999\u6E2F",
      "\u6559\u80B2.\u9999\u6E2F",
      "\u653F\u5E9C.\u9999\u6E2F",
      "\u500B\u4EBA.\u9999\u6E2F",
      "\u7DB2\u7D61.\u9999\u6E2F",
      "\u7D44\u7E54.\u9999\u6E2F",
      "\u0CAD\u0CBE\u0CB0\u0CA4",
      "\u0B2D\u0B3E\u0B30\u0B24",
      "\u09AD\u09BE\u09F0\u09A4",
      "\u092D\u093E\u0930\u0924\u092E\u094D",
      "\u092D\u093E\u0930\u094B\u0924",
      "\u0680\u0627\u0631\u062A",
      "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
      "\u092D\u093E\u0930\u0924",
      "\u0628\u0627\u0631\u062A",
      "\u0628\u06BE\u0627\u0631\u062A",
      "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
      "\u0AAD\u0ABE\u0AB0\u0AA4",
      "\u0A2D\u0A3E\u0A30\u0A24",
      "\u09AD\u09BE\u09B0\u09A4",
      "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
      "\u0627\u06CC\u0631\u0627\u0646",
      "\u0627\u064A\u0631\u0627\u0646",
      "\u0639\u0631\u0627\u0642",
      "\u0627\u0644\u0627\u0631\u062F\u0646",
      "\uD55C\uAD6D",
      "\u049B\u0430\u0437",
      "\u0DBD\u0D82\u0D9A\u0DCF",
      "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
      "\u0627\u0644\u0645\u063A\u0631\u0628",
      "\u043C\u043A\u0434",
      "\u043C\u043E\u043D",
      "\u6FB3\u9580",
      "\u6FB3\u95E8",
      "\u0645\u0644\u064A\u0633\u064A\u0627",
      "\u0639\u0645\u0627\u0646",
      "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
      "\u067E\u0627\u0643\u0633\u062A\u0627\u0646",
      "\u0641\u0644\u0633\u0637\u064A\u0646",
      "\u0441\u0440\u0431",
      "\u043F\u0440.\u0441\u0440\u0431",
      "\u043E\u0440\u0433.\u0441\u0440\u0431",
      "\u043E\u0431\u0440.\u0441\u0440\u0431",
      "\u043E\u0434.\u0441\u0440\u0431",
      "\u0443\u043F\u0440.\u0441\u0440\u0431",
      "\u0430\u043A.\u0441\u0440\u0431",
      "\u0440\u0444",
      "\u0642\u0637\u0631",
      "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
      "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u0629",
      "\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u06C3",
      "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0647",
      "\u0633\u0648\u062F\u0627\u0646",
      "\u65B0\u52A0\u5761",
      "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
      "\u0633\u0648\u0631\u064A\u0629",
      "\u0633\u0648\u0631\u064A\u0627",
      "\u0E44\u0E17\u0E22",
      "\u0E28\u0E36\u0E01\u0E29\u0E32.\u0E44\u0E17\u0E22",
      "\u0E18\u0E38\u0E23\u0E01\u0E34\u0E08.\u0E44\u0E17\u0E22",
      "\u0E23\u0E31\u0E10\u0E1A\u0E32\u0E25.\u0E44\u0E17\u0E22",
      "\u0E17\u0E2B\u0E32\u0E23.\u0E44\u0E17\u0E22",
      "\u0E40\u0E19\u0E47\u0E15.\u0E44\u0E17\u0E22",
      "\u0E2D\u0E07\u0E04\u0E4C\u0E01\u0E23.\u0E44\u0E17\u0E22",
      "\u062A\u0648\u0646\u0633",
      "\u53F0\u7063",
      "\u53F0\u6E7E",
      "\u81FA\u7063",
      "\u0443\u043A\u0440",
      "\u0627\u0644\u064A\u0645\u0646",
      "xxx",
      "*.ye",
      "ac.za",
      "agric.za",
      "alt.za",
      "co.za",
      "edu.za",
      "gov.za",
      "grondar.za",
      "law.za",
      "mil.za",
      "net.za",
      "ngo.za",
      "nic.za",
      "nis.za",
      "nom.za",
      "org.za",
      "school.za",
      "tm.za",
      "web.za",
      "zm",
      "ac.zm",
      "biz.zm",
      "co.zm",
      "com.zm",
      "edu.zm",
      "gov.zm",
      "info.zm",
      "mil.zm",
      "net.zm",
      "org.zm",
      "sch.zm",
      "zw",
      "ac.zw",
      "co.zw",
      "gov.zw",
      "mil.zw",
      "org.zw",
      "aaa",
      "aarp",
      "abarth",
      "abb",
      "abbott",
      "abbvie",
      "abc",
      "able",
      "abogado",
      "abudhabi",
      "academy",
      "accenture",
      "accountant",
      "accountants",
      "aco",
      "actor",
      "adac",
      "ads",
      "adult",
      "aeg",
      "aetna",
      "afamilycompany",
      "afl",
      "africa",
      "agakhan",
      "agency",
      "aig",
      "aigo",
      "airbus",
      "airforce",
      "airtel",
      "akdn",
      "alfaromeo",
      "alibaba",
      "alipay",
      "allfinanz",
      "allstate",
      "ally",
      "alsace",
      "alstom",
      "amazon",
      "americanexpress",
      "americanfamily",
      "amex",
      "amfam",
      "amica",
      "amsterdam",
      "analytics",
      "android",
      "anquan",
      "anz",
      "aol",
      "apartments",
      "app",
      "apple",
      "aquarelle",
      "arab",
      "aramco",
      "archi",
      "army",
      "art",
      "arte",
      "asda",
      "associates",
      "athleta",
      "attorney",
      "auction",
      "audi",
      "audible",
      "audio",
      "auspost",
      "author",
      "auto",
      "autos",
      "avianca",
      "aws",
      "axa",
      "azure",
      "baby",
      "baidu",
      "banamex",
      "bananarepublic",
      "band",
      "bank",
      "bar",
      "barcelona",
      "barclaycard",
      "barclays",
      "barefoot",
      "bargains",
      "baseball",
      "basketball",
      "bauhaus",
      "bayern",
      "bbc",
      "bbt",
      "bbva",
      "bcg",
      "bcn",
      "beats",
      "beauty",
      "beer",
      "bentley",
      "berlin",
      "best",
      "bestbuy",
      "bet",
      "bharti",
      "bible",
      "bid",
      "bike",
      "bing",
      "bingo",
      "bio",
      "black",
      "blackfriday",
      "blockbuster",
      "blog",
      "bloomberg",
      "blue",
      "bms",
      "bmw",
      "bnpparibas",
      "boats",
      "boehringer",
      "bofa",
      "bom",
      "bond",
      "boo",
      "book",
      "booking",
      "bosch",
      "bostik",
      "boston",
      "bot",
      "boutique",
      "box",
      "bradesco",
      "bridgestone",
      "broadway",
      "broker",
      "brother",
      "brussels",
      "budapest",
      "bugatti",
      "build",
      "builders",
      "business",
      "buy",
      "buzz",
      "bzh",
      "cab",
      "cafe",
      "cal",
      "call",
      "calvinklein",
      "cam",
      "camera",
      "camp",
      "cancerresearch",
      "canon",
      "capetown",
      "capital",
      "capitalone",
      "car",
      "caravan",
      "cards",
      "care",
      "career",
      "careers",
      "cars",
      "casa",
      "case",
      "caseih",
      "cash",
      "casino",
      "catering",
      "catholic",
      "cba",
      "cbn",
      "cbre",
      "cbs",
      "ceb",
      "center",
      "ceo",
      "cern",
      "cfa",
      "cfd",
      "chanel",
      "channel",
      "charity",
      "chase",
      "chat",
      "cheap",
      "chintai",
      "christmas",
      "chrome",
      "church",
      "cipriani",
      "circle",
      "cisco",
      "citadel",
      "citi",
      "citic",
      "city",
      "cityeats",
      "claims",
      "cleaning",
      "click",
      "clinic",
      "clinique",
      "clothing",
      "cloud",
      "club",
      "clubmed",
      "coach",
      "codes",
      "coffee",
      "college",
      "cologne",
      "comcast",
      "commbank",
      "community",
      "company",
      "compare",
      "computer",
      "comsec",
      "condos",
      "construction",
      "consulting",
      "contact",
      "contractors",
      "cooking",
      "cookingchannel",
      "cool",
      "corsica",
      "country",
      "coupon",
      "coupons",
      "courses",
      "cpa",
      "credit",
      "creditcard",
      "creditunion",
      "cricket",
      "crown",
      "crs",
      "cruise",
      "cruises",
      "csc",
      "cuisinella",
      "cymru",
      "cyou",
      "dabur",
      "dad",
      "dance",
      "data",
      "date",
      "dating",
      "datsun",
      "day",
      "dclk",
      "dds",
      "deal",
      "dealer",
      "deals",
      "degree",
      "delivery",
      "dell",
      "deloitte",
      "delta",
      "democrat",
      "dental",
      "dentist",
      "desi",
      "design",
      "dev",
      "dhl",
      "diamonds",
      "diet",
      "digital",
      "direct",
      "directory",
      "discount",
      "discover",
      "dish",
      "diy",
      "dnp",
      "docs",
      "doctor",
      "dog",
      "domains",
      "dot",
      "download",
      "drive",
      "dtv",
      "dubai",
      "duck",
      "dunlop",
      "dupont",
      "durban",
      "dvag",
      "dvr",
      "earth",
      "eat",
      "eco",
      "edeka",
      "education",
      "email",
      "emerck",
      "energy",
      "engineer",
      "engineering",
      "enterprises",
      "epson",
      "equipment",
      "ericsson",
      "erni",
      "esq",
      "estate",
      "esurance",
      "etisalat",
      "eurovision",
      "eus",
      "events",
      "exchange",
      "expert",
      "exposed",
      "express",
      "extraspace",
      "fage",
      "fail",
      "fairwinds",
      "faith",
      "family",
      "fan",
      "fans",
      "farm",
      "farmers",
      "fashion",
      "fast",
      "fedex",
      "feedback",
      "ferrari",
      "ferrero",
      "fiat",
      "fidelity",
      "fido",
      "film",
      "final",
      "finance",
      "financial",
      "fire",
      "firestone",
      "firmdale",
      "fish",
      "fishing",
      "fit",
      "fitness",
      "flickr",
      "flights",
      "flir",
      "florist",
      "flowers",
      "fly",
      "foo",
      "food",
      "foodnetwork",
      "football",
      "ford",
      "forex",
      "forsale",
      "forum",
      "foundation",
      "fox",
      "free",
      "fresenius",
      "frl",
      "frogans",
      "frontdoor",
      "frontier",
      "ftr",
      "fujitsu",
      "fujixerox",
      "fun",
      "fund",
      "furniture",
      "futbol",
      "fyi",
      "gal",
      "gallery",
      "gallo",
      "gallup",
      "game",
      "games",
      "gap",
      "garden",
      "gay",
      "gbiz",
      "gdn",
      "gea",
      "gent",
      "genting",
      "george",
      "ggee",
      "gift",
      "gifts",
      "gives",
      "giving",
      "glade",
      "glass",
      "gle",
      "global",
      "globo",
      "gmail",
      "gmbh",
      "gmo",
      "gmx",
      "godaddy",
      "gold",
      "goldpoint",
      "golf",
      "goo",
      "goodyear",
      "goog",
      "google",
      "gop",
      "got",
      "grainger",
      "graphics",
      "gratis",
      "green",
      "gripe",
      "grocery",
      "group",
      "guardian",
      "gucci",
      "guge",
      "guide",
      "guitars",
      "guru",
      "hair",
      "hamburg",
      "hangout",
      "haus",
      "hbo",
      "hdfc",
      "hdfcbank",
      "health",
      "healthcare",
      "help",
      "helsinki",
      "here",
      "hermes",
      "hgtv",
      "hiphop",
      "hisamitsu",
      "hitachi",
      "hiv",
      "hkt",
      "hockey",
      "holdings",
      "holiday",
      "homedepot",
      "homegoods",
      "homes",
      "homesense",
      "honda",
      "horse",
      "hospital",
      "host",
      "hosting",
      "hot",
      "hoteles",
      "hotels",
      "hotmail",
      "house",
      "how",
      "hsbc",
      "hughes",
      "hyatt",
      "hyundai",
      "ibm",
      "icbc",
      "ice",
      "icu",
      "ieee",
      "ifm",
      "ikano",
      "imamat",
      "imdb",
      "immo",
      "immobilien",
      "inc",
      "industries",
      "infiniti",
      "ing",
      "ink",
      "institute",
      "insurance",
      "insure",
      "intel",
      "international",
      "intuit",
      "investments",
      "ipiranga",
      "irish",
      "ismaili",
      "ist",
      "istanbul",
      "itau",
      "itv",
      "iveco",
      "jaguar",
      "java",
      "jcb",
      "jcp",
      "jeep",
      "jetzt",
      "jewelry",
      "jio",
      "jll",
      "jmp",
      "jnj",
      "joburg",
      "jot",
      "joy",
      "jpmorgan",
      "jprs",
      "juegos",
      "juniper",
      "kaufen",
      "kddi",
      "kerryhotels",
      "kerrylogistics",
      "kerryproperties",
      "kfh",
      "kia",
      "kim",
      "kinder",
      "kindle",
      "kitchen",
      "kiwi",
      "koeln",
      "komatsu",
      "kosher",
      "kpmg",
      "kpn",
      "krd",
      "kred",
      "kuokgroup",
      "kyoto",
      "lacaixa",
      "lamborghini",
      "lamer",
      "lancaster",
      "lancia",
      "land",
      "landrover",
      "lanxess",
      "lasalle",
      "lat",
      "latino",
      "latrobe",
      "law",
      "lawyer",
      "lds",
      "lease",
      "leclerc",
      "lefrak",
      "legal",
      "lego",
      "lexus",
      "lgbt",
      "lidl",
      "life",
      "lifeinsurance",
      "lifestyle",
      "lighting",
      "like",
      "lilly",
      "limited",
      "limo",
      "lincoln",
      "linde",
      "link",
      "lipsy",
      "live",
      "living",
      "lixil",
      "llc",
      "llp",
      "loan",
      "loans",
      "locker",
      "locus",
      "loft",
      "lol",
      "london",
      "lotte",
      "lotto",
      "love",
      "lpl",
      "lplfinancial",
      "ltd",
      "ltda",
      "lundbeck",
      "lupin",
      "luxe",
      "luxury",
      "macys",
      "madrid",
      "maif",
      "maison",
      "makeup",
      "man",
      "management",
      "mango",
      "map",
      "market",
      "marketing",
      "markets",
      "marriott",
      "marshalls",
      "maserati",
      "mattel",
      "mba",
      "mckinsey",
      "med",
      "media",
      "meet",
      "melbourne",
      "meme",
      "memorial",
      "men",
      "menu",
      "merckmsd",
      "metlife",
      "miami",
      "microsoft",
      "mini",
      "mint",
      "mit",
      "mitsubishi",
      "mlb",
      "mls",
      "mma",
      "mobile",
      "moda",
      "moe",
      "moi",
      "mom",
      "monash",
      "money",
      "monster",
      "mormon",
      "mortgage",
      "moscow",
      "moto",
      "motorcycles",
      "mov",
      "movie",
      "msd",
      "mtn",
      "mtr",
      "mutual",
      "nab",
      "nadex",
      "nagoya",
      "nationwide",
      "natura",
      "navy",
      "nba",
      "nec",
      "netbank",
      "netflix",
      "network",
      "neustar",
      "new",
      "newholland",
      "news",
      "next",
      "nextdirect",
      "nexus",
      "nfl",
      "ngo",
      "nhk",
      "nico",
      "nike",
      "nikon",
      "ninja",
      "nissan",
      "nissay",
      "nokia",
      "northwesternmutual",
      "norton",
      "now",
      "nowruz",
      "nowtv",
      "nra",
      "nrw",
      "ntt",
      "nyc",
      "obi",
      "observer",
      "off",
      "office",
      "okinawa",
      "olayan",
      "olayangroup",
      "oldnavy",
      "ollo",
      "omega",
      "one",
      "ong",
      "onl",
      "online",
      "onyourside",
      "ooo",
      "open",
      "oracle",
      "orange",
      "organic",
      "origins",
      "osaka",
      "otsuka",
      "ott",
      "ovh",
      "page",
      "panasonic",
      "paris",
      "pars",
      "partners",
      "parts",
      "party",
      "passagens",
      "pay",
      "pccw",
      "pet",
      "pfizer",
      "pharmacy",
      "phd",
      "philips",
      "phone",
      "photo",
      "photography",
      "photos",
      "physio",
      "pics",
      "pictet",
      "pictures",
      "pid",
      "pin",
      "ping",
      "pink",
      "pioneer",
      "pizza",
      "place",
      "play",
      "playstation",
      "plumbing",
      "plus",
      "pnc",
      "pohl",
      "poker",
      "politie",
      "porn",
      "pramerica",
      "praxi",
      "press",
      "prime",
      "prod",
      "productions",
      "prof",
      "progressive",
      "promo",
      "properties",
      "property",
      "protection",
      "pru",
      "prudential",
      "pub",
      "pwc",
      "qpon",
      "quebec",
      "quest",
      "qvc",
      "racing",
      "radio",
      "raid",
      "read",
      "realestate",
      "realtor",
      "realty",
      "recipes",
      "red",
      "redstone",
      "redumbrella",
      "rehab",
      "reise",
      "reisen",
      "reit",
      "reliance",
      "ren",
      "rent",
      "rentals",
      "repair",
      "report",
      "republican",
      "rest",
      "restaurant",
      "review",
      "reviews",
      "rexroth",
      "rich",
      "richardli",
      "ricoh",
      "rightathome",
      "ril",
      "rio",
      "rip",
      "rmit",
      "rocher",
      "rocks",
      "rodeo",
      "rogers",
      "room",
      "rsvp",
      "rugby",
      "ruhr",
      "run",
      "rwe",
      "ryukyu",
      "saarland",
      "safe",
      "safety",
      "sakura",
      "sale",
      "salon",
      "samsclub",
      "samsung",
      "sandvik",
      "sandvikcoromant",
      "sanofi",
      "sap",
      "sarl",
      "sas",
      "save",
      "saxo",
      "sbi",
      "sbs",
      "sca",
      "scb",
      "schaeffler",
      "schmidt",
      "scholarships",
      "school",
      "schule",
      "schwarz",
      "science",
      "scjohnson",
      "scor",
      "scot",
      "search",
      "seat",
      "secure",
      "security",
      "seek",
      "select",
      "sener",
      "services",
      "ses",
      "seven",
      "sew",
      "sex",
      "sexy",
      "sfr",
      "shangrila",
      "sharp",
      "shaw",
      "shell",
      "shia",
      "shiksha",
      "shoes",
      "shop",
      "shopping",
      "shouji",
      "show",
      "showtime",
      "shriram",
      "silk",
      "sina",
      "singles",
      "site",
      "ski",
      "skin",
      "sky",
      "skype",
      "sling",
      "smart",
      "smile",
      "sncf",
      "soccer",
      "social",
      "softbank",
      "software",
      "sohu",
      "solar",
      "solutions",
      "song",
      "sony",
      "soy",
      "spa",
      "space",
      "sport",
      "spot",
      "spreadbetting",
      "srl",
      "stada",
      "staples",
      "star",
      "statebank",
      "statefarm",
      "stc",
      "stcgroup",
      "stockholm",
      "storage",
      "store",
      "stream",
      "studio",
      "study",
      "style",
      "sucks",
      "supplies",
      "supply",
      "support",
      "surf",
      "surgery",
      "suzuki",
      "swatch",
      "swiftcover",
      "swiss",
      "sydney",
      "symantec",
      "systems",
      "tab",
      "taipei",
      "talk",
      "taobao",
      "target",
      "tatamotors",
      "tatar",
      "tattoo",
      "tax",
      "taxi",
      "tci",
      "tdk",
      "team",
      "tech",
      "technology",
      "temasek",
      "tennis",
      "teva",
      "thd",
      "theater",
      "theatre",
      "tiaa",
      "tickets",
      "tienda",
      "tiffany",
      "tips",
      "tires",
      "tirol",
      "tjmaxx",
      "tjx",
      "tkmaxx",
      "tmall",
      "today",
      "tokyo",
      "tools",
      "top",
      "toray",
      "toshiba",
      "total",
      "tours",
      "town",
      "toyota",
      "toys",
      "trade",
      "trading",
      "training",
      "travel",
      "travelchannel",
      "travelers",
      "travelersinsurance",
      "trust",
      "trv",
      "tube",
      "tui",
      "tunes",
      "tushu",
      "tvs",
      "ubank",
      "ubs",
      "unicom",
      "university",
      "uno",
      "uol",
      "ups",
      "vacations",
      "vana",
      "vanguard",
      "vegas",
      "ventures",
      "verisign",
      "versicherung",
      "vet",
      "viajes",
      "video",
      "vig",
      "viking",
      "villas",
      "vin",
      "vip",
      "virgin",
      "visa",
      "vision",
      "viva",
      "vivo",
      "vlaanderen",
      "vodka",
      "volkswagen",
      "volvo",
      "vote",
      "voting",
      "voto",
      "voyage",
      "vuelos",
      "wales",
      "walmart",
      "walter",
      "wang",
      "wanggou",
      "watch",
      "watches",
      "weather",
      "weatherchannel",
      "webcam",
      "weber",
      "website",
      "wed",
      "wedding",
      "weibo",
      "weir",
      "whoswho",
      "wien",
      "wiki",
      "williamhill",
      "win",
      "windows",
      "wine",
      "winners",
      "wme",
      "wolterskluwer",
      "woodside",
      "work",
      "works",
      "world",
      "wow",
      "wtc",
      "wtf",
      "xbox",
      "xerox",
      "xfinity",
      "xihuan",
      "xin",
      "\u0915\u0949\u092E",
      "\u30BB\u30FC\u30EB",
      "\u4F5B\u5C71",
      "\u6148\u5584",
      "\u96C6\u56E2",
      "\u5728\u7EBF",
      "\u5927\u4F17\u6C7D\u8F66",
      "\u70B9\u770B",
      "\u0E04\u0E2D\u0E21",
      "\u516B\u5366",
      "\u0645\u0648\u0642\u0639",
      "\u516C\u76CA",
      "\u516C\u53F8",
      "\u9999\u683C\u91CC\u62C9",
      "\u7F51\u7AD9",
      "\u79FB\u52A8",
      "\u6211\u7231\u4F60",
      "\u043C\u043E\u0441\u043A\u0432\u0430",
      "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
      "\u043E\u043D\u043B\u0430\u0439\u043D",
      "\u0441\u0430\u0439\u0442",
      "\u8054\u901A",
      "\u05E7\u05D5\u05DD",
      "\u65F6\u5C1A",
      "\u5FAE\u535A",
      "\u6DE1\u9A6C\u9521",
      "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
      "\u043E\u0440\u0433",
      "\u0928\u0947\u091F",
      "\u30B9\u30C8\u30A2",
      "\u30A2\u30DE\u30BE\u30F3",
      "\uC0BC\uC131",
      "\u5546\u6807",
      "\u5546\u5E97",
      "\u5546\u57CE",
      "\u0434\u0435\u0442\u0438",
      "\u30DD\u30A4\u30F3\u30C8",
      "\u65B0\u95FB",
      "\u5DE5\u884C",
      "\u5BB6\u96FB",
      "\u0643\u0648\u0645",
      "\u4E2D\u6587\u7F51",
      "\u4E2D\u4FE1",
      "\u5A31\u4E50",
      "\u8C37\u6B4C",
      "\u96FB\u8A0A\u76C8\u79D1",
      "\u8D2D\u7269",
      "\u30AF\u30E9\u30A6\u30C9",
      "\u901A\u8CA9",
      "\u7F51\u5E97",
      "\u0938\u0902\u0917\u0920\u0928",
      "\u9910\u5385",
      "\u7F51\u7EDC",
      "\u043A\u043E\u043C",
      "\u4E9A\u9A6C\u900A",
      "\u8BFA\u57FA\u4E9A",
      "\u98DF\u54C1",
      "\u98DE\u5229\u6D66",
      "\u624B\u8868",
      "\u624B\u673A",
      "\u0627\u0631\u0627\u0645\u0643\u0648",
      "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
      "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
      "\u0628\u0627\u0632\u0627\u0631",
      "\u0627\u0628\u0648\u0638\u0628\u064A",
      "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
      "\u0647\u0645\u0631\u0627\u0647",
      "\uB2F7\uCEF4",
      "\u653F\u5E9C",
      "\u0634\u0628\u0643\u0629",
      "\u0628\u064A\u062A\u0643",
      "\u0639\u0631\u0628",
      "\u673A\u6784",
      "\u7EC4\u7EC7\u673A\u6784",
      "\u5065\u5EB7",
      "\u62DB\u8058",
      "\u0440\u0443\u0441",
      "\u73E0\u5B9D",
      "\u5927\u62FF",
      "\u307F\u3093\u306A",
      "\u30B0\u30FC\u30B0\u30EB",
      "\u4E16\u754C",
      "\u66F8\u7C4D",
      "\u7F51\u5740",
      "\uB2F7\uB137",
      "\u30B3\u30E0",
      "\u5929\u4E3B\u6559",
      "\u6E38\u620F",
      "verm\xF6gensberater",
      "verm\xF6gensberatung",
      "\u4F01\u4E1A",
      "\u4FE1\u606F",
      "\u5609\u91CC\u5927\u9152\u5E97",
      "\u5609\u91CC",
      "\u5E7F\u4E1C",
      "\u653F\u52A1",
      "xyz",
      "yachts",
      "yahoo",
      "yamaxun",
      "yandex",
      "yodobashi",
      "yoga",
      "yokohama",
      "you",
      "youtube",
      "yun",
      "zappos",
      "zara",
      "zero",
      "zip",
      "zone",
      "zuerich",
      "cc.ua",
      "inf.ua",
      "ltd.ua",
      "adobeaemcloud.com",
      "adobeaemcloud.net",
      "*.dev.adobeaemcloud.com",
      "beep.pl",
      "barsy.ca",
      "*.compute.estate",
      "*.alces.network",
      "altervista.org",
      "alwaysdata.net",
      "cloudfront.net",
      "*.compute.amazonaws.com",
      "*.compute-1.amazonaws.com",
      "*.compute.amazonaws.com.cn",
      "us-east-1.amazonaws.com",
      "cn-north-1.eb.amazonaws.com.cn",
      "cn-northwest-1.eb.amazonaws.com.cn",
      "elasticbeanstalk.com",
      "ap-northeast-1.elasticbeanstalk.com",
      "ap-northeast-2.elasticbeanstalk.com",
      "ap-northeast-3.elasticbeanstalk.com",
      "ap-south-1.elasticbeanstalk.com",
      "ap-southeast-1.elasticbeanstalk.com",
      "ap-southeast-2.elasticbeanstalk.com",
      "ca-central-1.elasticbeanstalk.com",
      "eu-central-1.elasticbeanstalk.com",
      "eu-west-1.elasticbeanstalk.com",
      "eu-west-2.elasticbeanstalk.com",
      "eu-west-3.elasticbeanstalk.com",
      "sa-east-1.elasticbeanstalk.com",
      "us-east-1.elasticbeanstalk.com",
      "us-east-2.elasticbeanstalk.com",
      "us-gov-west-1.elasticbeanstalk.com",
      "us-west-1.elasticbeanstalk.com",
      "us-west-2.elasticbeanstalk.com",
      "*.elb.amazonaws.com",
      "*.elb.amazonaws.com.cn",
      "s3.amazonaws.com",
      "s3-ap-northeast-1.amazonaws.com",
      "s3-ap-northeast-2.amazonaws.com",
      "s3-ap-south-1.amazonaws.com",
      "s3-ap-southeast-1.amazonaws.com",
      "s3-ap-southeast-2.amazonaws.com",
      "s3-ca-central-1.amazonaws.com",
      "s3-eu-central-1.amazonaws.com",
      "s3-eu-west-1.amazonaws.com",
      "s3-eu-west-2.amazonaws.com",
      "s3-eu-west-3.amazonaws.com",
      "s3-external-1.amazonaws.com",
      "s3-fips-us-gov-west-1.amazonaws.com",
      "s3-sa-east-1.amazonaws.com",
      "s3-us-gov-west-1.amazonaws.com",
      "s3-us-east-2.amazonaws.com",
      "s3-us-west-1.amazonaws.com",
      "s3-us-west-2.amazonaws.com",
      "s3.ap-northeast-2.amazonaws.com",
      "s3.ap-south-1.amazonaws.com",
      "s3.cn-north-1.amazonaws.com.cn",
      "s3.ca-central-1.amazonaws.com",
      "s3.eu-central-1.amazonaws.com",
      "s3.eu-west-2.amazonaws.com",
      "s3.eu-west-3.amazonaws.com",
      "s3.us-east-2.amazonaws.com",
      "s3.dualstack.ap-northeast-1.amazonaws.com",
      "s3.dualstack.ap-northeast-2.amazonaws.com",
      "s3.dualstack.ap-south-1.amazonaws.com",
      "s3.dualstack.ap-southeast-1.amazonaws.com",
      "s3.dualstack.ap-southeast-2.amazonaws.com",
      "s3.dualstack.ca-central-1.amazonaws.com",
      "s3.dualstack.eu-central-1.amazonaws.com",
      "s3.dualstack.eu-west-1.amazonaws.com",
      "s3.dualstack.eu-west-2.amazonaws.com",
      "s3.dualstack.eu-west-3.amazonaws.com",
      "s3.dualstack.sa-east-1.amazonaws.com",
      "s3.dualstack.us-east-1.amazonaws.com",
      "s3.dualstack.us-east-2.amazonaws.com",
      "s3-website-us-east-1.amazonaws.com",
      "s3-website-us-west-1.amazonaws.com",
      "s3-website-us-west-2.amazonaws.com",
      "s3-website-ap-northeast-1.amazonaws.com",
      "s3-website-ap-southeast-1.amazonaws.com",
      "s3-website-ap-southeast-2.amazonaws.com",
      "s3-website-eu-west-1.amazonaws.com",
      "s3-website-sa-east-1.amazonaws.com",
      "s3-website.ap-northeast-2.amazonaws.com",
      "s3-website.ap-south-1.amazonaws.com",
      "s3-website.ca-central-1.amazonaws.com",
      "s3-website.eu-central-1.amazonaws.com",
      "s3-website.eu-west-2.amazonaws.com",
      "s3-website.eu-west-3.amazonaws.com",
      "s3-website.us-east-2.amazonaws.com",
      "amsw.nl",
      "t3l3p0rt.net",
      "tele.amune.org",
      "apigee.io",
      "on-aptible.com",
      "user.aseinet.ne.jp",
      "gv.vc",
      "d.gv.vc",
      "user.party.eus",
      "pimienta.org",
      "poivron.org",
      "potager.org",
      "sweetpepper.org",
      "myasustor.com",
      "myfritz.net",
      "*.awdev.ca",
      "*.advisor.ws",
      "b-data.io",
      "backplaneapp.io",
      "balena-devices.com",
      "app.banzaicloud.io",
      "betainabox.com",
      "bnr.la",
      "blackbaudcdn.net",
      "boomla.net",
      "boxfuse.io",
      "square7.ch",
      "bplaced.com",
      "bplaced.de",
      "square7.de",
      "bplaced.net",
      "square7.net",
      "browsersafetymark.io",
      "uk0.bigv.io",
      "dh.bytemark.co.uk",
      "vm.bytemark.co.uk",
      "mycd.eu",
      "carrd.co",
      "crd.co",
      "uwu.ai",
      "ae.org",
      "ar.com",
      "br.com",
      "cn.com",
      "com.de",
      "com.se",
      "de.com",
      "eu.com",
      "gb.com",
      "gb.net",
      "hu.com",
      "hu.net",
      "jp.net",
      "jpn.com",
      "kr.com",
      "mex.com",
      "no.com",
      "qc.com",
      "ru.com",
      "sa.com",
      "se.net",
      "uk.com",
      "uk.net",
      "us.com",
      "uy.com",
      "za.bz",
      "za.com",
      "africa.com",
      "gr.com",
      "in.net",
      "us.org",
      "co.com",
      "c.la",
      "certmgr.org",
      "xenapponazure.com",
      "discourse.group",
      "discourse.team",
      "virtueeldomein.nl",
      "cleverapps.io",
      "*.lcl.dev",
      "*.stg.dev",
      "c66.me",
      "cloud66.ws",
      "cloud66.zone",
      "jdevcloud.com",
      "wpdevcloud.com",
      "cloudaccess.host",
      "freesite.host",
      "cloudaccess.net",
      "cloudcontrolled.com",
      "cloudcontrolapp.com",
      "cloudera.site",
      "trycloudflare.com",
      "workers.dev",
      "wnext.app",
      "co.ca",
      "*.otap.co",
      "co.cz",
      "c.cdn77.org",
      "cdn77-ssl.net",
      "r.cdn77.net",
      "rsc.cdn77.org",
      "ssl.origin.cdn77-secure.org",
      "cloudns.asia",
      "cloudns.biz",
      "cloudns.club",
      "cloudns.cc",
      "cloudns.eu",
      "cloudns.in",
      "cloudns.info",
      "cloudns.org",
      "cloudns.pro",
      "cloudns.pw",
      "cloudns.us",
      "cloudeity.net",
      "cnpy.gdn",
      "co.nl",
      "co.no",
      "webhosting.be",
      "hosting-cluster.nl",
      "ac.ru",
      "edu.ru",
      "gov.ru",
      "int.ru",
      "mil.ru",
      "test.ru",
      "dyn.cosidns.de",
      "dynamisches-dns.de",
      "dnsupdater.de",
      "internet-dns.de",
      "l-o-g-i-n.de",
      "dynamic-dns.info",
      "feste-ip.net",
      "knx-server.net",
      "static-access.net",
      "realm.cz",
      "*.cryptonomic.net",
      "cupcake.is",
      "*.customer-oci.com",
      "*.oci.customer-oci.com",
      "*.ocp.customer-oci.com",
      "*.ocs.customer-oci.com",
      "cyon.link",
      "cyon.site",
      "daplie.me",
      "localhost.daplie.me",
      "dattolocal.com",
      "dattorelay.com",
      "dattoweb.com",
      "mydatto.com",
      "dattolocal.net",
      "mydatto.net",
      "biz.dk",
      "co.dk",
      "firm.dk",
      "reg.dk",
      "store.dk",
      "*.dapps.earth",
      "*.bzz.dapps.earth",
      "builtwithdark.com",
      "edgestack.me",
      "debian.net",
      "dedyn.io",
      "dnshome.de",
      "online.th",
      "shop.th",
      "drayddns.com",
      "dreamhosters.com",
      "mydrobo.com",
      "drud.io",
      "drud.us",
      "duckdns.org",
      "dy.fi",
      "tunk.org",
      "dyndns-at-home.com",
      "dyndns-at-work.com",
      "dyndns-blog.com",
      "dyndns-free.com",
      "dyndns-home.com",
      "dyndns-ip.com",
      "dyndns-mail.com",
      "dyndns-office.com",
      "dyndns-pics.com",
      "dyndns-remote.com",
      "dyndns-server.com",
      "dyndns-web.com",
      "dyndns-wiki.com",
      "dyndns-work.com",
      "dyndns.biz",
      "dyndns.info",
      "dyndns.org",
      "dyndns.tv",
      "at-band-camp.net",
      "ath.cx",
      "barrel-of-knowledge.info",
      "barrell-of-knowledge.info",
      "better-than.tv",
      "blogdns.com",
      "blogdns.net",
      "blogdns.org",
      "blogsite.org",
      "boldlygoingnowhere.org",
      "broke-it.net",
      "buyshouses.net",
      "cechire.com",
      "dnsalias.com",
      "dnsalias.net",
      "dnsalias.org",
      "dnsdojo.com",
      "dnsdojo.net",
      "dnsdojo.org",
      "does-it.net",
      "doesntexist.com",
      "doesntexist.org",
      "dontexist.com",
      "dontexist.net",
      "dontexist.org",
      "doomdns.com",
      "doomdns.org",
      "dvrdns.org",
      "dyn-o-saur.com",
      "dynalias.com",
      "dynalias.net",
      "dynalias.org",
      "dynathome.net",
      "dyndns.ws",
      "endofinternet.net",
      "endofinternet.org",
      "endoftheinternet.org",
      "est-a-la-maison.com",
      "est-a-la-masion.com",
      "est-le-patron.com",
      "est-mon-blogueur.com",
      "for-better.biz",
      "for-more.biz",
      "for-our.info",
      "for-some.biz",
      "for-the.biz",
      "forgot.her.name",
      "forgot.his.name",
      "from-ak.com",
      "from-al.com",
      "from-ar.com",
      "from-az.net",
      "from-ca.com",
      "from-co.net",
      "from-ct.com",
      "from-dc.com",
      "from-de.com",
      "from-fl.com",
      "from-ga.com",
      "from-hi.com",
      "from-ia.com",
      "from-id.com",
      "from-il.com",
      "from-in.com",
      "from-ks.com",
      "from-ky.com",
      "from-la.net",
      "from-ma.com",
      "from-md.com",
      "from-me.org",
      "from-mi.com",
      "from-mn.com",
      "from-mo.com",
      "from-ms.com",
      "from-mt.com",
      "from-nc.com",
      "from-nd.com",
      "from-ne.com",
      "from-nh.com",
      "from-nj.com",
      "from-nm.com",
      "from-nv.com",
      "from-ny.net",
      "from-oh.com",
      "from-ok.com",
      "from-or.com",
      "from-pa.com",
      "from-pr.com",
      "from-ri.com",
      "from-sc.com",
      "from-sd.com",
      "from-tn.com",
      "from-tx.com",
      "from-ut.com",
      "from-va.com",
      "from-vt.com",
      "from-wa.com",
      "from-wi.com",
      "from-wv.com",
      "from-wy.com",
      "ftpaccess.cc",
      "fuettertdasnetz.de",
      "game-host.org",
      "game-server.cc",
      "getmyip.com",
      "gets-it.net",
      "go.dyndns.org",
      "gotdns.com",
      "gotdns.org",
      "groks-the.info",
      "groks-this.info",
      "ham-radio-op.net",
      "here-for-more.info",
      "hobby-site.com",
      "hobby-site.org",
      "home.dyndns.org",
      "homedns.org",
      "homeftp.net",
      "homeftp.org",
      "homeip.net",
      "homelinux.com",
      "homelinux.net",
      "homelinux.org",
      "homeunix.com",
      "homeunix.net",
      "homeunix.org",
      "iamallama.com",
      "in-the-band.net",
      "is-a-anarchist.com",
      "is-a-blogger.com",
      "is-a-bookkeeper.com",
      "is-a-bruinsfan.org",
      "is-a-bulls-fan.com",
      "is-a-candidate.org",
      "is-a-caterer.com",
      "is-a-celticsfan.org",
      "is-a-chef.com",
      "is-a-chef.net",
      "is-a-chef.org",
      "is-a-conservative.com",
      "is-a-cpa.com",
      "is-a-cubicle-slave.com",
      "is-a-democrat.com",
      "is-a-designer.com",
      "is-a-doctor.com",
      "is-a-financialadvisor.com",
      "is-a-geek.com",
      "is-a-geek.net",
      "is-a-geek.org",
      "is-a-green.com",
      "is-a-guru.com",
      "is-a-hard-worker.com",
      "is-a-hunter.com",
      "is-a-knight.org",
      "is-a-landscaper.com",
      "is-a-lawyer.com",
      "is-a-liberal.com",
      "is-a-libertarian.com",
      "is-a-linux-user.org",
      "is-a-llama.com",
      "is-a-musician.com",
      "is-a-nascarfan.com",
      "is-a-nurse.com",
      "is-a-painter.com",
      "is-a-patsfan.org",
      "is-a-personaltrainer.com",
      "is-a-photographer.com",
      "is-a-player.com",
      "is-a-republican.com",
      "is-a-rockstar.com",
      "is-a-socialist.com",
      "is-a-soxfan.org",
      "is-a-student.com",
      "is-a-teacher.com",
      "is-a-techie.com",
      "is-a-therapist.com",
      "is-an-accountant.com",
      "is-an-actor.com",
      "is-an-actress.com",
      "is-an-anarchist.com",
      "is-an-artist.com",
      "is-an-engineer.com",
      "is-an-entertainer.com",
      "is-by.us",
      "is-certified.com",
      "is-found.org",
      "is-gone.com",
      "is-into-anime.com",
      "is-into-cars.com",
      "is-into-cartoons.com",
      "is-into-games.com",
      "is-leet.com",
      "is-lost.org",
      "is-not-certified.com",
      "is-saved.org",
      "is-slick.com",
      "is-uberleet.com",
      "is-very-bad.org",
      "is-very-evil.org",
      "is-very-good.org",
      "is-very-nice.org",
      "is-very-sweet.org",
      "is-with-theband.com",
      "isa-geek.com",
      "isa-geek.net",
      "isa-geek.org",
      "isa-hockeynut.com",
      "issmarterthanyou.com",
      "isteingeek.de",
      "istmein.de",
      "kicks-ass.net",
      "kicks-ass.org",
      "knowsitall.info",
      "land-4-sale.us",
      "lebtimnetz.de",
      "leitungsen.de",
      "likes-pie.com",
      "likescandy.com",
      "merseine.nu",
      "mine.nu",
      "misconfused.org",
      "mypets.ws",
      "myphotos.cc",
      "neat-url.com",
      "office-on-the.net",
      "on-the-web.tv",
      "podzone.net",
      "podzone.org",
      "readmyblog.org",
      "saves-the-whales.com",
      "scrapper-site.net",
      "scrapping.cc",
      "selfip.biz",
      "selfip.com",
      "selfip.info",
      "selfip.net",
      "selfip.org",
      "sells-for-less.com",
      "sells-for-u.com",
      "sells-it.net",
      "sellsyourhome.org",
      "servebbs.com",
      "servebbs.net",
      "servebbs.org",
      "serveftp.net",
      "serveftp.org",
      "servegame.org",
      "shacknet.nu",
      "simple-url.com",
      "space-to-rent.com",
      "stuff-4-sale.org",
      "stuff-4-sale.us",
      "teaches-yoga.com",
      "thruhere.net",
      "traeumtgerade.de",
      "webhop.biz",
      "webhop.info",
      "webhop.net",
      "webhop.org",
      "worse-than.tv",
      "writesthisblog.com",
      "ddnss.de",
      "dyn.ddnss.de",
      "dyndns.ddnss.de",
      "dyndns1.de",
      "dyn-ip24.de",
      "home-webserver.de",
      "dyn.home-webserver.de",
      "myhome-server.de",
      "ddnss.org",
      "definima.net",
      "definima.io",
      "bci.dnstrace.pro",
      "ddnsfree.com",
      "ddnsgeek.com",
      "giize.com",
      "gleeze.com",
      "kozow.com",
      "loseyourip.com",
      "ooguy.com",
      "theworkpc.com",
      "casacam.net",
      "dynu.net",
      "accesscam.org",
      "camdvr.org",
      "freeddns.org",
      "mywire.org",
      "webredirect.org",
      "myddns.rocks",
      "blogsite.xyz",
      "dynv6.net",
      "e4.cz",
      "en-root.fr",
      "mytuleap.com",
      "onred.one",
      "staging.onred.one",
      "enonic.io",
      "customer.enonic.io",
      "eu.org",
      "al.eu.org",
      "asso.eu.org",
      "at.eu.org",
      "au.eu.org",
      "be.eu.org",
      "bg.eu.org",
      "ca.eu.org",
      "cd.eu.org",
      "ch.eu.org",
      "cn.eu.org",
      "cy.eu.org",
      "cz.eu.org",
      "de.eu.org",
      "dk.eu.org",
      "edu.eu.org",
      "ee.eu.org",
      "es.eu.org",
      "fi.eu.org",
      "fr.eu.org",
      "gr.eu.org",
      "hr.eu.org",
      "hu.eu.org",
      "ie.eu.org",
      "il.eu.org",
      "in.eu.org",
      "int.eu.org",
      "is.eu.org",
      "it.eu.org",
      "jp.eu.org",
      "kr.eu.org",
      "lt.eu.org",
      "lu.eu.org",
      "lv.eu.org",
      "mc.eu.org",
      "me.eu.org",
      "mk.eu.org",
      "mt.eu.org",
      "my.eu.org",
      "net.eu.org",
      "ng.eu.org",
      "nl.eu.org",
      "no.eu.org",
      "nz.eu.org",
      "paris.eu.org",
      "pl.eu.org",
      "pt.eu.org",
      "q-a.eu.org",
      "ro.eu.org",
      "ru.eu.org",
      "se.eu.org",
      "si.eu.org",
      "sk.eu.org",
      "tr.eu.org",
      "uk.eu.org",
      "us.eu.org",
      "eu-1.evennode.com",
      "eu-2.evennode.com",
      "eu-3.evennode.com",
      "eu-4.evennode.com",
      "us-1.evennode.com",
      "us-2.evennode.com",
      "us-3.evennode.com",
      "us-4.evennode.com",
      "twmail.cc",
      "twmail.net",
      "twmail.org",
      "mymailer.com.tw",
      "url.tw",
      "apps.fbsbx.com",
      "ru.net",
      "adygeya.ru",
      "bashkiria.ru",
      "bir.ru",
      "cbg.ru",
      "com.ru",
      "dagestan.ru",
      "grozny.ru",
      "kalmykia.ru",
      "kustanai.ru",
      "marine.ru",
      "mordovia.ru",
      "msk.ru",
      "mytis.ru",
      "nalchik.ru",
      "nov.ru",
      "pyatigorsk.ru",
      "spb.ru",
      "vladikavkaz.ru",
      "vladimir.ru",
      "abkhazia.su",
      "adygeya.su",
      "aktyubinsk.su",
      "arkhangelsk.su",
      "armenia.su",
      "ashgabad.su",
      "azerbaijan.su",
      "balashov.su",
      "bashkiria.su",
      "bryansk.su",
      "bukhara.su",
      "chimkent.su",
      "dagestan.su",
      "east-kazakhstan.su",
      "exnet.su",
      "georgia.su",
      "grozny.su",
      "ivanovo.su",
      "jambyl.su",
      "kalmykia.su",
      "kaluga.su",
      "karacol.su",
      "karaganda.su",
      "karelia.su",
      "khakassia.su",
      "krasnodar.su",
      "kurgan.su",
      "kustanai.su",
      "lenug.su",
      "mangyshlak.su",
      "mordovia.su",
      "msk.su",
      "murmansk.su",
      "nalchik.su",
      "navoi.su",
      "north-kazakhstan.su",
      "nov.su",
      "obninsk.su",
      "penza.su",
      "pokrovsk.su",
      "sochi.su",
      "spb.su",
      "tashkent.su",
      "termez.su",
      "togliatti.su",
      "troitsk.su",
      "tselinograd.su",
      "tula.su",
      "tuva.su",
      "vladikavkaz.su",
      "vladimir.su",
      "vologda.su",
      "channelsdvr.net",
      "u.channelsdvr.net",
      "fastly-terrarium.com",
      "fastlylb.net",
      "map.fastlylb.net",
      "freetls.fastly.net",
      "map.fastly.net",
      "a.prod.fastly.net",
      "global.prod.fastly.net",
      "a.ssl.fastly.net",
      "b.ssl.fastly.net",
      "global.ssl.fastly.net",
      "fastpanel.direct",
      "fastvps-server.com",
      "fhapp.xyz",
      "fedorainfracloud.org",
      "fedorapeople.org",
      "cloud.fedoraproject.org",
      "app.os.fedoraproject.org",
      "app.os.stg.fedoraproject.org",
      "mydobiss.com",
      "filegear.me",
      "filegear-au.me",
      "filegear-de.me",
      "filegear-gb.me",
      "filegear-ie.me",
      "filegear-jp.me",
      "filegear-sg.me",
      "firebaseapp.com",
      "flynnhub.com",
      "flynnhosting.net",
      "0e.vc",
      "freebox-os.com",
      "freeboxos.com",
      "fbx-os.fr",
      "fbxos.fr",
      "freebox-os.fr",
      "freeboxos.fr",
      "freedesktop.org",
      "*.futurecms.at",
      "*.ex.futurecms.at",
      "*.in.futurecms.at",
      "futurehosting.at",
      "futuremailing.at",
      "*.ex.ortsinfo.at",
      "*.kunden.ortsinfo.at",
      "*.statics.cloud",
      "service.gov.uk",
      "gehirn.ne.jp",
      "usercontent.jp",
      "gentapps.com",
      "lab.ms",
      "github.io",
      "githubusercontent.com",
      "gitlab.io",
      "glitch.me",
      "lolipop.io",
      "cloudapps.digital",
      "london.cloudapps.digital",
      "homeoffice.gov.uk",
      "ro.im",
      "shop.ro",
      "goip.de",
      "run.app",
      "a.run.app",
      "web.app",
      "*.0emm.com",
      "appspot.com",
      "*.r.appspot.com",
      "blogspot.ae",
      "blogspot.al",
      "blogspot.am",
      "blogspot.ba",
      "blogspot.be",
      "blogspot.bg",
      "blogspot.bj",
      "blogspot.ca",
      "blogspot.cf",
      "blogspot.ch",
      "blogspot.cl",
      "blogspot.co.at",
      "blogspot.co.id",
      "blogspot.co.il",
      "blogspot.co.ke",
      "blogspot.co.nz",
      "blogspot.co.uk",
      "blogspot.co.za",
      "blogspot.com",
      "blogspot.com.ar",
      "blogspot.com.au",
      "blogspot.com.br",
      "blogspot.com.by",
      "blogspot.com.co",
      "blogspot.com.cy",
      "blogspot.com.ee",
      "blogspot.com.eg",
      "blogspot.com.es",
      "blogspot.com.mt",
      "blogspot.com.ng",
      "blogspot.com.tr",
      "blogspot.com.uy",
      "blogspot.cv",
      "blogspot.cz",
      "blogspot.de",
      "blogspot.dk",
      "blogspot.fi",
      "blogspot.fr",
      "blogspot.gr",
      "blogspot.hk",
      "blogspot.hr",
      "blogspot.hu",
      "blogspot.ie",
      "blogspot.in",
      "blogspot.is",
      "blogspot.it",
      "blogspot.jp",
      "blogspot.kr",
      "blogspot.li",
      "blogspot.lt",
      "blogspot.lu",
      "blogspot.md",
      "blogspot.mk",
      "blogspot.mr",
      "blogspot.mx",
      "blogspot.my",
      "blogspot.nl",
      "blogspot.no",
      "blogspot.pe",
      "blogspot.pt",
      "blogspot.qa",
      "blogspot.re",
      "blogspot.ro",
      "blogspot.rs",
      "blogspot.ru",
      "blogspot.se",
      "blogspot.sg",
      "blogspot.si",
      "blogspot.sk",
      "blogspot.sn",
      "blogspot.td",
      "blogspot.tw",
      "blogspot.ug",
      "blogspot.vn",
      "cloudfunctions.net",
      "cloud.goog",
      "codespot.com",
      "googleapis.com",
      "googlecode.com",
      "pagespeedmobilizer.com",
      "publishproxy.com",
      "withgoogle.com",
      "withyoutube.com",
      "awsmppl.com",
      "fin.ci",
      "free.hr",
      "caa.li",
      "ua.rs",
      "conf.se",
      "hs.zone",
      "hs.run",
      "hashbang.sh",
      "hasura.app",
      "hasura-app.io",
      "hepforge.org",
      "herokuapp.com",
      "herokussl.com",
      "myravendb.com",
      "ravendb.community",
      "ravendb.me",
      "development.run",
      "ravendb.run",
      "bpl.biz",
      "orx.biz",
      "ng.city",
      "biz.gl",
      "ng.ink",
      "col.ng",
      "firm.ng",
      "gen.ng",
      "ltd.ng",
      "ngo.ng",
      "ng.school",
      "sch.so",
      "h\xE4kkinen.fi",
      "*.moonscale.io",
      "moonscale.net",
      "iki.fi",
      "dyn-berlin.de",
      "in-berlin.de",
      "in-brb.de",
      "in-butter.de",
      "in-dsl.de",
      "in-dsl.net",
      "in-dsl.org",
      "in-vpn.de",
      "in-vpn.net",
      "in-vpn.org",
      "biz.at",
      "info.at",
      "info.cx",
      "ac.leg.br",
      "al.leg.br",
      "am.leg.br",
      "ap.leg.br",
      "ba.leg.br",
      "ce.leg.br",
      "df.leg.br",
      "es.leg.br",
      "go.leg.br",
      "ma.leg.br",
      "mg.leg.br",
      "ms.leg.br",
      "mt.leg.br",
      "pa.leg.br",
      "pb.leg.br",
      "pe.leg.br",
      "pi.leg.br",
      "pr.leg.br",
      "rj.leg.br",
      "rn.leg.br",
      "ro.leg.br",
      "rr.leg.br",
      "rs.leg.br",
      "sc.leg.br",
      "se.leg.br",
      "sp.leg.br",
      "to.leg.br",
      "pixolino.com",
      "ipifony.net",
      "mein-iserv.de",
      "test-iserv.de",
      "iserv.dev",
      "iobb.net",
      "myjino.ru",
      "*.hosting.myjino.ru",
      "*.landing.myjino.ru",
      "*.spectrum.myjino.ru",
      "*.vps.myjino.ru",
      "*.triton.zone",
      "*.cns.joyent.com",
      "js.org",
      "kaas.gg",
      "khplay.nl",
      "keymachine.de",
      "kinghost.net",
      "uni5.net",
      "knightpoint.systems",
      "oya.to",
      "co.krd",
      "edu.krd",
      "git-repos.de",
      "lcube-server.de",
      "svn-repos.de",
      "leadpages.co",
      "lpages.co",
      "lpusercontent.com",
      "lelux.site",
      "co.business",
      "co.education",
      "co.events",
      "co.financial",
      "co.network",
      "co.place",
      "co.technology",
      "app.lmpm.com",
      "linkitools.space",
      "linkyard.cloud",
      "linkyard-cloud.ch",
      "members.linode.com",
      "nodebalancer.linode.com",
      "we.bs",
      "loginline.app",
      "loginline.dev",
      "loginline.io",
      "loginline.services",
      "loginline.site",
      "krasnik.pl",
      "leczna.pl",
      "lubartow.pl",
      "lublin.pl",
      "poniatowa.pl",
      "swidnik.pl",
      "uklugs.org",
      "glug.org.uk",
      "lug.org.uk",
      "lugs.org.uk",
      "barsy.bg",
      "barsy.co.uk",
      "barsyonline.co.uk",
      "barsycenter.com",
      "barsyonline.com",
      "barsy.club",
      "barsy.de",
      "barsy.eu",
      "barsy.in",
      "barsy.info",
      "barsy.io",
      "barsy.me",
      "barsy.menu",
      "barsy.mobi",
      "barsy.net",
      "barsy.online",
      "barsy.org",
      "barsy.pro",
      "barsy.pub",
      "barsy.shop",
      "barsy.site",
      "barsy.support",
      "barsy.uk",
      "*.magentosite.cloud",
      "mayfirst.info",
      "mayfirst.org",
      "hb.cldmail.ru",
      "miniserver.com",
      "memset.net",
      "cloud.metacentrum.cz",
      "custom.metacentrum.cz",
      "flt.cloud.muni.cz",
      "usr.cloud.muni.cz",
      "meteorapp.com",
      "eu.meteorapp.com",
      "co.pl",
      "azurecontainer.io",
      "azurewebsites.net",
      "azure-mobile.net",
      "cloudapp.net",
      "mozilla-iot.org",
      "bmoattachments.org",
      "net.ru",
      "org.ru",
      "pp.ru",
      "ui.nabu.casa",
      "pony.club",
      "of.fashion",
      "on.fashion",
      "of.football",
      "in.london",
      "of.london",
      "for.men",
      "and.mom",
      "for.mom",
      "for.one",
      "for.sale",
      "of.work",
      "to.work",
      "nctu.me",
      "bitballoon.com",
      "netlify.com",
      "4u.com",
      "ngrok.io",
      "nh-serv.co.uk",
      "nfshost.com",
      "dnsking.ch",
      "mypi.co",
      "n4t.co",
      "001www.com",
      "ddnslive.com",
      "myiphost.com",
      "forumz.info",
      "16-b.it",
      "32-b.it",
      "64-b.it",
      "soundcast.me",
      "tcp4.me",
      "dnsup.net",
      "hicam.net",
      "now-dns.net",
      "ownip.net",
      "vpndns.net",
      "dynserv.org",
      "now-dns.org",
      "x443.pw",
      "now-dns.top",
      "ntdll.top",
      "freeddns.us",
      "crafting.xyz",
      "zapto.xyz",
      "nsupdate.info",
      "nerdpol.ovh",
      "blogsyte.com",
      "brasilia.me",
      "cable-modem.org",
      "ciscofreak.com",
      "collegefan.org",
      "couchpotatofries.org",
      "damnserver.com",
      "ddns.me",
      "ditchyourip.com",
      "dnsfor.me",
      "dnsiskinky.com",
      "dvrcam.info",
      "dynns.com",
      "eating-organic.net",
      "fantasyleague.cc",
      "geekgalaxy.com",
      "golffan.us",
      "health-carereform.com",
      "homesecuritymac.com",
      "homesecuritypc.com",
      "hopto.me",
      "ilovecollege.info",
      "loginto.me",
      "mlbfan.org",
      "mmafan.biz",
      "myactivedirectory.com",
      "mydissent.net",
      "myeffect.net",
      "mymediapc.net",
      "mypsx.net",
      "mysecuritycamera.com",
      "mysecuritycamera.net",
      "mysecuritycamera.org",
      "net-freaks.com",
      "nflfan.org",
      "nhlfan.net",
      "no-ip.ca",
      "no-ip.co.uk",
      "no-ip.net",
      "noip.us",
      "onthewifi.com",
      "pgafan.net",
      "point2this.com",
      "pointto.us",
      "privatizehealthinsurance.net",
      "quicksytes.com",
      "read-books.org",
      "securitytactics.com",
      "serveexchange.com",
      "servehumour.com",
      "servep2p.com",
      "servesarcasm.com",
      "stufftoread.com",
      "ufcfan.org",
      "unusualperson.com",
      "workisboring.com",
      "3utilities.com",
      "bounceme.net",
      "ddns.net",
      "ddnsking.com",
      "gotdns.ch",
      "hopto.org",
      "myftp.biz",
      "myftp.org",
      "myvnc.com",
      "no-ip.biz",
      "no-ip.info",
      "no-ip.org",
      "noip.me",
      "redirectme.net",
      "servebeer.com",
      "serveblog.net",
      "servecounterstrike.com",
      "serveftp.com",
      "servegame.com",
      "servehalflife.com",
      "servehttp.com",
      "serveirc.com",
      "serveminecraft.net",
      "servemp3.com",
      "servepics.com",
      "servequake.com",
      "sytes.net",
      "webhop.me",
      "zapto.org",
      "stage.nodeart.io",
      "nodum.co",
      "nodum.io",
      "pcloud.host",
      "nyc.mn",
      "nom.ae",
      "nom.af",
      "nom.ai",
      "nom.al",
      "nym.by",
      "nom.bz",
      "nym.bz",
      "nom.cl",
      "nym.ec",
      "nom.gd",
      "nom.ge",
      "nom.gl",
      "nym.gr",
      "nom.gt",
      "nym.gy",
      "nym.hk",
      "nom.hn",
      "nym.ie",
      "nom.im",
      "nom.ke",
      "nym.kz",
      "nym.la",
      "nym.lc",
      "nom.li",
      "nym.li",
      "nym.lt",
      "nym.lu",
      "nom.lv",
      "nym.me",
      "nom.mk",
      "nym.mn",
      "nym.mx",
      "nom.nu",
      "nym.nz",
      "nym.pe",
      "nym.pt",
      "nom.pw",
      "nom.qa",
      "nym.ro",
      "nom.rs",
      "nom.si",
      "nym.sk",
      "nom.st",
      "nym.su",
      "nym.sx",
      "nom.tj",
      "nym.tw",
      "nom.ug",
      "nom.uy",
      "nom.vc",
      "nom.vg",
      "static.observableusercontent.com",
      "cya.gg",
      "cloudycluster.net",
      "nid.io",
      "opencraft.hosting",
      "operaunite.com",
      "skygearapp.com",
      "outsystemscloud.com",
      "ownprovider.com",
      "own.pm",
      "ox.rs",
      "oy.lc",
      "pgfog.com",
      "pagefrontapp.com",
      "art.pl",
      "gliwice.pl",
      "krakow.pl",
      "poznan.pl",
      "wroc.pl",
      "zakopane.pl",
      "pantheonsite.io",
      "gotpantheon.com",
      "mypep.link",
      "perspecta.cloud",
      "on-web.fr",
      "*.platform.sh",
      "*.platformsh.site",
      "dyn53.io",
      "co.bn",
      "xen.prgmr.com",
      "priv.at",
      "prvcy.page",
      "*.dweb.link",
      "protonet.io",
      "chirurgiens-dentistes-en-france.fr",
      "byen.site",
      "pubtls.org",
      "qualifioapp.com",
      "qbuser.com",
      "instantcloud.cn",
      "ras.ru",
      "qa2.com",
      "qcx.io",
      "*.sys.qcx.io",
      "dev-myqnapcloud.com",
      "alpha-myqnapcloud.com",
      "myqnapcloud.com",
      "*.quipelements.com",
      "vapor.cloud",
      "vaporcloud.io",
      "rackmaze.com",
      "rackmaze.net",
      "*.on-k3s.io",
      "*.on-rancher.cloud",
      "*.on-rio.io",
      "readthedocs.io",
      "rhcloud.com",
      "app.render.com",
      "onrender.com",
      "repl.co",
      "repl.run",
      "resindevice.io",
      "devices.resinstaging.io",
      "hzc.io",
      "wellbeingzone.eu",
      "ptplus.fit",
      "wellbeingzone.co.uk",
      "git-pages.rit.edu",
      "sandcats.io",
      "logoip.de",
      "logoip.com",
      "schokokeks.net",
      "gov.scot",
      "scrysec.com",
      "firewall-gateway.com",
      "firewall-gateway.de",
      "my-gateway.de",
      "my-router.de",
      "spdns.de",
      "spdns.eu",
      "firewall-gateway.net",
      "my-firewall.org",
      "myfirewall.org",
      "spdns.org",
      "senseering.net",
      "biz.ua",
      "co.ua",
      "pp.ua",
      "shiftedit.io",
      "myshopblocks.com",
      "shopitsite.com",
      "mo-siemens.io",
      "1kapp.com",
      "appchizi.com",
      "applinzi.com",
      "sinaapp.com",
      "vipsinaapp.com",
      "siteleaf.net",
      "bounty-full.com",
      "alpha.bounty-full.com",
      "beta.bounty-full.com",
      "stackhero-network.com",
      "static.land",
      "dev.static.land",
      "sites.static.land",
      "apps.lair.io",
      "*.stolos.io",
      "spacekit.io",
      "customer.speedpartner.de",
      "api.stdlib.com",
      "storj.farm",
      "utwente.io",
      "soc.srcf.net",
      "user.srcf.net",
      "temp-dns.com",
      "applicationcloud.io",
      "scapp.io",
      "*.s5y.io",
      "*.sensiosite.cloud",
      "syncloud.it",
      "diskstation.me",
      "dscloud.biz",
      "dscloud.me",
      "dscloud.mobi",
      "dsmynas.com",
      "dsmynas.net",
      "dsmynas.org",
      "familyds.com",
      "familyds.net",
      "familyds.org",
      "i234.me",
      "myds.me",
      "synology.me",
      "vpnplus.to",
      "direct.quickconnect.to",
      "taifun-dns.de",
      "gda.pl",
      "gdansk.pl",
      "gdynia.pl",
      "med.pl",
      "sopot.pl",
      "edugit.org",
      "telebit.app",
      "telebit.io",
      "*.telebit.xyz",
      "gwiddle.co.uk",
      "thingdustdata.com",
      "cust.dev.thingdust.io",
      "cust.disrec.thingdust.io",
      "cust.prod.thingdust.io",
      "cust.testing.thingdust.io",
      "arvo.network",
      "azimuth.network",
      "bloxcms.com",
      "townnews-staging.com",
      "12hp.at",
      "2ix.at",
      "4lima.at",
      "lima-city.at",
      "12hp.ch",
      "2ix.ch",
      "4lima.ch",
      "lima-city.ch",
      "trafficplex.cloud",
      "de.cool",
      "12hp.de",
      "2ix.de",
      "4lima.de",
      "lima-city.de",
      "1337.pictures",
      "clan.rip",
      "lima-city.rocks",
      "webspace.rocks",
      "lima.zone",
      "*.transurl.be",
      "*.transurl.eu",
      "*.transurl.nl",
      "tuxfamily.org",
      "dd-dns.de",
      "diskstation.eu",
      "diskstation.org",
      "dray-dns.de",
      "draydns.de",
      "dyn-vpn.de",
      "dynvpn.de",
      "mein-vigor.de",
      "my-vigor.de",
      "my-wan.de",
      "syno-ds.de",
      "synology-diskstation.de",
      "synology-ds.de",
      "uber.space",
      "*.uberspace.de",
      "hk.com",
      "hk.org",
      "ltd.hk",
      "inc.hk",
      "virtualuser.de",
      "virtual-user.de",
      "urown.cloud",
      "dnsupdate.info",
      "lib.de.us",
      "2038.io",
      "router.management",
      "v-info.info",
      "voorloper.cloud",
      "v.ua",
      "wafflecell.com",
      "*.webhare.dev",
      "wedeploy.io",
      "wedeploy.me",
      "wedeploy.sh",
      "remotewd.com",
      "wmflabs.org",
      "myforum.community",
      "community-pro.de",
      "diskussionsbereich.de",
      "community-pro.net",
      "meinforum.net",
      "half.host",
      "xnbay.com",
      "u2.xnbay.com",
      "u2-local.xnbay.com",
      "cistron.nl",
      "demon.nl",
      "xs4all.space",
      "yandexcloud.net",
      "storage.yandexcloud.net",
      "website.yandexcloud.net",
      "official.academy",
      "yolasite.com",
      "ybo.faith",
      "yombo.me",
      "homelink.one",
      "ybo.party",
      "ybo.review",
      "ybo.science",
      "ybo.trade",
      "nohost.me",
      "noho.st",
      "za.net",
      "za.org",
      "now.sh",
      "bss.design",
      "basicserver.io",
      "virtualserver.io",
      "enterprisecloud.nu"
    ];
  }
});

// ../../node_modules/psl/index.js
var require_psl = __commonJS({
  "../../node_modules/psl/index.js"(exports2) {
    "use strict";
    var Punycode = require("punycode");
    var internals = {};
    internals.rules = require_rules().map(function(rule) {
      return {
        rule,
        suffix: rule.replace(/^(\*\.|\!)/, ""),
        punySuffix: -1,
        wildcard: rule.charAt(0) === "*",
        exception: rule.charAt(0) === "!"
      };
    });
    internals.endsWith = function(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };
    internals.findRule = function(domain) {
      var punyDomain = Punycode.toASCII(domain);
      return internals.rules.reduce(function(memo, rule) {
        if (rule.punySuffix === -1) {
          rule.punySuffix = Punycode.toASCII(rule.suffix);
        }
        if (!internals.endsWith(punyDomain, "." + rule.punySuffix) && punyDomain !== rule.punySuffix) {
          return memo;
        }
        return rule;
      }, null);
    };
    exports2.errorCodes = {
      DOMAIN_TOO_SHORT: "Domain name too short.",
      DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.",
      LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.",
      LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.",
      LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.",
      LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.",
      LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes."
    };
    internals.validate = function(input) {
      var ascii = Punycode.toASCII(input);
      if (ascii.length < 1) {
        return "DOMAIN_TOO_SHORT";
      }
      if (ascii.length > 255) {
        return "DOMAIN_TOO_LONG";
      }
      var labels = ascii.split(".");
      var label;
      for (var i = 0; i < labels.length; ++i) {
        label = labels[i];
        if (!label.length) {
          return "LABEL_TOO_SHORT";
        }
        if (label.length > 63) {
          return "LABEL_TOO_LONG";
        }
        if (label.charAt(0) === "-") {
          return "LABEL_STARTS_WITH_DASH";
        }
        if (label.charAt(label.length - 1) === "-") {
          return "LABEL_ENDS_WITH_DASH";
        }
        if (!/^[a-z0-9\-]+$/.test(label)) {
          return "LABEL_INVALID_CHARS";
        }
      }
    };
    exports2.parse = function(input) {
      if (typeof input !== "string") {
        throw new TypeError("Domain name must be a string.");
      }
      var domain = input.slice(0).toLowerCase();
      if (domain.charAt(domain.length - 1) === ".") {
        domain = domain.slice(0, domain.length - 1);
      }
      var error = internals.validate(domain);
      if (error) {
        return {
          input,
          error: {
            message: exports2.errorCodes[error],
            code: error
          }
        };
      }
      var parsed = {
        input,
        tld: null,
        sld: null,
        domain: null,
        subdomain: null,
        listed: false
      };
      var domainParts = domain.split(".");
      if (domainParts[domainParts.length - 1] === "local") {
        return parsed;
      }
      var handlePunycode = function() {
        if (!/xn--/.test(domain)) {
          return parsed;
        }
        if (parsed.domain) {
          parsed.domain = Punycode.toASCII(parsed.domain);
        }
        if (parsed.subdomain) {
          parsed.subdomain = Punycode.toASCII(parsed.subdomain);
        }
        return parsed;
      };
      var rule = internals.findRule(domain);
      if (!rule) {
        if (domainParts.length < 2) {
          return parsed;
        }
        parsed.tld = domainParts.pop();
        parsed.sld = domainParts.pop();
        parsed.domain = [parsed.sld, parsed.tld].join(".");
        if (domainParts.length) {
          parsed.subdomain = domainParts.pop();
        }
        return handlePunycode();
      }
      parsed.listed = true;
      var tldParts = rule.suffix.split(".");
      var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);
      if (rule.exception) {
        privateParts.push(tldParts.shift());
      }
      parsed.tld = tldParts.join(".");
      if (!privateParts.length) {
        return handlePunycode();
      }
      if (rule.wildcard) {
        tldParts.unshift(privateParts.pop());
        parsed.tld = tldParts.join(".");
      }
      if (!privateParts.length) {
        return handlePunycode();
      }
      parsed.sld = privateParts.pop();
      parsed.domain = [parsed.sld, parsed.tld].join(".");
      if (privateParts.length) {
        parsed.subdomain = privateParts.join(".");
      }
      return handlePunycode();
    };
    exports2.get = function(domain) {
      if (!domain) {
        return null;
      }
      return exports2.parse(domain).domain || null;
    };
    exports2.isValid = function(domain) {
      var parsed = exports2.parse(domain);
      return Boolean(parsed.domain && parsed.listed);
    };
  }
});

// ../../node_modules/tough-cookie/lib/pubsuffix-psl.js
var require_pubsuffix_psl = __commonJS({
  "../../node_modules/tough-cookie/lib/pubsuffix-psl.js"(exports2) {
    "use strict";
    var psl = require_psl();
    function getPublicSuffix(domain) {
      return psl.get(domain);
    }
    exports2.getPublicSuffix = getPublicSuffix;
  }
});

// ../../node_modules/tough-cookie/lib/store.js
var require_store = __commonJS({
  "../../node_modules/tough-cookie/lib/store.js"(exports2) {
    "use strict";
    function Store() {
    }
    exports2.Store = Store;
    Store.prototype.synchronous = false;
    Store.prototype.findCookie = function(domain, path2, key, cb) {
      throw new Error("findCookie is not implemented");
    };
    Store.prototype.findCookies = function(domain, path2, cb) {
      throw new Error("findCookies is not implemented");
    };
    Store.prototype.putCookie = function(cookie, cb) {
      throw new Error("putCookie is not implemented");
    };
    Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
      throw new Error("updateCookie is not implemented");
    };
    Store.prototype.removeCookie = function(domain, path2, key, cb) {
      throw new Error("removeCookie is not implemented");
    };
    Store.prototype.removeCookies = function(domain, path2, cb) {
      throw new Error("removeCookies is not implemented");
    };
    Store.prototype.removeAllCookies = function(cb) {
      throw new Error("removeAllCookies is not implemented");
    };
    Store.prototype.getAllCookies = function(cb) {
      throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
    };
  }
});

// ../../node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain = __commonJS({
  "../../node_modules/tough-cookie/lib/permuteDomain.js"(exports2) {
    "use strict";
    var pubsuffix = require_pubsuffix_psl();
    function permuteDomain(domain) {
      var pubSuf = pubsuffix.getPublicSuffix(domain);
      if (!pubSuf) {
        return null;
      }
      if (pubSuf == domain) {
        return [domain];
      }
      var prefix = domain.slice(0, -(pubSuf.length + 1));
      var parts = prefix.split(".").reverse();
      var cur = pubSuf;
      var permutations = [cur];
      while (parts.length) {
        cur = parts.shift() + "." + cur;
        permutations.push(cur);
      }
      return permutations;
    }
    exports2.permuteDomain = permuteDomain;
  }
});

// ../../node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch = __commonJS({
  "../../node_modules/tough-cookie/lib/pathMatch.js"(exports2) {
    "use strict";
    function pathMatch(reqPath, cookiePath) {
      if (cookiePath === reqPath) {
        return true;
      }
      var idx = reqPath.indexOf(cookiePath);
      if (idx === 0) {
        if (cookiePath.substr(-1) === "/") {
          return true;
        }
        if (reqPath.substr(cookiePath.length, 1) === "/") {
          return true;
        }
      }
      return false;
    }
    exports2.pathMatch = pathMatch;
  }
});

// ../../node_modules/tough-cookie/lib/memstore.js
var require_memstore = __commonJS({
  "../../node_modules/tough-cookie/lib/memstore.js"(exports2) {
    "use strict";
    var Store = require_store().Store;
    var permuteDomain = require_permuteDomain().permuteDomain;
    var pathMatch = require_pathMatch().pathMatch;
    var util2 = require("util");
    function MemoryCookieStore() {
      Store.call(this);
      this.idx = {};
    }
    util2.inherits(MemoryCookieStore, Store);
    exports2.MemoryCookieStore = MemoryCookieStore;
    MemoryCookieStore.prototype.idx = null;
    MemoryCookieStore.prototype.synchronous = true;
    MemoryCookieStore.prototype.inspect = function() {
      return "{ idx: " + util2.inspect(this.idx, false, 2) + " }";
    };
    if (util2.inspect.custom) {
      MemoryCookieStore.prototype[util2.inspect.custom] = MemoryCookieStore.prototype.inspect;
    }
    MemoryCookieStore.prototype.findCookie = function(domain, path2, key, cb) {
      if (!this.idx[domain]) {
        return cb(null, void 0);
      }
      if (!this.idx[domain][path2]) {
        return cb(null, void 0);
      }
      return cb(null, this.idx[domain][path2][key] || null);
    };
    MemoryCookieStore.prototype.findCookies = function(domain, path2, cb) {
      var results = [];
      if (!domain) {
        return cb(null, []);
      }
      var pathMatcher;
      if (!path2) {
        pathMatcher = function matchAll(domainIndex) {
          for (var curPath in domainIndex) {
            var pathIndex = domainIndex[curPath];
            for (var key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        };
      } else {
        pathMatcher = function matchRFC(domainIndex) {
          Object.keys(domainIndex).forEach(function(cookiePath) {
            if (pathMatch(path2, cookiePath)) {
              var pathIndex = domainIndex[cookiePath];
              for (var key in pathIndex) {
                results.push(pathIndex[key]);
              }
            }
          });
        };
      }
      var domains = permuteDomain(domain) || [domain];
      var idx = this.idx;
      domains.forEach(function(curDomain) {
        var domainIndex = idx[curDomain];
        if (!domainIndex) {
          return;
        }
        pathMatcher(domainIndex);
      });
      cb(null, results);
    };
    MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
      if (!this.idx[cookie.domain]) {
        this.idx[cookie.domain] = {};
      }
      if (!this.idx[cookie.domain][cookie.path]) {
        this.idx[cookie.domain][cookie.path] = {};
      }
      this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
      cb(null);
    };
    MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
      this.putCookie(newCookie, cb);
    };
    MemoryCookieStore.prototype.removeCookie = function(domain, path2, key, cb) {
      if (this.idx[domain] && this.idx[domain][path2] && this.idx[domain][path2][key]) {
        delete this.idx[domain][path2][key];
      }
      cb(null);
    };
    MemoryCookieStore.prototype.removeCookies = function(domain, path2, cb) {
      if (this.idx[domain]) {
        if (path2) {
          delete this.idx[domain][path2];
        } else {
          delete this.idx[domain];
        }
      }
      return cb(null);
    };
    MemoryCookieStore.prototype.removeAllCookies = function(cb) {
      this.idx = {};
      return cb(null);
    };
    MemoryCookieStore.prototype.getAllCookies = function(cb) {
      var cookies = [];
      var idx = this.idx;
      var domains = Object.keys(idx);
      domains.forEach(function(domain) {
        var paths = Object.keys(idx[domain]);
        paths.forEach(function(path2) {
          var keys = Object.keys(idx[domain][path2]);
          keys.forEach(function(key) {
            if (key !== null) {
              cookies.push(idx[domain][path2][key]);
            }
          });
        });
      });
      cookies.sort(function(a, b) {
        return (a.creationIndex || 0) - (b.creationIndex || 0);
      });
      cb(null, cookies);
    };
  }
});

// ../../node_modules/tough-cookie/lib/version.js
var require_version = __commonJS({
  "../../node_modules/tough-cookie/lib/version.js"(exports2, module2) {
    module2.exports = "2.5.0";
  }
});

// ../../node_modules/tough-cookie/lib/cookie.js
var require_cookie = __commonJS({
  "../../node_modules/tough-cookie/lib/cookie.js"(exports2) {
    "use strict";
    var net = require("net");
    var urlParse = require("url").parse;
    var util2 = require("util");
    var pubsuffix = require_pubsuffix_psl();
    var Store = require_store().Store;
    var MemoryCookieStore = require_memstore().MemoryCookieStore;
    var pathMatch = require_pathMatch().pathMatch;
    var VERSION5 = require_version();
    var punycode;
    try {
      punycode = require("punycode");
    } catch (e) {
      console.warn("tough-cookie: can't load punycode; won't use punycode for domain normalization");
    }
    var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
    var CONTROL_CHARS = /[\x00-\x1F]/;
    var TERMINATORS = ["\n", "\r", "\0"];
    var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
    var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
    var MONTH_TO_NUM = {
      jan: 0,
      feb: 1,
      mar: 2,
      apr: 3,
      may: 4,
      jun: 5,
      jul: 6,
      aug: 7,
      sep: 8,
      oct: 9,
      nov: 10,
      dec: 11
    };
    var NUM_TO_MONTH = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var NUM_TO_DAY = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    var MAX_TIME = 2147483647e3;
    var MIN_TIME = 0;
    function parseDigits(token, minDigits, maxDigits, trailingOK) {
      var count = 0;
      while (count < token.length) {
        var c = token.charCodeAt(count);
        if (c <= 47 || c >= 58) {
          break;
        }
        count++;
      }
      if (count < minDigits || count > maxDigits) {
        return null;
      }
      if (!trailingOK && count != token.length) {
        return null;
      }
      return parseInt(token.substr(0, count), 10);
    }
    function parseTime(token) {
      var parts = token.split(":");
      var result = [0, 0, 0];
      if (parts.length !== 3) {
        return null;
      }
      for (var i = 0; i < 3; i++) {
        var trailingOK = i == 2;
        var num = parseDigits(parts[i], 1, 2, trailingOK);
        if (num === null) {
          return null;
        }
        result[i] = num;
      }
      return result;
    }
    function parseMonth(token) {
      token = String(token).substr(0, 3).toLowerCase();
      var num = MONTH_TO_NUM[token];
      return num >= 0 ? num : null;
    }
    function parseDate(str) {
      if (!str) {
        return;
      }
      var tokens = str.split(DATE_DELIM);
      if (!tokens) {
        return;
      }
      var hour = null;
      var minute = null;
      var second = null;
      var dayOfMonth = null;
      var month = null;
      var year = null;
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i].trim();
        if (!token.length) {
          continue;
        }
        var result;
        if (second === null) {
          result = parseTime(token);
          if (result) {
            hour = result[0];
            minute = result[1];
            second = result[2];
            continue;
          }
        }
        if (dayOfMonth === null) {
          result = parseDigits(token, 1, 2, true);
          if (result !== null) {
            dayOfMonth = result;
            continue;
          }
        }
        if (month === null) {
          result = parseMonth(token);
          if (result !== null) {
            month = result;
            continue;
          }
        }
        if (year === null) {
          result = parseDigits(token, 2, 4, true);
          if (result !== null) {
            year = result;
            if (year >= 70 && year <= 99) {
              year += 1900;
            } else if (year >= 0 && year <= 69) {
              year += 2e3;
            }
          }
        }
      }
      if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
        return;
      }
      return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
    }
    function formatDate(date) {
      var d = date.getUTCDate();
      d = d >= 10 ? d : "0" + d;
      var h = date.getUTCHours();
      h = h >= 10 ? h : "0" + h;
      var m = date.getUTCMinutes();
      m = m >= 10 ? m : "0" + m;
      var s = date.getUTCSeconds();
      s = s >= 10 ? s : "0" + s;
      return NUM_TO_DAY[date.getUTCDay()] + ", " + d + " " + NUM_TO_MONTH[date.getUTCMonth()] + " " + date.getUTCFullYear() + " " + h + ":" + m + ":" + s + " GMT";
    }
    function canonicalDomain(str) {
      if (str == null) {
        return null;
      }
      str = str.trim().replace(/^\./, "");
      if (punycode && /[^\u0001-\u007f]/.test(str)) {
        str = punycode.toASCII(str);
      }
      return str.toLowerCase();
    }
    function domainMatch(str, domStr, canonicalize) {
      if (str == null || domStr == null) {
        return null;
      }
      if (canonicalize !== false) {
        str = canonicalDomain(str);
        domStr = canonicalDomain(domStr);
      }
      if (str == domStr) {
        return true;
      }
      if (net.isIP(str)) {
        return false;
      }
      var idx = str.indexOf(domStr);
      if (idx <= 0) {
        return false;
      }
      if (str.length !== domStr.length + idx) {
        return false;
      }
      if (str.substr(idx - 1, 1) !== ".") {
        return false;
      }
      return true;
    }
    function defaultPath(path2) {
      if (!path2 || path2.substr(0, 1) !== "/") {
        return "/";
      }
      if (path2 === "/") {
        return path2;
      }
      var rightSlash = path2.lastIndexOf("/");
      if (rightSlash === 0) {
        return "/";
      }
      return path2.slice(0, rightSlash);
    }
    function trimTerminator(str) {
      for (var t = 0; t < TERMINATORS.length; t++) {
        var terminatorIdx = str.indexOf(TERMINATORS[t]);
        if (terminatorIdx !== -1) {
          str = str.substr(0, terminatorIdx);
        }
      }
      return str;
    }
    function parseCookiePair(cookiePair, looseMode) {
      cookiePair = trimTerminator(cookiePair);
      var firstEq = cookiePair.indexOf("=");
      if (looseMode) {
        if (firstEq === 0) {
          cookiePair = cookiePair.substr(1);
          firstEq = cookiePair.indexOf("=");
        }
      } else {
        if (firstEq <= 0) {
          return;
        }
      }
      var cookieName, cookieValue;
      if (firstEq <= 0) {
        cookieName = "";
        cookieValue = cookiePair.trim();
      } else {
        cookieName = cookiePair.substr(0, firstEq).trim();
        cookieValue = cookiePair.substr(firstEq + 1).trim();
      }
      if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
        return;
      }
      var c = new Cookie();
      c.key = cookieName;
      c.value = cookieValue;
      return c;
    }
    function parse(str, options) {
      if (!options || typeof options !== "object") {
        options = {};
      }
      str = str.trim();
      var firstSemi = str.indexOf(";");
      var cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
      var c = parseCookiePair(cookiePair, !!options.loose);
      if (!c) {
        return;
      }
      if (firstSemi === -1) {
        return c;
      }
      var unparsed = str.slice(firstSemi + 1).trim();
      if (unparsed.length === 0) {
        return c;
      }
      var cookie_avs = unparsed.split(";");
      while (cookie_avs.length) {
        var av = cookie_avs.shift().trim();
        if (av.length === 0) {
          continue;
        }
        var av_sep = av.indexOf("=");
        var av_key, av_value;
        if (av_sep === -1) {
          av_key = av;
          av_value = null;
        } else {
          av_key = av.substr(0, av_sep);
          av_value = av.substr(av_sep + 1);
        }
        av_key = av_key.trim().toLowerCase();
        if (av_value) {
          av_value = av_value.trim();
        }
        switch (av_key) {
          case "expires":
            if (av_value) {
              var exp = parseDate(av_value);
              if (exp) {
                c.expires = exp;
              }
            }
            break;
          case "max-age":
            if (av_value) {
              if (/^-?[0-9]+$/.test(av_value)) {
                var delta = parseInt(av_value, 10);
                c.setMaxAge(delta);
              }
            }
            break;
          case "domain":
            if (av_value) {
              var domain = av_value.trim().replace(/^\./, "");
              if (domain) {
                c.domain = domain.toLowerCase();
              }
            }
            break;
          case "path":
            c.path = av_value && av_value[0] === "/" ? av_value : null;
            break;
          case "secure":
            c.secure = true;
            break;
          case "httponly":
            c.httpOnly = true;
            break;
          default:
            c.extensions = c.extensions || [];
            c.extensions.push(av);
            break;
        }
      }
      return c;
    }
    function jsonParse(str) {
      var obj;
      try {
        obj = JSON.parse(str);
      } catch (e) {
        return e;
      }
      return obj;
    }
    function fromJSON(str) {
      if (!str) {
        return null;
      }
      var obj;
      if (typeof str === "string") {
        obj = jsonParse(str);
        if (obj instanceof Error) {
          return null;
        }
      } else {
        obj = str;
      }
      var c = new Cookie();
      for (var i = 0; i < Cookie.serializableProperties.length; i++) {
        var prop = Cookie.serializableProperties[i];
        if (obj[prop] === void 0 || obj[prop] === Cookie.prototype[prop]) {
          continue;
        }
        if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
          if (obj[prop] === null) {
            c[prop] = null;
          } else {
            c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
          }
        } else {
          c[prop] = obj[prop];
        }
      }
      return c;
    }
    function cookieCompare(a, b) {
      var cmp = 0;
      var aPathLen = a.path ? a.path.length : 0;
      var bPathLen = b.path ? b.path.length : 0;
      cmp = bPathLen - aPathLen;
      if (cmp !== 0) {
        return cmp;
      }
      var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
      var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
      cmp = aTime - bTime;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = a.creationIndex - b.creationIndex;
      return cmp;
    }
    function permutePath(path2) {
      if (path2 === "/") {
        return ["/"];
      }
      if (path2.lastIndexOf("/") === path2.length - 1) {
        path2 = path2.substr(0, path2.length - 1);
      }
      var permutations = [path2];
      while (path2.length > 1) {
        var lindex = path2.lastIndexOf("/");
        if (lindex === 0) {
          break;
        }
        path2 = path2.substr(0, lindex);
        permutations.push(path2);
      }
      permutations.push("/");
      return permutations;
    }
    function getCookieContext(url) {
      if (url instanceof Object) {
        return url;
      }
      try {
        url = decodeURI(url);
      } catch (err) {
      }
      return urlParse(url);
    }
    function Cookie(options) {
      options = options || {};
      Object.keys(options).forEach(function(prop) {
        if (Cookie.prototype.hasOwnProperty(prop) && Cookie.prototype[prop] !== options[prop] && prop.substr(0, 1) !== "_") {
          this[prop] = options[prop];
        }
      }, this);
      this.creation = this.creation || new Date();
      Object.defineProperty(this, "creationIndex", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: ++Cookie.cookiesCreated
      });
    }
    Cookie.cookiesCreated = 0;
    Cookie.parse = parse;
    Cookie.fromJSON = fromJSON;
    Cookie.prototype.key = "";
    Cookie.prototype.value = "";
    Cookie.prototype.expires = "Infinity";
    Cookie.prototype.maxAge = null;
    Cookie.prototype.domain = null;
    Cookie.prototype.path = null;
    Cookie.prototype.secure = false;
    Cookie.prototype.httpOnly = false;
    Cookie.prototype.extensions = null;
    Cookie.prototype.hostOnly = null;
    Cookie.prototype.pathIsDefault = null;
    Cookie.prototype.creation = null;
    Cookie.prototype.lastAccessed = null;
    Object.defineProperty(Cookie.prototype, "creationIndex", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: 0
    });
    Cookie.serializableProperties = Object.keys(Cookie.prototype).filter(function(prop) {
      return !(Cookie.prototype[prop] instanceof Function || prop === "creationIndex" || prop.substr(0, 1) === "_");
    });
    Cookie.prototype.inspect = function inspect() {
      var now = Date.now();
      return 'Cookie="' + this.toString() + "; hostOnly=" + (this.hostOnly != null ? this.hostOnly : "?") + "; aAge=" + (this.lastAccessed ? now - this.lastAccessed.getTime() + "ms" : "?") + "; cAge=" + (this.creation ? now - this.creation.getTime() + "ms" : "?") + '"';
    };
    if (util2.inspect.custom) {
      Cookie.prototype[util2.inspect.custom] = Cookie.prototype.inspect;
    }
    Cookie.prototype.toJSON = function() {
      var obj = {};
      var props = Cookie.serializableProperties;
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        if (this[prop] === Cookie.prototype[prop]) {
          continue;
        }
        if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
          if (this[prop] === null) {
            obj[prop] = null;
          } else {
            obj[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString();
          }
        } else if (prop === "maxAge") {
          if (this[prop] !== null) {
            obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
          }
        } else {
          if (this[prop] !== Cookie.prototype[prop]) {
            obj[prop] = this[prop];
          }
        }
      }
      return obj;
    };
    Cookie.prototype.clone = function() {
      return fromJSON(this.toJSON());
    };
    Cookie.prototype.validate = function validate() {
      if (!COOKIE_OCTETS.test(this.value)) {
        return false;
      }
      if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
        return false;
      }
      if (this.maxAge != null && this.maxAge <= 0) {
        return false;
      }
      if (this.path != null && !PATH_VALUE.test(this.path)) {
        return false;
      }
      var cdomain = this.cdomain();
      if (cdomain) {
        if (cdomain.match(/\.$/)) {
          return false;
        }
        var suffix = pubsuffix.getPublicSuffix(cdomain);
        if (suffix == null) {
          return false;
        }
      }
      return true;
    };
    Cookie.prototype.setExpires = function setExpires(exp) {
      if (exp instanceof Date) {
        this.expires = exp;
      } else {
        this.expires = parseDate(exp) || "Infinity";
      }
    };
    Cookie.prototype.setMaxAge = function setMaxAge(age) {
      if (age === Infinity || age === -Infinity) {
        this.maxAge = age.toString();
      } else {
        this.maxAge = age;
      }
    };
    Cookie.prototype.cookieString = function cookieString() {
      var val = this.value;
      if (val == null) {
        val = "";
      }
      if (this.key === "") {
        return val;
      }
      return this.key + "=" + val;
    };
    Cookie.prototype.toString = function toString() {
      var str = this.cookieString();
      if (this.expires != Infinity) {
        if (this.expires instanceof Date) {
          str += "; Expires=" + formatDate(this.expires);
        } else {
          str += "; Expires=" + this.expires;
        }
      }
      if (this.maxAge != null && this.maxAge != Infinity) {
        str += "; Max-Age=" + this.maxAge;
      }
      if (this.domain && !this.hostOnly) {
        str += "; Domain=" + this.domain;
      }
      if (this.path) {
        str += "; Path=" + this.path;
      }
      if (this.secure) {
        str += "; Secure";
      }
      if (this.httpOnly) {
        str += "; HttpOnly";
      }
      if (this.extensions) {
        this.extensions.forEach(function(ext) {
          str += "; " + ext;
        });
      }
      return str;
    };
    Cookie.prototype.TTL = function TTL(now) {
      if (this.maxAge != null) {
        return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
      }
      var expires = this.expires;
      if (expires != Infinity) {
        if (!(expires instanceof Date)) {
          expires = parseDate(expires) || Infinity;
        }
        if (expires == Infinity) {
          return Infinity;
        }
        return expires.getTime() - (now || Date.now());
      }
      return Infinity;
    };
    Cookie.prototype.expiryTime = function expiryTime(now) {
      if (this.maxAge != null) {
        var relativeTo = now || this.creation || new Date();
        var age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
        return relativeTo.getTime() + age;
      }
      if (this.expires == Infinity) {
        return Infinity;
      }
      return this.expires.getTime();
    };
    Cookie.prototype.expiryDate = function expiryDate(now) {
      var millisec = this.expiryTime(now);
      if (millisec == Infinity) {
        return new Date(MAX_TIME);
      } else if (millisec == -Infinity) {
        return new Date(MIN_TIME);
      } else {
        return new Date(millisec);
      }
    };
    Cookie.prototype.isPersistent = function isPersistent() {
      return this.maxAge != null || this.expires != Infinity;
    };
    Cookie.prototype.cdomain = Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
      if (this.domain == null) {
        return null;
      }
      return canonicalDomain(this.domain);
    };
    function CookieJar(store, options) {
      if (typeof options === "boolean") {
        options = { rejectPublicSuffixes: options };
      } else if (options == null) {
        options = {};
      }
      if (options.rejectPublicSuffixes != null) {
        this.rejectPublicSuffixes = options.rejectPublicSuffixes;
      }
      if (options.looseMode != null) {
        this.enableLooseMode = options.looseMode;
      }
      if (!store) {
        store = new MemoryCookieStore();
      }
      this.store = store;
    }
    CookieJar.prototype.store = null;
    CookieJar.prototype.rejectPublicSuffixes = true;
    CookieJar.prototype.enableLooseMode = false;
    var CAN_BE_SYNC = [];
    CAN_BE_SYNC.push("setCookie");
    CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
      var err;
      var context = getCookieContext(url);
      if (options instanceof Function) {
        cb = options;
        options = {};
      }
      var host = canonicalDomain(context.hostname);
      var loose = this.enableLooseMode;
      if (options.loose != null) {
        loose = options.loose;
      }
      if (!(cookie instanceof Cookie)) {
        cookie = Cookie.parse(cookie, { loose });
      }
      if (!cookie) {
        err = new Error("Cookie failed to parse");
        return cb(options.ignoreError ? null : err);
      }
      var now = options.now || new Date();
      if (this.rejectPublicSuffixes && cookie.domain) {
        var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
        if (suffix == null) {
          err = new Error("Cookie has domain set to a public suffix");
          return cb(options.ignoreError ? null : err);
        }
      }
      if (cookie.domain) {
        if (!domainMatch(host, cookie.cdomain(), false)) {
          err = new Error("Cookie not in this host's domain. Cookie:" + cookie.cdomain() + " Request:" + host);
          return cb(options.ignoreError ? null : err);
        }
        if (cookie.hostOnly == null) {
          cookie.hostOnly = false;
        }
      } else {
        cookie.hostOnly = true;
        cookie.domain = host;
      }
      if (!cookie.path || cookie.path[0] !== "/") {
        cookie.path = defaultPath(context.pathname);
        cookie.pathIsDefault = true;
      }
      if (options.http === false && cookie.httpOnly) {
        err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
        return cb(options.ignoreError ? null : err);
      }
      var store = this.store;
      if (!store.updateCookie) {
        store.updateCookie = function(oldCookie, newCookie, cb2) {
          this.putCookie(newCookie, cb2);
        };
      }
      function withCookie(err2, oldCookie) {
        if (err2) {
          return cb(err2);
        }
        var next = function(err3) {
          if (err3) {
            return cb(err3);
          } else {
            cb(null, cookie);
          }
        };
        if (oldCookie) {
          if (options.http === false && oldCookie.httpOnly) {
            err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
            return cb(options.ignoreError ? null : err2);
          }
          cookie.creation = oldCookie.creation;
          cookie.creationIndex = oldCookie.creationIndex;
          cookie.lastAccessed = now;
          store.updateCookie(oldCookie, cookie, next);
        } else {
          cookie.creation = cookie.lastAccessed = now;
          store.putCookie(cookie, next);
        }
      }
      store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
    };
    CAN_BE_SYNC.push("getCookies");
    CookieJar.prototype.getCookies = function(url, options, cb) {
      var context = getCookieContext(url);
      if (options instanceof Function) {
        cb = options;
        options = {};
      }
      var host = canonicalDomain(context.hostname);
      var path2 = context.pathname || "/";
      var secure = options.secure;
      if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
        secure = true;
      }
      var http2 = options.http;
      if (http2 == null) {
        http2 = true;
      }
      var now = options.now || Date.now();
      var expireCheck = options.expire !== false;
      var allPaths = !!options.allPaths;
      var store = this.store;
      function matchingCookie(c) {
        if (c.hostOnly) {
          if (c.domain != host) {
            return false;
          }
        } else {
          if (!domainMatch(host, c.domain, false)) {
            return false;
          }
        }
        if (!allPaths && !pathMatch(path2, c.path)) {
          return false;
        }
        if (c.secure && !secure) {
          return false;
        }
        if (c.httpOnly && !http2) {
          return false;
        }
        if (expireCheck && c.expiryTime() <= now) {
          store.removeCookie(c.domain, c.path, c.key, function() {
          });
          return false;
        }
        return true;
      }
      store.findCookies(host, allPaths ? null : path2, function(err, cookies) {
        if (err) {
          return cb(err);
        }
        cookies = cookies.filter(matchingCookie);
        if (options.sort !== false) {
          cookies = cookies.sort(cookieCompare);
        }
        var now2 = new Date();
        cookies.forEach(function(c) {
          c.lastAccessed = now2;
        });
        cb(null, cookies);
      });
    };
    CAN_BE_SYNC.push("getCookieString");
    CookieJar.prototype.getCookieString = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      var cb = args.pop();
      var next = function(err, cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies.sort(cookieCompare).map(function(c) {
            return c.cookieString();
          }).join("; "));
        }
      };
      args.push(next);
      this.getCookies.apply(this, args);
    };
    CAN_BE_SYNC.push("getSetCookieStrings");
    CookieJar.prototype.getSetCookieStrings = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      var cb = args.pop();
      var next = function(err, cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies.map(function(c) {
            return c.toString();
          }));
        }
      };
      args.push(next);
      this.getCookies.apply(this, args);
    };
    CAN_BE_SYNC.push("serialize");
    CookieJar.prototype.serialize = function(cb) {
      var type = this.store.constructor.name;
      if (type === "Object") {
        type = null;
      }
      var serialized = {
        version: "tough-cookie@" + VERSION5,
        storeType: type,
        rejectPublicSuffixes: !!this.rejectPublicSuffixes,
        cookies: []
      };
      if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
        return cb(new Error("store does not support getAllCookies and cannot be serialized"));
      }
      this.store.getAllCookies(function(err, cookies) {
        if (err) {
          return cb(err);
        }
        serialized.cookies = cookies.map(function(cookie) {
          cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;
          delete cookie.creationIndex;
          return cookie;
        });
        return cb(null, serialized);
      });
    };
    CookieJar.prototype.toJSON = function() {
      return this.serializeSync();
    };
    CAN_BE_SYNC.push("_importCookies");
    CookieJar.prototype._importCookies = function(serialized, cb) {
      var jar = this;
      var cookies = serialized.cookies;
      if (!cookies || !Array.isArray(cookies)) {
        return cb(new Error("serialized jar has no cookies array"));
      }
      cookies = cookies.slice();
      function putNext(err) {
        if (err) {
          return cb(err);
        }
        if (!cookies.length) {
          return cb(err, jar);
        }
        var cookie;
        try {
          cookie = fromJSON(cookies.shift());
        } catch (e) {
          return cb(e);
        }
        if (cookie === null) {
          return putNext(null);
        }
        jar.store.putCookie(cookie, putNext);
      }
      putNext();
    };
    CookieJar.deserialize = function(strOrObj, store, cb) {
      if (arguments.length !== 3) {
        cb = store;
        store = null;
      }
      var serialized;
      if (typeof strOrObj === "string") {
        serialized = jsonParse(strOrObj);
        if (serialized instanceof Error) {
          return cb(serialized);
        }
      } else {
        serialized = strOrObj;
      }
      var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
      jar._importCookies(serialized, function(err) {
        if (err) {
          return cb(err);
        }
        cb(null, jar);
      });
    };
    CookieJar.deserializeSync = function(strOrObj, store) {
      var serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
      var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
      if (!jar.store.synchronous) {
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      }
      jar._importCookiesSync(serialized);
      return jar;
    };
    CookieJar.fromJSON = CookieJar.deserializeSync;
    CookieJar.prototype.clone = function(newStore, cb) {
      if (arguments.length === 1) {
        cb = newStore;
        newStore = null;
      }
      this.serialize(function(err, serialized) {
        if (err) {
          return cb(err);
        }
        CookieJar.deserialize(serialized, newStore, cb);
      });
    };
    CAN_BE_SYNC.push("removeAllCookies");
    CookieJar.prototype.removeAllCookies = function(cb) {
      var store = this.store;
      if (store.removeAllCookies instanceof Function && store.removeAllCookies !== Store.prototype.removeAllCookies) {
        return store.removeAllCookies(cb);
      }
      store.getAllCookies(function(err, cookies) {
        if (err) {
          return cb(err);
        }
        if (cookies.length === 0) {
          return cb(null);
        }
        var completedCount = 0;
        var removeErrors = [];
        function removeCookieCb(removeErr) {
          if (removeErr) {
            removeErrors.push(removeErr);
          }
          completedCount++;
          if (completedCount === cookies.length) {
            return cb(removeErrors.length ? removeErrors[0] : null);
          }
        }
        cookies.forEach(function(cookie) {
          store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
        });
      });
    };
    CookieJar.prototype._cloneSync = syncWrap("clone");
    CookieJar.prototype.cloneSync = function(newStore) {
      if (!newStore.synchronous) {
        throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
      }
      return this._cloneSync(newStore);
    };
    function syncWrap(method) {
      return function() {
        if (!this.store.synchronous) {
          throw new Error("CookieJar store is not synchronous; use async API instead.");
        }
        var args = Array.prototype.slice.call(arguments);
        var syncErr, syncResult;
        args.push(function syncCb(err, result) {
          syncErr = err;
          syncResult = result;
        });
        this[method].apply(this, args);
        if (syncErr) {
          throw syncErr;
        }
        return syncResult;
      };
    }
    CAN_BE_SYNC.forEach(function(method) {
      CookieJar.prototype[method + "Sync"] = syncWrap(method);
    });
    exports2.version = VERSION5;
    exports2.CookieJar = CookieJar;
    exports2.Cookie = Cookie;
    exports2.Store = Store;
    exports2.MemoryCookieStore = MemoryCookieStore;
    exports2.parseDate = parseDate;
    exports2.formatDate = formatDate;
    exports2.parse = parse;
    exports2.fromJSON = fromJSON;
    exports2.domainMatch = domainMatch;
    exports2.defaultPath = defaultPath;
    exports2.pathMatch = pathMatch;
    exports2.getPublicSuffix = pubsuffix.getPublicSuffix;
    exports2.cookieCompare = cookieCompare;
    exports2.permuteDomain = require_permuteDomain().permuteDomain;
    exports2.permutePath = permutePath;
    exports2.canonicalDomain = canonicalDomain;
  }
});

// ../../node_modules/request/lib/cookies.js
var require_cookies = __commonJS({
  "../../node_modules/request/lib/cookies.js"(exports2) {
    "use strict";
    var tough = require_cookie();
    var Cookie = tough.Cookie;
    var CookieJar = tough.CookieJar;
    exports2.parse = function(str) {
      if (str && str.uri) {
        str = str.uri;
      }
      if (typeof str !== "string") {
        throw new Error("The cookie function only accepts STRING as param");
      }
      return Cookie.parse(str, { loose: true });
    };
    function RequestJar(store) {
      var self2 = this;
      self2._jar = new CookieJar(store, { looseMode: true });
    }
    RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
      var self2 = this;
      return self2._jar.setCookieSync(cookieOrStr, uri, options || {});
    };
    RequestJar.prototype.getCookieString = function(uri) {
      var self2 = this;
      return self2._jar.getCookieStringSync(uri);
    };
    RequestJar.prototype.getCookies = function(uri) {
      var self2 = this;
      return self2._jar.getCookiesSync(uri);
    };
    exports2.jar = function(store) {
      return new RequestJar(store);
    };
  }
});

// ../../node_modules/json-stringify-safe/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/json-stringify-safe/stringify.js"(exports2, module2) {
    exports2 = module2.exports = stringify;
    exports2.getSerialize = serializer;
    function stringify(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
    }
    function serializer(replacer, cycleReplacer) {
      var stack = [], keys = [];
      if (cycleReplacer == null)
        cycleReplacer = function(key, value) {
          if (stack[0] === value)
            return "[Circular ~]";
          return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        };
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value))
            value = cycleReplacer.call(this, key, value);
        } else
          stack.push(value);
        return replacer == null ? value : replacer.call(this, key, value);
      };
    }
  }
});

// ../../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/request/lib/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/request/lib/helpers.js"(exports2) {
    "use strict";
    var jsonSafeStringify = require_stringify();
    var crypto = require("crypto");
    var Buffer2 = require_safe_buffer().Buffer;
    var defer = typeof setImmediate === "undefined" ? process.nextTick : setImmediate;
    function paramsHaveRequestBody(params) {
      return params.body || params.requestBodyStream || params.json && typeof params.json !== "boolean" || params.multipart;
    }
    function safeStringify(obj, replacer) {
      var ret;
      try {
        ret = JSON.stringify(obj, replacer);
      } catch (e) {
        ret = jsonSafeStringify(obj, replacer);
      }
      return ret;
    }
    function md5(str) {
      return crypto.createHash("md5").update(str).digest("hex");
    }
    function isReadStream(rs) {
      return rs.readable && rs.path && rs.mode;
    }
    function toBase64(str) {
      return Buffer2.from(str || "", "utf8").toString("base64");
    }
    function copy(obj) {
      var o = {};
      Object.keys(obj).forEach(function(i) {
        o[i] = obj[i];
      });
      return o;
    }
    function version() {
      var numbers = process.version.replace("v", "").split(".");
      return {
        major: parseInt(numbers[0], 10),
        minor: parseInt(numbers[1], 10),
        patch: parseInt(numbers[2], 10)
      };
    }
    exports2.paramsHaveRequestBody = paramsHaveRequestBody;
    exports2.safeStringify = safeStringify;
    exports2.md5 = md5;
    exports2.isReadStream = isReadStream;
    exports2.toBase64 = toBase64;
    exports2.copy = copy;
    exports2.version = version;
    exports2.defer = defer;
  }
});

// ../../node_modules/aws-sign2/index.js
var require_aws_sign2 = __commonJS({
  "../../node_modules/aws-sign2/index.js"(exports2, module2) {
    var crypto = require("crypto");
    var parse = require("url").parse;
    var keys = [
      "acl",
      "location",
      "logging",
      "notification",
      "partNumber",
      "policy",
      "requestPayment",
      "torrent",
      "uploadId",
      "uploads",
      "versionId",
      "versioning",
      "versions",
      "website"
    ];
    function authorization(options) {
      return "AWS " + options.key + ":" + sign(options);
    }
    module2.exports = authorization;
    module2.exports.authorization = authorization;
    function hmacSha1(options) {
      return crypto.createHmac("sha1", options.secret).update(options.message).digest("base64");
    }
    module2.exports.hmacSha1 = hmacSha1;
    function sign(options) {
      options.message = stringToSign(options);
      return hmacSha1(options);
    }
    module2.exports.sign = sign;
    function signQuery(options) {
      options.message = queryStringToSign(options);
      return hmacSha1(options);
    }
    module2.exports.signQuery = signQuery;
    function stringToSign(options) {
      var headers = options.amazonHeaders || "";
      if (headers)
        headers += "\n";
      var r = [
        options.verb,
        options.md5,
        options.contentType,
        options.date ? options.date.toUTCString() : "",
        headers + options.resource
      ];
      return r.join("\n");
    }
    module2.exports.stringToSign = stringToSign;
    function queryStringToSign(options) {
      return "GET\n\n\n" + options.date + "\n" + options.resource;
    }
    module2.exports.queryStringToSign = queryStringToSign;
    function canonicalizeHeaders(headers) {
      var buf = [], fields = Object.keys(headers);
      for (var i = 0, len = fields.length; i < len; ++i) {
        var field = fields[i], val = headers[field], field = field.toLowerCase();
        if (field.indexOf("x-amz") !== 0)
          continue;
        buf.push(field + ":" + val);
      }
      return buf.sort().join("\n");
    }
    module2.exports.canonicalizeHeaders = canonicalizeHeaders;
    function canonicalizeResource(resource) {
      var url = parse(resource, true), path2 = url.pathname, buf = [];
      Object.keys(url.query).forEach(function(key) {
        if (!~keys.indexOf(key))
          return;
        var val = url.query[key] == "" ? "" : "=" + encodeURIComponent(url.query[key]);
        buf.push(key + val);
      });
      return path2 + (buf.length ? "?" + buf.sort().join("&") : "");
    }
    module2.exports.canonicalizeResource = canonicalizeResource;
  }
});

// ../../node_modules/aws4/lru.js
var require_lru = __commonJS({
  "../../node_modules/aws4/lru.js"(exports2, module2) {
    module2.exports = function(size) {
      return new LruCache(size);
    };
    function LruCache(size) {
      this.capacity = size | 0;
      this.map = Object.create(null);
      this.list = new DoublyLinkedList();
    }
    LruCache.prototype.get = function(key) {
      var node = this.map[key];
      if (node == null)
        return void 0;
      this.used(node);
      return node.val;
    };
    LruCache.prototype.set = function(key, val) {
      var node = this.map[key];
      if (node != null) {
        node.val = val;
      } else {
        if (!this.capacity)
          this.prune();
        if (!this.capacity)
          return false;
        node = new DoublyLinkedNode(key, val);
        this.map[key] = node;
        this.capacity--;
      }
      this.used(node);
      return true;
    };
    LruCache.prototype.used = function(node) {
      this.list.moveToFront(node);
    };
    LruCache.prototype.prune = function() {
      var node = this.list.pop();
      if (node != null) {
        delete this.map[node.key];
        this.capacity++;
      }
    };
    function DoublyLinkedList() {
      this.firstNode = null;
      this.lastNode = null;
    }
    DoublyLinkedList.prototype.moveToFront = function(node) {
      if (this.firstNode == node)
        return;
      this.remove(node);
      if (this.firstNode == null) {
        this.firstNode = node;
        this.lastNode = node;
        node.prev = null;
        node.next = null;
      } else {
        node.prev = null;
        node.next = this.firstNode;
        node.next.prev = node;
        this.firstNode = node;
      }
    };
    DoublyLinkedList.prototype.pop = function() {
      var lastNode = this.lastNode;
      if (lastNode != null) {
        this.remove(lastNode);
      }
      return lastNode;
    };
    DoublyLinkedList.prototype.remove = function(node) {
      if (this.firstNode == node) {
        this.firstNode = node.next;
      } else if (node.prev != null) {
        node.prev.next = node.next;
      }
      if (this.lastNode == node) {
        this.lastNode = node.prev;
      } else if (node.next != null) {
        node.next.prev = node.prev;
      }
    };
    function DoublyLinkedNode(key, val) {
      this.key = key;
      this.val = val;
      this.prev = null;
      this.next = null;
    }
  }
});

// ../../node_modules/aws4/aws4.js
var require_aws4 = __commonJS({
  "../../node_modules/aws4/aws4.js"(exports2) {
    var aws4 = exports2;
    var url = require("url");
    var querystring = require("querystring");
    var crypto = require("crypto");
    var lru = require_lru();
    var credentialsCache = lru(1e3);
    function hmac(key, string, encoding) {
      return crypto.createHmac("sha256", key).update(string, "utf8").digest(encoding);
    }
    function hash(string, encoding) {
      return crypto.createHash("sha256").update(string, "utf8").digest(encoding);
    }
    function encodeRfc3986(urlEncodedString) {
      return urlEncodedString.replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeRfc3986Full(str) {
      return encodeRfc3986(encodeURIComponent(str));
    }
    var HEADERS_TO_IGNORE = {
      "authorization": true,
      "connection": true,
      "x-amzn-trace-id": true,
      "user-agent": true,
      "expect": true,
      "presigned-expires": true,
      "range": true
    };
    function RequestSigner(request, credentials) {
      if (typeof request === "string")
        request = url.parse(request);
      var headers = request.headers = request.headers || {}, hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host);
      this.request = request;
      this.credentials = credentials || this.defaultCredentials();
      this.service = request.service || hostParts[0] || "";
      this.region = request.region || hostParts[1] || "us-east-1";
      if (this.service === "email")
        this.service = "ses";
      if (!request.method && request.body)
        request.method = "POST";
      if (!headers.Host && !headers.host) {
        headers.Host = request.hostname || request.host || this.createHost();
        if (request.port)
          headers.Host += ":" + request.port;
      }
      if (!request.hostname && !request.host)
        request.hostname = headers.Host || headers.host;
      this.isCodeCommitGit = this.service === "codecommit" && request.method === "GIT";
    }
    RequestSigner.prototype.matchHost = function(host) {
      var match = (host || "").match(/([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com(\.cn)?$/);
      var hostParts = (match || []).slice(1, 3);
      if (hostParts[1] === "es")
        hostParts = hostParts.reverse();
      if (hostParts[1] == "s3") {
        hostParts[0] = "s3";
        hostParts[1] = "us-east-1";
      } else {
        for (var i = 0; i < 2; i++) {
          if (/^s3-/.test(hostParts[i])) {
            hostParts[1] = hostParts[i].slice(3);
            hostParts[0] = "s3";
            break;
          }
        }
      }
      return hostParts;
    };
    RequestSigner.prototype.isSingleRegion = function() {
      if (["s3", "sdb"].indexOf(this.service) >= 0 && this.region === "us-east-1")
        return true;
      return ["cloudfront", "ls", "route53", "iam", "importexport", "sts"].indexOf(this.service) >= 0;
    };
    RequestSigner.prototype.createHost = function() {
      var region = this.isSingleRegion() ? "" : "." + this.region, subdomain = this.service === "ses" ? "email" : this.service;
      return subdomain + region + ".amazonaws.com";
    };
    RequestSigner.prototype.prepareRequest = function() {
      this.parsePath();
      var request = this.request, headers = request.headers, query;
      if (request.signQuery) {
        this.parsedPath.query = query = this.parsedPath.query || {};
        if (this.credentials.sessionToken)
          query["X-Amz-Security-Token"] = this.credentials.sessionToken;
        if (this.service === "s3" && !query["X-Amz-Expires"])
          query["X-Amz-Expires"] = 86400;
        if (query["X-Amz-Date"])
          this.datetime = query["X-Amz-Date"];
        else
          query["X-Amz-Date"] = this.getDateTime();
        query["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
        query["X-Amz-Credential"] = this.credentials.accessKeyId + "/" + this.credentialString();
        query["X-Amz-SignedHeaders"] = this.signedHeaders();
      } else {
        if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
          if (request.body && !headers["Content-Type"] && !headers["content-type"])
            headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
          if (request.body && !headers["Content-Length"] && !headers["content-length"])
            headers["Content-Length"] = Buffer.byteLength(request.body);
          if (this.credentials.sessionToken && !headers["X-Amz-Security-Token"] && !headers["x-amz-security-token"])
            headers["X-Amz-Security-Token"] = this.credentials.sessionToken;
          if (this.service === "s3" && !headers["X-Amz-Content-Sha256"] && !headers["x-amz-content-sha256"])
            headers["X-Amz-Content-Sha256"] = hash(this.request.body || "", "hex");
          if (headers["X-Amz-Date"] || headers["x-amz-date"])
            this.datetime = headers["X-Amz-Date"] || headers["x-amz-date"];
          else
            headers["X-Amz-Date"] = this.getDateTime();
        }
        delete headers.Authorization;
        delete headers.authorization;
      }
    };
    RequestSigner.prototype.sign = function() {
      if (!this.parsedPath)
        this.prepareRequest();
      if (this.request.signQuery) {
        this.parsedPath.query["X-Amz-Signature"] = this.signature();
      } else {
        this.request.headers.Authorization = this.authHeader();
      }
      this.request.path = this.formatPath();
      return this.request;
    };
    RequestSigner.prototype.getDateTime = function() {
      if (!this.datetime) {
        var headers = this.request.headers, date = new Date(headers.Date || headers.date || new Date());
        this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, "");
        if (this.isCodeCommitGit)
          this.datetime = this.datetime.slice(0, -1);
      }
      return this.datetime;
    };
    RequestSigner.prototype.getDate = function() {
      return this.getDateTime().substr(0, 8);
    };
    RequestSigner.prototype.authHeader = function() {
      return [
        "AWS4-HMAC-SHA256 Credential=" + this.credentials.accessKeyId + "/" + this.credentialString(),
        "SignedHeaders=" + this.signedHeaders(),
        "Signature=" + this.signature()
      ].join(", ");
    };
    RequestSigner.prototype.signature = function() {
      var date = this.getDate(), cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(), kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
      if (!kCredentials) {
        kDate = hmac("AWS4" + this.credentials.secretAccessKey, date);
        kRegion = hmac(kDate, this.region);
        kService = hmac(kRegion, this.service);
        kCredentials = hmac(kService, "aws4_request");
        credentialsCache.set(cacheKey, kCredentials);
      }
      return hmac(kCredentials, this.stringToSign(), "hex");
    };
    RequestSigner.prototype.stringToSign = function() {
      return [
        "AWS4-HMAC-SHA256",
        this.getDateTime(),
        this.credentialString(),
        hash(this.canonicalString(), "hex")
      ].join("\n");
    };
    RequestSigner.prototype.canonicalString = function() {
      if (!this.parsedPath)
        this.prepareRequest();
      var pathStr = this.parsedPath.path, query = this.parsedPath.query, headers = this.request.headers, queryStr = "", normalizePath = this.service !== "s3", decodePath = this.service === "s3" || this.request.doNotEncodePath, decodeSlashesInPath = this.service === "s3", firstValOnly = this.service === "s3", bodyHash;
      if (this.service === "s3" && this.request.signQuery) {
        bodyHash = "UNSIGNED-PAYLOAD";
      } else if (this.isCodeCommitGit) {
        bodyHash = "";
      } else {
        bodyHash = headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || hash(this.request.body || "", "hex");
      }
      if (query) {
        var reducedQuery = Object.keys(query).reduce(function(obj, key) {
          if (!key)
            return obj;
          obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] : firstValOnly ? query[key][0] : query[key];
          return obj;
        }, {});
        var encodedQueryPieces = [];
        Object.keys(reducedQuery).sort().forEach(function(key) {
          if (!Array.isArray(reducedQuery[key])) {
            encodedQueryPieces.push(key + "=" + encodeRfc3986Full(reducedQuery[key]));
          } else {
            reducedQuery[key].map(encodeRfc3986Full).sort().forEach(function(val) {
              encodedQueryPieces.push(key + "=" + val);
            });
          }
        });
        queryStr = encodedQueryPieces.join("&");
      }
      if (pathStr !== "/") {
        if (normalizePath)
          pathStr = pathStr.replace(/\/{2,}/g, "/");
        pathStr = pathStr.split("/").reduce(function(path2, piece) {
          if (normalizePath && piece === "..") {
            path2.pop();
          } else if (!normalizePath || piece !== ".") {
            if (decodePath)
              piece = decodeURIComponent(piece.replace(/\+/g, " "));
            path2.push(encodeRfc3986Full(piece));
          }
          return path2;
        }, []).join("/");
        if (pathStr[0] !== "/")
          pathStr = "/" + pathStr;
        if (decodeSlashesInPath)
          pathStr = pathStr.replace(/%2F/g, "/");
      }
      return [
        this.request.method || "GET",
        pathStr,
        queryStr,
        this.canonicalHeaders() + "\n",
        this.signedHeaders(),
        bodyHash
      ].join("\n");
    };
    RequestSigner.prototype.canonicalHeaders = function() {
      var headers = this.request.headers;
      function trimAll(header) {
        return header.toString().trim().replace(/\s+/g, " ");
      }
      return Object.keys(headers).filter(function(key) {
        return HEADERS_TO_IGNORE[key.toLowerCase()] == null;
      }).sort(function(a, b) {
        return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
      }).map(function(key) {
        return key.toLowerCase() + ":" + trimAll(headers[key]);
      }).join("\n");
    };
    RequestSigner.prototype.signedHeaders = function() {
      return Object.keys(this.request.headers).map(function(key) {
        return key.toLowerCase();
      }).filter(function(key) {
        return HEADERS_TO_IGNORE[key] == null;
      }).sort().join(";");
    };
    RequestSigner.prototype.credentialString = function() {
      return [
        this.getDate(),
        this.region,
        this.service,
        "aws4_request"
      ].join("/");
    };
    RequestSigner.prototype.defaultCredentials = function() {
      var env = process.env;
      return {
        accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
        secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
        sessionToken: env.AWS_SESSION_TOKEN
      };
    };
    RequestSigner.prototype.parsePath = function() {
      var path2 = this.request.path || "/";
      if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path2)) {
        path2 = encodeURI(decodeURI(path2));
      }
      var queryIx = path2.indexOf("?"), query = null;
      if (queryIx >= 0) {
        query = querystring.parse(path2.slice(queryIx + 1));
        path2 = path2.slice(0, queryIx);
      }
      this.parsedPath = {
        path: path2,
        query
      };
    };
    RequestSigner.prototype.formatPath = function() {
      var path2 = this.parsedPath.path, query = this.parsedPath.query;
      if (!query)
        return path2;
      if (query[""] != null)
        delete query[""];
      return path2 + "?" + encodeRfc3986(querystring.stringify(query));
    };
    aws4.RequestSigner = RequestSigner;
    aws4.sign = function(request, credentials) {
      return new RequestSigner(request, credentials).sign();
    };
  }
});

// ../../node_modules/assert-plus/assert.js
var require_assert = __commonJS({
  "../../node_modules/assert-plus/assert.js"(exports2, module2) {
    var assert3 = require("assert");
    var Stream2 = require("stream").Stream;
    var util2 = require("util");
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    function _toss(name, expected, oper, arg, actual) {
      throw new assert3.AssertionError({
        message: util2.format("%s (%s) is required", name, expected),
        actual: actual === void 0 ? typeof arg : actual(arg),
        expected,
        operator: oper || "===",
        stackStartFunction: _toss.caller
      });
    }
    function _getClass(arg) {
      return Object.prototype.toString.call(arg).slice(8, -1);
    }
    function noop() {
    }
    var types = {
      bool: {
        check: function(arg) {
          return typeof arg === "boolean";
        }
      },
      func: {
        check: function(arg) {
          return typeof arg === "function";
        }
      },
      string: {
        check: function(arg) {
          return typeof arg === "string";
        }
      },
      object: {
        check: function(arg) {
          return typeof arg === "object" && arg !== null;
        }
      },
      number: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg);
        }
      },
      finite: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg) && isFinite(arg);
        }
      },
      buffer: {
        check: function(arg) {
          return Buffer.isBuffer(arg);
        },
        operator: "Buffer.isBuffer"
      },
      array: {
        check: function(arg) {
          return Array.isArray(arg);
        },
        operator: "Array.isArray"
      },
      stream: {
        check: function(arg) {
          return arg instanceof Stream2;
        },
        operator: "instanceof",
        actual: _getClass
      },
      date: {
        check: function(arg) {
          return arg instanceof Date;
        },
        operator: "instanceof",
        actual: _getClass
      },
      regexp: {
        check: function(arg) {
          return arg instanceof RegExp;
        },
        operator: "instanceof",
        actual: _getClass
      },
      uuid: {
        check: function(arg) {
          return typeof arg === "string" && UUID_REGEXP.test(arg);
        },
        operator: "isUUID"
      }
    };
    function _setExports(ndebug) {
      var keys = Object.keys(types);
      var out;
      if (process.env.NODE_NDEBUG) {
        out = noop;
      } else {
        out = function(arg, msg) {
          if (!arg) {
            _toss(msg, "true", arg);
          }
        };
      }
      keys.forEach(function(k) {
        if (ndebug) {
          out[k] = noop;
          return;
        }
        var type = types[k];
        out[k] = function(arg, msg) {
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = "optional" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = "arrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      keys.forEach(function(k) {
        var name = "optionalArrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      Object.keys(assert3).forEach(function(k) {
        if (k === "AssertionError") {
          out[k] = assert3[k];
          return;
        }
        if (ndebug) {
          out[k] = noop;
          return;
        }
        out[k] = assert3[k];
      });
      out._setExports = _setExports;
      return out;
    }
    module2.exports = _setExports(process.env.NODE_NDEBUG);
  }
});

// ../../node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "../../node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// ../../node_modules/sshpk/lib/algs.js
var require_algs = __commonJS({
  "../../node_modules/sshpk/lib/algs.js"(exports2, module2) {
    var Buffer2 = require_safer().Buffer;
    var algInfo = {
      "dsa": {
        parts: ["p", "q", "g", "y"],
        sizePart: "p"
      },
      "rsa": {
        parts: ["e", "n"],
        sizePart: "n"
      },
      "ecdsa": {
        parts: ["curve", "Q"],
        sizePart: "Q"
      },
      "ed25519": {
        parts: ["A"],
        sizePart: "A"
      }
    };
    algInfo["curve25519"] = algInfo["ed25519"];
    var algPrivInfo = {
      "dsa": {
        parts: ["p", "q", "g", "y", "x"]
      },
      "rsa": {
        parts: ["n", "e", "d", "iqmp", "p", "q"]
      },
      "ecdsa": {
        parts: ["curve", "Q", "d"]
      },
      "ed25519": {
        parts: ["A", "k"]
      }
    };
    algPrivInfo["curve25519"] = algPrivInfo["ed25519"];
    var hashAlgs = {
      "md5": true,
      "sha1": true,
      "sha256": true,
      "sha384": true,
      "sha512": true
    };
    var curves = {
      "nistp256": {
        size: 256,
        pkcs8oid: "1.2.840.10045.3.1.7",
        p: Buffer2.from("00ffffffff 00000001 00000000 0000000000000000 ffffffff ffffffff ffffffff".replace(/ /g, ""), "hex"),
        a: Buffer2.from("00FFFFFFFF 00000001 00000000 0000000000000000 FFFFFFFF FFFFFFFF FFFFFFFC".replace(/ /g, ""), "hex"),
        b: Buffer2.from("5ac635d8 aa3a93e7 b3ebbd55 769886bc651d06b0 cc53b0f6 3bce3c3e 27d2604b".replace(/ /g, ""), "hex"),
        s: Buffer2.from("00c49d3608 86e70493 6a6678e1 139d26b7819f7e90".replace(/ /g, ""), "hex"),
        n: Buffer2.from("00ffffffff 00000000 ffffffff ffffffffbce6faad a7179e84 f3b9cac2 fc632551".replace(/ /g, ""), "hex"),
        G: Buffer2.from("046b17d1f2 e12c4247 f8bce6e5 63a440f277037d81 2deb33a0 f4a13945 d898c2964fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e162bce3357 6b315ece cbb64068 37bf51f5".replace(/ /g, ""), "hex")
      },
      "nistp384": {
        size: 384,
        pkcs8oid: "1.3.132.0.34",
        p: Buffer2.from("00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffeffffffff 00000000 00000000 ffffffff".replace(/ /g, ""), "hex"),
        a: Buffer2.from("00FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFEFFFFFFFF 00000000 00000000 FFFFFFFC".replace(/ /g, ""), "hex"),
        b: Buffer2.from("b3312fa7 e23ee7e4 988e056b e3f82d19181d9c6e fe814112 0314088f 5013875ac656398d 8a2ed19d 2a85c8ed d3ec2aef".replace(/ /g, ""), "hex"),
        s: Buffer2.from("00a335926a a319a27a 1d00896a 6773a4827acdac73".replace(/ /g, ""), "hex"),
        n: Buffer2.from("00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff c7634d81 f4372ddf581a0db2 48b0a77a ecec196a ccc52973".replace(/ /g, ""), "hex"),
        G: Buffer2.from("04aa87ca22 be8b0537 8eb1c71e f320ad746e1d3b62 8ba79b98 59f741e0 82542a385502f25d bf55296c 3a545e38 72760ab73617de4a 96262c6f 5d9e98bf 9292dc29f8f41dbd 289a147c e9da3113 b5f0b8c00a60b1ce 1d7e819d 7a431d7c 90ea0e5f".replace(/ /g, ""), "hex")
      },
      "nistp521": {
        size: 521,
        pkcs8oid: "1.3.132.0.35",
        p: Buffer2.from("01ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffff".replace(/ /g, ""), "hex"),
        a: Buffer2.from("01FFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC".replace(/ /g, ""), "hex"),
        b: Buffer2.from("51953eb961 8e1c9a1f 929a21a0 b68540eea2da725b 99b315f3 b8b48991 8ef109e156193951 ec7e937b 1652c0bd 3bb1bf073573df88 3d2c34f1 ef451fd4 6b503f00".replace(/ /g, ""), "hex"),
        s: Buffer2.from("00d09e8800 291cb853 96cc6717 393284aaa0da64ba".replace(/ /g, ""), "hex"),
        n: Buffer2.from("01ffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffa51868783 bf2f966b 7fcc0148 f709a5d03bb5c9b8 899c47ae bb6fb71e 91386409".replace(/ /g, ""), "hex"),
        G: Buffer2.from("0400c6 858e06b7 0404e9cd 9e3ecb66 2395b4429c648139 053fb521 f828af60 6b4d3dbaa14b5e77 efe75928 fe1dc127 a2ffa8de3348b3c1 856a429b f97e7e31 c2e5bd660118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd998f54449 579b4468 17afbd17 273e662c97ee7299 5ef42640 c550b901 3fad0761353c7086 a272c240 88be9476 9fd16650".replace(/ /g, ""), "hex")
      }
    };
    module2.exports = {
      info: algInfo,
      privInfo: algPrivInfo,
      hashAlgs,
      curves
    };
  }
});

// ../../node_modules/sshpk/lib/errors.js
var require_errors = __commonJS({
  "../../node_modules/sshpk/lib/errors.js"(exports2, module2) {
    var assert3 = require_assert();
    var util2 = require("util");
    function FingerprintFormatError(fp, format) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, FingerprintFormatError);
      this.name = "FingerprintFormatError";
      this.fingerprint = fp;
      this.format = format;
      this.message = "Fingerprint format is not supported, or is invalid: ";
      if (fp !== void 0)
        this.message += " fingerprint = " + fp;
      if (format !== void 0)
        this.message += " format = " + format;
    }
    util2.inherits(FingerprintFormatError, Error);
    function InvalidAlgorithmError(alg) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, InvalidAlgorithmError);
      this.name = "InvalidAlgorithmError";
      this.algorithm = alg;
      this.message = 'Algorithm "' + alg + '" is not supported';
    }
    util2.inherits(InvalidAlgorithmError, Error);
    function KeyParseError(name, format, innerErr) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, KeyParseError);
      this.name = "KeyParseError";
      this.format = format;
      this.keyName = name;
      this.innerErr = innerErr;
      this.message = "Failed to parse " + name + " as a valid " + format + " format key: " + innerErr.message;
    }
    util2.inherits(KeyParseError, Error);
    function SignatureParseError(type, format, innerErr) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, SignatureParseError);
      this.name = "SignatureParseError";
      this.type = type;
      this.format = format;
      this.innerErr = innerErr;
      this.message = "Failed to parse the given data as a " + type + " signature in " + format + " format: " + innerErr.message;
    }
    util2.inherits(SignatureParseError, Error);
    function CertificateParseError(name, format, innerErr) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CertificateParseError);
      this.name = "CertificateParseError";
      this.format = format;
      this.certName = name;
      this.innerErr = innerErr;
      this.message = "Failed to parse " + name + " as a valid " + format + " format certificate: " + innerErr.message;
    }
    util2.inherits(CertificateParseError, Error);
    function KeyEncryptedError(name, format) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, KeyEncryptedError);
      this.name = "KeyEncryptedError";
      this.format = format;
      this.keyName = name;
      this.message = "The " + format + " format key " + name + " is encrypted (password-protected), and no passphrase was provided in `options`";
    }
    util2.inherits(KeyEncryptedError, Error);
    module2.exports = {
      FingerprintFormatError,
      InvalidAlgorithmError,
      KeyParseError,
      SignatureParseError,
      KeyEncryptedError,
      CertificateParseError
    };
  }
});

// ../../node_modules/asn1/lib/ber/errors.js
var require_errors2 = __commonJS({
  "../../node_modules/asn1/lib/ber/errors.js"(exports2, module2) {
    module2.exports = {
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        e.name = "InvalidAsn1Error";
        e.message = msg || "";
        return e;
      }
    };
  }
});

// ../../node_modules/asn1/lib/ber/types.js
var require_types = __commonJS({
  "../../node_modules/asn1/lib/ber/types.js"(exports2, module2) {
    module2.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9,
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
  }
});

// ../../node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS({
  "../../node_modules/asn1/lib/ber/reader.js"(exports2, module2) {
    var assert3 = require("assert");
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors2();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data) {
      if (!data || !Buffer2.isBuffer(data))
        throw new TypeError("data must be a node Buffer");
      this._buf = data;
      this._size = data.length;
      this._len = 0;
      this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "length", {
      enumerable: true,
      get: function() {
        return this._len;
      }
    });
    Object.defineProperty(Reader.prototype, "offset", {
      enumerable: true,
      get: function() {
        return this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "remain", {
      get: function() {
        return this._size - this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "buffer", {
      get: function() {
        return this._buf.slice(this._offset);
      }
    });
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1)
        return null;
      var b = this._buf[this._offset] & 255;
      if (!peek)
        this._offset += 1;
      return b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === void 0)
        offset = this._offset;
      if (offset >= this._size)
        return null;
      var lenB = this._buf[offset++] & 255;
      if (lenB === null)
        return null;
      if ((lenB & 128) === 128) {
        lenB &= 127;
        if (lenB === 0)
          throw newInvalidAsn1Error("Indefinite length not supported");
        if (lenB > 4)
          throw newInvalidAsn1Error("encoding too long");
        if (this._size - offset < lenB)
          return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 255);
      } else {
        this._len = lenB;
      }
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== void 0 && tag !== seq)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      this._offset = o;
      return seq;
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return this._readTag(ASN1.Boolean) === 0 ? false : true;
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      if (this.length === 0)
        return retbuf ? Buffer2.alloc(0) : "";
      var str = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
      return retbuf ? str : str.toString("utf8");
    };
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
      var b = this.readString(tag, true);
      if (b === null)
        return null;
      var values = [];
      var value = 0;
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 255;
        value <<= 7;
        value += byte & 127;
        if ((byte & 128) === 0) {
          values.push(value);
          value = 0;
        }
      }
      value = values.shift();
      values.unshift(value % 40);
      values.unshift(value / 40 >> 0);
      return values.join(".");
    };
    Reader.prototype._readTag = function(tag) {
      assert3.ok(tag !== void 0);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > 4)
        throw newInvalidAsn1Error("Integer too long: " + this.length);
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      var fb = this._buf[this._offset];
      var value = 0;
      for (var i = 0; i < this.length; i++) {
        value <<= 8;
        value |= this._buf[this._offset++] & 255;
      }
      if ((fb & 128) === 128 && i !== 4)
        value -= 1 << i * 8;
      return value >> 0;
    };
    module2.exports = Reader;
  }
});

// ../../node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS({
  "../../node_modules/asn1/lib/ber/writer.js"(exports2, module2) {
    var assert3 = require("assert");
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors2();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge(from, to) {
      assert3.ok(from);
      assert3.equal(typeof from, "object");
      assert3.ok(to);
      assert3.equal(typeof to, "object");
      var keys = Object.getOwnPropertyNames(from);
      keys.forEach(function(key) {
        if (to[key])
          return;
        var value = Object.getOwnPropertyDescriptor(from, key);
        Object.defineProperty(to, key, value);
      });
      return to;
    }
    function Writer(options) {
      options = merge(DEFAULT_OPTS, options || {});
      this._buf = Buffer2.alloc(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
      this._seq = [];
    }
    Object.defineProperty(Writer.prototype, "buffer", {
      get: function() {
        if (this._seq.length)
          throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
        return this._buf.slice(0, this._offset);
      }
    });
    Writer.prototype.writeByte = function(b) {
      if (typeof b !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Integer;
      var sz = 4;
      while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
        sz--;
        i <<= 8;
      }
      if (sz > 4)
        throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
      while (sz-- > 0) {
        this._buf[this._offset++] = (i & 4278190080) >>> 24;
        i <<= 8;
      }
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Enumeration;
      return this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof b !== "boolean")
        throw new TypeError("argument must be a Boolean");
      if (typeof tag !== "number")
        tag = ASN1.Boolean;
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 1;
      this._buf[this._offset++] = b ? 255 : 0;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string (was: " + typeof s + ")");
      if (typeof tag !== "number")
        tag = ASN1.OctetString;
      var len = Buffer2.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof tag !== "number")
        throw new TypeError("tag must be a number");
      if (!Buffer2.isBuffer(buf))
        throw new TypeError("argument must be a buffer");
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if (!strings instanceof Array)
        throw new TypeError("argument must be an Array[String]");
      var self2 = this;
      strings.forEach(function(s) {
        self2.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string");
      if (typeof tag !== "number")
        tag = ASN1.OID;
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error("argument is not a valid OID string");
      function encodeOctet(bytes2, octet) {
        if (octet < 128) {
          bytes2.push(octet);
        } else if (octet < 16384) {
          bytes2.push(octet >>> 7 | 128);
          bytes2.push(octet & 127);
        } else if (octet < 2097152) {
          bytes2.push(octet >>> 14 | 128);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else if (octet < 268435456) {
          bytes2.push(octet >>> 21 | 128);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else {
          bytes2.push((octet >>> 28 | 128) & 255);
          bytes2.push((octet >>> 21 | 128) & 255);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        }
      }
      var tmp = s.split(".");
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self2 = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self2.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof len !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(4);
      if (len <= 127) {
        this._buf[this._offset++] = len;
      } else if (len <= 255) {
        this._buf[this._offset++] = 129;
        this._buf[this._offset++] = len;
      } else if (len <= 65535) {
        this._buf[this._offset++] = 130;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 16777215) {
        this._buf[this._offset++] = 131;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw newInvalidAsn1Error("Length too long (> 4 bytes)");
      }
    };
    Writer.prototype.startSequence = function(tag) {
      if (typeof tag !== "number")
        tag = ASN1.Sequence | ASN1.Constructor;
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
      if (len <= 127) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 255) {
        this._shift(start, len, -1);
        this._buf[seq] = 129;
        this._buf[seq + 1] = len;
      } else if (len <= 65535) {
        this._buf[seq] = 130;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 16777215) {
        this._shift(start, len, 1);
        this._buf[seq] = 131;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw newInvalidAsn1Error("Sequence too long");
      }
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert3.ok(start !== void 0);
      assert3.ok(len !== void 0);
      assert3.ok(shift);
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      assert3.ok(len);
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
        var buf = Buffer2.alloc(sz);
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    module2.exports = Writer;
  }
});

// ../../node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS({
  "../../node_modules/asn1/lib/ber/index.js"(exports2, module2) {
    var errors = require_errors2();
    var types = require_types();
    var Reader = require_reader();
    var Writer = require_writer();
    module2.exports = {
      Reader,
      Writer
    };
    for (t in types) {
      if (types.hasOwnProperty(t))
        module2.exports[t] = types[t];
    }
    var t;
    for (e in errors) {
      if (errors.hasOwnProperty(e))
        module2.exports[e] = errors[e];
    }
    var e;
  }
});

// ../../node_modules/asn1/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/asn1/lib/index.js"(exports2, module2) {
    var Ber = require_ber();
    module2.exports = {
      Ber,
      BerReader: Ber.Reader,
      BerWriter: Ber.Writer
    };
  }
});

// ../../node_modules/jsbn/index.js
var require_jsbn = __commonJS({
  "../../node_modules/jsbn/index.js"(exports2, module2) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if (typeof a == "number")
            this.fromNumber(a, b, c);
          else if (b == null && typeof a != "string")
            this.fromString(a, 256);
          else
            this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv)
        BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i)
          r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0)
          this[0] = x;
        else if (x < -1)
          this[0] = x + this.DV;
        else
          this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 256)
          k = 8;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-")
              mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB)
            sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0)
            this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c)
          --this.t;
      }
      function bnToString(b) {
        if (this.s < 0)
          return "-" + this.negate().toString(b);
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else
          return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0)
              m = true;
            if (m)
              r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0)
          return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0)
          return this.s < 0 ? -r : r;
        while (--i >= 0)
          if ((r = this[i] - a[i]) != 0)
            return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0)
          return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i)
          r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i)
          r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i)
          r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i)
          r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0)
          r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1)
          r[i++] = this.DV + c;
        else if (c > 0)
          r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < y.t; ++i)
          r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0)
          r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q2, r) {
        var pm = m.abs();
        if (pm.t <= 0)
          return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q2 != null)
            q2.fromInt(0);
          if (r != null)
            this.copyTo(r);
          return;
        }
        if (r == null)
          r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0)
          return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q2 == null ? nbi() : q2;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys)
          y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd)
              r.subTo(t2, r);
          }
        }
        if (q2 != null) {
          r.drShiftTo(ys, q2);
          if (ts != ms)
            BigInteger.ZERO.subTo(q2, q2);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0)
          r.rShiftTo(nsh, r);
        if (ts < 0)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0)
          return x.mod(this.m);
        else
          return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1)
          return 0;
        var x = this[0];
        if ((x & 1) == 0)
          return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1)
          return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0)
            z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven())
          z2 = new Classic(m);
        else
          z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1)
            return this[0] - this.DV;
          else if (this.t == 0)
            return -1;
        } else if (this.t == 1)
          return this[0];
        else if (this.t == 0)
          return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0)
          return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
          return 0;
        else
          return 1;
      }
      function bnpToRadix(b) {
        if (b == null)
          b = 10;
        if (this.signum() == 0 || b < 2 || b > 36)
          return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null)
          b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0)
              mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if (typeof b == "number") {
          if (a < 2)
            this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven())
              this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a)
                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0)
            x[0] &= (1 << t2) - 1;
          else
            x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0)
              d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128))
              ++k;
            if (k > 0 || d != this.s)
              r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i)
          r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i)
            r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i)
            r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i)
          r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0)
          this.rShiftTo(-n, r);
        else
          this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0)
          this.lShiftTo(-n, r);
        else
          this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0)
          return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0)
          ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0)
            return i * this.DB + lbit(this[i]);
        if (this.s < 0)
          return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i)
          r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t)
          return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0)
          r[i++] = c;
        else if (c < -1)
          r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q2 = nbi(), r = nbi();
        this.divRemTo(a, q2, r);
        return new Array(q2, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0)
          return;
        while (this.t <= w)
          this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t)
            this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0)
          r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i)
          r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i)
          this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0)
          r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t)
          return x.mod(this.m);
        else if (x.compareTo(this.m) < 0)
          return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0)
          x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0)
          return r;
        else if (i < 18)
          k = 1;
        else if (i < 48)
          k = 3;
        else if (i < 144)
          k = 4;
        else if (i < 768)
          k = 5;
        else
          k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1)
            w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0)
              w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0)
              z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0)
          return x;
        if (i < g)
          g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0)
            x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0)
            y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0)
          y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0)
          return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0)
            r = this[0] % n;
          else
            for (var i = this.t - 1; i >= 0; --i)
              r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0)
          return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven())
              b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven())
              d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac)
              a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac)
              c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0)
          return BigInteger.ZERO;
        if (d.compareTo(m) >= 0)
          return d.subtract(m);
        if (d.signum() < 0)
          d.addTo(m, d);
        else
          return d;
        if (d.signum() < 0)
          return d.add(m);
        else
          return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i])
              return true;
          return false;
        }
        if (x.isEven())
          return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim)
            m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j)
            if (m % lowprimes[i++] == 0)
              return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0)
          return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length)
          t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0)
                return false;
            }
            if (y.compareTo(n1) != 0)
              return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize)
          rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int(new Date().getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i)
          ba[i] = rng_get_byte();
      }
      function SecureRandom2() {
      }
      SecureRandom2.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      BigInteger.SecureRandom = SecureRandom2;
      BigInteger.BigInteger = BigInteger;
      if (typeof exports2 !== "undefined") {
        exports2 = module2.exports = BigInteger;
      } else {
        this.BigInteger = BigInteger;
        this.SecureRandom = SecureRandom2;
      }
    }).call(exports2);
  }
});

// ../../node_modules/ecc-jsbn/lib/ec.js
var require_ec = __commonJS({
  "../../node_modules/ecc-jsbn/lib/ec.js"(exports2, module2) {
    var BigInteger = require_jsbn().BigInteger;
    var Barrett = BigInteger.prototype.Barrett;
    function ECFieldElementFp(q2, x) {
      this.x = x;
      this.q = q2;
    }
    function feFpEquals(other) {
      if (other == this)
        return true;
      return this.q.equals(other.q) && this.x.equals(other.x);
    }
    function feFpToBigInteger() {
      return this.x;
    }
    function feFpNegate() {
      return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
    }
    function feFpAdd(b) {
      return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
    }
    function feFpSubtract(b) {
      return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
    }
    function feFpMultiply(b) {
      return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
    }
    function feFpSquare() {
      return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
    }
    function feFpDivide(b) {
      return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
    }
    ECFieldElementFp.prototype.equals = feFpEquals;
    ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
    ECFieldElementFp.prototype.negate = feFpNegate;
    ECFieldElementFp.prototype.add = feFpAdd;
    ECFieldElementFp.prototype.subtract = feFpSubtract;
    ECFieldElementFp.prototype.multiply = feFpMultiply;
    ECFieldElementFp.prototype.square = feFpSquare;
    ECFieldElementFp.prototype.divide = feFpDivide;
    function ECPointFp(curve, x, y, z) {
      this.curve = curve;
      this.x = x;
      this.y = y;
      if (z == null) {
        this.z = BigInteger.ONE;
      } else {
        this.z = z;
      }
      this.zinv = null;
    }
    function pointFpGetX() {
      if (this.zinv == null) {
        this.zinv = this.z.modInverse(this.curve.q);
      }
      var r = this.x.toBigInteger().multiply(this.zinv);
      this.curve.reduce(r);
      return this.curve.fromBigInteger(r);
    }
    function pointFpGetY() {
      if (this.zinv == null) {
        this.zinv = this.z.modInverse(this.curve.q);
      }
      var r = this.y.toBigInteger().multiply(this.zinv);
      this.curve.reduce(r);
      return this.curve.fromBigInteger(r);
    }
    function pointFpEquals(other) {
      if (other == this)
        return true;
      if (this.isInfinity())
        return other.isInfinity();
      if (other.isInfinity())
        return this.isInfinity();
      var u, v;
      u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
      if (!u.equals(BigInteger.ZERO))
        return false;
      v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
      return v.equals(BigInteger.ZERO);
    }
    function pointFpIsInfinity() {
      if (this.x == null && this.y == null)
        return true;
      return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
    }
    function pointFpNegate() {
      return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
    }
    function pointFpAdd(b) {
      if (this.isInfinity())
        return b;
      if (b.isInfinity())
        return this;
      var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
      var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
      if (BigInteger.ZERO.equals(v)) {
        if (BigInteger.ZERO.equals(u)) {
          return this.twice();
        }
        return this.curve.getInfinity();
      }
      var THREE = new BigInteger("3");
      var x1 = this.x.toBigInteger();
      var y1 = this.y.toBigInteger();
      var x2 = b.x.toBigInteger();
      var y2 = b.y.toBigInteger();
      var v2 = v.square();
      var v3 = v2.multiply(v);
      var x1v2 = x1.multiply(v2);
      var zu2 = u.square().multiply(this.z);
      var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
      var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
      var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
      return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
    }
    function pointFpTwice() {
      if (this.isInfinity())
        return this;
      if (this.y.toBigInteger().signum() == 0)
        return this.curve.getInfinity();
      var THREE = new BigInteger("3");
      var x1 = this.x.toBigInteger();
      var y1 = this.y.toBigInteger();
      var y1z1 = y1.multiply(this.z);
      var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
      var a = this.curve.a.toBigInteger();
      var w = x1.square().multiply(THREE);
      if (!BigInteger.ZERO.equals(a)) {
        w = w.add(this.z.square().multiply(a));
      }
      w = w.mod(this.curve.q);
      var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
      var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
      var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
      return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
    }
    function pointFpMultiply(k) {
      if (this.isInfinity())
        return this;
      if (k.signum() == 0)
        return this.curve.getInfinity();
      var e = k;
      var h = e.multiply(new BigInteger("3"));
      var neg = this.negate();
      var R = this;
      var i;
      for (i = h.bitLength() - 2; i > 0; --i) {
        R = R.twice();
        var hBit = h.testBit(i);
        var eBit = e.testBit(i);
        if (hBit != eBit) {
          R = R.add(hBit ? this : neg);
        }
      }
      return R;
    }
    function pointFpMultiplyTwo(j, x, k) {
      var i;
      if (j.bitLength() > k.bitLength())
        i = j.bitLength() - 1;
      else
        i = k.bitLength() - 1;
      var R = this.curve.getInfinity();
      var both = this.add(x);
      while (i >= 0) {
        R = R.twice();
        if (j.testBit(i)) {
          if (k.testBit(i)) {
            R = R.add(both);
          } else {
            R = R.add(this);
          }
        } else {
          if (k.testBit(i)) {
            R = R.add(x);
          }
        }
        --i;
      }
      return R;
    }
    ECPointFp.prototype.getX = pointFpGetX;
    ECPointFp.prototype.getY = pointFpGetY;
    ECPointFp.prototype.equals = pointFpEquals;
    ECPointFp.prototype.isInfinity = pointFpIsInfinity;
    ECPointFp.prototype.negate = pointFpNegate;
    ECPointFp.prototype.add = pointFpAdd;
    ECPointFp.prototype.twice = pointFpTwice;
    ECPointFp.prototype.multiply = pointFpMultiply;
    ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
    function ECCurveFp(q2, a, b) {
      this.q = q2;
      this.a = this.fromBigInteger(a);
      this.b = this.fromBigInteger(b);
      this.infinity = new ECPointFp(this, null, null);
      this.reducer = new Barrett(this.q);
    }
    function curveFpGetQ() {
      return this.q;
    }
    function curveFpGetA() {
      return this.a;
    }
    function curveFpGetB() {
      return this.b;
    }
    function curveFpEquals(other) {
      if (other == this)
        return true;
      return this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b);
    }
    function curveFpGetInfinity() {
      return this.infinity;
    }
    function curveFpFromBigInteger(x) {
      return new ECFieldElementFp(this.q, x);
    }
    function curveReduce(x) {
      this.reducer.reduce(x);
    }
    function curveFpEncodePointHex(p) {
      if (p.isInfinity())
        return "00";
      var xHex = p.getX().toBigInteger().toString(16);
      var yHex = p.getY().toBigInteger().toString(16);
      var oLen = this.getQ().toString(16).length;
      if (oLen % 2 != 0)
        oLen++;
      while (xHex.length < oLen) {
        xHex = "0" + xHex;
      }
      while (yHex.length < oLen) {
        yHex = "0" + yHex;
      }
      return "04" + xHex + yHex;
    }
    ECCurveFp.prototype.getQ = curveFpGetQ;
    ECCurveFp.prototype.getA = curveFpGetA;
    ECCurveFp.prototype.getB = curveFpGetB;
    ECCurveFp.prototype.equals = curveFpEquals;
    ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
    ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
    ECCurveFp.prototype.reduce = curveReduce;
    ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
    ECCurveFp.prototype.decodePointHex = function(s) {
      var yIsEven;
      switch (parseInt(s.substr(0, 2), 16)) {
        case 0:
          return this.infinity;
        case 2:
          yIsEven = false;
        case 3:
          if (yIsEven == void 0)
            yIsEven = true;
          var len = s.length - 2;
          var xHex = s.substr(2, len);
          var x = this.fromBigInteger(new BigInteger(xHex, 16));
          var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
          var beta = alpha.sqrt();
          if (beta == null)
            throw "Invalid point compression";
          var betaValue = beta.toBigInteger();
          if (betaValue.testBit(0) != yIsEven) {
            beta = this.fromBigInteger(this.getQ().subtract(betaValue));
          }
          return new ECPointFp(this, x, beta);
        case 4:
        case 6:
        case 7:
          var len = (s.length - 2) / 2;
          var xHex = s.substr(2, len);
          var yHex = s.substr(len + 2, len);
          return new ECPointFp(this, this.fromBigInteger(new BigInteger(xHex, 16)), this.fromBigInteger(new BigInteger(yHex, 16)));
        default:
          return null;
      }
    };
    ECCurveFp.prototype.encodeCompressedPointHex = function(p) {
      if (p.isInfinity())
        return "00";
      var xHex = p.getX().toBigInteger().toString(16);
      var oLen = this.getQ().toString(16).length;
      if (oLen % 2 != 0)
        oLen++;
      while (xHex.length < oLen)
        xHex = "0" + xHex;
      var yPrefix;
      if (p.getY().toBigInteger().isEven())
        yPrefix = "02";
      else
        yPrefix = "03";
      return yPrefix + xHex;
    };
    ECFieldElementFp.prototype.getR = function() {
      if (this.r != void 0)
        return this.r;
      this.r = null;
      var bitLength = this.q.bitLength();
      if (bitLength > 128) {
        var firstWord = this.q.shiftRight(bitLength - 64);
        if (firstWord.intValue() == -1) {
          this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
        }
      }
      return this.r;
    };
    ECFieldElementFp.prototype.modMult = function(x1, x2) {
      return this.modReduce(x1.multiply(x2));
    };
    ECFieldElementFp.prototype.modReduce = function(x) {
      if (this.getR() != null) {
        var qLen = q.bitLength();
        while (x.bitLength() > qLen + 1) {
          var u = x.shiftRight(qLen);
          var v = x.subtract(u.shiftLeft(qLen));
          if (!this.getR().equals(BigInteger.ONE)) {
            u = u.multiply(this.getR());
          }
          x = u.add(v);
        }
        while (x.compareTo(q) >= 0) {
          x = x.subtract(q);
        }
      } else {
        x = x.mod(q);
      }
      return x;
    };
    ECFieldElementFp.prototype.sqrt = function() {
      if (!this.q.testBit(0))
        throw "unsupported";
      if (this.q.testBit(1)) {
        var z = new ECFieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
        return z.square().equals(this) ? z : null;
      }
      var qMinusOne = this.q.subtract(BigInteger.ONE);
      var legendreExponent = qMinusOne.shiftRight(1);
      if (!this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)) {
        return null;
      }
      var u = qMinusOne.shiftRight(2);
      var k = u.shiftLeft(1).add(BigInteger.ONE);
      var Q = this.x;
      var fourQ = modDouble(modDouble(Q));
      var U, V;
      do {
        var P;
        do {
          P = new BigInteger(this.q.bitLength(), new SecureRandom());
        } while (P.compareTo(this.q) >= 0 || !P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne));
        var result = this.lucasSequence(P, Q, k);
        U = result[0];
        V = result[1];
        if (this.modMult(V, V).equals(fourQ)) {
          if (V.testBit(0)) {
            V = V.add(q);
          }
          V = V.shiftRight(1);
          return new ECFieldElementFp(q, V);
        }
      } while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));
      return null;
    };
    ECFieldElementFp.prototype.lucasSequence = function(P, Q, k) {
      var n = k.bitLength();
      var s = k.getLowestSetBit();
      var Uh = BigInteger.ONE;
      var Vl = BigInteger.TWO;
      var Vh = P;
      var Ql = BigInteger.ONE;
      var Qh = BigInteger.ONE;
      for (var j = n - 1; j >= s + 1; --j) {
        Ql = this.modMult(Ql, Qh);
        if (k.testBit(j)) {
          Qh = this.modMult(Ql, Q);
          Uh = this.modMult(Uh, Vh);
          Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
          Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
        } else {
          Qh = Ql;
          Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
          Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
          Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
        }
      }
      Ql = this.modMult(Ql, Qh);
      Qh = this.modMult(Ql, Q);
      Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
      Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
      Ql = this.modMult(Ql, Qh);
      for (var j = 1; j <= s; ++j) {
        Uh = this.modMult(Uh, Vl);
        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
        Ql = this.modMult(Ql, Ql);
      }
      return [Uh, Vl];
    };
    var exports2 = {
      ECCurveFp,
      ECPointFp,
      ECFieldElementFp
    };
    module2.exports = exports2;
  }
});

// ../../node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "../../node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++)
            r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q2, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q2[i]);
          p[i] ^= t;
          q2[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q2, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q2, x16);
        return 0;
      }
      function crypto_scalarmult_base(q2, n) {
        return crypto_scalarmult(q2, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q2) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q2[1], q2[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q2[0], q2[1]);
        M(b, b, t);
        M(c, p[3], q2[3]);
        M(c, c, D2);
        M(d, p[2], q2[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q2, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q2[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q2, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q2, b);
          add(q2, p);
          add(p, p);
          cswap(p, q2, b);
        }
      }
      function scalarbase(p, s) {
        var q2 = [gf(), gf(), gf(), gf()];
        set25519(q2[0], X);
        set25519(q2[1], Y);
        set25519(q2[2], gf1);
        M(q2[3], X, Y);
        scalarmult(p, q2, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
        mlen = -1;
        if (n < 64)
          return -1;
        if (unpackneg(q2, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q2, h);
        scalarbase(q2, sm.subarray(32));
        add(p, q2);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        mlen = n;
        return mlen;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        var t, i;
        for (i = 0; i < arguments.length; i++) {
          if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
            throw new TypeError("unexpected type " + t + ", use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      if (!nacl.util) {
        nacl.util = {};
        nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
          throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
        };
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return false;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return false;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q2, n, p);
        return q2;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q2, n);
        return q2;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        if (arguments.length !== 2)
          throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof require !== "undefined") {
          crypto = require("crypto");
          if (crypto && crypto.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// ../../node_modules/sshpk/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/sshpk/lib/utils.js"(exports2, module2) {
    module2.exports = {
      bufferSplit,
      addRSAMissing,
      calculateDSAPublic,
      calculateED25519Public,
      calculateX25519Public,
      mpNormalize,
      mpDenormalize,
      ecNormalize,
      countZeros,
      assertCompatible,
      isCompatible,
      opensslKeyDeriv,
      opensshCipherInfo,
      publicFromPrivateECDSA,
      zeroPadToLength,
      writeBitString,
      readBitString,
      pbkdf2
    };
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var PrivateKey = require_private_key();
    var Key = require_key();
    var crypto = require("crypto");
    var algs = require_algs();
    var asn1 = require_lib2();
    var ec = require_ec();
    var jsbn = require_jsbn().BigInteger;
    var nacl = require_nacl_fast();
    var MAX_CLASS_DEPTH = 3;
    function isCompatible(obj, klass, needVer) {
      if (obj === null || typeof obj !== "object")
        return false;
      if (needVer === void 0)
        needVer = klass.prototype._sshpkApiVersion;
      if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
        return true;
      var proto = Object.getPrototypeOf(obj);
      var depth = 0;
      while (proto.constructor.name !== klass.name) {
        proto = Object.getPrototypeOf(proto);
        if (!proto || ++depth > MAX_CLASS_DEPTH)
          return false;
      }
      if (proto.constructor.name !== klass.name)
        return false;
      var ver = proto._sshpkApiVersion;
      if (ver === void 0)
        ver = klass._oldVersionDetect(obj);
      if (ver[0] != needVer[0] || ver[1] < needVer[1])
        return false;
      return true;
    }
    function assertCompatible(obj, klass, needVer, name) {
      if (name === void 0)
        name = "object";
      assert3.ok(obj, name + " must not be null");
      assert3.object(obj, name + " must be an object");
      if (needVer === void 0)
        needVer = klass.prototype._sshpkApiVersion;
      if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
        return;
      var proto = Object.getPrototypeOf(obj);
      var depth = 0;
      while (proto.constructor.name !== klass.name) {
        proto = Object.getPrototypeOf(proto);
        assert3.ok(proto && ++depth <= MAX_CLASS_DEPTH, name + " must be a " + klass.name + " instance");
      }
      assert3.strictEqual(proto.constructor.name, klass.name, name + " must be a " + klass.name + " instance");
      var ver = proto._sshpkApiVersion;
      if (ver === void 0)
        ver = klass._oldVersionDetect(obj);
      assert3.ok(ver[0] == needVer[0] && ver[1] >= needVer[1], name + " must be compatible with " + klass.name + " klass version " + needVer[0] + "." + needVer[1]);
    }
    var CIPHER_LEN = {
      "des-ede3-cbc": { key: 24, iv: 8 },
      "aes-128-cbc": { key: 16, iv: 16 },
      "aes-256-cbc": { key: 32, iv: 16 }
    };
    var PKCS5_SALT_LEN = 8;
    function opensslKeyDeriv(cipher, salt, passphrase, count) {
      assert3.buffer(salt, "salt");
      assert3.buffer(passphrase, "passphrase");
      assert3.number(count, "iteration count");
      var clen = CIPHER_LEN[cipher];
      assert3.object(clen, "supported cipher");
      salt = salt.slice(0, PKCS5_SALT_LEN);
      var D, D_prev, bufs;
      var material = Buffer2.alloc(0);
      while (material.length < clen.key + clen.iv) {
        bufs = [];
        if (D_prev)
          bufs.push(D_prev);
        bufs.push(passphrase);
        bufs.push(salt);
        D = Buffer2.concat(bufs);
        for (var j = 0; j < count; ++j)
          D = crypto.createHash("md5").update(D).digest();
        material = Buffer2.concat([material, D]);
        D_prev = D;
      }
      return {
        key: material.slice(0, clen.key),
        iv: material.slice(clen.key, clen.key + clen.iv)
      };
    }
    function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
      var hkey = Buffer2.alloc(salt.length + 4);
      salt.copy(hkey);
      var gen = 0, ts = [];
      var i = 1;
      while (gen < size) {
        var t = T(i++);
        gen += t.length;
        ts.push(t);
      }
      return Buffer2.concat(ts).slice(0, size);
      function T(I) {
        hkey.writeUInt32BE(I, hkey.length - 4);
        var hmac = crypto.createHmac(hashAlg, passphrase);
        hmac.update(hkey);
        var Ti = hmac.digest();
        var Uc = Ti;
        var c = 1;
        while (c++ < iterations) {
          hmac = crypto.createHmac(hashAlg, passphrase);
          hmac.update(Uc);
          Uc = hmac.digest();
          for (var x = 0; x < Ti.length; ++x)
            Ti[x] ^= Uc[x];
        }
        return Ti;
      }
    }
    function countZeros(buf) {
      var o = 0, obit = 8;
      while (o < buf.length) {
        var mask = 1 << obit;
        if ((buf[o] & mask) === mask)
          break;
        obit--;
        if (obit < 0) {
          o++;
          obit = 8;
        }
      }
      return o * 8 + (8 - obit) - 1;
    }
    function bufferSplit(buf, chr) {
      assert3.buffer(buf);
      assert3.string(chr);
      var parts = [];
      var lastPart = 0;
      var matches2 = 0;
      for (var i = 0; i < buf.length; ++i) {
        if (buf[i] === chr.charCodeAt(matches2))
          ++matches2;
        else if (buf[i] === chr.charCodeAt(0))
          matches2 = 1;
        else
          matches2 = 0;
        if (matches2 >= chr.length) {
          var newPart = i + 1;
          parts.push(buf.slice(lastPart, newPart - matches2));
          lastPart = newPart;
          matches2 = 0;
        }
      }
      if (lastPart <= buf.length)
        parts.push(buf.slice(lastPart, buf.length));
      return parts;
    }
    function ecNormalize(buf, addZero) {
      assert3.buffer(buf);
      if (buf[0] === 0 && buf[1] === 4) {
        if (addZero)
          return buf;
        return buf.slice(1);
      } else if (buf[0] === 4) {
        if (!addZero)
          return buf;
      } else {
        while (buf[0] === 0)
          buf = buf.slice(1);
        if (buf[0] === 2 || buf[0] === 3)
          throw new Error("Compressed elliptic curve points are not supported");
        if (buf[0] !== 4)
          throw new Error("Not a valid elliptic curve point");
        if (!addZero)
          return buf;
      }
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      return b;
    }
    function readBitString(der, tag) {
      if (tag === void 0)
        tag = asn1.Ber.BitString;
      var buf = der.readString(tag, true);
      assert3.strictEqual(buf[0], 0, "bit strings with unused bits are not supported (0x" + buf[0].toString(16) + ")");
      return buf.slice(1);
    }
    function writeBitString(der, buf, tag) {
      if (tag === void 0)
        tag = asn1.Ber.BitString;
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      der.writeBuffer(b, tag);
    }
    function mpNormalize(buf) {
      assert3.buffer(buf);
      while (buf.length > 1 && buf[0] === 0 && (buf[1] & 128) === 0)
        buf = buf.slice(1);
      if ((buf[0] & 128) === 128) {
        var b = Buffer2.alloc(buf.length + 1);
        b[0] = 0;
        buf.copy(b, 1);
        buf = b;
      }
      return buf;
    }
    function mpDenormalize(buf) {
      assert3.buffer(buf);
      while (buf.length > 1 && buf[0] === 0)
        buf = buf.slice(1);
      return buf;
    }
    function zeroPadToLength(buf, len) {
      assert3.buffer(buf);
      assert3.number(len);
      while (buf.length > len) {
        assert3.equal(buf[0], 0);
        buf = buf.slice(1);
      }
      while (buf.length < len) {
        var b = Buffer2.alloc(buf.length + 1);
        b[0] = 0;
        buf.copy(b, 1);
        buf = b;
      }
      return buf;
    }
    function bigintToMpBuf(bigint) {
      var buf = Buffer2.from(bigint.toByteArray());
      buf = mpNormalize(buf);
      return buf;
    }
    function calculateDSAPublic(g, p, x) {
      assert3.buffer(g);
      assert3.buffer(p);
      assert3.buffer(x);
      g = new jsbn(g);
      p = new jsbn(p);
      x = new jsbn(x);
      var y = g.modPow(x, p);
      var ybuf = bigintToMpBuf(y);
      return ybuf;
    }
    function calculateED25519Public(k) {
      assert3.buffer(k);
      var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
      return Buffer2.from(kp.publicKey);
    }
    function calculateX25519Public(k) {
      assert3.buffer(k);
      var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
      return Buffer2.from(kp.publicKey);
    }
    function addRSAMissing(key) {
      assert3.object(key);
      assertCompatible(key, PrivateKey, [1, 1]);
      var d = new jsbn(key.part.d.data);
      var buf;
      if (!key.part.dmodp) {
        var p = new jsbn(key.part.p.data);
        var dmodp = d.mod(p.subtract(1));
        buf = bigintToMpBuf(dmodp);
        key.part.dmodp = { name: "dmodp", data: buf };
        key.parts.push(key.part.dmodp);
      }
      if (!key.part.dmodq) {
        var q2 = new jsbn(key.part.q.data);
        var dmodq = d.mod(q2.subtract(1));
        buf = bigintToMpBuf(dmodq);
        key.part.dmodq = { name: "dmodq", data: buf };
        key.parts.push(key.part.dmodq);
      }
    }
    function publicFromPrivateECDSA(curveName, priv) {
      assert3.string(curveName, "curveName");
      assert3.buffer(priv);
      var params = algs.curves[curveName];
      var p = new jsbn(params.p);
      var a = new jsbn(params.a);
      var b = new jsbn(params.b);
      var curve = new ec.ECCurveFp(p, a, b);
      var G = curve.decodePointHex(params.G.toString("hex"));
      var d = new jsbn(mpNormalize(priv));
      var pub = G.multiply(d);
      pub = Buffer2.from(curve.encodePointHex(pub), "hex");
      var parts = [];
      parts.push({ name: "curve", data: Buffer2.from(curveName) });
      parts.push({ name: "Q", data: pub });
      var key = new Key({ type: "ecdsa", curve, parts });
      return key;
    }
    function opensshCipherInfo(cipher) {
      var inf = {};
      switch (cipher) {
        case "3des-cbc":
          inf.keySize = 24;
          inf.blockSize = 8;
          inf.opensslName = "des-ede3-cbc";
          break;
        case "blowfish-cbc":
          inf.keySize = 16;
          inf.blockSize = 8;
          inf.opensslName = "bf-cbc";
          break;
        case "aes128-cbc":
        case "aes128-ctr":
        case "aes128-gcm@openssh.com":
          inf.keySize = 16;
          inf.blockSize = 16;
          inf.opensslName = "aes-128-" + cipher.slice(7, 10);
          break;
        case "aes192-cbc":
        case "aes192-ctr":
        case "aes192-gcm@openssh.com":
          inf.keySize = 24;
          inf.blockSize = 16;
          inf.opensslName = "aes-192-" + cipher.slice(7, 10);
          break;
        case "aes256-cbc":
        case "aes256-ctr":
        case "aes256-gcm@openssh.com":
          inf.keySize = 32;
          inf.blockSize = 16;
          inf.opensslName = "aes-256-" + cipher.slice(7, 10);
          break;
        default:
          throw new Error('Unsupported openssl cipher "' + cipher + '"');
      }
      return inf;
    }
  }
});

// ../../node_modules/sshpk/lib/ssh-buffer.js
var require_ssh_buffer = __commonJS({
  "../../node_modules/sshpk/lib/ssh-buffer.js"(exports2, module2) {
    module2.exports = SSHBuffer;
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    function SSHBuffer(opts) {
      assert3.object(opts, "options");
      if (opts.buffer !== void 0)
        assert3.buffer(opts.buffer, "options.buffer");
      this._size = opts.buffer ? opts.buffer.length : 1024;
      this._buffer = opts.buffer || Buffer2.alloc(this._size);
      this._offset = 0;
    }
    SSHBuffer.prototype.toBuffer = function() {
      return this._buffer.slice(0, this._offset);
    };
    SSHBuffer.prototype.atEnd = function() {
      return this._offset >= this._buffer.length;
    };
    SSHBuffer.prototype.remainder = function() {
      return this._buffer.slice(this._offset);
    };
    SSHBuffer.prototype.skip = function(n) {
      this._offset += n;
    };
    SSHBuffer.prototype.expand = function() {
      this._size *= 2;
      var buf = Buffer2.alloc(this._size);
      this._buffer.copy(buf, 0);
      this._buffer = buf;
    };
    SSHBuffer.prototype.readPart = function() {
      return { data: this.readBuffer() };
    };
    SSHBuffer.prototype.readBuffer = function() {
      var len = this._buffer.readUInt32BE(this._offset);
      this._offset += 4;
      assert3.ok(this._offset + len <= this._buffer.length, "length out of bounds at +0x" + this._offset.toString(16) + " (data truncated?)");
      var buf = this._buffer.slice(this._offset, this._offset + len);
      this._offset += len;
      return buf;
    };
    SSHBuffer.prototype.readString = function() {
      return this.readBuffer().toString();
    };
    SSHBuffer.prototype.readCString = function() {
      var offset = this._offset;
      while (offset < this._buffer.length && this._buffer[offset] !== 0)
        offset++;
      assert3.ok(offset < this._buffer.length, "c string does not terminate");
      var str = this._buffer.slice(this._offset, offset).toString();
      this._offset = offset + 1;
      return str;
    };
    SSHBuffer.prototype.readInt = function() {
      var v = this._buffer.readUInt32BE(this._offset);
      this._offset += 4;
      return v;
    };
    SSHBuffer.prototype.readInt64 = function() {
      assert3.ok(this._offset + 8 < this._buffer.length, "buffer not long enough to read Int64");
      var v = this._buffer.slice(this._offset, this._offset + 8);
      this._offset += 8;
      return v;
    };
    SSHBuffer.prototype.readChar = function() {
      var v = this._buffer[this._offset++];
      return v;
    };
    SSHBuffer.prototype.writeBuffer = function(buf) {
      while (this._offset + 4 + buf.length > this._size)
        this.expand();
      this._buffer.writeUInt32BE(buf.length, this._offset);
      this._offset += 4;
      buf.copy(this._buffer, this._offset);
      this._offset += buf.length;
    };
    SSHBuffer.prototype.writeString = function(str) {
      this.writeBuffer(Buffer2.from(str, "utf8"));
    };
    SSHBuffer.prototype.writeCString = function(str) {
      while (this._offset + 1 + str.length > this._size)
        this.expand();
      this._buffer.write(str, this._offset);
      this._offset += str.length;
      this._buffer[this._offset++] = 0;
    };
    SSHBuffer.prototype.writeInt = function(v) {
      while (this._offset + 4 > this._size)
        this.expand();
      this._buffer.writeUInt32BE(v, this._offset);
      this._offset += 4;
    };
    SSHBuffer.prototype.writeInt64 = function(v) {
      assert3.buffer(v, "value");
      if (v.length > 8) {
        var lead = v.slice(0, v.length - 8);
        for (var i = 0; i < lead.length; ++i) {
          assert3.strictEqual(lead[i], 0, "must fit in 64 bits of precision");
        }
        v = v.slice(v.length - 8, v.length);
      }
      while (this._offset + 8 > this._size)
        this.expand();
      v.copy(this._buffer, this._offset);
      this._offset += 8;
    };
    SSHBuffer.prototype.writeChar = function(v) {
      while (this._offset + 1 > this._size)
        this.expand();
      this._buffer[this._offset++] = v;
    };
    SSHBuffer.prototype.writePart = function(p) {
      this.writeBuffer(p.data);
    };
    SSHBuffer.prototype.write = function(buf) {
      while (this._offset + buf.length > this._size)
        this.expand();
      buf.copy(this._buffer, this._offset);
      this._offset += buf.length;
    };
  }
});

// ../../node_modules/sshpk/lib/signature.js
var require_signature = __commonJS({
  "../../node_modules/sshpk/lib/signature.js"(exports2, module2) {
    module2.exports = Signature;
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = require("crypto");
    var errs = require_errors();
    var utils = require_utils();
    var asn1 = require_lib2();
    var SSHBuffer = require_ssh_buffer();
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    var SignatureParseError = errs.SignatureParseError;
    function Signature(opts) {
      assert3.object(opts, "options");
      assert3.arrayOfObject(opts.parts, "options.parts");
      assert3.string(opts.type, "options.type");
      var partLookup = {};
      for (var i = 0; i < opts.parts.length; ++i) {
        var part = opts.parts[i];
        partLookup[part.name] = part;
      }
      this.type = opts.type;
      this.hashAlgorithm = opts.hashAlgo;
      this.curve = opts.curve;
      this.parts = opts.parts;
      this.part = partLookup;
    }
    Signature.prototype.toBuffer = function(format) {
      if (format === void 0)
        format = "asn1";
      assert3.string(format, "format");
      var buf;
      var stype = "ssh-" + this.type;
      switch (this.type) {
        case "rsa":
          switch (this.hashAlgorithm) {
            case "sha256":
              stype = "rsa-sha2-256";
              break;
            case "sha512":
              stype = "rsa-sha2-512";
              break;
            case "sha1":
            case void 0:
              break;
            default:
              throw new Error("SSH signature format does not support hash algorithm " + this.hashAlgorithm);
          }
          if (format === "ssh") {
            buf = new SSHBuffer({});
            buf.writeString(stype);
            buf.writePart(this.part.sig);
            return buf.toBuffer();
          } else {
            return this.part.sig.data;
          }
          break;
        case "ed25519":
          if (format === "ssh") {
            buf = new SSHBuffer({});
            buf.writeString(stype);
            buf.writePart(this.part.sig);
            return buf.toBuffer();
          } else {
            return this.part.sig.data;
          }
          break;
        case "dsa":
        case "ecdsa":
          var r, s;
          if (format === "asn1") {
            var der = new asn1.BerWriter();
            der.startSequence();
            r = utils.mpNormalize(this.part.r.data);
            s = utils.mpNormalize(this.part.s.data);
            der.writeBuffer(r, asn1.Ber.Integer);
            der.writeBuffer(s, asn1.Ber.Integer);
            der.endSequence();
            return der.buffer;
          } else if (format === "ssh" && this.type === "dsa") {
            buf = new SSHBuffer({});
            buf.writeString("ssh-dss");
            r = this.part.r.data;
            if (r.length > 20 && r[0] === 0)
              r = r.slice(1);
            s = this.part.s.data;
            if (s.length > 20 && s[0] === 0)
              s = s.slice(1);
            if (this.hashAlgorithm && this.hashAlgorithm !== "sha1" || r.length + s.length !== 40) {
              throw new Error("OpenSSH only supports DSA signatures with SHA1 hash");
            }
            buf.writeBuffer(Buffer2.concat([r, s]));
            return buf.toBuffer();
          } else if (format === "ssh" && this.type === "ecdsa") {
            var inner = new SSHBuffer({});
            r = this.part.r.data;
            inner.writeBuffer(r);
            inner.writePart(this.part.s);
            buf = new SSHBuffer({});
            var curve;
            if (r[0] === 0)
              r = r.slice(1);
            var sz = r.length * 8;
            if (sz === 256)
              curve = "nistp256";
            else if (sz === 384)
              curve = "nistp384";
            else if (sz === 528)
              curve = "nistp521";
            buf.writeString("ecdsa-sha2-" + curve);
            buf.writeBuffer(inner.toBuffer());
            return buf.toBuffer();
          }
          throw new Error("Invalid signature format");
        default:
          throw new Error("Invalid signature data");
      }
    };
    Signature.prototype.toString = function(format) {
      assert3.optionalString(format, "format");
      return this.toBuffer(format).toString("base64");
    };
    Signature.parse = function(data, type, format) {
      if (typeof data === "string")
        data = Buffer2.from(data, "base64");
      assert3.buffer(data, "data");
      assert3.string(format, "format");
      assert3.string(type, "type");
      var opts = {};
      opts.type = type.toLowerCase();
      opts.parts = [];
      try {
        assert3.ok(data.length > 0, "signature must not be empty");
        switch (opts.type) {
          case "rsa":
            return parseOneNum(data, type, format, opts);
          case "ed25519":
            return parseOneNum(data, type, format, opts);
          case "dsa":
          case "ecdsa":
            if (format === "asn1")
              return parseDSAasn1(data, type, format, opts);
            else if (opts.type === "dsa")
              return parseDSA(data, type, format, opts);
            else
              return parseECDSA(data, type, format, opts);
          default:
            throw new InvalidAlgorithmError(type);
        }
      } catch (e) {
        if (e instanceof InvalidAlgorithmError)
          throw e;
        throw new SignatureParseError(type, format, e);
      }
    };
    function parseOneNum(data, type, format, opts) {
      if (format === "ssh") {
        try {
          var buf = new SSHBuffer({ buffer: data });
          var head = buf.readString();
        } catch (e) {
        }
        if (buf !== void 0) {
          var msg = "SSH signature does not match expected type (expected " + type + ", got " + head + ")";
          switch (head) {
            case "ssh-rsa":
              assert3.strictEqual(type, "rsa", msg);
              opts.hashAlgo = "sha1";
              break;
            case "rsa-sha2-256":
              assert3.strictEqual(type, "rsa", msg);
              opts.hashAlgo = "sha256";
              break;
            case "rsa-sha2-512":
              assert3.strictEqual(type, "rsa", msg);
              opts.hashAlgo = "sha512";
              break;
            case "ssh-ed25519":
              assert3.strictEqual(type, "ed25519", msg);
              opts.hashAlgo = "sha512";
              break;
            default:
              throw new Error("Unknown SSH signature type: " + head);
          }
          var sig = buf.readPart();
          assert3.ok(buf.atEnd(), "extra trailing bytes");
          sig.name = "sig";
          opts.parts.push(sig);
          return new Signature(opts);
        }
      }
      opts.parts.push({ name: "sig", data });
      return new Signature(opts);
    }
    function parseDSAasn1(data, type, format, opts) {
      var der = new asn1.BerReader(data);
      der.readSequence();
      var r = der.readString(asn1.Ber.Integer, true);
      var s = der.readString(asn1.Ber.Integer, true);
      opts.parts.push({ name: "r", data: utils.mpNormalize(r) });
      opts.parts.push({ name: "s", data: utils.mpNormalize(s) });
      return new Signature(opts);
    }
    function parseDSA(data, type, format, opts) {
      if (data.length != 40) {
        var buf = new SSHBuffer({ buffer: data });
        var d = buf.readBuffer();
        if (d.toString("ascii") === "ssh-dss")
          d = buf.readBuffer();
        assert3.ok(buf.atEnd(), "extra trailing bytes");
        assert3.strictEqual(d.length, 40, "invalid inner length");
        data = d;
      }
      opts.parts.push({ name: "r", data: data.slice(0, 20) });
      opts.parts.push({ name: "s", data: data.slice(20, 40) });
      return new Signature(opts);
    }
    function parseECDSA(data, type, format, opts) {
      var buf = new SSHBuffer({ buffer: data });
      var r, s;
      var inner = buf.readBuffer();
      var stype = inner.toString("ascii");
      if (stype.slice(0, 6) === "ecdsa-") {
        var parts = stype.split("-");
        assert3.strictEqual(parts[0], "ecdsa");
        assert3.strictEqual(parts[1], "sha2");
        opts.curve = parts[2];
        switch (opts.curve) {
          case "nistp256":
            opts.hashAlgo = "sha256";
            break;
          case "nistp384":
            opts.hashAlgo = "sha384";
            break;
          case "nistp521":
            opts.hashAlgo = "sha512";
            break;
          default:
            throw new Error("Unsupported ECDSA curve: " + opts.curve);
        }
        inner = buf.readBuffer();
        assert3.ok(buf.atEnd(), "extra trailing bytes on outer");
        buf = new SSHBuffer({ buffer: inner });
        r = buf.readPart();
      } else {
        r = { data: inner };
      }
      s = buf.readPart();
      assert3.ok(buf.atEnd(), "extra trailing bytes");
      r.name = "r";
      s.name = "s";
      opts.parts.push(r);
      opts.parts.push(s);
      return new Signature(opts);
    }
    Signature.isSignature = function(obj, ver) {
      return utils.isCompatible(obj, Signature, ver);
    };
    Signature.prototype._sshpkApiVersion = [2, 1];
    Signature._oldVersionDetect = function(obj) {
      assert3.func(obj.toBuffer);
      if (obj.hasOwnProperty("hashAlgorithm"))
        return [2, 0];
      return [1, 0];
    };
  }
});

// ../../node_modules/ecc-jsbn/lib/sec.js
var require_sec = __commonJS({
  "../../node_modules/ecc-jsbn/lib/sec.js"(exports2, module2) {
    var BigInteger = require_jsbn().BigInteger;
    var ECCurveFp = require_ec().ECCurveFp;
    function X9ECParameters(curve, g, n, h) {
      this.curve = curve;
      this.g = g;
      this.n = n;
      this.h = h;
    }
    function x9getCurve() {
      return this.curve;
    }
    function x9getG() {
      return this.g;
    }
    function x9getN() {
      return this.n;
    }
    function x9getH() {
      return this.h;
    }
    X9ECParameters.prototype.getCurve = x9getCurve;
    X9ECParameters.prototype.getG = x9getG;
    X9ECParameters.prototype.getN = x9getN;
    X9ECParameters.prototype.getH = x9getH;
    function fromHex(s) {
      return new BigInteger(s, 16);
    }
    function secp128r1() {
      var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
      var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
      var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
      var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04161FF7528B899B2D0C28607CA52C5B86CF5AC8395BAFEB13C02DA292DDED7A83");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp160k1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
      var a = BigInteger.ZERO;
      var b = fromHex("7");
      var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("043B4C382CE37AA192A4019E763036F4F5DD4D7EBB938CF935318FDCED6BC28286531733C3F03C4FEE");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp160r1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
      var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
      var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
      var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("044A96B5688EF573284664698968C38BB913CBFC8223A628553168947D59DCC912042351377AC5FB32");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp192k1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
      var a = BigInteger.ZERO;
      var b = fromHex("3");
      var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp192r1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
      var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
      var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
      var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF101207192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp224r1() {
      var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
      var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
      var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
      var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("04B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
      return new X9ECParameters(curve, G, n, h);
    }
    function secp256r1() {
      var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
      var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
      var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
      var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
      var h = BigInteger.ONE;
      var curve = new ECCurveFp(p, a, b);
      var G = curve.decodePointHex("046B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C2964FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
      return new X9ECParameters(curve, G, n, h);
    }
    module2.exports = {
      "secp128r1": secp128r1,
      "secp160k1": secp160k1,
      "secp160r1": secp160r1,
      "secp192k1": secp192k1,
      "secp192r1": secp192r1,
      "secp224r1": secp224r1,
      "secp256r1": secp256r1
    };
  }
});

// ../../node_modules/ecc-jsbn/index.js
var require_ecc_jsbn = __commonJS({
  "../../node_modules/ecc-jsbn/index.js"(exports2) {
    var crypto = require("crypto");
    var BigInteger = require_jsbn().BigInteger;
    var ECPointFp = require_ec().ECPointFp;
    var Buffer2 = require_safer().Buffer;
    exports2.ECCurves = require_sec();
    function unstupid(hex, len) {
      return hex.length >= len ? hex : unstupid("0" + hex, len);
    }
    exports2.ECKey = function(curve, key, isPublic) {
      var priv;
      var c = curve();
      var n = c.getN();
      var bytes = Math.floor(n.bitLength() / 8);
      if (key) {
        if (isPublic) {
          var curve = c.getCurve();
          this.P = curve.decodePointHex(key.toString("hex"));
        } else {
          if (key.length != bytes)
            return false;
          priv = new BigInteger(key.toString("hex"), 16);
        }
      } else {
        var n1 = n.subtract(BigInteger.ONE);
        var r = new BigInteger(crypto.randomBytes(n.bitLength()));
        priv = r.mod(n1).add(BigInteger.ONE);
        this.P = c.getG().multiply(priv);
      }
      if (this.P) {
        this.PublicKey = Buffer2.from(c.getCurve().encodeCompressedPointHex(this.P), "hex");
      }
      if (priv) {
        this.PrivateKey = Buffer2.from(unstupid(priv.toString(16), bytes * 2), "hex");
        this.deriveSharedSecret = function(key2) {
          if (!key2 || !key2.P)
            return false;
          var S = key2.P.multiply(priv);
          return Buffer2.from(unstupid(S.getX().toBigInteger().toString(16), bytes * 2), "hex");
        };
      }
    };
  }
});

// ../../node_modules/sshpk/lib/dhe.js
var require_dhe = __commonJS({
  "../../node_modules/sshpk/lib/dhe.js"(exports2, module2) {
    module2.exports = {
      DiffieHellman,
      generateECDSA,
      generateED25519
    };
    var assert3 = require_assert();
    var crypto = require("crypto");
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var nacl = require_nacl_fast();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var CRYPTO_HAVE_ECDH = crypto.createECDH !== void 0;
    var ecdh = require_ecc_jsbn();
    var ec = require_ec();
    var jsbn = require_jsbn().BigInteger;
    function DiffieHellman(key) {
      utils.assertCompatible(key, Key, [1, 4], "key");
      this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
      this._algo = key.type;
      this._curve = key.curve;
      this._key = key;
      if (key.type === "dsa") {
        if (!CRYPTO_HAVE_ECDH) {
          throw new Error("Due to bugs in the node 0.10 crypto API, node 0.12.x or later is required to use DH");
        }
        this._dh = crypto.createDiffieHellman(key.part.p.data, void 0, key.part.g.data, void 0);
        this._p = key.part.p;
        this._g = key.part.g;
        if (this._isPriv)
          this._dh.setPrivateKey(key.part.x.data);
        this._dh.setPublicKey(key.part.y.data);
      } else if (key.type === "ecdsa") {
        if (!CRYPTO_HAVE_ECDH) {
          this._ecParams = new X9ECParameters(this._curve);
          if (this._isPriv) {
            this._priv = new ECPrivate(this._ecParams, key.part.d.data);
          }
          return;
        }
        var curve = {
          "nistp256": "prime256v1",
          "nistp384": "secp384r1",
          "nistp521": "secp521r1"
        }[key.curve];
        this._dh = crypto.createECDH(curve);
        if (typeof this._dh !== "object" || typeof this._dh.setPrivateKey !== "function") {
          CRYPTO_HAVE_ECDH = false;
          DiffieHellman.call(this, key);
          return;
        }
        if (this._isPriv)
          this._dh.setPrivateKey(key.part.d.data);
        this._dh.setPublicKey(key.part.Q.data);
      } else if (key.type === "curve25519") {
        if (this._isPriv) {
          utils.assertCompatible(key, PrivateKey, [1, 5], "key");
          this._priv = key.part.k.data;
        }
      } else {
        throw new Error("DH not supported for " + key.type + " keys");
      }
    }
    DiffieHellman.prototype.getPublicKey = function() {
      if (this._isPriv)
        return this._key.toPublic();
      return this._key;
    };
    DiffieHellman.prototype.getPrivateKey = function() {
      if (this._isPriv)
        return this._key;
      else
        return void 0;
    };
    DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;
    DiffieHellman.prototype._keyCheck = function(pk, isPub) {
      assert3.object(pk, "key");
      if (!isPub)
        utils.assertCompatible(pk, PrivateKey, [1, 3], "key");
      utils.assertCompatible(pk, Key, [1, 4], "key");
      if (pk.type !== this._algo) {
        throw new Error("A " + pk.type + " key cannot be used in " + this._algo + " Diffie-Hellman");
      }
      if (pk.curve !== this._curve) {
        throw new Error("A key from the " + pk.curve + " curve cannot be used with a " + this._curve + " Diffie-Hellman");
      }
      if (pk.type === "dsa") {
        assert3.deepEqual(pk.part.p, this._p, "DSA key prime does not match");
        assert3.deepEqual(pk.part.g, this._g, "DSA key generator does not match");
      }
    };
    DiffieHellman.prototype.setKey = function(pk) {
      this._keyCheck(pk);
      if (pk.type === "dsa") {
        this._dh.setPrivateKey(pk.part.x.data);
        this._dh.setPublicKey(pk.part.y.data);
      } else if (pk.type === "ecdsa") {
        if (CRYPTO_HAVE_ECDH) {
          this._dh.setPrivateKey(pk.part.d.data);
          this._dh.setPublicKey(pk.part.Q.data);
        } else {
          this._priv = new ECPrivate(this._ecParams, pk.part.d.data);
        }
      } else if (pk.type === "curve25519") {
        var k = pk.part.k;
        if (!pk.part.k)
          k = pk.part.r;
        this._priv = k.data;
        if (this._priv[0] === 0)
          this._priv = this._priv.slice(1);
        this._priv = this._priv.slice(0, 32);
      }
      this._key = pk;
      this._isPriv = true;
    };
    DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;
    DiffieHellman.prototype.computeSecret = function(otherpk) {
      this._keyCheck(otherpk, true);
      if (!this._isPriv)
        throw new Error("DH exchange has not been initialized with a private key yet");
      var pub;
      if (this._algo === "dsa") {
        return this._dh.computeSecret(otherpk.part.y.data);
      } else if (this._algo === "ecdsa") {
        if (CRYPTO_HAVE_ECDH) {
          return this._dh.computeSecret(otherpk.part.Q.data);
        } else {
          pub = new ECPublic(this._ecParams, otherpk.part.Q.data);
          return this._priv.deriveSharedSecret(pub);
        }
      } else if (this._algo === "curve25519") {
        pub = otherpk.part.A.data;
        while (pub[0] === 0 && pub.length > 32)
          pub = pub.slice(1);
        var priv = this._priv;
        assert3.strictEqual(pub.length, 32);
        assert3.strictEqual(priv.length, 32);
        var secret = nacl.box.before(new Uint8Array(pub), new Uint8Array(priv));
        return Buffer2.from(secret);
      }
      throw new Error("Invalid algorithm: " + this._algo);
    };
    DiffieHellman.prototype.generateKey = function() {
      var parts = [];
      var priv, pub;
      if (this._algo === "dsa") {
        this._dh.generateKeys();
        parts.push({ name: "p", data: this._p.data });
        parts.push({ name: "q", data: this._key.part.q.data });
        parts.push({ name: "g", data: this._g.data });
        parts.push({ name: "y", data: this._dh.getPublicKey() });
        parts.push({ name: "x", data: this._dh.getPrivateKey() });
        this._key = new PrivateKey({
          type: "dsa",
          parts
        });
        this._isPriv = true;
        return this._key;
      } else if (this._algo === "ecdsa") {
        if (CRYPTO_HAVE_ECDH) {
          this._dh.generateKeys();
          parts.push({
            name: "curve",
            data: Buffer2.from(this._curve)
          });
          parts.push({ name: "Q", data: this._dh.getPublicKey() });
          parts.push({ name: "d", data: this._dh.getPrivateKey() });
          this._key = new PrivateKey({
            type: "ecdsa",
            curve: this._curve,
            parts
          });
          this._isPriv = true;
          return this._key;
        } else {
          var n = this._ecParams.getN();
          var r = new jsbn(crypto.randomBytes(n.bitLength()));
          var n1 = n.subtract(jsbn.ONE);
          priv = r.mod(n1).add(jsbn.ONE);
          pub = this._ecParams.getG().multiply(priv);
          priv = Buffer2.from(priv.toByteArray());
          pub = Buffer2.from(this._ecParams.getCurve().encodePointHex(pub), "hex");
          this._priv = new ECPrivate(this._ecParams, priv);
          parts.push({
            name: "curve",
            data: Buffer2.from(this._curve)
          });
          parts.push({ name: "Q", data: pub });
          parts.push({ name: "d", data: priv });
          this._key = new PrivateKey({
            type: "ecdsa",
            curve: this._curve,
            parts
          });
          this._isPriv = true;
          return this._key;
        }
      } else if (this._algo === "curve25519") {
        var pair = nacl.box.keyPair();
        priv = Buffer2.from(pair.secretKey);
        pub = Buffer2.from(pair.publicKey);
        priv = Buffer2.concat([priv, pub]);
        assert3.strictEqual(priv.length, 64);
        assert3.strictEqual(pub.length, 32);
        parts.push({ name: "A", data: pub });
        parts.push({ name: "k", data: priv });
        this._key = new PrivateKey({
          type: "curve25519",
          parts
        });
        this._isPriv = true;
        return this._key;
      }
      throw new Error("Invalid algorithm: " + this._algo);
    };
    DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;
    function X9ECParameters(name) {
      var params = algs.curves[name];
      assert3.object(params);
      var p = new jsbn(params.p);
      var a = new jsbn(params.a);
      var b = new jsbn(params.b);
      var n = new jsbn(params.n);
      var h = jsbn.ONE;
      var curve = new ec.ECCurveFp(p, a, b);
      var G = curve.decodePointHex(params.G.toString("hex"));
      this.curve = curve;
      this.g = G;
      this.n = n;
      this.h = h;
    }
    X9ECParameters.prototype.getCurve = function() {
      return this.curve;
    };
    X9ECParameters.prototype.getG = function() {
      return this.g;
    };
    X9ECParameters.prototype.getN = function() {
      return this.n;
    };
    X9ECParameters.prototype.getH = function() {
      return this.h;
    };
    function ECPublic(params, buffer) {
      this._params = params;
      if (buffer[0] === 0)
        buffer = buffer.slice(1);
      this._pub = params.getCurve().decodePointHex(buffer.toString("hex"));
    }
    function ECPrivate(params, buffer) {
      this._params = params;
      this._priv = new jsbn(utils.mpNormalize(buffer));
    }
    ECPrivate.prototype.deriveSharedSecret = function(pubKey) {
      assert3.ok(pubKey instanceof ECPublic);
      var S = pubKey._pub.multiply(this._priv);
      return Buffer2.from(S.getX().toBigInteger().toByteArray());
    };
    function generateED25519() {
      var pair = nacl.sign.keyPair();
      var priv = Buffer2.from(pair.secretKey);
      var pub = Buffer2.from(pair.publicKey);
      assert3.strictEqual(priv.length, 64);
      assert3.strictEqual(pub.length, 32);
      var parts = [];
      parts.push({ name: "A", data: pub });
      parts.push({ name: "k", data: priv.slice(0, 32) });
      var key = new PrivateKey({
        type: "ed25519",
        parts
      });
      return key;
    }
    function generateECDSA(curve) {
      var parts = [];
      var key;
      if (CRYPTO_HAVE_ECDH) {
        var osCurve = {
          "nistp256": "prime256v1",
          "nistp384": "secp384r1",
          "nistp521": "secp521r1"
        }[curve];
        var dh = crypto.createECDH(osCurve);
        dh.generateKeys();
        parts.push({
          name: "curve",
          data: Buffer2.from(curve)
        });
        parts.push({ name: "Q", data: dh.getPublicKey() });
        parts.push({ name: "d", data: dh.getPrivateKey() });
        key = new PrivateKey({
          type: "ecdsa",
          curve,
          parts
        });
        return key;
      } else {
        var ecParams = new X9ECParameters(curve);
        var n = ecParams.getN();
        var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
        var c = new jsbn(crypto.randomBytes(cByteLen));
        var n1 = n.subtract(jsbn.ONE);
        var priv = c.mod(n1).add(jsbn.ONE);
        var pub = ecParams.getG().multiply(priv);
        priv = Buffer2.from(priv.toByteArray());
        pub = Buffer2.from(ecParams.getCurve().encodePointHex(pub), "hex");
        parts.push({ name: "curve", data: Buffer2.from(curve) });
        parts.push({ name: "Q", data: pub });
        parts.push({ name: "d", data: priv });
        key = new PrivateKey({
          type: "ecdsa",
          curve,
          parts
        });
        return key;
      }
    }
  }
});

// ../../node_modules/sshpk/lib/ed-compat.js
var require_ed_compat = __commonJS({
  "../../node_modules/sshpk/lib/ed-compat.js"(exports2, module2) {
    module2.exports = {
      Verifier,
      Signer
    };
    var nacl = require_nacl_fast();
    var stream = require("stream");
    var util2 = require("util");
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var Signature = require_signature();
    function Verifier(key, hashAlgo) {
      if (hashAlgo.toLowerCase() !== "sha512")
        throw new Error("ED25519 only supports the use of SHA-512 hashes");
      this.key = key;
      this.chunks = [];
      stream.Writable.call(this, {});
    }
    util2.inherits(Verifier, stream.Writable);
    Verifier.prototype._write = function(chunk, enc, cb) {
      this.chunks.push(chunk);
      cb();
    };
    Verifier.prototype.update = function(chunk) {
      if (typeof chunk === "string")
        chunk = Buffer2.from(chunk, "binary");
      this.chunks.push(chunk);
    };
    Verifier.prototype.verify = function(signature, fmt) {
      var sig;
      if (Signature.isSignature(signature, [2, 0])) {
        if (signature.type !== "ed25519")
          return false;
        sig = signature.toBuffer("raw");
      } else if (typeof signature === "string") {
        sig = Buffer2.from(signature, "base64");
      } else if (Signature.isSignature(signature, [1, 0])) {
        throw new Error("signature was created by too old a version of sshpk and cannot be verified");
      }
      assert3.buffer(sig);
      return nacl.sign.detached.verify(new Uint8Array(Buffer2.concat(this.chunks)), new Uint8Array(sig), new Uint8Array(this.key.part.A.data));
    };
    function Signer(key, hashAlgo) {
      if (hashAlgo.toLowerCase() !== "sha512")
        throw new Error("ED25519 only supports the use of SHA-512 hashes");
      this.key = key;
      this.chunks = [];
      stream.Writable.call(this, {});
    }
    util2.inherits(Signer, stream.Writable);
    Signer.prototype._write = function(chunk, enc, cb) {
      this.chunks.push(chunk);
      cb();
    };
    Signer.prototype.update = function(chunk) {
      if (typeof chunk === "string")
        chunk = Buffer2.from(chunk, "binary");
      this.chunks.push(chunk);
    };
    Signer.prototype.sign = function() {
      var sig = nacl.sign.detached(new Uint8Array(Buffer2.concat(this.chunks)), new Uint8Array(Buffer2.concat([
        this.key.part.k.data,
        this.key.part.A.data
      ])));
      var sigBuf = Buffer2.from(sig);
      var sigObj = Signature.parse(sigBuf, "ed25519", "raw");
      sigObj.hashAlgorithm = "sha512";
      return sigObj;
    };
  }
});

// ../../node_modules/sshpk/lib/formats/pkcs8.js
var require_pkcs8 = __commonJS({
  "../../node_modules/sshpk/lib/formats/pkcs8.js"(exports2, module2) {
    module2.exports = {
      read,
      readPkcs8,
      write,
      writePkcs8,
      pkcs8ToBuffer,
      readECDSACurve,
      writeECDSACurve
    };
    var assert3 = require_assert();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    function read(buf, options) {
      return pem.read(buf, options, "pkcs8");
    }
    function write(key, options) {
      return pem.write(key, options, "pkcs8");
    }
    function readMPInt(der, nm) {
      assert3.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
      return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    }
    function readPkcs8(alg, type, der) {
      if (der.peek() === asn1.Ber.Integer) {
        assert3.strictEqual(type, "private", "unexpected Integer at start of public key");
        der.readString(asn1.Ber.Integer, true);
      }
      der.readSequence();
      var next = der.offset + der.length;
      var oid = der.readOID();
      switch (oid) {
        case "1.2.840.113549.1.1.1":
          der._offset = next;
          if (type === "public")
            return readPkcs8RSAPublic(der);
          else
            return readPkcs8RSAPrivate(der);
        case "1.2.840.10040.4.1":
          if (type === "public")
            return readPkcs8DSAPublic(der);
          else
            return readPkcs8DSAPrivate(der);
        case "1.2.840.10045.2.1":
          if (type === "public")
            return readPkcs8ECDSAPublic(der);
          else
            return readPkcs8ECDSAPrivate(der);
        case "1.3.101.112":
          if (type === "public") {
            return readPkcs8EdDSAPublic(der);
          } else {
            return readPkcs8EdDSAPrivate(der);
          }
        case "1.3.101.110":
          if (type === "public") {
            return readPkcs8X25519Public(der);
          } else {
            return readPkcs8X25519Private(der);
          }
        default:
          throw new Error("Unknown key type OID " + oid);
      }
    }
    function readPkcs8RSAPublic(der) {
      der.readSequence(asn1.Ber.BitString);
      der.readByte();
      der.readSequence();
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "exponent");
      var key = {
        type: "rsa",
        source: der.originalInput,
        parts: [
          { name: "e", data: e },
          { name: "n", data: n }
        ]
      };
      return new Key(key);
    }
    function readPkcs8RSAPrivate(der) {
      der.readSequence(asn1.Ber.OctetString);
      der.readSequence();
      var ver = readMPInt(der, "version");
      assert3.equal(ver[0], 0, "unknown RSA private key version");
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "public exponent");
      var d = readMPInt(der, "private exponent");
      var p = readMPInt(der, "prime1");
      var q2 = readMPInt(der, "prime2");
      var dmodp = readMPInt(der, "exponent1");
      var dmodq = readMPInt(der, "exponent2");
      var iqmp = readMPInt(der, "iqmp");
      var key = {
        type: "rsa",
        parts: [
          { name: "n", data: n },
          { name: "e", data: e },
          { name: "d", data: d },
          { name: "iqmp", data: iqmp },
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "dmodp", data: dmodp },
          { name: "dmodq", data: dmodq }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs8DSAPublic(der) {
      der.readSequence();
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      der.readSequence(asn1.Ber.BitString);
      der.readByte();
      var y = readMPInt(der, "y");
      var key = {
        type: "dsa",
        parts: [
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g },
          { name: "y", data: y }
        ]
      };
      return new Key(key);
    }
    function readPkcs8DSAPrivate(der) {
      der.readSequence();
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      der.readSequence(asn1.Ber.OctetString);
      var x = readMPInt(der, "x");
      var y = utils.calculateDSAPublic(g, p, x);
      var key = {
        type: "dsa",
        parts: [
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g },
          { name: "y", data: y },
          { name: "x", data: x }
        ]
      };
      return new PrivateKey(key);
    }
    function readECDSACurve(der) {
      var curveName, curveNames;
      var j, c, cd;
      if (der.peek() === asn1.Ber.OID) {
        var oid = der.readOID();
        curveNames = Object.keys(algs.curves);
        for (j = 0; j < curveNames.length; ++j) {
          c = curveNames[j];
          cd = algs.curves[c];
          if (cd.pkcs8oid === oid) {
            curveName = c;
            break;
          }
        }
      } else {
        der.readSequence();
        var version = der.readString(asn1.Ber.Integer, true);
        assert3.strictEqual(version[0], 1, "ECDSA key not version 1");
        var curve = {};
        der.readSequence();
        var fieldTypeOid = der.readOID();
        assert3.strictEqual(fieldTypeOid, "1.2.840.10045.1.1", "ECDSA key is not from a prime-field");
        var p = curve.p = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
        curve.size = p.length * 8 - utils.countZeros(p);
        der.readSequence();
        curve.a = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
        curve.b = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
        if (der.peek() === asn1.Ber.BitString)
          curve.s = der.readString(asn1.Ber.BitString, true);
        curve.G = der.readString(asn1.Ber.OctetString, true);
        assert3.strictEqual(curve.G[0], 4, "uncompressed G is required");
        curve.n = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
        curve.h = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
        assert3.strictEqual(curve.h[0], 1, "a cofactor=1 curve is required");
        curveNames = Object.keys(algs.curves);
        var ks = Object.keys(curve);
        for (j = 0; j < curveNames.length; ++j) {
          c = curveNames[j];
          cd = algs.curves[c];
          var equal = true;
          for (var i = 0; i < ks.length; ++i) {
            var k = ks[i];
            if (cd[k] === void 0)
              continue;
            if (typeof cd[k] === "object" && cd[k].equals !== void 0) {
              if (!cd[k].equals(curve[k])) {
                equal = false;
                break;
              }
            } else if (Buffer2.isBuffer(cd[k])) {
              if (cd[k].toString("binary") !== curve[k].toString("binary")) {
                equal = false;
                break;
              }
            } else {
              if (cd[k] !== curve[k]) {
                equal = false;
                break;
              }
            }
          }
          if (equal) {
            curveName = c;
            break;
          }
        }
      }
      return curveName;
    }
    function readPkcs8ECDSAPrivate(der) {
      var curveName = readECDSACurve(der);
      assert3.string(curveName, "a known elliptic curve");
      der.readSequence(asn1.Ber.OctetString);
      der.readSequence();
      var version = readMPInt(der, "version");
      assert3.equal(version[0], 1, "unknown version of ECDSA key");
      var d = der.readString(asn1.Ber.OctetString, true);
      var Q;
      if (der.peek() == 160) {
        der.readSequence(160);
        der._offset += der.length;
      }
      if (der.peek() == 161) {
        der.readSequence(161);
        Q = der.readString(asn1.Ber.BitString, true);
        Q = utils.ecNormalize(Q);
      }
      if (Q === void 0) {
        var pub = utils.publicFromPrivateECDSA(curveName, d);
        Q = pub.part.Q.data;
      }
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curveName) },
          { name: "Q", data: Q },
          { name: "d", data: d }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs8ECDSAPublic(der) {
      var curveName = readECDSACurve(der);
      assert3.string(curveName, "a known elliptic curve");
      var Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curveName) },
          { name: "Q", data: Q }
        ]
      };
      return new Key(key);
    }
    function readPkcs8EdDSAPublic(der) {
      if (der.peek() === 0)
        der.readByte();
      var A = utils.readBitString(der);
      var key = {
        type: "ed25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) }
        ]
      };
      return new Key(key);
    }
    function readPkcs8X25519Public(der) {
      var A = utils.readBitString(der);
      var key = {
        type: "curve25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) }
        ]
      };
      return new Key(key);
    }
    function readPkcs8EdDSAPrivate(der) {
      if (der.peek() === 0)
        der.readByte();
      der.readSequence(asn1.Ber.OctetString);
      var k = der.readString(asn1.Ber.OctetString, true);
      k = utils.zeroPadToLength(k, 32);
      var A;
      if (der.peek() === asn1.Ber.BitString) {
        A = utils.readBitString(der);
        A = utils.zeroPadToLength(A, 32);
      } else {
        A = utils.calculateED25519Public(k);
      }
      var key = {
        type: "ed25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) },
          { name: "k", data: utils.zeroPadToLength(k, 32) }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs8X25519Private(der) {
      if (der.peek() === 0)
        der.readByte();
      der.readSequence(asn1.Ber.OctetString);
      var k = der.readString(asn1.Ber.OctetString, true);
      k = utils.zeroPadToLength(k, 32);
      var A = utils.calculateX25519Public(k);
      var key = {
        type: "curve25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) },
          { name: "k", data: utils.zeroPadToLength(k, 32) }
        ]
      };
      return new PrivateKey(key);
    }
    function pkcs8ToBuffer(key) {
      var der = new asn1.BerWriter();
      writePkcs8(der, key);
      return der.buffer;
    }
    function writePkcs8(der, key) {
      der.startSequence();
      if (PrivateKey.isPrivateKey(key)) {
        var sillyInt = Buffer2.from([0]);
        der.writeBuffer(sillyInt, asn1.Ber.Integer);
      }
      der.startSequence();
      switch (key.type) {
        case "rsa":
          der.writeOID("1.2.840.113549.1.1.1");
          if (PrivateKey.isPrivateKey(key))
            writePkcs8RSAPrivate(key, der);
          else
            writePkcs8RSAPublic(key, der);
          break;
        case "dsa":
          der.writeOID("1.2.840.10040.4.1");
          if (PrivateKey.isPrivateKey(key))
            writePkcs8DSAPrivate(key, der);
          else
            writePkcs8DSAPublic(key, der);
          break;
        case "ecdsa":
          der.writeOID("1.2.840.10045.2.1");
          if (PrivateKey.isPrivateKey(key))
            writePkcs8ECDSAPrivate(key, der);
          else
            writePkcs8ECDSAPublic(key, der);
          break;
        case "ed25519":
          der.writeOID("1.3.101.112");
          if (PrivateKey.isPrivateKey(key))
            throw new Error("Ed25519 private keys in pkcs8 format are not supported");
          writePkcs8EdDSAPublic(key, der);
          break;
        default:
          throw new Error("Unsupported key type: " + key.type);
      }
      der.endSequence();
    }
    function writePkcs8RSAPrivate(key, der) {
      der.writeNull();
      der.endSequence();
      der.startSequence(asn1.Ber.OctetString);
      der.startSequence();
      var version = Buffer2.from([0]);
      der.writeBuffer(version, asn1.Ber.Integer);
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      if (!key.part.dmodp || !key.part.dmodq)
        utils.addRSAMissing(key);
      der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
    }
    function writePkcs8RSAPublic(key, der) {
      der.writeNull();
      der.endSequence();
      der.startSequence(asn1.Ber.BitString);
      der.writeByte(0);
      der.startSequence();
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
    }
    function writePkcs8DSAPrivate(key, der) {
      der.startSequence();
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
      der.startSequence(asn1.Ber.OctetString);
      der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
      der.endSequence();
    }
    function writePkcs8DSAPublic(key, der) {
      der.startSequence();
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
      der.endSequence();
      der.endSequence();
      der.startSequence(asn1.Ber.BitString);
      der.writeByte(0);
      der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
      der.endSequence();
    }
    function writeECDSACurve(key, der) {
      var curve = algs.curves[key.curve];
      if (curve.pkcs8oid) {
        der.writeOID(curve.pkcs8oid);
      } else {
        der.startSequence();
        var version = Buffer2.from([1]);
        der.writeBuffer(version, asn1.Ber.Integer);
        der.startSequence();
        der.writeOID("1.2.840.10045.1.1");
        der.writeBuffer(curve.p, asn1.Ber.Integer);
        der.endSequence();
        der.startSequence();
        var a = curve.p;
        if (a[0] === 0)
          a = a.slice(1);
        der.writeBuffer(a, asn1.Ber.OctetString);
        der.writeBuffer(curve.b, asn1.Ber.OctetString);
        der.writeBuffer(curve.s, asn1.Ber.BitString);
        der.endSequence();
        der.writeBuffer(curve.G, asn1.Ber.OctetString);
        der.writeBuffer(curve.n, asn1.Ber.Integer);
        var h = curve.h;
        if (!h) {
          h = Buffer2.from([1]);
        }
        der.writeBuffer(h, asn1.Ber.Integer);
        der.endSequence();
      }
    }
    function writePkcs8ECDSAPublic(key, der) {
      writeECDSACurve(key, der);
      der.endSequence();
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
    }
    function writePkcs8ECDSAPrivate(key, der) {
      writeECDSACurve(key, der);
      der.endSequence();
      der.startSequence(asn1.Ber.OctetString);
      der.startSequence();
      var version = Buffer2.from([1]);
      der.writeBuffer(version, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
      der.startSequence(161);
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
      der.endSequence();
      der.endSequence();
      der.endSequence();
    }
    function writePkcs8EdDSAPublic(key, der) {
      der.endSequence();
      utils.writeBitString(der, key.part.A.data);
    }
  }
});

// ../../node_modules/sshpk/lib/formats/pkcs1.js
var require_pkcs1 = __commonJS({
  "../../node_modules/sshpk/lib/formats/pkcs1.js"(exports2, module2) {
    module2.exports = {
      read,
      readPkcs1,
      write,
      writePkcs1
    };
    var assert3 = require_assert();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var pkcs8 = require_pkcs8();
    var readECDSACurve = pkcs8.readECDSACurve;
    function read(buf, options) {
      return pem.read(buf, options, "pkcs1");
    }
    function write(key, options) {
      return pem.write(key, options, "pkcs1");
    }
    function readMPInt(der, nm) {
      assert3.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
      return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    }
    function readPkcs1(alg, type, der) {
      switch (alg) {
        case "RSA":
          if (type === "public")
            return readPkcs1RSAPublic(der);
          else if (type === "private")
            return readPkcs1RSAPrivate(der);
          throw new Error("Unknown key type: " + type);
        case "DSA":
          if (type === "public")
            return readPkcs1DSAPublic(der);
          else if (type === "private")
            return readPkcs1DSAPrivate(der);
          throw new Error("Unknown key type: " + type);
        case "EC":
        case "ECDSA":
          if (type === "private")
            return readPkcs1ECDSAPrivate(der);
          else if (type === "public")
            return readPkcs1ECDSAPublic(der);
          throw new Error("Unknown key type: " + type);
        case "EDDSA":
        case "EdDSA":
          if (type === "private")
            return readPkcs1EdDSAPrivate(der);
          throw new Error(type + " keys not supported with EdDSA");
        default:
          throw new Error("Unknown key algo: " + alg);
      }
    }
    function readPkcs1RSAPublic(der) {
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "exponent");
      var key = {
        type: "rsa",
        parts: [
          { name: "e", data: e },
          { name: "n", data: n }
        ]
      };
      return new Key(key);
    }
    function readPkcs1RSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert3.strictEqual(version[0], 0);
      var n = readMPInt(der, "modulus");
      var e = readMPInt(der, "public exponent");
      var d = readMPInt(der, "private exponent");
      var p = readMPInt(der, "prime1");
      var q2 = readMPInt(der, "prime2");
      var dmodp = readMPInt(der, "exponent1");
      var dmodq = readMPInt(der, "exponent2");
      var iqmp = readMPInt(der, "iqmp");
      var key = {
        type: "rsa",
        parts: [
          { name: "n", data: n },
          { name: "e", data: e },
          { name: "d", data: d },
          { name: "iqmp", data: iqmp },
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "dmodp", data: dmodp },
          { name: "dmodq", data: dmodq }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs1DSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert3.strictEqual(version.readUInt8(0), 0);
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      var y = readMPInt(der, "y");
      var x = readMPInt(der, "x");
      var key = {
        type: "dsa",
        parts: [
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g },
          { name: "y", data: y },
          { name: "x", data: x }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs1EdDSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert3.strictEqual(version.readUInt8(0), 1);
      var k = der.readString(asn1.Ber.OctetString, true);
      der.readSequence(160);
      var oid = der.readOID();
      assert3.strictEqual(oid, "1.3.101.112", "the ed25519 curve identifier");
      der.readSequence(161);
      var A = utils.readBitString(der);
      var key = {
        type: "ed25519",
        parts: [
          { name: "A", data: utils.zeroPadToLength(A, 32) },
          { name: "k", data: k }
        ]
      };
      return new PrivateKey(key);
    }
    function readPkcs1DSAPublic(der) {
      var y = readMPInt(der, "y");
      var p = readMPInt(der, "p");
      var q2 = readMPInt(der, "q");
      var g = readMPInt(der, "g");
      var key = {
        type: "dsa",
        parts: [
          { name: "y", data: y },
          { name: "p", data: p },
          { name: "q", data: q2 },
          { name: "g", data: g }
        ]
      };
      return new Key(key);
    }
    function readPkcs1ECDSAPublic(der) {
      der.readSequence();
      var oid = der.readOID();
      assert3.strictEqual(oid, "1.2.840.10045.2.1", "must be ecPublicKey");
      var curveOid = der.readOID();
      var curve;
      var curves = Object.keys(algs.curves);
      for (var j = 0; j < curves.length; ++j) {
        var c = curves[j];
        var cd = algs.curves[c];
        if (cd.pkcs8oid === curveOid) {
          curve = c;
          break;
        }
      }
      assert3.string(curve, "a known ECDSA named curve");
      var Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "Q", data: Q }
        ]
      };
      return new Key(key);
    }
    function readPkcs1ECDSAPrivate(der) {
      var version = readMPInt(der, "version");
      assert3.strictEqual(version.readUInt8(0), 1);
      var d = der.readString(asn1.Ber.OctetString, true);
      der.readSequence(160);
      var curve = readECDSACurve(der);
      assert3.string(curve, "a known elliptic curve");
      der.readSequence(161);
      var Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
      var key = {
        type: "ecdsa",
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "Q", data: Q },
          { name: "d", data: d }
        ]
      };
      return new PrivateKey(key);
    }
    function writePkcs1(der, key) {
      der.startSequence();
      switch (key.type) {
        case "rsa":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1RSAPrivate(der, key);
          else
            writePkcs1RSAPublic(der, key);
          break;
        case "dsa":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1DSAPrivate(der, key);
          else
            writePkcs1DSAPublic(der, key);
          break;
        case "ecdsa":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1ECDSAPrivate(der, key);
          else
            writePkcs1ECDSAPublic(der, key);
          break;
        case "ed25519":
          if (PrivateKey.isPrivateKey(key))
            writePkcs1EdDSAPrivate(der, key);
          else
            writePkcs1EdDSAPublic(der, key);
          break;
        default:
          throw new Error("Unknown key algo: " + key.type);
      }
      der.endSequence();
    }
    function writePkcs1RSAPublic(der, key) {
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    }
    function writePkcs1RSAPrivate(der, key) {
      var ver = Buffer2.from([0]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      if (!key.part.dmodp || !key.part.dmodq)
        utils.addRSAMissing(key);
      der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
    }
    function writePkcs1DSAPrivate(der, key) {
      var ver = Buffer2.from([0]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
    }
    function writePkcs1DSAPublic(der, key) {
      der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
      der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    }
    function writePkcs1ECDSAPublic(der, key) {
      der.startSequence();
      der.writeOID("1.2.840.10045.2.1");
      var curve = key.part.curve.data.toString();
      var curveOid = algs.curves[curve].pkcs8oid;
      assert3.string(curveOid, "a known ECDSA named curve");
      der.writeOID(curveOid);
      der.endSequence();
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
    }
    function writePkcs1ECDSAPrivate(der, key) {
      var ver = Buffer2.from([1]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
      der.startSequence(160);
      var curve = key.part.curve.data.toString();
      var curveOid = algs.curves[curve].pkcs8oid;
      assert3.string(curveOid, "a known ECDSA named curve");
      der.writeOID(curveOid);
      der.endSequence();
      der.startSequence(161);
      var Q = utils.ecNormalize(key.part.Q.data, true);
      der.writeBuffer(Q, asn1.Ber.BitString);
      der.endSequence();
    }
    function writePkcs1EdDSAPrivate(der, key) {
      var ver = Buffer2.from([1]);
      der.writeBuffer(ver, asn1.Ber.Integer);
      der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);
      der.startSequence(160);
      der.writeOID("1.3.101.112");
      der.endSequence();
      der.startSequence(161);
      utils.writeBitString(der, key.part.A.data);
      der.endSequence();
    }
    function writePkcs1EdDSAPublic(der, key) {
      throw new Error("Public keys are not supported for EdDSA PKCS#1");
    }
  }
});

// ../../node_modules/sshpk/lib/formats/rfc4253.js
var require_rfc4253 = __commonJS({
  "../../node_modules/sshpk/lib/formats/rfc4253.js"(exports2, module2) {
    module2.exports = {
      read: read.bind(void 0, false, void 0),
      readType: read.bind(void 0, false),
      write,
      readPartial: read.bind(void 0, true),
      readInternal: read,
      keyTypeToAlg,
      algToKeyType
    };
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var SSHBuffer = require_ssh_buffer();
    function algToKeyType(alg) {
      assert3.string(alg);
      if (alg === "ssh-dss")
        return "dsa";
      else if (alg === "ssh-rsa")
        return "rsa";
      else if (alg === "ssh-ed25519")
        return "ed25519";
      else if (alg === "ssh-curve25519")
        return "curve25519";
      else if (alg.match(/^ecdsa-sha2-/))
        return "ecdsa";
      else
        throw new Error("Unknown algorithm " + alg);
    }
    function keyTypeToAlg(key) {
      assert3.object(key);
      if (key.type === "dsa")
        return "ssh-dss";
      else if (key.type === "rsa")
        return "ssh-rsa";
      else if (key.type === "ed25519")
        return "ssh-ed25519";
      else if (key.type === "curve25519")
        return "ssh-curve25519";
      else if (key.type === "ecdsa")
        return "ecdsa-sha2-" + key.part.curve.data.toString();
      else
        throw new Error("Unknown key type " + key.type);
    }
    function read(partial, type, buf, options) {
      if (typeof buf === "string")
        buf = Buffer2.from(buf);
      assert3.buffer(buf, "buf");
      var key = {};
      var parts = key.parts = [];
      var sshbuf = new SSHBuffer({ buffer: buf });
      var alg = sshbuf.readString();
      assert3.ok(!sshbuf.atEnd(), "key must have at least one part");
      key.type = algToKeyType(alg);
      var partCount = algs.info[key.type].parts.length;
      if (type && type === "private")
        partCount = algs.privInfo[key.type].parts.length;
      while (!sshbuf.atEnd() && parts.length < partCount)
        parts.push(sshbuf.readPart());
      while (!partial && !sshbuf.atEnd())
        parts.push(sshbuf.readPart());
      assert3.ok(parts.length >= 1, "key must have at least one part");
      assert3.ok(partial || sshbuf.atEnd(), "leftover bytes at end of key");
      var Constructor = Key;
      var algInfo = algs.info[key.type];
      if (type === "private" || algInfo.parts.length !== parts.length) {
        algInfo = algs.privInfo[key.type];
        Constructor = PrivateKey;
      }
      assert3.strictEqual(algInfo.parts.length, parts.length);
      if (key.type === "ecdsa") {
        var res = /^ecdsa-sha2-(.+)$/.exec(alg);
        assert3.ok(res !== null);
        assert3.strictEqual(res[1], parts[0].data.toString());
      }
      var normalized = true;
      for (var i = 0; i < algInfo.parts.length; ++i) {
        var p = parts[i];
        p.name = algInfo.parts[i];
        if (key.type === "ed25519" && p.name === "k")
          p.data = p.data.slice(0, 32);
        if (p.name !== "curve" && algInfo.normalize !== false) {
          var nd;
          if (key.type === "ed25519") {
            nd = utils.zeroPadToLength(p.data, 32);
          } else {
            nd = utils.mpNormalize(p.data);
          }
          if (nd.toString("binary") !== p.data.toString("binary")) {
            p.data = nd;
            normalized = false;
          }
        }
      }
      if (normalized)
        key._rfc4253Cache = sshbuf.toBuffer();
      if (partial && typeof partial === "object") {
        partial.remainder = sshbuf.remainder();
        partial.consumed = sshbuf._offset;
      }
      return new Constructor(key);
    }
    function write(key, options) {
      assert3.object(key);
      var alg = keyTypeToAlg(key);
      var i;
      var algInfo = algs.info[key.type];
      if (PrivateKey.isPrivateKey(key))
        algInfo = algs.privInfo[key.type];
      var parts = algInfo.parts;
      var buf = new SSHBuffer({});
      buf.writeString(alg);
      for (i = 0; i < parts.length; ++i) {
        var data = key.part[parts[i]].data;
        if (algInfo.normalize !== false) {
          if (key.type === "ed25519")
            data = utils.zeroPadToLength(data, 32);
          else
            data = utils.mpNormalize(data);
        }
        if (key.type === "ed25519" && parts[i] === "k")
          data = Buffer2.concat([data, key.part.A.data]);
        buf.writeBuffer(data);
      }
      return buf.toBuffer();
    }
  }
});

// ../../node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS({
  "../../node_modules/bcrypt-pbkdf/index.js"(exports2, module2) {
    "use strict";
    var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
    var BLF_J = 0;
    var Blowfish = function() {
      this.S = [
        new Uint32Array([
          3509652390,
          2564797868,
          805139163,
          3491422135,
          3101798381,
          1780907670,
          3128725573,
          4046225305,
          614570311,
          3012652279,
          134345442,
          2240740374,
          1667834072,
          1901547113,
          2757295779,
          4103290238,
          227898511,
          1921955416,
          1904987480,
          2182433518,
          2069144605,
          3260701109,
          2620446009,
          720527379,
          3318853667,
          677414384,
          3393288472,
          3101374703,
          2390351024,
          1614419982,
          1822297739,
          2954791486,
          3608508353,
          3174124327,
          2024746970,
          1432378464,
          3864339955,
          2857741204,
          1464375394,
          1676153920,
          1439316330,
          715854006,
          3033291828,
          289532110,
          2706671279,
          2087905683,
          3018724369,
          1668267050,
          732546397,
          1947742710,
          3462151702,
          2609353502,
          2950085171,
          1814351708,
          2050118529,
          680887927,
          999245976,
          1800124847,
          3300911131,
          1713906067,
          1641548236,
          4213287313,
          1216130144,
          1575780402,
          4018429277,
          3917837745,
          3693486850,
          3949271944,
          596196993,
          3549867205,
          258830323,
          2213823033,
          772490370,
          2760122372,
          1774776394,
          2652871518,
          566650946,
          4142492826,
          1728879713,
          2882767088,
          1783734482,
          3629395816,
          2517608232,
          2874225571,
          1861159788,
          326777828,
          3124490320,
          2130389656,
          2716951837,
          967770486,
          1724537150,
          2185432712,
          2364442137,
          1164943284,
          2105845187,
          998989502,
          3765401048,
          2244026483,
          1075463327,
          1455516326,
          1322494562,
          910128902,
          469688178,
          1117454909,
          936433444,
          3490320968,
          3675253459,
          1240580251,
          122909385,
          2157517691,
          634681816,
          4142456567,
          3825094682,
          3061402683,
          2540495037,
          79693498,
          3249098678,
          1084186820,
          1583128258,
          426386531,
          1761308591,
          1047286709,
          322548459,
          995290223,
          1845252383,
          2603652396,
          3431023940,
          2942221577,
          3202600964,
          3727903485,
          1712269319,
          422464435,
          3234572375,
          1170764815,
          3523960633,
          3117677531,
          1434042557,
          442511882,
          3600875718,
          1076654713,
          1738483198,
          4213154764,
          2393238008,
          3677496056,
          1014306527,
          4251020053,
          793779912,
          2902807211,
          842905082,
          4246964064,
          1395751752,
          1040244610,
          2656851899,
          3396308128,
          445077038,
          3742853595,
          3577915638,
          679411651,
          2892444358,
          2354009459,
          1767581616,
          3150600392,
          3791627101,
          3102740896,
          284835224,
          4246832056,
          1258075500,
          768725851,
          2589189241,
          3069724005,
          3532540348,
          1274779536,
          3789419226,
          2764799539,
          1660621633,
          3471099624,
          4011903706,
          913787905,
          3497959166,
          737222580,
          2514213453,
          2928710040,
          3937242737,
          1804850592,
          3499020752,
          2949064160,
          2386320175,
          2390070455,
          2415321851,
          4061277028,
          2290661394,
          2416832540,
          1336762016,
          1754252060,
          3520065937,
          3014181293,
          791618072,
          3188594551,
          3933548030,
          2332172193,
          3852520463,
          3043980520,
          413987798,
          3465142937,
          3030929376,
          4245938359,
          2093235073,
          3534596313,
          375366246,
          2157278981,
          2479649556,
          555357303,
          3870105701,
          2008414854,
          3344188149,
          4221384143,
          3956125452,
          2067696032,
          3594591187,
          2921233993,
          2428461,
          544322398,
          577241275,
          1471733935,
          610547355,
          4027169054,
          1432588573,
          1507829418,
          2025931657,
          3646575487,
          545086370,
          48609733,
          2200306550,
          1653985193,
          298326376,
          1316178497,
          3007786442,
          2064951626,
          458293330,
          2589141269,
          3591329599,
          3164325604,
          727753846,
          2179363840,
          146436021,
          1461446943,
          4069977195,
          705550613,
          3059967265,
          3887724982,
          4281599278,
          3313849956,
          1404054877,
          2845806497,
          146425753,
          1854211946
        ]),
        new Uint32Array([
          1266315497,
          3048417604,
          3681880366,
          3289982499,
          290971e4,
          1235738493,
          2632868024,
          2414719590,
          3970600049,
          1771706367,
          1449415276,
          3266420449,
          422970021,
          1963543593,
          2690192192,
          3826793022,
          1062508698,
          1531092325,
          1804592342,
          2583117782,
          2714934279,
          4024971509,
          1294809318,
          4028980673,
          1289560198,
          2221992742,
          1669523910,
          35572830,
          157838143,
          1052438473,
          1016535060,
          1802137761,
          1753167236,
          1386275462,
          3080475397,
          2857371447,
          1040679964,
          2145300060,
          2390574316,
          1461121720,
          2956646967,
          4031777805,
          4028374788,
          33600511,
          2920084762,
          1018524850,
          629373528,
          3691585981,
          3515945977,
          2091462646,
          2486323059,
          586499841,
          988145025,
          935516892,
          3367335476,
          2599673255,
          2839830854,
          265290510,
          3972581182,
          2759138881,
          3795373465,
          1005194799,
          847297441,
          406762289,
          1314163512,
          1332590856,
          1866599683,
          4127851711,
          750260880,
          613907577,
          1450815602,
          3165620655,
          3734664991,
          3650291728,
          3012275730,
          3704569646,
          1427272223,
          778793252,
          1343938022,
          2676280711,
          2052605720,
          1946737175,
          3164576444,
          3914038668,
          3967478842,
          3682934266,
          1661551462,
          3294938066,
          4011595847,
          840292616,
          3712170807,
          616741398,
          312560963,
          711312465,
          1351876610,
          322626781,
          1910503582,
          271666773,
          2175563734,
          1594956187,
          70604529,
          3617834859,
          1007753275,
          1495573769,
          4069517037,
          2549218298,
          2663038764,
          504708206,
          2263041392,
          3941167025,
          2249088522,
          1514023603,
          1998579484,
          1312622330,
          694541497,
          2582060303,
          2151582166,
          1382467621,
          776784248,
          2618340202,
          3323268794,
          2497899128,
          2784771155,
          503983604,
          4076293799,
          907881277,
          423175695,
          432175456,
          1378068232,
          4145222326,
          3954048622,
          3938656102,
          3820766613,
          2793130115,
          2977904593,
          26017576,
          3274890735,
          3194772133,
          1700274565,
          1756076034,
          4006520079,
          3677328699,
          720338349,
          1533947780,
          354530856,
          688349552,
          3973924725,
          1637815568,
          332179504,
          3949051286,
          53804574,
          2852348879,
          3044236432,
          1282449977,
          3583942155,
          3416972820,
          4006381244,
          1617046695,
          2628476075,
          3002303598,
          1686838959,
          431878346,
          2686675385,
          1700445008,
          1080580658,
          1009431731,
          832498133,
          3223435511,
          2605976345,
          2271191193,
          2516031870,
          1648197032,
          4164389018,
          2548247927,
          300782431,
          375919233,
          238389289,
          3353747414,
          2531188641,
          2019080857,
          1475708069,
          455242339,
          2609103871,
          448939670,
          3451063019,
          1395535956,
          2413381860,
          1841049896,
          1491858159,
          885456874,
          4264095073,
          4001119347,
          1565136089,
          3898914787,
          1108368660,
          540939232,
          1173283510,
          2745871338,
          3681308437,
          4207628240,
          3343053890,
          4016749493,
          1699691293,
          1103962373,
          3625875870,
          2256883143,
          3830138730,
          1031889488,
          3479347698,
          1535977030,
          4236805024,
          3251091107,
          2132092099,
          1774941330,
          1199868427,
          1452454533,
          157007616,
          2904115357,
          342012276,
          595725824,
          1480756522,
          206960106,
          497939518,
          591360097,
          863170706,
          2375253569,
          3596610801,
          1814182875,
          2094937945,
          3421402208,
          1082520231,
          3463918190,
          2785509508,
          435703966,
          3908032597,
          1641649973,
          2842273706,
          3305899714,
          1510255612,
          2148256476,
          2655287854,
          3276092548,
          4258621189,
          236887753,
          3681803219,
          274041037,
          1734335097,
          3815195456,
          3317970021,
          1899903192,
          1026095262,
          4050517792,
          356393447,
          2410691914,
          3873677099,
          3682840055
        ]),
        new Uint32Array([
          3913112168,
          2491498743,
          4132185628,
          2489919796,
          1091903735,
          1979897079,
          3170134830,
          3567386728,
          3557303409,
          857797738,
          1136121015,
          1342202287,
          507115054,
          2535736646,
          337727348,
          3213592640,
          1301675037,
          2528481711,
          1895095763,
          1721773893,
          3216771564,
          62756741,
          2142006736,
          835421444,
          2531993523,
          1442658625,
          3659876326,
          2882144922,
          676362277,
          1392781812,
          170690266,
          3921047035,
          1759253602,
          3611846912,
          1745797284,
          664899054,
          1329594018,
          3901205900,
          3045908486,
          2062866102,
          2865634940,
          3543621612,
          3464012697,
          1080764994,
          553557557,
          3656615353,
          3996768171,
          991055499,
          499776247,
          1265440854,
          648242737,
          3940784050,
          980351604,
          3713745714,
          1749149687,
          3396870395,
          4211799374,
          3640570775,
          1161844396,
          3125318951,
          1431517754,
          545492359,
          4268468663,
          3499529547,
          1437099964,
          2702547544,
          3433638243,
          2581715763,
          2787789398,
          1060185593,
          1593081372,
          2418618748,
          4260947970,
          69676912,
          2159744348,
          86519011,
          2512459080,
          3838209314,
          1220612927,
          3339683548,
          133810670,
          1090789135,
          1078426020,
          1569222167,
          845107691,
          3583754449,
          4072456591,
          1091646820,
          628848692,
          1613405280,
          3757631651,
          526609435,
          236106946,
          48312990,
          2942717905,
          3402727701,
          1797494240,
          859738849,
          992217954,
          4005476642,
          2243076622,
          3870952857,
          3732016268,
          765654824,
          3490871365,
          2511836413,
          1685915746,
          3888969200,
          1414112111,
          2273134842,
          3281911079,
          4080962846,
          172450625,
          2569994100,
          980381355,
          4109958455,
          2819808352,
          2716589560,
          2568741196,
          3681446669,
          3329971472,
          1835478071,
          660984891,
          3704678404,
          4045999559,
          3422617507,
          3040415634,
          1762651403,
          1719377915,
          3470491036,
          2693910283,
          3642056355,
          3138596744,
          1364962596,
          2073328063,
          1983633131,
          926494387,
          3423689081,
          2150032023,
          4096667949,
          1749200295,
          3328846651,
          309677260,
          2016342300,
          1779581495,
          3079819751,
          111262694,
          1274766160,
          443224088,
          298511866,
          1025883608,
          3806446537,
          1145181785,
          168956806,
          3641502830,
          3584813610,
          1689216846,
          3666258015,
          3200248200,
          1692713982,
          2646376535,
          4042768518,
          1618508792,
          1610833997,
          3523052358,
          4130873264,
          2001055236,
          3610705100,
          2202168115,
          4028541809,
          2961195399,
          1006657119,
          2006996926,
          3186142756,
          1430667929,
          3210227297,
          1314452623,
          4074634658,
          4101304120,
          2273951170,
          1399257539,
          3367210612,
          3027628629,
          1190975929,
          2062231137,
          2333990788,
          2221543033,
          2438960610,
          1181637006,
          548689776,
          2362791313,
          3372408396,
          3104550113,
          3145860560,
          296247880,
          1970579870,
          3078560182,
          3769228297,
          1714227617,
          3291629107,
          3898220290,
          166772364,
          1251581989,
          493813264,
          448347421,
          195405023,
          2709975567,
          677966185,
          3703036547,
          1463355134,
          2715995803,
          1338867538,
          1343315457,
          2802222074,
          2684532164,
          233230375,
          2599980071,
          2000651841,
          3277868038,
          1638401717,
          4028070440,
          3237316320,
          6314154,
          819756386,
          300326615,
          590932579,
          1405279636,
          3267499572,
          3150704214,
          2428286686,
          3959192993,
          3461946742,
          1862657033,
          1266418056,
          963775037,
          2089974820,
          2263052895,
          1917689273,
          448879540,
          3550394620,
          3981727096,
          150775221,
          3627908307,
          1303187396,
          508620638,
          2975983352,
          2726630617,
          1817252668,
          1876281319,
          1457606340,
          908771278,
          3720792119,
          3617206836,
          2455994898,
          1729034894,
          1080033504
        ]),
        new Uint32Array([
          976866871,
          3556439503,
          2881648439,
          1522871579,
          1555064734,
          1336096578,
          3548522304,
          2579274686,
          3574697629,
          3205460757,
          3593280638,
          3338716283,
          3079412587,
          564236357,
          2993598910,
          1781952180,
          1464380207,
          3163844217,
          3332601554,
          1699332808,
          1393555694,
          1183702653,
          3581086237,
          1288719814,
          691649499,
          2847557200,
          2895455976,
          3193889540,
          2717570544,
          1781354906,
          1676643554,
          2592534050,
          3230253752,
          1126444790,
          2770207658,
          2633158820,
          2210423226,
          2615765581,
          2414155088,
          3127139286,
          673620729,
          2805611233,
          1269405062,
          4015350505,
          3341807571,
          4149409754,
          1057255273,
          2012875353,
          2162469141,
          2276492801,
          2601117357,
          993977747,
          3918593370,
          2654263191,
          753973209,
          36408145,
          2530585658,
          25011837,
          3520020182,
          2088578344,
          530523599,
          2918365339,
          1524020338,
          1518925132,
          3760827505,
          3759777254,
          1202760957,
          3985898139,
          3906192525,
          674977740,
          4174734889,
          2031300136,
          2019492241,
          3983892565,
          4153806404,
          3822280332,
          352677332,
          2297720250,
          60907813,
          90501309,
          3286998549,
          1016092578,
          2535922412,
          2839152426,
          457141659,
          509813237,
          4120667899,
          652014361,
          1966332200,
          2975202805,
          55981186,
          2327461051,
          676427537,
          3255491064,
          2882294119,
          3433927263,
          1307055953,
          942726286,
          933058658,
          2468411793,
          3933900994,
          4215176142,
          1361170020,
          2001714738,
          2830558078,
          3274259782,
          1222529897,
          1679025792,
          2729314320,
          3714953764,
          1770335741,
          151462246,
          3013232138,
          1682292957,
          1483529935,
          471910574,
          1539241949,
          458788160,
          3436315007,
          1807016891,
          3718408830,
          978976581,
          1043663428,
          3165965781,
          1927990952,
          4200891579,
          2372276910,
          3208408903,
          3533431907,
          1412390302,
          2931980059,
          4132332400,
          1947078029,
          3881505623,
          4168226417,
          2941484381,
          1077988104,
          1320477388,
          886195818,
          18198404,
          3786409e3,
          2509781533,
          112762804,
          3463356488,
          1866414978,
          891333506,
          18488651,
          661792760,
          1628790961,
          3885187036,
          3141171499,
          876946877,
          2693282273,
          1372485963,
          791857591,
          2686433993,
          3759982718,
          3167212022,
          3472953795,
          2716379847,
          445679433,
          3561995674,
          3504004811,
          3574258232,
          54117162,
          3331405415,
          2381918588,
          3769707343,
          4154350007,
          1140177722,
          4074052095,
          668550556,
          3214352940,
          367459370,
          261225585,
          2610173221,
          4209349473,
          3468074219,
          3265815641,
          314222801,
          3066103646,
          3808782860,
          282218597,
          3406013506,
          3773591054,
          379116347,
          1285071038,
          846784868,
          2669647154,
          3771962079,
          3550491691,
          2305946142,
          453669953,
          1268987020,
          3317592352,
          3279303384,
          3744833421,
          2610507566,
          3859509063,
          266596637,
          3847019092,
          517658769,
          3462560207,
          3443424879,
          370717030,
          4247526661,
          2224018117,
          4143653529,
          4112773975,
          2788324899,
          2477274417,
          1456262402,
          2901442914,
          1517677493,
          1846949527,
          2295493580,
          3734397586,
          2176403920,
          1280348187,
          1908823572,
          3871786941,
          846861322,
          1172426758,
          3287448474,
          3383383037,
          1655181056,
          3139813346,
          901632758,
          1897031941,
          2986607138,
          3066810236,
          3447102507,
          1393639104,
          373351379,
          950779232,
          625454576,
          3124240540,
          4148612726,
          2007998917,
          544563296,
          2244738638,
          2330496472,
          2058025392,
          1291430526,
          424198748,
          50039436,
          29584100,
          3605783033,
          2429876329,
          2791104160,
          1057563949,
          3255363231,
          3075367218,
          3463963227,
          1469046755,
          985887462
        ])
      ];
      this.P = new Uint32Array([
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ]);
    };
    function F(S, x8, i) {
      return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
    }
    Blowfish.prototype.encipher = function(x, x8) {
      if (x8 === void 0) {
        x8 = new Uint8Array(x.buffer);
        if (x.byteOffset !== 0)
          x8 = x8.subarray(x.byteOffset);
      }
      x[0] ^= this.P[0];
      for (var i = 1; i < 16; i += 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[17];
      x[1] = t;
    };
    Blowfish.prototype.decipher = function(x) {
      var x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0)
        x8 = x8.subarray(x.byteOffset);
      x[0] ^= this.P[17];
      for (var i = 16; i > 0; i -= 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[0];
      x[1] = t;
    };
    function stream2word(data, databytes) {
      var i, temp = 0;
      for (i = 0; i < 4; i++, BLF_J++) {
        if (BLF_J >= databytes)
          BLF_J = 0;
        temp = temp << 8 | data[BLF_J];
      }
      return temp;
    }
    Blowfish.prototype.expand0state = function(key, keybytes) {
      var d = new Uint32Array(2), i, k;
      var d8 = new Uint8Array(d.buffer);
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      BLF_J = 0;
      for (i = 0; i < 18; i += 2) {
        this.encipher(d, d8);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          this.encipher(d, d8);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
    };
    Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
      var d = new Uint32Array(2), i, k;
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      for (i = 0, BLF_J = 0; i < 18; i += 2) {
        d[0] ^= stream2word(data, databytes);
        d[1] ^= stream2word(data, databytes);
        this.encipher(d);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          d[0] ^= stream2word(data, databytes);
          d[1] ^= stream2word(data, databytes);
          this.encipher(d);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
      BLF_J = 0;
    };
    Blowfish.prototype.enc = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.encipher(data.subarray(i * 2));
      }
    };
    Blowfish.prototype.dec = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.decipher(data.subarray(i * 2));
      }
    };
    var BCRYPT_BLOCKS = 8;
    var BCRYPT_HASHSIZE = 32;
    function bcrypt_hash(sha2pass, sha2salt, out) {
      var state = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
        79,
        120,
        121,
        99,
        104,
        114,
        111,
        109,
        97,
        116,
        105,
        99,
        66,
        108,
        111,
        119,
        102,
        105,
        115,
        104,
        83,
        119,
        97,
        116,
        68,
        121,
        110,
        97,
        109,
        105,
        116,
        101
      ]);
      state.expandstate(sha2salt, 64, sha2pass, 64);
      for (i = 0; i < 64; i++) {
        state.expand0state(sha2salt, 64);
        state.expand0state(sha2pass, 64);
      }
      for (i = 0; i < BCRYPT_BLOCKS; i++)
        cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
      for (i = 0; i < 64; i++)
        state.enc(cdata, cdata.byteLength / 8);
      for (i = 0; i < BCRYPT_BLOCKS; i++) {
        out[4 * i + 3] = cdata[i] >>> 24;
        out[4 * i + 2] = cdata[i] >>> 16;
        out[4 * i + 1] = cdata[i] >>> 8;
        out[4 * i + 0] = cdata[i];
      }
    }
    function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
      var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
      if (rounds < 1)
        return -1;
      if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
        return -1;
      stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
      amt = Math.floor((keylen + stride - 1) / stride);
      for (i = 0; i < saltlen; i++)
        countsalt[i] = salt[i];
      crypto_hash_sha512(sha2pass, pass, passlen);
      for (count = 1; keylen > 0; count++) {
        countsalt[saltlen + 0] = count >>> 24;
        countsalt[saltlen + 1] = count >>> 16;
        countsalt[saltlen + 2] = count >>> 8;
        countsalt[saltlen + 3] = count;
        crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (i = out.byteLength; i--; )
          out[i] = tmpout[i];
        for (i = 1; i < rounds; i++) {
          crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
          bcrypt_hash(sha2pass, sha2salt, tmpout);
          for (j = 0; j < out.byteLength; j++)
            out[j] ^= tmpout[j];
        }
        amt = Math.min(amt, keylen);
        for (i = 0; i < amt; i++) {
          dest = i * stride + (count - 1);
          if (dest >= origkeylen)
            break;
          key[dest] = out[i];
        }
        keylen -= i;
      }
      return 0;
    }
    module2.exports = {
      BLOCKS: BCRYPT_BLOCKS,
      HASHSIZE: BCRYPT_HASHSIZE,
      hash: bcrypt_hash,
      pbkdf: bcrypt_pbkdf
    };
  }
});

// ../../node_modules/sshpk/lib/formats/ssh-private.js
var require_ssh_private = __commonJS({
  "../../node_modules/sshpk/lib/formats/ssh-private.js"(exports2, module2) {
    module2.exports = {
      read,
      readSSHPrivate,
      write
    };
    var assert3 = require_assert();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var crypto = require("crypto");
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var rfc4253 = require_rfc4253();
    var SSHBuffer = require_ssh_buffer();
    var errors = require_errors();
    var bcrypt;
    function read(buf, options) {
      return pem.read(buf, options);
    }
    var MAGIC = "openssh-key-v1";
    function readSSHPrivate(type, buf, options) {
      buf = new SSHBuffer({ buffer: buf });
      var magic = buf.readCString();
      assert3.strictEqual(magic, MAGIC, "bad magic string");
      var cipher = buf.readString();
      var kdf = buf.readString();
      var kdfOpts = buf.readBuffer();
      var nkeys = buf.readInt();
      if (nkeys !== 1) {
        throw new Error("OpenSSH-format key file contains multiple keys: this is unsupported.");
      }
      var pubKey = buf.readBuffer();
      if (type === "public") {
        assert3.ok(buf.atEnd(), "excess bytes left after key");
        return rfc4253.read(pubKey);
      }
      var privKeyBlob = buf.readBuffer();
      assert3.ok(buf.atEnd(), "excess bytes left after key");
      var kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });
      switch (kdf) {
        case "none":
          if (cipher !== "none") {
            throw new Error('OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"');
          }
          break;
        case "bcrypt":
          var salt = kdfOptsBuf.readBuffer();
          var rounds = kdfOptsBuf.readInt();
          var cinf = utils.opensshCipherInfo(cipher);
          if (bcrypt === void 0) {
            bcrypt = require_bcrypt_pbkdf();
          }
          if (typeof options.passphrase === "string") {
            options.passphrase = Buffer2.from(options.passphrase, "utf-8");
          }
          if (!Buffer2.isBuffer(options.passphrase)) {
            throw new errors.KeyEncryptedError(options.filename, "OpenSSH");
          }
          var pass = new Uint8Array(options.passphrase);
          var salti = new Uint8Array(salt);
          var out = new Uint8Array(cinf.keySize + cinf.blockSize);
          var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds);
          if (res !== 0) {
            throw new Error("bcrypt_pbkdf function returned failure, parameters invalid");
          }
          out = Buffer2.from(out);
          var ckey = out.slice(0, cinf.keySize);
          var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
          var cipherStream = crypto.createDecipheriv(cinf.opensslName, ckey, iv);
          cipherStream.setAutoPadding(false);
          var chunk, chunks = [];
          cipherStream.once("error", function(e) {
            if (e.toString().indexOf("bad decrypt") !== -1) {
              throw new Error("Incorrect passphrase supplied, could not decrypt key");
            }
            throw e;
          });
          cipherStream.write(privKeyBlob);
          cipherStream.end();
          while ((chunk = cipherStream.read()) !== null)
            chunks.push(chunk);
          privKeyBlob = Buffer2.concat(chunks);
          break;
        default:
          throw new Error('OpenSSH-format key uses unknown KDF "' + kdf + '"');
      }
      buf = new SSHBuffer({ buffer: privKeyBlob });
      var checkInt1 = buf.readInt();
      var checkInt2 = buf.readInt();
      if (checkInt1 !== checkInt2) {
        throw new Error("Incorrect passphrase supplied, could not decrypt key");
      }
      var ret = {};
      var key = rfc4253.readInternal(ret, "private", buf.remainder());
      buf.skip(ret.consumed);
      var comment = buf.readString();
      key.comment = comment;
      return key;
    }
    function write(key, options) {
      var pubKey;
      if (PrivateKey.isPrivateKey(key))
        pubKey = key.toPublic();
      else
        pubKey = key;
      var cipher = "none";
      var kdf = "none";
      var kdfopts = Buffer2.alloc(0);
      var cinf = { blockSize: 8 };
      var passphrase;
      if (options !== void 0) {
        passphrase = options.passphrase;
        if (typeof passphrase === "string")
          passphrase = Buffer2.from(passphrase, "utf-8");
        if (passphrase !== void 0) {
          assert3.buffer(passphrase, "options.passphrase");
          assert3.optionalString(options.cipher, "options.cipher");
          cipher = options.cipher;
          if (cipher === void 0)
            cipher = "aes128-ctr";
          cinf = utils.opensshCipherInfo(cipher);
          kdf = "bcrypt";
        }
      }
      var privBuf;
      if (PrivateKey.isPrivateKey(key)) {
        privBuf = new SSHBuffer({});
        var checkInt = crypto.randomBytes(4).readUInt32BE(0);
        privBuf.writeInt(checkInt);
        privBuf.writeInt(checkInt);
        privBuf.write(key.toBuffer("rfc4253"));
        privBuf.writeString(key.comment || "");
        var n = 1;
        while (privBuf._offset % cinf.blockSize !== 0)
          privBuf.writeChar(n++);
        privBuf = privBuf.toBuffer();
      }
      switch (kdf) {
        case "none":
          break;
        case "bcrypt":
          var salt = crypto.randomBytes(16);
          var rounds = 16;
          var kdfssh = new SSHBuffer({});
          kdfssh.writeBuffer(salt);
          kdfssh.writeInt(rounds);
          kdfopts = kdfssh.toBuffer();
          if (bcrypt === void 0) {
            bcrypt = require_bcrypt_pbkdf();
          }
          var pass = new Uint8Array(passphrase);
          var salti = new Uint8Array(salt);
          var out = new Uint8Array(cinf.keySize + cinf.blockSize);
          var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds);
          if (res !== 0) {
            throw new Error("bcrypt_pbkdf function returned failure, parameters invalid");
          }
          out = Buffer2.from(out);
          var ckey = out.slice(0, cinf.keySize);
          var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
          var cipherStream = crypto.createCipheriv(cinf.opensslName, ckey, iv);
          cipherStream.setAutoPadding(false);
          var chunk, chunks = [];
          cipherStream.once("error", function(e) {
            throw e;
          });
          cipherStream.write(privBuf);
          cipherStream.end();
          while ((chunk = cipherStream.read()) !== null)
            chunks.push(chunk);
          privBuf = Buffer2.concat(chunks);
          break;
        default:
          throw new Error("Unsupported kdf " + kdf);
      }
      var buf = new SSHBuffer({});
      buf.writeCString(MAGIC);
      buf.writeString(cipher);
      buf.writeString(kdf);
      buf.writeBuffer(kdfopts);
      buf.writeInt(1);
      buf.writeBuffer(pubKey.toBuffer("rfc4253"));
      if (privBuf)
        buf.writeBuffer(privBuf);
      buf = buf.toBuffer();
      var header;
      if (PrivateKey.isPrivateKey(key))
        header = "OPENSSH PRIVATE KEY";
      else
        header = "OPENSSH PUBLIC KEY";
      var tmp = buf.toString("base64");
      var len = tmp.length + tmp.length / 70 + 18 + 16 + header.length * 2 + 10;
      buf = Buffer2.alloc(len);
      var o = 0;
      o += buf.write("-----BEGIN " + header + "-----\n", o);
      for (var i = 0; i < tmp.length; ) {
        var limit = i + 70;
        if (limit > tmp.length)
          limit = tmp.length;
        o += buf.write(tmp.slice(i, limit), o);
        buf[o++] = 10;
        i = limit;
      }
      o += buf.write("-----END " + header + "-----\n", o);
      return buf.slice(0, o);
    }
  }
});

// ../../node_modules/sshpk/lib/formats/pem.js
var require_pem = __commonJS({
  "../../node_modules/sshpk/lib/formats/pem.js"(exports2, module2) {
    module2.exports = {
      read,
      write
    };
    var assert3 = require_assert();
    var asn1 = require_lib2();
    var crypto = require("crypto");
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pkcs1 = require_pkcs1();
    var pkcs8 = require_pkcs8();
    var sshpriv = require_ssh_private();
    var rfc4253 = require_rfc4253();
    var errors = require_errors();
    var OID_PBES2 = "1.2.840.113549.1.5.13";
    var OID_PBKDF2 = "1.2.840.113549.1.5.12";
    var OID_TO_CIPHER = {
      "1.2.840.113549.3.7": "3des-cbc",
      "2.16.840.1.101.3.4.1.2": "aes128-cbc",
      "2.16.840.1.101.3.4.1.42": "aes256-cbc"
    };
    var CIPHER_TO_OID = {};
    Object.keys(OID_TO_CIPHER).forEach(function(k) {
      CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;
    });
    var OID_TO_HASH = {
      "1.2.840.113549.2.7": "sha1",
      "1.2.840.113549.2.9": "sha256",
      "1.2.840.113549.2.11": "sha512"
    };
    var HASH_TO_OID = {};
    Object.keys(OID_TO_HASH).forEach(function(k) {
      HASH_TO_OID[OID_TO_HASH[k]] = k;
    });
    function read(buf, options, forceType) {
      var input = buf;
      if (typeof buf !== "string") {
        assert3.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var lines = buf.trim().split(/[\r\n]+/g);
      var m;
      var si = -1;
      while (!m && si < lines.length) {
        m = lines[++si].match(/[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
      }
      assert3.ok(m, "invalid PEM header");
      var m2;
      var ei = lines.length;
      while (!m2 && ei > 0) {
        m2 = lines[--ei].match(/[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
      }
      assert3.ok(m2, "invalid PEM footer");
      assert3.equal(m[2], m2[2]);
      var type = m[2].toLowerCase();
      var alg;
      if (m[1]) {
        assert3.equal(m[1], m2[1], "PEM header and footer mismatch");
        alg = m[1].trim();
      }
      lines = lines.slice(si, ei + 1);
      var headers = {};
      while (true) {
        lines = lines.slice(1);
        m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
        if (!m)
          break;
        headers[m[1].toLowerCase()] = m[2];
      }
      lines = lines.slice(0, -1).join("");
      buf = Buffer2.from(lines, "base64");
      var cipher, key, iv;
      if (headers["proc-type"]) {
        var parts = headers["proc-type"].split(",");
        if (parts[0] === "4" && parts[1] === "ENCRYPTED") {
          if (typeof options.passphrase === "string") {
            options.passphrase = Buffer2.from(options.passphrase, "utf-8");
          }
          if (!Buffer2.isBuffer(options.passphrase)) {
            throw new errors.KeyEncryptedError(options.filename, "PEM");
          } else {
            parts = headers["dek-info"].split(",");
            assert3.ok(parts.length === 2);
            cipher = parts[0].toLowerCase();
            iv = Buffer2.from(parts[1], "hex");
            key = utils.opensslKeyDeriv(cipher, iv, options.passphrase, 1).key;
          }
        }
      }
      if (alg && alg.toLowerCase() === "encrypted") {
        var eder = new asn1.BerReader(buf);
        var pbesEnd;
        eder.readSequence();
        eder.readSequence();
        pbesEnd = eder.offset + eder.length;
        var method = eder.readOID();
        if (method !== OID_PBES2) {
          throw new Error("Unsupported PEM/PKCS8 encryption scheme: " + method);
        }
        eder.readSequence();
        eder.readSequence();
        var kdfEnd = eder.offset + eder.length;
        var kdfOid = eder.readOID();
        if (kdfOid !== OID_PBKDF2)
          throw new Error("Unsupported PBES2 KDF: " + kdfOid);
        eder.readSequence();
        var salt = eder.readString(asn1.Ber.OctetString, true);
        var iterations = eder.readInt();
        var hashAlg = "sha1";
        if (eder.offset < kdfEnd) {
          eder.readSequence();
          var hashAlgOid = eder.readOID();
          hashAlg = OID_TO_HASH[hashAlgOid];
          if (hashAlg === void 0) {
            throw new Error("Unsupported PBKDF2 hash: " + hashAlgOid);
          }
        }
        eder._offset = kdfEnd;
        eder.readSequence();
        var cipherOid = eder.readOID();
        cipher = OID_TO_CIPHER[cipherOid];
        if (cipher === void 0) {
          throw new Error("Unsupported PBES2 cipher: " + cipherOid);
        }
        iv = eder.readString(asn1.Ber.OctetString, true);
        eder._offset = pbesEnd;
        buf = eder.readString(asn1.Ber.OctetString, true);
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(options.passphrase, "utf-8");
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(options.filename, "PEM");
        }
        var cinfo = utils.opensshCipherInfo(cipher);
        cipher = cinfo.opensslName;
        key = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize, options.passphrase);
        alg = void 0;
      }
      if (cipher && key && iv) {
        var cipherStream = crypto.createDecipheriv(cipher, key, iv);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          if (e.toString().indexOf("bad decrypt") !== -1) {
            throw new Error("Incorrect passphrase supplied, could not decrypt key");
          }
          throw e;
        });
        cipherStream.write(buf);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        buf = Buffer2.concat(chunks);
      }
      if (alg && alg.toLowerCase() === "openssh")
        return sshpriv.readSSHPrivate(type, buf, options);
      if (alg && alg.toLowerCase() === "ssh2")
        return rfc4253.readType(type, buf, options);
      var der = new asn1.BerReader(buf);
      der.originalInput = input;
      der.readSequence();
      if (alg) {
        if (forceType)
          assert3.strictEqual(forceType, "pkcs1");
        return pkcs1.readPkcs1(alg, type, der);
      } else {
        if (forceType)
          assert3.strictEqual(forceType, "pkcs8");
        return pkcs8.readPkcs8(alg, type, der);
      }
    }
    function write(key, options, type) {
      assert3.object(key);
      var alg = {
        "ecdsa": "EC",
        "rsa": "RSA",
        "dsa": "DSA",
        "ed25519": "EdDSA"
      }[key.type];
      var header;
      var der = new asn1.BerWriter();
      if (PrivateKey.isPrivateKey(key)) {
        if (type && type === "pkcs8") {
          header = "PRIVATE KEY";
          pkcs8.writePkcs8(der, key);
        } else {
          if (type)
            assert3.strictEqual(type, "pkcs1");
          header = alg + " PRIVATE KEY";
          pkcs1.writePkcs1(der, key);
        }
      } else if (Key.isKey(key)) {
        if (type && type === "pkcs1") {
          header = alg + " PUBLIC KEY";
          pkcs1.writePkcs1(der, key);
        } else {
          if (type)
            assert3.strictEqual(type, "pkcs8");
          header = "PUBLIC KEY";
          pkcs8.writePkcs8(der, key);
        }
      } else {
        throw new Error("key is not a Key or PrivateKey");
      }
      var tmp = der.buffer.toString("base64");
      var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
      var buf = Buffer2.alloc(len);
      var o = 0;
      o += buf.write("-----BEGIN " + header + "-----\n", o);
      for (var i = 0; i < tmp.length; ) {
        var limit = i + 64;
        if (limit > tmp.length)
          limit = tmp.length;
        o += buf.write(tmp.slice(i, limit), o);
        buf[o++] = 10;
        i = limit;
      }
      o += buf.write("-----END " + header + "-----\n", o);
      return buf.slice(0, o);
    }
  }
});

// ../../node_modules/sshpk/lib/formats/ssh.js
var require_ssh = __commonJS({
  "../../node_modules/sshpk/lib/formats/ssh.js"(exports2, module2) {
    module2.exports = {
      read,
      write
    };
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var rfc4253 = require_rfc4253();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var sshpriv = require_ssh_private();
    var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
    var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;
    function read(buf, options) {
      if (typeof buf !== "string") {
        assert3.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var trimmed = buf.trim().replace(/[\\\r]/g, "");
      var m = trimmed.match(SSHKEY_RE);
      if (!m)
        m = trimmed.match(SSHKEY_RE2);
      assert3.ok(m, "key must match regex");
      var type = rfc4253.algToKeyType(m[1]);
      var kbuf = Buffer2.from(m[2], "base64");
      var key;
      var ret = {};
      if (m[4]) {
        try {
          key = rfc4253.read(kbuf);
        } catch (e) {
          m = trimmed.match(SSHKEY_RE2);
          assert3.ok(m, "key must match regex");
          kbuf = Buffer2.from(m[2], "base64");
          key = rfc4253.readInternal(ret, "public", kbuf);
        }
      } else {
        key = rfc4253.readInternal(ret, "public", kbuf);
      }
      assert3.strictEqual(type, key.type);
      if (m[4] && m[4].length > 0) {
        key.comment = m[4];
      } else if (ret.consumed) {
        var data = m[2] + (m[3] ? m[3] : "");
        var realOffset = Math.ceil(ret.consumed / 3) * 4;
        data = data.slice(0, realOffset - 2).replace(/[^a-zA-Z0-9+\/=]/g, "") + data.slice(realOffset - 2);
        var padding = ret.consumed % 3;
        if (padding > 0 && data.slice(realOffset - 1, realOffset) !== "=")
          realOffset--;
        while (data.slice(realOffset, realOffset + 1) === "=")
          realOffset++;
        var trailer = data.slice(realOffset);
        trailer = trailer.replace(/[\r\n]/g, " ").replace(/^\s+/, "");
        if (trailer.match(/^[a-zA-Z0-9]/))
          key.comment = trailer;
      }
      return key;
    }
    function write(key, options) {
      assert3.object(key);
      if (!Key.isKey(key))
        throw new Error("Must be a public key");
      var parts = [];
      var alg = rfc4253.keyTypeToAlg(key);
      parts.push(alg);
      var buf = rfc4253.write(key);
      parts.push(buf.toString("base64"));
      if (key.comment)
        parts.push(key.comment);
      return Buffer2.from(parts.join(" "));
    }
  }
});

// ../../node_modules/sshpk/lib/formats/dnssec.js
var require_dnssec = __commonJS({
  "../../node_modules/sshpk/lib/formats/dnssec.js"(exports2, module2) {
    module2.exports = {
      read,
      write
    };
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var Key = require_key();
    var PrivateKey = require_private_key();
    var utils = require_utils();
    var SSHBuffer = require_ssh_buffer();
    var Dhe = require_dhe();
    var supportedAlgos = {
      "rsa-sha1": 5,
      "rsa-sha256": 8,
      "rsa-sha512": 10,
      "ecdsa-p256-sha256": 13,
      "ecdsa-p384-sha384": 14
    };
    var supportedAlgosById = {};
    Object.keys(supportedAlgos).forEach(function(k) {
      supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
    });
    function read(buf, options) {
      if (typeof buf !== "string") {
        assert3.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var lines = buf.split("\n");
      if (lines[0].match(/^Private-key-format\: v1/)) {
        var algElems = lines[1].split(" ");
        var algoNum = parseInt(algElems[1], 10);
        var algoName = algElems[2];
        if (!supportedAlgosById[algoNum])
          throw new Error("Unsupported algorithm: " + algoName);
        return readDNSSECPrivateKey(algoNum, lines.slice(2));
      }
      var line = 0;
      while (lines[line].match(/^\;/))
        line++;
      if ((lines[line].match(/\. IN KEY /) || lines[line].match(/\. IN DNSKEY /)) && lines[line + 1].length === 0) {
        return readRFC3110(lines[line]);
      }
      throw new Error("Cannot parse dnssec key");
    }
    function readRFC3110(keyString) {
      var elems = keyString.split(" ");
      var algorithm = parseInt(elems[5], 10);
      if (!supportedAlgosById[algorithm])
        throw new Error("Unsupported algorithm: " + algorithm);
      var base64key = elems.slice(6, elems.length).join();
      var keyBuffer = Buffer2.from(base64key, "base64");
      if (supportedAlgosById[algorithm].match(/^RSA-/)) {
        var publicExponentLen = keyBuffer.readUInt8(0);
        if (publicExponentLen != 3 && publicExponentLen != 1)
          throw new Error("Cannot parse dnssec key: unsupported exponent length");
        var publicExponent = keyBuffer.slice(1, publicExponentLen + 1);
        publicExponent = utils.mpNormalize(publicExponent);
        var modulus = keyBuffer.slice(1 + publicExponentLen);
        modulus = utils.mpNormalize(modulus);
        var rsaKey = {
          type: "rsa",
          parts: []
        };
        rsaKey.parts.push({ name: "e", data: publicExponent });
        rsaKey.parts.push({ name: "n", data: modulus });
        return new Key(rsaKey);
      }
      if (supportedAlgosById[algorithm] === "ECDSA-P384-SHA384" || supportedAlgosById[algorithm] === "ECDSA-P256-SHA256") {
        var curve = "nistp384";
        var size = 384;
        if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
          curve = "nistp256";
          size = 256;
        }
        var ecdsaKey = {
          type: "ecdsa",
          curve,
          size,
          parts: [
            { name: "curve", data: Buffer2.from(curve) },
            { name: "Q", data: utils.ecNormalize(keyBuffer) }
          ]
        };
        return new Key(ecdsaKey);
      }
      throw new Error("Unsupported algorithm: " + supportedAlgosById[algorithm]);
    }
    function elementToBuf(e) {
      return Buffer2.from(e.split(" ")[1], "base64");
    }
    function readDNSSECRSAPrivateKey(elements) {
      var rsaParams = {};
      elements.forEach(function(element) {
        if (element.split(" ")[0] === "Modulus:")
          rsaParams["n"] = elementToBuf(element);
        else if (element.split(" ")[0] === "PublicExponent:")
          rsaParams["e"] = elementToBuf(element);
        else if (element.split(" ")[0] === "PrivateExponent:")
          rsaParams["d"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Prime1:")
          rsaParams["p"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Prime2:")
          rsaParams["q"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Exponent1:")
          rsaParams["dmodp"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Exponent2:")
          rsaParams["dmodq"] = elementToBuf(element);
        else if (element.split(" ")[0] === "Coefficient:")
          rsaParams["iqmp"] = elementToBuf(element);
      });
      var key = {
        type: "rsa",
        parts: [
          { name: "e", data: utils.mpNormalize(rsaParams["e"]) },
          { name: "n", data: utils.mpNormalize(rsaParams["n"]) },
          { name: "d", data: utils.mpNormalize(rsaParams["d"]) },
          { name: "p", data: utils.mpNormalize(rsaParams["p"]) },
          { name: "q", data: utils.mpNormalize(rsaParams["q"]) },
          {
            name: "dmodp",
            data: utils.mpNormalize(rsaParams["dmodp"])
          },
          {
            name: "dmodq",
            data: utils.mpNormalize(rsaParams["dmodq"])
          },
          {
            name: "iqmp",
            data: utils.mpNormalize(rsaParams["iqmp"])
          }
        ]
      };
      return new PrivateKey(key);
    }
    function readDNSSECPrivateKey(alg, elements) {
      if (supportedAlgosById[alg].match(/^RSA-/)) {
        return readDNSSECRSAPrivateKey(elements);
      }
      if (supportedAlgosById[alg] === "ECDSA-P384-SHA384" || supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
        var d = Buffer2.from(elements[0].split(" ")[1], "base64");
        var curve = "nistp384";
        var size = 384;
        if (supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
          curve = "nistp256";
          size = 256;
        }
        var publicKey = utils.publicFromPrivateECDSA(curve, d);
        var Q = publicKey.part["Q"].data;
        var ecdsaKey = {
          type: "ecdsa",
          curve,
          size,
          parts: [
            { name: "curve", data: Buffer2.from(curve) },
            { name: "d", data: d },
            { name: "Q", data: Q }
          ]
        };
        return new PrivateKey(ecdsaKey);
      }
      throw new Error("Unsupported algorithm: " + supportedAlgosById[alg]);
    }
    function dnssecTimestamp(date) {
      var year = date.getFullYear() + "";
      var month = date.getMonth() + 1;
      var timestampStr = year + month + date.getUTCDate();
      timestampStr += "" + date.getUTCHours() + date.getUTCMinutes();
      timestampStr += date.getUTCSeconds();
      return timestampStr;
    }
    function rsaAlgFromOptions(opts) {
      if (!opts || !opts.hashAlgo || opts.hashAlgo === "sha1")
        return "5 (RSASHA1)";
      else if (opts.hashAlgo === "sha256")
        return "8 (RSASHA256)";
      else if (opts.hashAlgo === "sha512")
        return "10 (RSASHA512)";
      else
        throw new Error("Unknown or unsupported hash: " + opts.hashAlgo);
    }
    function writeRSA(key, options) {
      if (!key.part.dmodp || !key.part.dmodq) {
        utils.addRSAMissing(key);
      }
      var out = "";
      out += "Private-key-format: v1.3\n";
      out += "Algorithm: " + rsaAlgFromOptions(options) + "\n";
      var n = utils.mpDenormalize(key.part["n"].data);
      out += "Modulus: " + n.toString("base64") + "\n";
      var e = utils.mpDenormalize(key.part["e"].data);
      out += "PublicExponent: " + e.toString("base64") + "\n";
      var d = utils.mpDenormalize(key.part["d"].data);
      out += "PrivateExponent: " + d.toString("base64") + "\n";
      var p = utils.mpDenormalize(key.part["p"].data);
      out += "Prime1: " + p.toString("base64") + "\n";
      var q2 = utils.mpDenormalize(key.part["q"].data);
      out += "Prime2: " + q2.toString("base64") + "\n";
      var dmodp = utils.mpDenormalize(key.part["dmodp"].data);
      out += "Exponent1: " + dmodp.toString("base64") + "\n";
      var dmodq = utils.mpDenormalize(key.part["dmodq"].data);
      out += "Exponent2: " + dmodq.toString("base64") + "\n";
      var iqmp = utils.mpDenormalize(key.part["iqmp"].data);
      out += "Coefficient: " + iqmp.toString("base64") + "\n";
      var timestamp = new Date();
      out += "Created: " + dnssecTimestamp(timestamp) + "\n";
      out += "Publish: " + dnssecTimestamp(timestamp) + "\n";
      out += "Activate: " + dnssecTimestamp(timestamp) + "\n";
      return Buffer2.from(out, "ascii");
    }
    function writeECDSA(key, options) {
      var out = "";
      out += "Private-key-format: v1.3\n";
      if (key.curve === "nistp256") {
        out += "Algorithm: 13 (ECDSAP256SHA256)\n";
      } else if (key.curve === "nistp384") {
        out += "Algorithm: 14 (ECDSAP384SHA384)\n";
      } else {
        throw new Error("Unsupported curve");
      }
      var base64Key = key.part["d"].data.toString("base64");
      out += "PrivateKey: " + base64Key + "\n";
      var timestamp = new Date();
      out += "Created: " + dnssecTimestamp(timestamp) + "\n";
      out += "Publish: " + dnssecTimestamp(timestamp) + "\n";
      out += "Activate: " + dnssecTimestamp(timestamp) + "\n";
      return Buffer2.from(out, "ascii");
    }
    function write(key, options) {
      if (PrivateKey.isPrivateKey(key)) {
        if (key.type === "rsa") {
          return writeRSA(key, options);
        } else if (key.type === "ecdsa") {
          return writeECDSA(key, options);
        } else {
          throw new Error("Unsupported algorithm: " + key.type);
        }
      } else if (Key.isKey(key)) {
        throw new Error('Format "dnssec" only supports writing private keys');
      } else {
        throw new Error("key is not a Key or PrivateKey");
      }
    }
  }
});

// ../../node_modules/sshpk/lib/formats/putty.js
var require_putty = __commonJS({
  "../../node_modules/sshpk/lib/formats/putty.js"(exports2, module2) {
    module2.exports = {
      read,
      write
    };
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var rfc4253 = require_rfc4253();
    var Key = require_key();
    var errors = require_errors();
    function read(buf, options) {
      var lines = buf.toString("ascii").split(/[\r\n]+/);
      var found = false;
      var parts;
      var si = 0;
      while (si < lines.length) {
        parts = splitHeader(lines[si++]);
        if (parts && parts[0].toLowerCase() === "putty-user-key-file-2") {
          found = true;
          break;
        }
      }
      if (!found) {
        throw new Error("No PuTTY format first line found");
      }
      var alg = parts[1];
      parts = splitHeader(lines[si++]);
      assert3.equal(parts[0].toLowerCase(), "encryption");
      parts = splitHeader(lines[si++]);
      assert3.equal(parts[0].toLowerCase(), "comment");
      var comment = parts[1];
      parts = splitHeader(lines[si++]);
      assert3.equal(parts[0].toLowerCase(), "public-lines");
      var publicLines = parseInt(parts[1], 10);
      if (!isFinite(publicLines) || publicLines < 0 || publicLines > lines.length) {
        throw new Error("Invalid public-lines count");
      }
      var publicBuf = Buffer2.from(lines.slice(si, si + publicLines).join(""), "base64");
      var keyType = rfc4253.algToKeyType(alg);
      var key = rfc4253.read(publicBuf);
      if (key.type !== keyType) {
        throw new Error("Outer key algorithm mismatch");
      }
      key.comment = comment;
      return key;
    }
    function splitHeader(line) {
      var idx = line.indexOf(":");
      if (idx === -1)
        return null;
      var header = line.slice(0, idx);
      ++idx;
      while (line[idx] === " ")
        ++idx;
      var rest = line.slice(idx);
      return [header, rest];
    }
    function write(key, options) {
      assert3.object(key);
      if (!Key.isKey(key))
        throw new Error("Must be a public key");
      var alg = rfc4253.keyTypeToAlg(key);
      var buf = rfc4253.write(key);
      var comment = key.comment || "";
      var b64 = buf.toString("base64");
      var lines = wrap(b64, 64);
      lines.unshift("Public-Lines: " + lines.length);
      lines.unshift("Comment: " + comment);
      lines.unshift("Encryption: none");
      lines.unshift("PuTTY-User-Key-File-2: " + alg);
      return Buffer2.from(lines.join("\n") + "\n");
    }
    function wrap(txt, len) {
      var lines = [];
      var pos = 0;
      while (pos < txt.length) {
        lines.push(txt.slice(pos, pos + 64));
        pos += 64;
      }
      return lines;
    }
  }
});

// ../../node_modules/sshpk/lib/formats/auto.js
var require_auto = __commonJS({
  "../../node_modules/sshpk/lib/formats/auto.js"(exports2, module2) {
    module2.exports = {
      read,
      write
    };
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var ssh = require_ssh();
    var rfc4253 = require_rfc4253();
    var dnssec = require_dnssec();
    var putty = require_putty();
    var DNSSEC_PRIVKEY_HEADER_PREFIX = "Private-key-format: v1";
    function read(buf, options) {
      if (typeof buf === "string") {
        if (buf.trim().match(/^[-]+[ ]*BEGIN/))
          return pem.read(buf, options);
        if (buf.match(/^\s*ssh-[a-z]/))
          return ssh.read(buf, options);
        if (buf.match(/^\s*ecdsa-/))
          return ssh.read(buf, options);
        if (buf.match(/^putty-user-key-file-2:/i))
          return putty.read(buf, options);
        if (findDNSSECHeader(buf))
          return dnssec.read(buf, options);
        buf = Buffer2.from(buf, "binary");
      } else {
        assert3.buffer(buf);
        if (findPEMHeader(buf))
          return pem.read(buf, options);
        if (findSSHHeader(buf))
          return ssh.read(buf, options);
        if (findPuTTYHeader(buf))
          return putty.read(buf, options);
        if (findDNSSECHeader(buf))
          return dnssec.read(buf, options);
      }
      if (buf.readUInt32BE(0) < buf.length)
        return rfc4253.read(buf, options);
      throw new Error("Failed to auto-detect format of key");
    }
    function findPuTTYHeader(buf) {
      var offset = 0;
      while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
        ++offset;
      if (offset + 22 <= buf.length && buf.slice(offset, offset + 22).toString("ascii").toLowerCase() === "putty-user-key-file-2:")
        return true;
      return false;
    }
    function findSSHHeader(buf) {
      var offset = 0;
      while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
        ++offset;
      if (offset + 4 <= buf.length && buf.slice(offset, offset + 4).toString("ascii") === "ssh-")
        return true;
      if (offset + 6 <= buf.length && buf.slice(offset, offset + 6).toString("ascii") === "ecdsa-")
        return true;
      return false;
    }
    function findPEMHeader(buf) {
      var offset = 0;
      while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10))
        ++offset;
      if (buf[offset] !== 45)
        return false;
      while (offset < buf.length && buf[offset] === 45)
        ++offset;
      while (offset < buf.length && buf[offset] === 32)
        ++offset;
      if (offset + 5 > buf.length || buf.slice(offset, offset + 5).toString("ascii") !== "BEGIN")
        return false;
      return true;
    }
    function findDNSSECHeader(buf) {
      if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
        return false;
      var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
      if (headerCheck.toString("ascii") === DNSSEC_PRIVKEY_HEADER_PREFIX)
        return true;
      if (typeof buf !== "string") {
        buf = buf.toString("ascii");
      }
      var lines = buf.split("\n");
      var line = 0;
      while (lines[line].match(/^\;/))
        line++;
      if (lines[line].toString("ascii").match(/\. IN KEY /))
        return true;
      if (lines[line].toString("ascii").match(/\. IN DNSKEY /))
        return true;
      return false;
    }
    function write(key, options) {
      throw new Error('"auto" format cannot be used for writing');
    }
  }
});

// ../../node_modules/sshpk/lib/private-key.js
var require_private_key = __commonJS({
  "../../node_modules/sshpk/lib/private-key.js"(exports2, module2) {
    module2.exports = PrivateKey;
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = require("crypto");
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var errs = require_errors();
    var util2 = require("util");
    var utils = require_utils();
    var dhe = require_dhe();
    var generateECDSA = dhe.generateECDSA;
    var generateED25519 = dhe.generateED25519;
    var edCompat = require_ed_compat();
    var nacl = require_nacl_fast();
    var Key = require_key();
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    var KeyParseError = errs.KeyParseError;
    var KeyEncryptedError = errs.KeyEncryptedError;
    var formats = {};
    formats["auto"] = require_auto();
    formats["pem"] = require_pem();
    formats["pkcs1"] = require_pkcs1();
    formats["pkcs8"] = require_pkcs8();
    formats["rfc4253"] = require_rfc4253();
    formats["ssh-private"] = require_ssh_private();
    formats["openssh"] = formats["ssh-private"];
    formats["ssh"] = formats["ssh-private"];
    formats["dnssec"] = require_dnssec();
    function PrivateKey(opts) {
      assert3.object(opts, "options");
      Key.call(this, opts);
      this._pubCache = void 0;
    }
    util2.inherits(PrivateKey, Key);
    PrivateKey.formats = formats;
    PrivateKey.prototype.toBuffer = function(format, options) {
      if (format === void 0)
        format = "pkcs1";
      assert3.string(format, "format");
      assert3.object(formats[format], "formats[format]");
      assert3.optionalObject(options, "options");
      return formats[format].write(this, options);
    };
    PrivateKey.prototype.hash = function(algo, type) {
      return this.toPublic().hash(algo, type);
    };
    PrivateKey.prototype.fingerprint = function(algo, type) {
      return this.toPublic().fingerprint(algo, type);
    };
    PrivateKey.prototype.toPublic = function() {
      if (this._pubCache)
        return this._pubCache;
      var algInfo = algs.info[this.type];
      var pubParts = [];
      for (var i = 0; i < algInfo.parts.length; ++i) {
        var p = algInfo.parts[i];
        pubParts.push(this.part[p]);
      }
      this._pubCache = new Key({
        type: this.type,
        source: this,
        parts: pubParts
      });
      if (this.comment)
        this._pubCache.comment = this.comment;
      return this._pubCache;
    };
    PrivateKey.prototype.derive = function(newType) {
      assert3.string(newType, "type");
      var priv, pub, pair;
      if (this.type === "ed25519" && newType === "curve25519") {
        priv = this.part.k.data;
        if (priv[0] === 0)
          priv = priv.slice(1);
        pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
        pub = Buffer2.from(pair.publicKey);
        return new PrivateKey({
          type: "curve25519",
          parts: [
            { name: "A", data: utils.mpNormalize(pub) },
            { name: "k", data: utils.mpNormalize(priv) }
          ]
        });
      } else if (this.type === "curve25519" && newType === "ed25519") {
        priv = this.part.k.data;
        if (priv[0] === 0)
          priv = priv.slice(1);
        pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
        pub = Buffer2.from(pair.publicKey);
        return new PrivateKey({
          type: "ed25519",
          parts: [
            { name: "A", data: utils.mpNormalize(pub) },
            { name: "k", data: utils.mpNormalize(priv) }
          ]
        });
      }
      throw new Error("Key derivation not supported from " + this.type + " to " + newType);
    };
    PrivateKey.prototype.createVerify = function(hashAlgo) {
      return this.toPublic().createVerify(hashAlgo);
    };
    PrivateKey.prototype.createSign = function(hashAlgo) {
      if (hashAlgo === void 0)
        hashAlgo = this.defaultHashAlgorithm();
      assert3.string(hashAlgo, "hash algorithm");
      if (this.type === "ed25519" && edCompat !== void 0)
        return new edCompat.Signer(this, hashAlgo);
      if (this.type === "curve25519")
        throw new Error("Curve25519 keys are not suitable for signing or verification");
      var v, nm, err;
      try {
        nm = hashAlgo.toUpperCase();
        v = crypto.createSign(nm);
      } catch (e) {
        err = e;
      }
      if (v === void 0 || err instanceof Error && err.message.match(/Unknown message digest/)) {
        nm = "RSA-";
        nm += hashAlgo.toUpperCase();
        v = crypto.createSign(nm);
      }
      assert3.ok(v, "failed to create verifier");
      var oldSign = v.sign.bind(v);
      var key = this.toBuffer("pkcs1");
      var type = this.type;
      var curve = this.curve;
      v.sign = function() {
        var sig = oldSign(key);
        if (typeof sig === "string")
          sig = Buffer2.from(sig, "binary");
        sig = Signature.parse(sig, type, "asn1");
        sig.hashAlgorithm = hashAlgo;
        sig.curve = curve;
        return sig;
      };
      return v;
    };
    PrivateKey.parse = function(data, format, options) {
      if (typeof data !== "string")
        assert3.buffer(data, "data");
      if (format === void 0)
        format = "auto";
      assert3.string(format, "format");
      if (typeof options === "string")
        options = { filename: options };
      assert3.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert3.optionalString(options.filename, "options.filename");
      if (options.filename === void 0)
        options.filename = "(unnamed)";
      assert3.object(formats[format], "formats[format]");
      try {
        var k = formats[format].read(data, options);
        assert3.ok(k instanceof PrivateKey, "key is not a private key");
        if (!k.comment)
          k.comment = options.filename;
        return k;
      } catch (e) {
        if (e.name === "KeyEncryptedError")
          throw e;
        throw new KeyParseError(options.filename, format, e);
      }
    };
    PrivateKey.isPrivateKey = function(obj, ver) {
      return utils.isCompatible(obj, PrivateKey, ver);
    };
    PrivateKey.generate = function(type, options) {
      if (options === void 0)
        options = {};
      assert3.object(options, "options");
      switch (type) {
        case "ecdsa":
          if (options.curve === void 0)
            options.curve = "nistp256";
          assert3.string(options.curve, "options.curve");
          return generateECDSA(options.curve);
        case "ed25519":
          return generateED25519();
        default:
          throw new Error('Key generation not supported with key type "' + type + '"');
      }
    };
    PrivateKey.prototype._sshpkApiVersion = [1, 6];
    PrivateKey._oldVersionDetect = function(obj) {
      assert3.func(obj.toPublic);
      assert3.func(obj.createSign);
      if (obj.derive)
        return [1, 3];
      if (obj.defaultHashAlgorithm)
        return [1, 2];
      if (obj.formats["auto"])
        return [1, 1];
      return [1, 0];
    };
  }
});

// ../../node_modules/sshpk/lib/identity.js
var require_identity = __commonJS({
  "../../node_modules/sshpk/lib/identity.js"(exports2, module2) {
    module2.exports = Identity;
    var assert3 = require_assert();
    var algs = require_algs();
    var crypto = require("crypto");
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var errs = require_errors();
    var util2 = require("util");
    var utils = require_utils();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;
    var oids = {};
    oids.cn = "2.5.4.3";
    oids.o = "2.5.4.10";
    oids.ou = "2.5.4.11";
    oids.l = "2.5.4.7";
    oids.s = "2.5.4.8";
    oids.c = "2.5.4.6";
    oids.sn = "2.5.4.4";
    oids.postalCode = "2.5.4.17";
    oids.serialNumber = "2.5.4.5";
    oids.street = "2.5.4.9";
    oids.x500UniqueIdentifier = "2.5.4.45";
    oids.role = "2.5.4.72";
    oids.telephoneNumber = "2.5.4.20";
    oids.description = "2.5.4.13";
    oids.dc = "0.9.2342.19200300.100.1.25";
    oids.uid = "0.9.2342.19200300.100.1.1";
    oids.mail = "0.9.2342.19200300.100.1.3";
    oids.title = "2.5.4.12";
    oids.gn = "2.5.4.42";
    oids.initials = "2.5.4.43";
    oids.pseudonym = "2.5.4.65";
    oids.emailAddress = "1.2.840.113549.1.9.1";
    var unoids = {};
    Object.keys(oids).forEach(function(k) {
      unoids[oids[k]] = k;
    });
    function Identity(opts) {
      var self2 = this;
      assert3.object(opts, "options");
      assert3.arrayOfObject(opts.components, "options.components");
      this.components = opts.components;
      this.componentLookup = {};
      this.components.forEach(function(c) {
        if (c.name && !c.oid)
          c.oid = oids[c.name];
        if (c.oid && !c.name)
          c.name = unoids[c.oid];
        if (self2.componentLookup[c.name] === void 0)
          self2.componentLookup[c.name] = [];
        self2.componentLookup[c.name].push(c);
      });
      if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
        this.cn = this.componentLookup.cn[0].value;
      }
      assert3.optionalString(opts.type, "options.type");
      if (opts.type === void 0) {
        if (this.components.length === 1 && this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
          this.type = "host";
          this.hostname = this.componentLookup.cn[0].value;
        } else if (this.componentLookup.dc && this.components.length === this.componentLookup.dc.length) {
          this.type = "host";
          this.hostname = this.componentLookup.dc.map(function(c) {
            return c.value;
          }).join(".");
        } else if (this.componentLookup.uid && this.components.length === this.componentLookup.uid.length) {
          this.type = "user";
          this.uid = this.componentLookup.uid[0].value;
        } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
          this.type = "host";
          this.hostname = this.componentLookup.cn[0].value;
        } else if (this.componentLookup.uid && this.componentLookup.uid.length === 1) {
          this.type = "user";
          this.uid = this.componentLookup.uid[0].value;
        } else if (this.componentLookup.mail && this.componentLookup.mail.length === 1) {
          this.type = "email";
          this.email = this.componentLookup.mail[0].value;
        } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1) {
          this.type = "user";
          this.uid = this.componentLookup.cn[0].value;
        } else {
          this.type = "unknown";
        }
      } else {
        this.type = opts.type;
        if (this.type === "host")
          this.hostname = opts.hostname;
        else if (this.type === "user")
          this.uid = opts.uid;
        else if (this.type === "email")
          this.email = opts.email;
        else
          throw new Error("Unknown type " + this.type);
      }
    }
    Identity.prototype.toString = function() {
      return this.components.map(function(c) {
        var n = c.name.toUpperCase();
        n = n.replace(/=/g, "\\=");
        var v = c.value;
        v = v.replace(/,/g, "\\,");
        return n + "=" + v;
      }).join(", ");
    };
    Identity.prototype.get = function(name, asArray) {
      assert3.string(name, "name");
      var arr = this.componentLookup[name];
      if (arr === void 0 || arr.length === 0)
        return void 0;
      if (!asArray && arr.length > 1)
        throw new Error("Multiple values for attribute " + name);
      if (!asArray)
        return arr[0].value;
      return arr.map(function(c) {
        return c.value;
      });
    };
    Identity.prototype.toArray = function(idx) {
      return this.components.map(function(c) {
        return {
          name: c.name,
          value: c.value
        };
      });
    };
    var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
    var NOT_IA5 = /[^\x00-\x7f]/;
    Identity.prototype.toAsn1 = function(der, tag) {
      der.startSequence(tag);
      this.components.forEach(function(c) {
        der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
        der.startSequence();
        der.writeOID(c.oid);
        if (c.asn1type === asn1.Ber.Utf8String || c.value.match(NOT_IA5)) {
          var v = Buffer2.from(c.value, "utf8");
          der.writeBuffer(v, asn1.Ber.Utf8String);
        } else if (c.asn1type === asn1.Ber.IA5String || c.value.match(NOT_PRINTABLE)) {
          der.writeString(c.value, asn1.Ber.IA5String);
        } else {
          var type = asn1.Ber.PrintableString;
          if (c.asn1type !== void 0)
            type = c.asn1type;
          der.writeString(c.value, type);
        }
        der.endSequence();
        der.endSequence();
      });
      der.endSequence();
    };
    function globMatch(a, b) {
      if (a === "**" || b === "**")
        return true;
      var aParts = a.split(".");
      var bParts = b.split(".");
      if (aParts.length !== bParts.length)
        return false;
      for (var i = 0; i < aParts.length; ++i) {
        if (aParts[i] === "*" || bParts[i] === "*")
          continue;
        if (aParts[i] !== bParts[i])
          return false;
      }
      return true;
    }
    Identity.prototype.equals = function(other) {
      if (!Identity.isIdentity(other, [1, 0]))
        return false;
      if (other.components.length !== this.components.length)
        return false;
      for (var i = 0; i < this.components.length; ++i) {
        if (this.components[i].oid !== other.components[i].oid)
          return false;
        if (!globMatch(this.components[i].value, other.components[i].value)) {
          return false;
        }
      }
      return true;
    };
    Identity.forHost = function(hostname) {
      assert3.string(hostname, "hostname");
      return new Identity({
        type: "host",
        hostname,
        components: [{ name: "cn", value: hostname }]
      });
    };
    Identity.forUser = function(uid) {
      assert3.string(uid, "uid");
      return new Identity({
        type: "user",
        uid,
        components: [{ name: "uid", value: uid }]
      });
    };
    Identity.forEmail = function(email) {
      assert3.string(email, "email");
      return new Identity({
        type: "email",
        email,
        components: [{ name: "mail", value: email }]
      });
    };
    Identity.parseDN = function(dn) {
      assert3.string(dn, "dn");
      var parts = [""];
      var idx = 0;
      var rem = dn;
      while (rem.length > 0) {
        var m;
        if ((m = /^,/.exec(rem)) !== null) {
          parts[++idx] = "";
          rem = rem.slice(m[0].length);
        } else if ((m = /^\\,/.exec(rem)) !== null) {
          parts[idx] += ",";
          rem = rem.slice(m[0].length);
        } else if ((m = /^\\./.exec(rem)) !== null) {
          parts[idx] += m[0];
          rem = rem.slice(m[0].length);
        } else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
          parts[idx] += m[0];
          rem = rem.slice(m[0].length);
        } else {
          throw new Error("Failed to parse DN");
        }
      }
      var cmps = parts.map(function(c) {
        c = c.trim();
        var eqPos = c.indexOf("=");
        while (eqPos > 0 && c.charAt(eqPos - 1) === "\\")
          eqPos = c.indexOf("=", eqPos + 1);
        if (eqPos === -1) {
          throw new Error("Failed to parse DN");
        }
        var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, "=");
        var value = c.slice(eqPos + 1);
        return { name, value };
      });
      return new Identity({ components: cmps });
    };
    Identity.fromArray = function(components) {
      assert3.arrayOfObject(components, "components");
      components.forEach(function(cmp) {
        assert3.object(cmp, "component");
        assert3.string(cmp.name, "component.name");
        if (!Buffer2.isBuffer(cmp.value) && !(typeof cmp.value === "string")) {
          throw new Error("Invalid component value");
        }
      });
      return new Identity({ components });
    };
    Identity.parseAsn1 = function(der, top) {
      var components = [];
      der.readSequence(top);
      var end = der.offset + der.length;
      while (der.offset < end) {
        der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
        var after = der.offset + der.length;
        der.readSequence();
        var oid = der.readOID();
        var type = der.peek();
        var value;
        switch (type) {
          case asn1.Ber.PrintableString:
          case asn1.Ber.IA5String:
          case asn1.Ber.OctetString:
          case asn1.Ber.T61String:
            value = der.readString(type);
            break;
          case asn1.Ber.Utf8String:
            value = der.readString(type, true);
            value = value.toString("utf8");
            break;
          case asn1.Ber.CharacterString:
          case asn1.Ber.BMPString:
            value = der.readString(type, true);
            value = value.toString("utf16le");
            break;
          default:
            throw new Error("Unknown asn1 type " + type);
        }
        components.push({ oid, asn1type: type, value });
        der._offset = after;
      }
      der._offset = end;
      return new Identity({
        components
      });
    };
    Identity.isIdentity = function(obj, ver) {
      return utils.isCompatible(obj, Identity, ver);
    };
    Identity.prototype._sshpkApiVersion = [1, 0];
    Identity._oldVersionDetect = function(obj) {
      return [1, 0];
    };
  }
});

// ../../node_modules/sshpk/lib/formats/openssh-cert.js
var require_openssh_cert = __commonJS({
  "../../node_modules/sshpk/lib/formats/openssh-cert.js"(exports2, module2) {
    module2.exports = {
      read,
      verify,
      sign,
      signAsync,
      write,
      fromBuffer,
      toBuffer
    };
    var assert3 = require_assert();
    var SSHBuffer = require_ssh_buffer();
    var crypto = require("crypto");
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var Identity = require_identity();
    var rfc4253 = require_rfc4253();
    var Signature = require_signature();
    var utils = require_utils();
    var Certificate = require_certificate();
    function verify(cert, key) {
      return false;
    }
    var TYPES = {
      "user": 1,
      "host": 2
    };
    Object.keys(TYPES).forEach(function(k) {
      TYPES[TYPES[k]] = k;
    });
    var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
    function read(buf, options) {
      if (Buffer2.isBuffer(buf))
        buf = buf.toString("ascii");
      var parts = buf.trim().split(/[ \t\n]+/g);
      if (parts.length < 2 || parts.length > 3)
        throw new Error("Not a valid SSH certificate line");
      var algo = parts[0];
      var data = parts[1];
      data = Buffer2.from(data, "base64");
      return fromBuffer(data, algo);
    }
    function fromBuffer(data, algo, partial) {
      var sshbuf = new SSHBuffer({ buffer: data });
      var innerAlgo = sshbuf.readString();
      if (algo !== void 0 && innerAlgo !== algo)
        throw new Error("SSH certificate algorithm mismatch");
      if (algo === void 0)
        algo = innerAlgo;
      var cert = {};
      cert.signatures = {};
      cert.signatures.openssh = {};
      cert.signatures.openssh.nonce = sshbuf.readBuffer();
      var key = {};
      var parts = key.parts = [];
      key.type = getAlg(algo);
      var partCount = algs.info[key.type].parts.length;
      while (parts.length < partCount)
        parts.push(sshbuf.readPart());
      assert3.ok(parts.length >= 1, "key must have at least one part");
      var algInfo = algs.info[key.type];
      if (key.type === "ecdsa") {
        var res = ECDSA_ALGO.exec(algo);
        assert3.ok(res !== null);
        assert3.strictEqual(res[1], parts[0].data.toString());
      }
      for (var i = 0; i < algInfo.parts.length; ++i) {
        parts[i].name = algInfo.parts[i];
        if (parts[i].name !== "curve" && algInfo.normalize !== false) {
          var p = parts[i];
          p.data = utils.mpNormalize(p.data);
        }
      }
      cert.subjectKey = new Key(key);
      cert.serial = sshbuf.readInt64();
      var type = TYPES[sshbuf.readInt()];
      assert3.string(type, "valid cert type");
      cert.signatures.openssh.keyId = sshbuf.readString();
      var principals = [];
      var pbuf = sshbuf.readBuffer();
      var psshbuf = new SSHBuffer({ buffer: pbuf });
      while (!psshbuf.atEnd())
        principals.push(psshbuf.readString());
      if (principals.length === 0)
        principals = ["*"];
      cert.subjects = principals.map(function(pr) {
        if (type === "user")
          return Identity.forUser(pr);
        else if (type === "host")
          return Identity.forHost(pr);
        throw new Error("Unknown identity type " + type);
      });
      cert.validFrom = int64ToDate(sshbuf.readInt64());
      cert.validUntil = int64ToDate(sshbuf.readInt64());
      var exts = [];
      var extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
      var ext;
      while (!extbuf.atEnd()) {
        ext = { critical: true };
        ext.name = extbuf.readString();
        ext.data = extbuf.readBuffer();
        exts.push(ext);
      }
      extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
      while (!extbuf.atEnd()) {
        ext = { critical: false };
        ext.name = extbuf.readString();
        ext.data = extbuf.readBuffer();
        exts.push(ext);
      }
      cert.signatures.openssh.exts = exts;
      sshbuf.readBuffer();
      var signingKeyBuf = sshbuf.readBuffer();
      cert.issuerKey = rfc4253.read(signingKeyBuf);
      cert.issuer = Identity.forHost("**");
      var sigBuf = sshbuf.readBuffer();
      cert.signatures.openssh.signature = Signature.parse(sigBuf, cert.issuerKey.type, "ssh");
      if (partial !== void 0) {
        partial.remainder = sshbuf.remainder();
        partial.consumed = sshbuf._offset;
      }
      return new Certificate(cert);
    }
    function int64ToDate(buf) {
      var i = buf.readUInt32BE(0) * 4294967296;
      i += buf.readUInt32BE(4);
      var d = new Date();
      d.setTime(i * 1e3);
      d.sourceInt64 = buf;
      return d;
    }
    function dateToInt64(date) {
      if (date.sourceInt64 !== void 0)
        return date.sourceInt64;
      var i = Math.round(date.getTime() / 1e3);
      var upper = Math.floor(i / 4294967296);
      var lower = Math.floor(i % 4294967296);
      var buf = Buffer2.alloc(8);
      buf.writeUInt32BE(upper, 0);
      buf.writeUInt32BE(lower, 4);
      return buf;
    }
    function sign(cert, key) {
      if (cert.signatures.openssh === void 0)
        cert.signatures.openssh = {};
      try {
        var blob = toBuffer(cert, true);
      } catch (e) {
        delete cert.signatures.openssh;
        return false;
      }
      var sig = cert.signatures.openssh;
      var hashAlgo = void 0;
      if (key.type === "rsa" || key.type === "dsa")
        hashAlgo = "sha1";
      var signer = key.createSign(hashAlgo);
      signer.write(blob);
      sig.signature = signer.sign();
      return true;
    }
    function signAsync(cert, signer, done) {
      if (cert.signatures.openssh === void 0)
        cert.signatures.openssh = {};
      try {
        var blob = toBuffer(cert, true);
      } catch (e) {
        delete cert.signatures.openssh;
        done(e);
        return;
      }
      var sig = cert.signatures.openssh;
      signer(blob, function(err, signature) {
        if (err) {
          done(err);
          return;
        }
        try {
          signature.toBuffer("ssh");
        } catch (e) {
          done(e);
          return;
        }
        sig.signature = signature;
        done();
      });
    }
    function write(cert, options) {
      if (options === void 0)
        options = {};
      var blob = toBuffer(cert);
      var out = getCertType(cert.subjectKey) + " " + blob.toString("base64");
      if (options.comment)
        out = out + " " + options.comment;
      return out;
    }
    function toBuffer(cert, noSig) {
      assert3.object(cert.signatures.openssh, "signature for openssh format");
      var sig = cert.signatures.openssh;
      if (sig.nonce === void 0)
        sig.nonce = crypto.randomBytes(16);
      var buf = new SSHBuffer({});
      buf.writeString(getCertType(cert.subjectKey));
      buf.writeBuffer(sig.nonce);
      var key = cert.subjectKey;
      var algInfo = algs.info[key.type];
      algInfo.parts.forEach(function(part) {
        buf.writePart(key.part[part]);
      });
      buf.writeInt64(cert.serial);
      var type = cert.subjects[0].type;
      assert3.notStrictEqual(type, "unknown");
      cert.subjects.forEach(function(id) {
        assert3.strictEqual(id.type, type);
      });
      type = TYPES[type];
      buf.writeInt(type);
      if (sig.keyId === void 0) {
        sig.keyId = cert.subjects[0].type + "_" + (cert.subjects[0].uid || cert.subjects[0].hostname);
      }
      buf.writeString(sig.keyId);
      var sub = new SSHBuffer({});
      cert.subjects.forEach(function(id) {
        if (type === TYPES.host)
          sub.writeString(id.hostname);
        else if (type === TYPES.user)
          sub.writeString(id.uid);
      });
      buf.writeBuffer(sub.toBuffer());
      buf.writeInt64(dateToInt64(cert.validFrom));
      buf.writeInt64(dateToInt64(cert.validUntil));
      var exts = sig.exts;
      if (exts === void 0)
        exts = [];
      var extbuf = new SSHBuffer({});
      exts.forEach(function(ext) {
        if (ext.critical !== true)
          return;
        extbuf.writeString(ext.name);
        extbuf.writeBuffer(ext.data);
      });
      buf.writeBuffer(extbuf.toBuffer());
      extbuf = new SSHBuffer({});
      exts.forEach(function(ext) {
        if (ext.critical === true)
          return;
        extbuf.writeString(ext.name);
        extbuf.writeBuffer(ext.data);
      });
      buf.writeBuffer(extbuf.toBuffer());
      buf.writeBuffer(Buffer2.alloc(0));
      sub = rfc4253.write(cert.issuerKey);
      buf.writeBuffer(sub);
      if (!noSig)
        buf.writeBuffer(sig.signature.toBuffer("ssh"));
      return buf.toBuffer();
    }
    function getAlg(certType) {
      if (certType === "ssh-rsa-cert-v01@openssh.com")
        return "rsa";
      if (certType === "ssh-dss-cert-v01@openssh.com")
        return "dsa";
      if (certType.match(ECDSA_ALGO))
        return "ecdsa";
      if (certType === "ssh-ed25519-cert-v01@openssh.com")
        return "ed25519";
      throw new Error("Unsupported cert type " + certType);
    }
    function getCertType(key) {
      if (key.type === "rsa")
        return "ssh-rsa-cert-v01@openssh.com";
      if (key.type === "dsa")
        return "ssh-dss-cert-v01@openssh.com";
      if (key.type === "ecdsa")
        return "ecdsa-sha2-" + key.curve + "-cert-v01@openssh.com";
      if (key.type === "ed25519")
        return "ssh-ed25519-cert-v01@openssh.com";
      throw new Error("Unsupported key type " + key.type);
    }
  }
});

// ../../node_modules/sshpk/lib/formats/x509.js
var require_x509 = __commonJS({
  "../../node_modules/sshpk/lib/formats/x509.js"(exports2, module2) {
    module2.exports = {
      read,
      verify,
      sign,
      signAsync,
      write
    };
    var assert3 = require_assert();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var Identity = require_identity();
    var Signature = require_signature();
    var Certificate = require_certificate();
    var pkcs8 = require_pkcs8();
    function readMPInt(der, nm) {
      assert3.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
      return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    }
    function verify(cert, key) {
      var sig = cert.signatures.x509;
      assert3.object(sig, "x509 signature");
      var algParts = sig.algo.split("-");
      if (algParts[0] !== key.type)
        return false;
      var blob = sig.cache;
      if (blob === void 0) {
        var der = new asn1.BerWriter();
        writeTBSCert(cert, der);
        blob = der.buffer;
      }
      var verifier = key.createVerify(algParts[1]);
      verifier.write(blob);
      return verifier.verify(sig.signature);
    }
    function Local(i) {
      return asn1.Ber.Context | asn1.Ber.Constructor | i;
    }
    function Context(i) {
      return asn1.Ber.Context | i;
    }
    var SIGN_ALGS = {
      "rsa-md5": "1.2.840.113549.1.1.4",
      "rsa-sha1": "1.2.840.113549.1.1.5",
      "rsa-sha256": "1.2.840.113549.1.1.11",
      "rsa-sha384": "1.2.840.113549.1.1.12",
      "rsa-sha512": "1.2.840.113549.1.1.13",
      "dsa-sha1": "1.2.840.10040.4.3",
      "dsa-sha256": "2.16.840.1.101.3.4.3.2",
      "ecdsa-sha1": "1.2.840.10045.4.1",
      "ecdsa-sha256": "1.2.840.10045.4.3.2",
      "ecdsa-sha384": "1.2.840.10045.4.3.3",
      "ecdsa-sha512": "1.2.840.10045.4.3.4",
      "ed25519-sha512": "1.3.101.112"
    };
    Object.keys(SIGN_ALGS).forEach(function(k) {
      SIGN_ALGS[SIGN_ALGS[k]] = k;
    });
    SIGN_ALGS["1.3.14.3.2.3"] = "rsa-md5";
    SIGN_ALGS["1.3.14.3.2.29"] = "rsa-sha1";
    var EXTS = {
      "issuerKeyId": "2.5.29.35",
      "altName": "2.5.29.17",
      "basicConstraints": "2.5.29.19",
      "keyUsage": "2.5.29.15",
      "extKeyUsage": "2.5.29.37"
    };
    function read(buf, options) {
      if (typeof buf === "string") {
        buf = Buffer2.from(buf, "binary");
      }
      assert3.buffer(buf, "buf");
      var der = new asn1.BerReader(buf);
      der.readSequence();
      if (Math.abs(der.length - der.remain) > 1) {
        throw new Error("DER sequence does not contain whole byte stream");
      }
      var tbsStart = der.offset;
      der.readSequence();
      var sigOffset = der.offset + der.length;
      var tbsEnd = sigOffset;
      if (der.peek() === Local(0)) {
        der.readSequence(Local(0));
        var version = der.readInt();
        assert3.ok(version <= 3, "only x.509 versions up to v3 supported");
      }
      var cert = {};
      cert.signatures = {};
      var sig = cert.signatures.x509 = {};
      sig.extras = {};
      cert.serial = readMPInt(der, "serial");
      der.readSequence();
      var after = der.offset + der.length;
      var certAlgOid = der.readOID();
      var certAlg = SIGN_ALGS[certAlgOid];
      if (certAlg === void 0)
        throw new Error("unknown signature algorithm " + certAlgOid);
      der._offset = after;
      cert.issuer = Identity.parseAsn1(der);
      der.readSequence();
      cert.validFrom = readDate(der);
      cert.validUntil = readDate(der);
      cert.subjects = [Identity.parseAsn1(der)];
      der.readSequence();
      after = der.offset + der.length;
      cert.subjectKey = pkcs8.readPkcs8(void 0, "public", der);
      der._offset = after;
      if (der.peek() === Local(1)) {
        der.readSequence(Local(1));
        sig.extras.issuerUniqueID = buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
      }
      if (der.peek() === Local(2)) {
        der.readSequence(Local(2));
        sig.extras.subjectUniqueID = buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
      }
      if (der.peek() === Local(3)) {
        der.readSequence(Local(3));
        var extEnd = der.offset + der.length;
        der.readSequence();
        while (der.offset < extEnd)
          readExtension(cert, buf, der);
        assert3.strictEqual(der.offset, extEnd);
      }
      assert3.strictEqual(der.offset, sigOffset);
      der.readSequence();
      after = der.offset + der.length;
      var sigAlgOid = der.readOID();
      var sigAlg = SIGN_ALGS[sigAlgOid];
      if (sigAlg === void 0)
        throw new Error("unknown signature algorithm " + sigAlgOid);
      der._offset = after;
      var sigData = der.readString(asn1.Ber.BitString, true);
      if (sigData[0] === 0)
        sigData = sigData.slice(1);
      var algParts = sigAlg.split("-");
      sig.signature = Signature.parse(sigData, algParts[0], "asn1");
      sig.signature.hashAlgorithm = algParts[1];
      sig.algo = sigAlg;
      sig.cache = buf.slice(tbsStart, tbsEnd);
      return new Certificate(cert);
    }
    function readDate(der) {
      if (der.peek() === asn1.Ber.UTCTime) {
        return utcTimeToDate(der.readString(asn1.Ber.UTCTime));
      } else if (der.peek() === asn1.Ber.GeneralizedTime) {
        return gTimeToDate(der.readString(asn1.Ber.GeneralizedTime));
      } else {
        throw new Error("Unsupported date format");
      }
    }
    function writeDate(der, date) {
      if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
        der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);
      } else {
        der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);
      }
    }
    var ALTNAME = {
      OtherName: Local(0),
      RFC822Name: Context(1),
      DNSName: Context(2),
      X400Address: Local(3),
      DirectoryName: Local(4),
      EDIPartyName: Local(5),
      URI: Context(6),
      IPAddress: Context(7),
      OID: Context(8)
    };
    var EXTPURPOSE = {
      "serverAuth": "1.3.6.1.5.5.7.3.1",
      "clientAuth": "1.3.6.1.5.5.7.3.2",
      "codeSigning": "1.3.6.1.5.5.7.3.3",
      "joyentDocker": "1.3.6.1.4.1.38678.1.4.1",
      "joyentCmon": "1.3.6.1.4.1.38678.1.4.2"
    };
    var EXTPURPOSE_REV = {};
    Object.keys(EXTPURPOSE).forEach(function(k) {
      EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
    });
    var KEYUSEBITS = [
      "signature",
      "identity",
      "keyEncryption",
      "encryption",
      "keyAgreement",
      "ca",
      "crl"
    ];
    function readExtension(cert, buf, der) {
      der.readSequence();
      var after = der.offset + der.length;
      var extId = der.readOID();
      var id;
      var sig = cert.signatures.x509;
      if (!sig.extras.exts)
        sig.extras.exts = [];
      var critical;
      if (der.peek() === asn1.Ber.Boolean)
        critical = der.readBoolean();
      switch (extId) {
        case EXTS.basicConstraints:
          der.readSequence(asn1.Ber.OctetString);
          der.readSequence();
          var bcEnd = der.offset + der.length;
          var ca = false;
          if (der.peek() === asn1.Ber.Boolean)
            ca = der.readBoolean();
          if (cert.purposes === void 0)
            cert.purposes = [];
          if (ca === true)
            cert.purposes.push("ca");
          var bc = { oid: extId, critical };
          if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)
            bc.pathLen = der.readInt();
          sig.extras.exts.push(bc);
          break;
        case EXTS.extKeyUsage:
          der.readSequence(asn1.Ber.OctetString);
          der.readSequence();
          if (cert.purposes === void 0)
            cert.purposes = [];
          var ekEnd = der.offset + der.length;
          while (der.offset < ekEnd) {
            var oid = der.readOID();
            cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
          }
          if (cert.purposes.indexOf("serverAuth") !== -1 && cert.purposes.indexOf("clientAuth") === -1) {
            cert.subjects.forEach(function(ide) {
              if (ide.type !== "host") {
                ide.type = "host";
                ide.hostname = ide.uid || ide.email || ide.components[0].value;
              }
            });
          } else if (cert.purposes.indexOf("clientAuth") !== -1 && cert.purposes.indexOf("serverAuth") === -1) {
            cert.subjects.forEach(function(ide) {
              if (ide.type !== "user") {
                ide.type = "user";
                ide.uid = ide.hostname || ide.email || ide.components[0].value;
              }
            });
          }
          sig.extras.exts.push({ oid: extId, critical });
          break;
        case EXTS.keyUsage:
          der.readSequence(asn1.Ber.OctetString);
          var bits = der.readString(asn1.Ber.BitString, true);
          var setBits = readBitField(bits, KEYUSEBITS);
          setBits.forEach(function(bit) {
            if (cert.purposes === void 0)
              cert.purposes = [];
            if (cert.purposes.indexOf(bit) === -1)
              cert.purposes.push(bit);
          });
          sig.extras.exts.push({
            oid: extId,
            critical,
            bits
          });
          break;
        case EXTS.altName:
          der.readSequence(asn1.Ber.OctetString);
          der.readSequence();
          var aeEnd = der.offset + der.length;
          while (der.offset < aeEnd) {
            switch (der.peek()) {
              case ALTNAME.OtherName:
              case ALTNAME.EDIPartyName:
                der.readSequence();
                der._offset += der.length;
                break;
              case ALTNAME.OID:
                der.readOID(ALTNAME.OID);
                break;
              case ALTNAME.RFC822Name:
                var email = der.readString(ALTNAME.RFC822Name);
                id = Identity.forEmail(email);
                if (!cert.subjects[0].equals(id))
                  cert.subjects.push(id);
                break;
              case ALTNAME.DirectoryName:
                der.readSequence(ALTNAME.DirectoryName);
                id = Identity.parseAsn1(der);
                if (!cert.subjects[0].equals(id))
                  cert.subjects.push(id);
                break;
              case ALTNAME.DNSName:
                var host = der.readString(ALTNAME.DNSName);
                id = Identity.forHost(host);
                if (!cert.subjects[0].equals(id))
                  cert.subjects.push(id);
                break;
              default:
                der.readString(der.peek());
                break;
            }
          }
          sig.extras.exts.push({ oid: extId, critical });
          break;
        default:
          sig.extras.exts.push({
            oid: extId,
            critical,
            data: der.readString(asn1.Ber.OctetString, true)
          });
          break;
      }
      der._offset = after;
    }
    var UTCTIME_RE = /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
    function utcTimeToDate(t) {
      var m = t.match(UTCTIME_RE);
      assert3.ok(m, "timestamps must be in UTC");
      var d = new Date();
      var thisYear = d.getUTCFullYear();
      var century = Math.floor(thisYear / 100) * 100;
      var year = parseInt(m[1], 10);
      if (thisYear % 100 < 50 && year >= 60)
        year += century - 1;
      else
        year += century;
      d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
      d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
      if (m[6] && m[6].length > 0)
        d.setUTCSeconds(parseInt(m[6], 10));
      return d;
    }
    var GTIME_RE = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
    function gTimeToDate(t) {
      var m = t.match(GTIME_RE);
      assert3.ok(m);
      var d = new Date();
      d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));
      d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
      if (m[6] && m[6].length > 0)
        d.setUTCSeconds(parseInt(m[6], 10));
      return d;
    }
    function zeroPad(n, m) {
      if (m === void 0)
        m = 2;
      var s = "" + n;
      while (s.length < m)
        s = "0" + s;
      return s;
    }
    function dateToUTCTime(d) {
      var s = "";
      s += zeroPad(d.getUTCFullYear() % 100);
      s += zeroPad(d.getUTCMonth() + 1);
      s += zeroPad(d.getUTCDate());
      s += zeroPad(d.getUTCHours());
      s += zeroPad(d.getUTCMinutes());
      s += zeroPad(d.getUTCSeconds());
      s += "Z";
      return s;
    }
    function dateToGTime(d) {
      var s = "";
      s += zeroPad(d.getUTCFullYear(), 4);
      s += zeroPad(d.getUTCMonth() + 1);
      s += zeroPad(d.getUTCDate());
      s += zeroPad(d.getUTCHours());
      s += zeroPad(d.getUTCMinutes());
      s += zeroPad(d.getUTCSeconds());
      s += "Z";
      return s;
    }
    function sign(cert, key) {
      if (cert.signatures.x509 === void 0)
        cert.signatures.x509 = {};
      var sig = cert.signatures.x509;
      sig.algo = key.type + "-" + key.defaultHashAlgorithm();
      if (SIGN_ALGS[sig.algo] === void 0)
        return false;
      var der = new asn1.BerWriter();
      writeTBSCert(cert, der);
      var blob = der.buffer;
      sig.cache = blob;
      var signer = key.createSign();
      signer.write(blob);
      cert.signatures.x509.signature = signer.sign();
      return true;
    }
    function signAsync(cert, signer, done) {
      if (cert.signatures.x509 === void 0)
        cert.signatures.x509 = {};
      var sig = cert.signatures.x509;
      var der = new asn1.BerWriter();
      writeTBSCert(cert, der);
      var blob = der.buffer;
      sig.cache = blob;
      signer(blob, function(err, signature) {
        if (err) {
          done(err);
          return;
        }
        sig.algo = signature.type + "-" + signature.hashAlgorithm;
        if (SIGN_ALGS[sig.algo] === void 0) {
          done(new Error('Invalid signing algorithm "' + sig.algo + '"'));
          return;
        }
        sig.signature = signature;
        done();
      });
    }
    function write(cert, options) {
      var sig = cert.signatures.x509;
      assert3.object(sig, "x509 signature");
      var der = new asn1.BerWriter();
      der.startSequence();
      if (sig.cache) {
        der._ensure(sig.cache.length);
        sig.cache.copy(der._buf, der._offset);
        der._offset += sig.cache.length;
      } else {
        writeTBSCert(cert, der);
      }
      der.startSequence();
      der.writeOID(SIGN_ALGS[sig.algo]);
      if (sig.algo.match(/^rsa-/))
        der.writeNull();
      der.endSequence();
      var sigData = sig.signature.toBuffer("asn1");
      var data = Buffer2.alloc(sigData.length + 1);
      data[0] = 0;
      sigData.copy(data, 1);
      der.writeBuffer(data, asn1.Ber.BitString);
      der.endSequence();
      return der.buffer;
    }
    function writeTBSCert(cert, der) {
      var sig = cert.signatures.x509;
      assert3.object(sig, "x509 signature");
      der.startSequence();
      der.startSequence(Local(0));
      der.writeInt(2);
      der.endSequence();
      der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);
      der.startSequence();
      der.writeOID(SIGN_ALGS[sig.algo]);
      if (sig.algo.match(/^rsa-/))
        der.writeNull();
      der.endSequence();
      cert.issuer.toAsn1(der);
      der.startSequence();
      writeDate(der, cert.validFrom);
      writeDate(der, cert.validUntil);
      der.endSequence();
      var subject = cert.subjects[0];
      var altNames = cert.subjects.slice(1);
      subject.toAsn1(der);
      pkcs8.writePkcs8(der, cert.subjectKey);
      if (sig.extras && sig.extras.issuerUniqueID) {
        der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
      }
      if (sig.extras && sig.extras.subjectUniqueID) {
        der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
      }
      if (altNames.length > 0 || subject.type === "host" || cert.purposes !== void 0 && cert.purposes.length > 0 || sig.extras && sig.extras.exts) {
        der.startSequence(Local(3));
        der.startSequence();
        var exts = [];
        if (cert.purposes !== void 0 && cert.purposes.length > 0) {
          exts.push({
            oid: EXTS.basicConstraints,
            critical: true
          });
          exts.push({
            oid: EXTS.keyUsage,
            critical: true
          });
          exts.push({
            oid: EXTS.extKeyUsage,
            critical: true
          });
        }
        exts.push({ oid: EXTS.altName });
        if (sig.extras && sig.extras.exts)
          exts = sig.extras.exts;
        for (var i = 0; i < exts.length; ++i) {
          der.startSequence();
          der.writeOID(exts[i].oid);
          if (exts[i].critical !== void 0)
            der.writeBoolean(exts[i].critical);
          if (exts[i].oid === EXTS.altName) {
            der.startSequence(asn1.Ber.OctetString);
            der.startSequence();
            if (subject.type === "host") {
              der.writeString(subject.hostname, Context(2));
            }
            for (var j = 0; j < altNames.length; ++j) {
              if (altNames[j].type === "host") {
                der.writeString(altNames[j].hostname, ALTNAME.DNSName);
              } else if (altNames[j].type === "email") {
                der.writeString(altNames[j].email, ALTNAME.RFC822Name);
              } else {
                der.startSequence(ALTNAME.DirectoryName);
                altNames[j].toAsn1(der);
                der.endSequence();
              }
            }
            der.endSequence();
            der.endSequence();
          } else if (exts[i].oid === EXTS.basicConstraints) {
            der.startSequence(asn1.Ber.OctetString);
            der.startSequence();
            var ca = cert.purposes.indexOf("ca") !== -1;
            var pathLen = exts[i].pathLen;
            der.writeBoolean(ca);
            if (pathLen !== void 0)
              der.writeInt(pathLen);
            der.endSequence();
            der.endSequence();
          } else if (exts[i].oid === EXTS.extKeyUsage) {
            der.startSequence(asn1.Ber.OctetString);
            der.startSequence();
            cert.purposes.forEach(function(purpose) {
              if (purpose === "ca")
                return;
              if (KEYUSEBITS.indexOf(purpose) !== -1)
                return;
              var oid = purpose;
              if (EXTPURPOSE[purpose] !== void 0)
                oid = EXTPURPOSE[purpose];
              der.writeOID(oid);
            });
            der.endSequence();
            der.endSequence();
          } else if (exts[i].oid === EXTS.keyUsage) {
            der.startSequence(asn1.Ber.OctetString);
            if (exts[i].bits !== void 0) {
              der.writeBuffer(exts[i].bits, asn1.Ber.BitString);
            } else {
              var bits = writeBitField(cert.purposes, KEYUSEBITS);
              der.writeBuffer(bits, asn1.Ber.BitString);
            }
            der.endSequence();
          } else {
            der.writeBuffer(exts[i].data, asn1.Ber.OctetString);
          }
          der.endSequence();
        }
        der.endSequence();
        der.endSequence();
      }
      der.endSequence();
    }
    function readBitField(bits, bitIndex) {
      var bitLen = 8 * (bits.length - 1) - bits[0];
      var setBits = {};
      for (var i = 0; i < bitLen; ++i) {
        var byteN = 1 + Math.floor(i / 8);
        var bit = 7 - i % 8;
        var mask = 1 << bit;
        var bitVal = (bits[byteN] & mask) !== 0;
        var name = bitIndex[i];
        if (bitVal && typeof name === "string") {
          setBits[name] = true;
        }
      }
      return Object.keys(setBits);
    }
    function writeBitField(setBits, bitIndex) {
      var bitLen = bitIndex.length;
      var blen = Math.ceil(bitLen / 8);
      var unused = blen * 8 - bitLen;
      var bits = Buffer2.alloc(1 + blen);
      bits[0] = unused;
      for (var i = 0; i < bitLen; ++i) {
        var byteN = 1 + Math.floor(i / 8);
        var bit = 7 - i % 8;
        var mask = 1 << bit;
        var name = bitIndex[i];
        if (name === void 0)
          continue;
        var bitVal = setBits.indexOf(name) !== -1;
        if (bitVal) {
          bits[byteN] |= mask;
        }
      }
      return bits;
    }
  }
});

// ../../node_modules/sshpk/lib/formats/x509-pem.js
var require_x509_pem = __commonJS({
  "../../node_modules/sshpk/lib/formats/x509-pem.js"(exports2, module2) {
    var x509 = require_x509();
    module2.exports = {
      read,
      verify: x509.verify,
      sign: x509.sign,
      write
    };
    var assert3 = require_assert();
    var asn1 = require_lib2();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var pem = require_pem();
    var Identity = require_identity();
    var Signature = require_signature();
    var Certificate = require_certificate();
    function read(buf, options) {
      if (typeof buf !== "string") {
        assert3.buffer(buf, "buf");
        buf = buf.toString("ascii");
      }
      var lines = buf.trim().split(/[\r\n]+/g);
      var m;
      var si = -1;
      while (!m && si < lines.length) {
        m = lines[++si].match(/[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
      }
      assert3.ok(m, "invalid PEM header");
      var m2;
      var ei = lines.length;
      while (!m2 && ei > 0) {
        m2 = lines[--ei].match(/[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
      }
      assert3.ok(m2, "invalid PEM footer");
      lines = lines.slice(si, ei + 1);
      var headers = {};
      while (true) {
        lines = lines.slice(1);
        m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
        if (!m)
          break;
        headers[m[1].toLowerCase()] = m[2];
      }
      lines = lines.slice(0, -1).join("");
      buf = Buffer2.from(lines, "base64");
      return x509.read(buf, options);
    }
    function write(cert, options) {
      var dbuf = x509.write(cert, options);
      var header = "CERTIFICATE";
      var tmp = dbuf.toString("base64");
      var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
      var buf = Buffer2.alloc(len);
      var o = 0;
      o += buf.write("-----BEGIN " + header + "-----\n", o);
      for (var i = 0; i < tmp.length; ) {
        var limit = i + 64;
        if (limit > tmp.length)
          limit = tmp.length;
        o += buf.write(tmp.slice(i, limit), o);
        buf[o++] = 10;
        i = limit;
      }
      o += buf.write("-----END " + header + "-----\n", o);
      return buf.slice(0, o);
    }
  }
});

// ../../node_modules/sshpk/lib/certificate.js
var require_certificate = __commonJS({
  "../../node_modules/sshpk/lib/certificate.js"(exports2, module2) {
    module2.exports = Certificate;
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = require("crypto");
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var errs = require_errors();
    var util2 = require("util");
    var utils = require_utils();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var Identity = require_identity();
    var formats = {};
    formats["openssh"] = require_openssh_cert();
    formats["x509"] = require_x509();
    formats["pem"] = require_x509_pem();
    var CertificateParseError = errs.CertificateParseError;
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    function Certificate(opts) {
      assert3.object(opts, "options");
      assert3.arrayOfObject(opts.subjects, "options.subjects");
      utils.assertCompatible(opts.subjects[0], Identity, [1, 0], "options.subjects");
      utils.assertCompatible(opts.subjectKey, Key, [1, 0], "options.subjectKey");
      utils.assertCompatible(opts.issuer, Identity, [1, 0], "options.issuer");
      if (opts.issuerKey !== void 0) {
        utils.assertCompatible(opts.issuerKey, Key, [1, 0], "options.issuerKey");
      }
      assert3.object(opts.signatures, "options.signatures");
      assert3.buffer(opts.serial, "options.serial");
      assert3.date(opts.validFrom, "options.validFrom");
      assert3.date(opts.validUntil, "optons.validUntil");
      assert3.optionalArrayOfString(opts.purposes, "options.purposes");
      this._hashCache = {};
      this.subjects = opts.subjects;
      this.issuer = opts.issuer;
      this.subjectKey = opts.subjectKey;
      this.issuerKey = opts.issuerKey;
      this.signatures = opts.signatures;
      this.serial = opts.serial;
      this.validFrom = opts.validFrom;
      this.validUntil = opts.validUntil;
      this.purposes = opts.purposes;
    }
    Certificate.formats = formats;
    Certificate.prototype.toBuffer = function(format, options) {
      if (format === void 0)
        format = "x509";
      assert3.string(format, "format");
      assert3.object(formats[format], "formats[format]");
      assert3.optionalObject(options, "options");
      return formats[format].write(this, options);
    };
    Certificate.prototype.toString = function(format, options) {
      if (format === void 0)
        format = "pem";
      return this.toBuffer(format, options).toString();
    };
    Certificate.prototype.fingerprint = function(algo) {
      if (algo === void 0)
        algo = "sha256";
      assert3.string(algo, "algorithm");
      var opts = {
        type: "certificate",
        hash: this.hash(algo),
        algorithm: algo
      };
      return new Fingerprint(opts);
    };
    Certificate.prototype.hash = function(algo) {
      assert3.string(algo, "algorithm");
      algo = algo.toLowerCase();
      if (algs.hashAlgs[algo] === void 0)
        throw new InvalidAlgorithmError(algo);
      if (this._hashCache[algo])
        return this._hashCache[algo];
      var hash = crypto.createHash(algo).update(this.toBuffer("x509")).digest();
      this._hashCache[algo] = hash;
      return hash;
    };
    Certificate.prototype.isExpired = function(when) {
      if (when === void 0)
        when = new Date();
      return !(when.getTime() >= this.validFrom.getTime() && when.getTime() < this.validUntil.getTime());
    };
    Certificate.prototype.isSignedBy = function(issuerCert) {
      utils.assertCompatible(issuerCert, Certificate, [1, 0], "issuer");
      if (!this.issuer.equals(issuerCert.subjects[0]))
        return false;
      if (this.issuer.purposes && this.issuer.purposes.length > 0 && this.issuer.purposes.indexOf("ca") === -1) {
        return false;
      }
      return this.isSignedByKey(issuerCert.subjectKey);
    };
    Certificate.prototype.getExtension = function(keyOrOid) {
      assert3.string(keyOrOid, "keyOrOid");
      var ext = this.getExtensions().filter(function(maybeExt) {
        if (maybeExt.format === "x509")
          return maybeExt.oid === keyOrOid;
        if (maybeExt.format === "openssh")
          return maybeExt.name === keyOrOid;
        return false;
      })[0];
      return ext;
    };
    Certificate.prototype.getExtensions = function() {
      var exts = [];
      var x509 = this.signatures.x509;
      if (x509 && x509.extras && x509.extras.exts) {
        x509.extras.exts.forEach(function(ext) {
          ext.format = "x509";
          exts.push(ext);
        });
      }
      var openssh = this.signatures.openssh;
      if (openssh && openssh.exts) {
        openssh.exts.forEach(function(ext) {
          ext.format = "openssh";
          exts.push(ext);
        });
      }
      return exts;
    };
    Certificate.prototype.isSignedByKey = function(issuerKey) {
      utils.assertCompatible(issuerKey, Key, [1, 2], "issuerKey");
      if (this.issuerKey !== void 0) {
        return this.issuerKey.fingerprint("sha512").matches(issuerKey);
      }
      var fmt = Object.keys(this.signatures)[0];
      var valid = formats[fmt].verify(this, issuerKey);
      if (valid)
        this.issuerKey = issuerKey;
      return valid;
    };
    Certificate.prototype.signWith = function(key) {
      utils.assertCompatible(key, PrivateKey, [1, 2], "key");
      var fmts = Object.keys(formats);
      var didOne = false;
      for (var i = 0; i < fmts.length; ++i) {
        if (fmts[i] !== "pem") {
          var ret = formats[fmts[i]].sign(this, key);
          if (ret === true)
            didOne = true;
        }
      }
      if (!didOne) {
        throw new Error("Failed to sign the certificate for any available certificate formats");
      }
    };
    Certificate.createSelfSigned = function(subjectOrSubjects, key, options) {
      var subjects;
      if (Array.isArray(subjectOrSubjects))
        subjects = subjectOrSubjects;
      else
        subjects = [subjectOrSubjects];
      assert3.arrayOfObject(subjects);
      subjects.forEach(function(subject) {
        utils.assertCompatible(subject, Identity, [1, 0], "subject");
      });
      utils.assertCompatible(key, PrivateKey, [1, 2], "private key");
      assert3.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert3.optionalObject(options.validFrom, "options.validFrom");
      assert3.optionalObject(options.validUntil, "options.validUntil");
      var validFrom = options.validFrom;
      var validUntil = options.validUntil;
      if (validFrom === void 0)
        validFrom = new Date();
      if (validUntil === void 0) {
        assert3.optionalNumber(options.lifetime, "options.lifetime");
        var lifetime = options.lifetime;
        if (lifetime === void 0)
          lifetime = 10 * 365 * 24 * 3600;
        validUntil = new Date();
        validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
      }
      assert3.optionalBuffer(options.serial, "options.serial");
      var serial = options.serial;
      if (serial === void 0)
        serial = Buffer2.from("0000000000000001", "hex");
      var purposes = options.purposes;
      if (purposes === void 0)
        purposes = [];
      if (purposes.indexOf("signature") === -1)
        purposes.push("signature");
      if (purposes.indexOf("ca") === -1)
        purposes.push("ca");
      if (purposes.indexOf("crl") === -1)
        purposes.push("crl");
      if (purposes.length <= 3) {
        var hostSubjects = subjects.filter(function(subject) {
          return subject.type === "host";
        });
        var userSubjects = subjects.filter(function(subject) {
          return subject.type === "user";
        });
        if (hostSubjects.length > 0) {
          if (purposes.indexOf("serverAuth") === -1)
            purposes.push("serverAuth");
        }
        if (userSubjects.length > 0) {
          if (purposes.indexOf("clientAuth") === -1)
            purposes.push("clientAuth");
        }
        if (userSubjects.length > 0 || hostSubjects.length > 0) {
          if (purposes.indexOf("keyAgreement") === -1)
            purposes.push("keyAgreement");
          if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
            purposes.push("encryption");
        }
      }
      var cert = new Certificate({
        subjects,
        issuer: subjects[0],
        subjectKey: key.toPublic(),
        issuerKey: key.toPublic(),
        signatures: {},
        serial,
        validFrom,
        validUntil,
        purposes
      });
      cert.signWith(key);
      return cert;
    };
    Certificate.create = function(subjectOrSubjects, key, issuer, issuerKey, options) {
      var subjects;
      if (Array.isArray(subjectOrSubjects))
        subjects = subjectOrSubjects;
      else
        subjects = [subjectOrSubjects];
      assert3.arrayOfObject(subjects);
      subjects.forEach(function(subject) {
        utils.assertCompatible(subject, Identity, [1, 0], "subject");
      });
      utils.assertCompatible(key, Key, [1, 0], "key");
      if (PrivateKey.isPrivateKey(key))
        key = key.toPublic();
      utils.assertCompatible(issuer, Identity, [1, 0], "issuer");
      utils.assertCompatible(issuerKey, PrivateKey, [1, 2], "issuer key");
      assert3.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert3.optionalObject(options.validFrom, "options.validFrom");
      assert3.optionalObject(options.validUntil, "options.validUntil");
      var validFrom = options.validFrom;
      var validUntil = options.validUntil;
      if (validFrom === void 0)
        validFrom = new Date();
      if (validUntil === void 0) {
        assert3.optionalNumber(options.lifetime, "options.lifetime");
        var lifetime = options.lifetime;
        if (lifetime === void 0)
          lifetime = 10 * 365 * 24 * 3600;
        validUntil = new Date();
        validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
      }
      assert3.optionalBuffer(options.serial, "options.serial");
      var serial = options.serial;
      if (serial === void 0)
        serial = Buffer2.from("0000000000000001", "hex");
      var purposes = options.purposes;
      if (purposes === void 0)
        purposes = [];
      if (purposes.indexOf("signature") === -1)
        purposes.push("signature");
      if (options.ca === true) {
        if (purposes.indexOf("ca") === -1)
          purposes.push("ca");
        if (purposes.indexOf("crl") === -1)
          purposes.push("crl");
      }
      var hostSubjects = subjects.filter(function(subject) {
        return subject.type === "host";
      });
      var userSubjects = subjects.filter(function(subject) {
        return subject.type === "user";
      });
      if (hostSubjects.length > 0) {
        if (purposes.indexOf("serverAuth") === -1)
          purposes.push("serverAuth");
      }
      if (userSubjects.length > 0) {
        if (purposes.indexOf("clientAuth") === -1)
          purposes.push("clientAuth");
      }
      if (userSubjects.length > 0 || hostSubjects.length > 0) {
        if (purposes.indexOf("keyAgreement") === -1)
          purposes.push("keyAgreement");
        if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
          purposes.push("encryption");
      }
      var cert = new Certificate({
        subjects,
        issuer,
        subjectKey: key,
        issuerKey: issuerKey.toPublic(),
        signatures: {},
        serial,
        validFrom,
        validUntil,
        purposes
      });
      cert.signWith(issuerKey);
      return cert;
    };
    Certificate.parse = function(data, format, options) {
      if (typeof data !== "string")
        assert3.buffer(data, "data");
      if (format === void 0)
        format = "auto";
      assert3.string(format, "format");
      if (typeof options === "string")
        options = { filename: options };
      assert3.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert3.optionalString(options.filename, "options.filename");
      if (options.filename === void 0)
        options.filename = "(unnamed)";
      assert3.object(formats[format], "formats[format]");
      try {
        var k = formats[format].read(data, options);
        return k;
      } catch (e) {
        throw new CertificateParseError(options.filename, format, e);
      }
    };
    Certificate.isCertificate = function(obj, ver) {
      return utils.isCompatible(obj, Certificate, ver);
    };
    Certificate.prototype._sshpkApiVersion = [1, 1];
    Certificate._oldVersionDetect = function(obj) {
      return [1, 0];
    };
  }
});

// ../../node_modules/sshpk/lib/fingerprint.js
var require_fingerprint = __commonJS({
  "../../node_modules/sshpk/lib/fingerprint.js"(exports2, module2) {
    module2.exports = Fingerprint;
    var assert3 = require_assert();
    var Buffer2 = require_safer().Buffer;
    var algs = require_algs();
    var crypto = require("crypto");
    var errs = require_errors();
    var Key = require_key();
    var PrivateKey = require_private_key();
    var Certificate = require_certificate();
    var utils = require_utils();
    var FingerprintFormatError = errs.FingerprintFormatError;
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    function Fingerprint(opts) {
      assert3.object(opts, "options");
      assert3.string(opts.type, "options.type");
      assert3.buffer(opts.hash, "options.hash");
      assert3.string(opts.algorithm, "options.algorithm");
      this.algorithm = opts.algorithm.toLowerCase();
      if (algs.hashAlgs[this.algorithm] !== true)
        throw new InvalidAlgorithmError(this.algorithm);
      this.hash = opts.hash;
      this.type = opts.type;
      this.hashType = opts.hashType;
    }
    Fingerprint.prototype.toString = function(format) {
      if (format === void 0) {
        if (this.algorithm === "md5" || this.hashType === "spki")
          format = "hex";
        else
          format = "base64";
      }
      assert3.string(format);
      switch (format) {
        case "hex":
          if (this.hashType === "spki")
            return this.hash.toString("hex");
          return addColons(this.hash.toString("hex"));
        case "base64":
          if (this.hashType === "spki")
            return this.hash.toString("base64");
          return sshBase64Format(this.algorithm, this.hash.toString("base64"));
        default:
          throw new FingerprintFormatError(void 0, format);
      }
    };
    Fingerprint.prototype.matches = function(other) {
      assert3.object(other, "key or certificate");
      if (this.type === "key" && this.hashType !== "ssh") {
        utils.assertCompatible(other, Key, [1, 7], "key with spki");
        if (PrivateKey.isPrivateKey(other)) {
          utils.assertCompatible(other, PrivateKey, [1, 6], "privatekey with spki support");
        }
      } else if (this.type === "key") {
        utils.assertCompatible(other, Key, [1, 0], "key");
      } else {
        utils.assertCompatible(other, Certificate, [1, 0], "certificate");
      }
      var theirHash = other.hash(this.algorithm, this.hashType);
      var theirHash2 = crypto.createHash(this.algorithm).update(theirHash).digest("base64");
      if (this.hash2 === void 0)
        this.hash2 = crypto.createHash(this.algorithm).update(this.hash).digest("base64");
      return this.hash2 === theirHash2;
    };
    var base64RE = /^[A-Za-z0-9+\/=]+$/;
    var hexRE = /^[a-fA-F0-9]+$/;
    Fingerprint.parse = function(fp, options) {
      assert3.string(fp, "fingerprint");
      var alg, hash, enAlgs;
      if (Array.isArray(options)) {
        enAlgs = options;
        options = {};
      }
      assert3.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      if (options.enAlgs !== void 0)
        enAlgs = options.enAlgs;
      if (options.algorithms !== void 0)
        enAlgs = options.algorithms;
      assert3.optionalArrayOfString(enAlgs, "algorithms");
      var hashType = "ssh";
      if (options.hashType !== void 0)
        hashType = options.hashType;
      assert3.string(hashType, "options.hashType");
      var parts = fp.split(":");
      if (parts.length == 2) {
        alg = parts[0].toLowerCase();
        if (!base64RE.test(parts[1]))
          throw new FingerprintFormatError(fp);
        try {
          hash = Buffer2.from(parts[1], "base64");
        } catch (e) {
          throw new FingerprintFormatError(fp);
        }
      } else if (parts.length > 2) {
        alg = "md5";
        if (parts[0].toLowerCase() === "md5")
          parts = parts.slice(1);
        parts = parts.map(function(p) {
          while (p.length < 2)
            p = "0" + p;
          if (p.length > 2)
            throw new FingerprintFormatError(fp);
          return p;
        });
        parts = parts.join("");
        if (!hexRE.test(parts) || parts.length % 2 !== 0)
          throw new FingerprintFormatError(fp);
        try {
          hash = Buffer2.from(parts, "hex");
        } catch (e) {
          throw new FingerprintFormatError(fp);
        }
      } else {
        if (hexRE.test(fp)) {
          hash = Buffer2.from(fp, "hex");
        } else if (base64RE.test(fp)) {
          hash = Buffer2.from(fp, "base64");
        } else {
          throw new FingerprintFormatError(fp);
        }
        switch (hash.length) {
          case 32:
            alg = "sha256";
            break;
          case 16:
            alg = "md5";
            break;
          case 20:
            alg = "sha1";
            break;
          case 64:
            alg = "sha512";
            break;
          default:
            throw new FingerprintFormatError(fp);
        }
        if (options.hashType === void 0)
          hashType = "spki";
      }
      if (alg === void 0)
        throw new FingerprintFormatError(fp);
      if (algs.hashAlgs[alg] === void 0)
        throw new InvalidAlgorithmError(alg);
      if (enAlgs !== void 0) {
        enAlgs = enAlgs.map(function(a) {
          return a.toLowerCase();
        });
        if (enAlgs.indexOf(alg) === -1)
          throw new InvalidAlgorithmError(alg);
      }
      return new Fingerprint({
        algorithm: alg,
        hash,
        type: options.type || "key",
        hashType
      });
    };
    function addColons(s) {
      return s.replace(/(.{2})(?=.)/g, "$1:");
    }
    function base64Strip(s) {
      return s.replace(/=*$/, "");
    }
    function sshBase64Format(alg, h) {
      return alg.toUpperCase() + ":" + base64Strip(h);
    }
    Fingerprint.isFingerprint = function(obj, ver) {
      return utils.isCompatible(obj, Fingerprint, ver);
    };
    Fingerprint.prototype._sshpkApiVersion = [1, 2];
    Fingerprint._oldVersionDetect = function(obj) {
      assert3.func(obj.toString);
      assert3.func(obj.matches);
      return [1, 0];
    };
  }
});

// ../../node_modules/sshpk/lib/key.js
var require_key = __commonJS({
  "../../node_modules/sshpk/lib/key.js"(exports2, module2) {
    module2.exports = Key;
    var assert3 = require_assert();
    var algs = require_algs();
    var crypto = require("crypto");
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var DiffieHellman = require_dhe().DiffieHellman;
    var errs = require_errors();
    var utils = require_utils();
    var PrivateKey = require_private_key();
    var edCompat;
    try {
      edCompat = require_ed_compat();
    } catch (e) {
    }
    var InvalidAlgorithmError = errs.InvalidAlgorithmError;
    var KeyParseError = errs.KeyParseError;
    var formats = {};
    formats["auto"] = require_auto();
    formats["pem"] = require_pem();
    formats["pkcs1"] = require_pkcs1();
    formats["pkcs8"] = require_pkcs8();
    formats["rfc4253"] = require_rfc4253();
    formats["ssh"] = require_ssh();
    formats["ssh-private"] = require_ssh_private();
    formats["openssh"] = formats["ssh-private"];
    formats["dnssec"] = require_dnssec();
    formats["putty"] = require_putty();
    formats["ppk"] = formats["putty"];
    function Key(opts) {
      assert3.object(opts, "options");
      assert3.arrayOfObject(opts.parts, "options.parts");
      assert3.string(opts.type, "options.type");
      assert3.optionalString(opts.comment, "options.comment");
      var algInfo = algs.info[opts.type];
      if (typeof algInfo !== "object")
        throw new InvalidAlgorithmError(opts.type);
      var partLookup = {};
      for (var i = 0; i < opts.parts.length; ++i) {
        var part = opts.parts[i];
        partLookup[part.name] = part;
      }
      this.type = opts.type;
      this.parts = opts.parts;
      this.part = partLookup;
      this.comment = void 0;
      this.source = opts.source;
      this._rfc4253Cache = opts._rfc4253Cache;
      this._hashCache = {};
      var sz;
      this.curve = void 0;
      if (this.type === "ecdsa") {
        var curve = this.part.curve.data.toString();
        this.curve = curve;
        sz = algs.curves[curve].size;
      } else if (this.type === "ed25519" || this.type === "curve25519") {
        sz = 256;
        this.curve = "curve25519";
      } else {
        var szPart = this.part[algInfo.sizePart];
        sz = szPart.data.length;
        sz = sz * 8 - utils.countZeros(szPart.data);
      }
      this.size = sz;
    }
    Key.formats = formats;
    Key.prototype.toBuffer = function(format, options) {
      if (format === void 0)
        format = "ssh";
      assert3.string(format, "format");
      assert3.object(formats[format], "formats[format]");
      assert3.optionalObject(options, "options");
      if (format === "rfc4253") {
        if (this._rfc4253Cache === void 0)
          this._rfc4253Cache = formats["rfc4253"].write(this);
        return this._rfc4253Cache;
      }
      return formats[format].write(this, options);
    };
    Key.prototype.toString = function(format, options) {
      return this.toBuffer(format, options).toString();
    };
    Key.prototype.hash = function(algo, type) {
      assert3.string(algo, "algorithm");
      assert3.optionalString(type, "type");
      if (type === void 0)
        type = "ssh";
      algo = algo.toLowerCase();
      if (algs.hashAlgs[algo] === void 0)
        throw new InvalidAlgorithmError(algo);
      var cacheKey = algo + "||" + type;
      if (this._hashCache[cacheKey])
        return this._hashCache[cacheKey];
      var buf;
      if (type === "ssh") {
        buf = this.toBuffer("rfc4253");
      } else if (type === "spki") {
        buf = formats.pkcs8.pkcs8ToBuffer(this);
      } else {
        throw new Error("Hash type " + type + " not supported");
      }
      var hash = crypto.createHash(algo).update(buf).digest();
      this._hashCache[cacheKey] = hash;
      return hash;
    };
    Key.prototype.fingerprint = function(algo, type) {
      if (algo === void 0)
        algo = "sha256";
      if (type === void 0)
        type = "ssh";
      assert3.string(algo, "algorithm");
      assert3.string(type, "type");
      var opts = {
        type: "key",
        hash: this.hash(algo, type),
        algorithm: algo,
        hashType: type
      };
      return new Fingerprint(opts);
    };
    Key.prototype.defaultHashAlgorithm = function() {
      var hashAlgo = "sha1";
      if (this.type === "rsa")
        hashAlgo = "sha256";
      if (this.type === "dsa" && this.size > 1024)
        hashAlgo = "sha256";
      if (this.type === "ed25519")
        hashAlgo = "sha512";
      if (this.type === "ecdsa") {
        if (this.size <= 256)
          hashAlgo = "sha256";
        else if (this.size <= 384)
          hashAlgo = "sha384";
        else
          hashAlgo = "sha512";
      }
      return hashAlgo;
    };
    Key.prototype.createVerify = function(hashAlgo) {
      if (hashAlgo === void 0)
        hashAlgo = this.defaultHashAlgorithm();
      assert3.string(hashAlgo, "hash algorithm");
      if (this.type === "ed25519" && edCompat !== void 0)
        return new edCompat.Verifier(this, hashAlgo);
      if (this.type === "curve25519")
        throw new Error("Curve25519 keys are not suitable for signing or verification");
      var v, nm, err;
      try {
        nm = hashAlgo.toUpperCase();
        v = crypto.createVerify(nm);
      } catch (e) {
        err = e;
      }
      if (v === void 0 || err instanceof Error && err.message.match(/Unknown message digest/)) {
        nm = "RSA-";
        nm += hashAlgo.toUpperCase();
        v = crypto.createVerify(nm);
      }
      assert3.ok(v, "failed to create verifier");
      var oldVerify = v.verify.bind(v);
      var key = this.toBuffer("pkcs8");
      var curve = this.curve;
      var self2 = this;
      v.verify = function(signature, fmt) {
        if (Signature.isSignature(signature, [2, 0])) {
          if (signature.type !== self2.type)
            return false;
          if (signature.hashAlgorithm && signature.hashAlgorithm !== hashAlgo)
            return false;
          if (signature.curve && self2.type === "ecdsa" && signature.curve !== curve)
            return false;
          return oldVerify(key, signature.toBuffer("asn1"));
        } else if (typeof signature === "string" || Buffer.isBuffer(signature)) {
          return oldVerify(key, signature, fmt);
        } else if (Signature.isSignature(signature, [1, 0])) {
          throw new Error("signature was created by too old a version of sshpk and cannot be verified");
        } else {
          throw new TypeError("signature must be a string, Buffer, or Signature object");
        }
      };
      return v;
    };
    Key.prototype.createDiffieHellman = function() {
      if (this.type === "rsa")
        throw new Error("RSA keys do not support Diffie-Hellman");
      return new DiffieHellman(this);
    };
    Key.prototype.createDH = Key.prototype.createDiffieHellman;
    Key.parse = function(data, format, options) {
      if (typeof data !== "string")
        assert3.buffer(data, "data");
      if (format === void 0)
        format = "auto";
      assert3.string(format, "format");
      if (typeof options === "string")
        options = { filename: options };
      assert3.optionalObject(options, "options");
      if (options === void 0)
        options = {};
      assert3.optionalString(options.filename, "options.filename");
      if (options.filename === void 0)
        options.filename = "(unnamed)";
      assert3.object(formats[format], "formats[format]");
      try {
        var k = formats[format].read(data, options);
        if (k instanceof PrivateKey)
          k = k.toPublic();
        if (!k.comment)
          k.comment = options.filename;
        return k;
      } catch (e) {
        if (e.name === "KeyEncryptedError")
          throw e;
        throw new KeyParseError(options.filename, format, e);
      }
    };
    Key.isKey = function(obj, ver) {
      return utils.isCompatible(obj, Key, ver);
    };
    Key.prototype._sshpkApiVersion = [1, 7];
    Key._oldVersionDetect = function(obj) {
      assert3.func(obj.toBuffer);
      assert3.func(obj.fingerprint);
      if (obj.createDH)
        return [1, 4];
      if (obj.defaultHashAlgorithm)
        return [1, 3];
      if (obj.formats["auto"])
        return [1, 2];
      if (obj.formats["pkcs1"])
        return [1, 1];
      return [1, 0];
    };
  }
});

// ../../node_modules/sshpk/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/sshpk/lib/index.js"(exports2, module2) {
    var Key = require_key();
    var Fingerprint = require_fingerprint();
    var Signature = require_signature();
    var PrivateKey = require_private_key();
    var Certificate = require_certificate();
    var Identity = require_identity();
    var errs = require_errors();
    module2.exports = {
      Key,
      parseKey: Key.parse,
      Fingerprint,
      parseFingerprint: Fingerprint.parse,
      Signature,
      parseSignature: Signature.parse,
      PrivateKey,
      parsePrivateKey: PrivateKey.parse,
      generatePrivateKey: PrivateKey.generate,
      Certificate,
      parseCertificate: Certificate.parse,
      createSelfSignedCertificate: Certificate.createSelfSigned,
      createCertificate: Certificate.create,
      Identity,
      identityFromDN: Identity.parseDN,
      identityForHost: Identity.forHost,
      identityForUser: Identity.forUser,
      identityForEmail: Identity.forEmail,
      identityFromArray: Identity.fromArray,
      FingerprintFormatError: errs.FingerprintFormatError,
      InvalidAlgorithmError: errs.InvalidAlgorithmError,
      KeyParseError: errs.KeyParseError,
      SignatureParseError: errs.SignatureParseError,
      KeyEncryptedError: errs.KeyEncryptedError,
      CertificateParseError: errs.CertificateParseError
    };
  }
});

// ../../node_modules/http-signature/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/http-signature/lib/utils.js"(exports2, module2) {
    var assert3 = require_assert();
    var sshpk = require_lib3();
    var util2 = require("util");
    var HASH_ALGOS = {
      "sha1": true,
      "sha256": true,
      "sha512": true
    };
    var PK_ALGOS = {
      "rsa": true,
      "dsa": true,
      "ecdsa": true
    };
    function HttpSignatureError(message, caller) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, caller || HttpSignatureError);
      this.message = message;
      this.name = caller.name;
    }
    util2.inherits(HttpSignatureError, Error);
    function InvalidAlgorithmError(message) {
      HttpSignatureError.call(this, message, InvalidAlgorithmError);
    }
    util2.inherits(InvalidAlgorithmError, HttpSignatureError);
    function validateAlgorithm(algorithm) {
      var alg = algorithm.toLowerCase().split("-");
      if (alg.length !== 2) {
        throw new InvalidAlgorithmError(alg[0].toUpperCase() + " is not a valid algorithm");
      }
      if (alg[0] !== "hmac" && !PK_ALGOS[alg[0]]) {
        throw new InvalidAlgorithmError(alg[0].toUpperCase() + " type keys are not supported");
      }
      if (!HASH_ALGOS[alg[1]]) {
        throw new InvalidAlgorithmError(alg[1].toUpperCase() + " is not a supported hash algorithm");
      }
      return alg;
    }
    module2.exports = {
      HASH_ALGOS,
      PK_ALGOS,
      HttpSignatureError,
      InvalidAlgorithmError,
      validateAlgorithm,
      sshKeyToPEM: function sshKeyToPEM(key) {
        assert3.string(key, "ssh_key");
        var k = sshpk.parseKey(key, "ssh");
        return k.toString("pem");
      },
      fingerprint: function fingerprint(key) {
        assert3.string(key, "ssh_key");
        var k = sshpk.parseKey(key, "ssh");
        return k.fingerprint("md5").toString("hex");
      },
      pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
        assert3.equal("string", typeof pem, "typeof pem");
        var k = sshpk.parseKey(pem, "pem");
        k.comment = comment;
        return k.toString("ssh");
      }
    };
  }
});

// ../../node_modules/http-signature/lib/parser.js
var require_parser3 = __commonJS({
  "../../node_modules/http-signature/lib/parser.js"(exports2, module2) {
    var assert3 = require_assert();
    var util2 = require("util");
    var utils = require_utils2();
    var HASH_ALGOS = utils.HASH_ALGOS;
    var PK_ALGOS = utils.PK_ALGOS;
    var HttpSignatureError = utils.HttpSignatureError;
    var InvalidAlgorithmError = utils.InvalidAlgorithmError;
    var validateAlgorithm = utils.validateAlgorithm;
    var State = {
      New: 0,
      Params: 1
    };
    var ParamsState = {
      Name: 0,
      Quote: 1,
      Value: 2,
      Comma: 3
    };
    function ExpiredRequestError(message) {
      HttpSignatureError.call(this, message, ExpiredRequestError);
    }
    util2.inherits(ExpiredRequestError, HttpSignatureError);
    function InvalidHeaderError(message) {
      HttpSignatureError.call(this, message, InvalidHeaderError);
    }
    util2.inherits(InvalidHeaderError, HttpSignatureError);
    function InvalidParamsError(message) {
      HttpSignatureError.call(this, message, InvalidParamsError);
    }
    util2.inherits(InvalidParamsError, HttpSignatureError);
    function MissingHeaderError(message) {
      HttpSignatureError.call(this, message, MissingHeaderError);
    }
    util2.inherits(MissingHeaderError, HttpSignatureError);
    function StrictParsingError(message) {
      HttpSignatureError.call(this, message, StrictParsingError);
    }
    util2.inherits(StrictParsingError, HttpSignatureError);
    module2.exports = {
      parseRequest: function parseRequest(request, options) {
        assert3.object(request, "request");
        assert3.object(request.headers, "request.headers");
        if (options === void 0) {
          options = {};
        }
        if (options.headers === void 0) {
          options.headers = [request.headers["x-date"] ? "x-date" : "date"];
        }
        assert3.object(options, "options");
        assert3.arrayOfString(options.headers, "options.headers");
        assert3.optionalFinite(options.clockSkew, "options.clockSkew");
        var authzHeaderName = options.authorizationHeaderName || "authorization";
        if (!request.headers[authzHeaderName]) {
          throw new MissingHeaderError("no " + authzHeaderName + " header present in the request");
        }
        options.clockSkew = options.clockSkew || 300;
        var i = 0;
        var state = State.New;
        var substate = ParamsState.Name;
        var tmpName = "";
        var tmpValue = "";
        var parsed = {
          scheme: "",
          params: {},
          signingString: ""
        };
        var authz = request.headers[authzHeaderName];
        for (i = 0; i < authz.length; i++) {
          var c = authz.charAt(i);
          switch (Number(state)) {
            case State.New:
              if (c !== " ")
                parsed.scheme += c;
              else
                state = State.Params;
              break;
            case State.Params:
              switch (Number(substate)) {
                case ParamsState.Name:
                  var code = c.charCodeAt(0);
                  if (code >= 65 && code <= 90 || code >= 97 && code <= 122) {
                    tmpName += c;
                  } else if (c === "=") {
                    if (tmpName.length === 0)
                      throw new InvalidHeaderError("bad param format");
                    substate = ParamsState.Quote;
                  } else {
                    throw new InvalidHeaderError("bad param format");
                  }
                  break;
                case ParamsState.Quote:
                  if (c === '"') {
                    tmpValue = "";
                    substate = ParamsState.Value;
                  } else {
                    throw new InvalidHeaderError("bad param format");
                  }
                  break;
                case ParamsState.Value:
                  if (c === '"') {
                    parsed.params[tmpName] = tmpValue;
                    substate = ParamsState.Comma;
                  } else {
                    tmpValue += c;
                  }
                  break;
                case ParamsState.Comma:
                  if (c === ",") {
                    tmpName = "";
                    substate = ParamsState.Name;
                  } else {
                    throw new InvalidHeaderError("bad param format");
                  }
                  break;
                default:
                  throw new Error("Invalid substate");
              }
              break;
            default:
              throw new Error("Invalid substate");
          }
        }
        if (!parsed.params.headers || parsed.params.headers === "") {
          if (request.headers["x-date"]) {
            parsed.params.headers = ["x-date"];
          } else {
            parsed.params.headers = ["date"];
          }
        } else {
          parsed.params.headers = parsed.params.headers.split(" ");
        }
        if (!parsed.scheme || parsed.scheme !== "Signature")
          throw new InvalidHeaderError('scheme was not "Signature"');
        if (!parsed.params.keyId)
          throw new InvalidHeaderError("keyId was not specified");
        if (!parsed.params.algorithm)
          throw new InvalidHeaderError("algorithm was not specified");
        if (!parsed.params.signature)
          throw new InvalidHeaderError("signature was not specified");
        parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
        try {
          validateAlgorithm(parsed.params.algorithm);
        } catch (e) {
          if (e instanceof InvalidAlgorithmError)
            throw new InvalidParamsError(parsed.params.algorithm + " is not supported");
          else
            throw e;
        }
        for (i = 0; i < parsed.params.headers.length; i++) {
          var h = parsed.params.headers[i].toLowerCase();
          parsed.params.headers[i] = h;
          if (h === "request-line") {
            if (!options.strict) {
              parsed.signingString += request.method + " " + request.url + " HTTP/" + request.httpVersion;
            } else {
              throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
            }
          } else if (h === "(request-target)") {
            parsed.signingString += "(request-target): " + request.method.toLowerCase() + " " + request.url;
          } else {
            var value = request.headers[h];
            if (value === void 0)
              throw new MissingHeaderError(h + " was not in the request");
            parsed.signingString += h + ": " + value;
          }
          if (i + 1 < parsed.params.headers.length)
            parsed.signingString += "\n";
        }
        var date;
        if (request.headers.date || request.headers["x-date"]) {
          if (request.headers["x-date"]) {
            date = new Date(request.headers["x-date"]);
          } else {
            date = new Date(request.headers.date);
          }
          var now = new Date();
          var skew = Math.abs(now.getTime() - date.getTime());
          if (skew > options.clockSkew * 1e3) {
            throw new ExpiredRequestError("clock skew of " + skew / 1e3 + "s was greater than " + options.clockSkew + "s");
          }
        }
        options.headers.forEach(function(hdr) {
          if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
            throw new MissingHeaderError(hdr + " was not a signed header");
        });
        if (options.algorithms) {
          if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
            throw new InvalidParamsError(parsed.params.algorithm + " is not a supported algorithm");
        }
        parsed.algorithm = parsed.params.algorithm.toUpperCase();
        parsed.keyId = parsed.params.keyId;
        return parsed;
      }
    };
  }
});

// ../../node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf = __commonJS({
  "../../node_modules/extsprintf/lib/extsprintf.js"(exports2) {
    var mod_assert = require("assert");
    var mod_util = require("util");
    exports2.sprintf = jsSprintf;
    exports2.printf = jsPrintf;
    exports2.fprintf = jsFprintf;
    function jsSprintf(fmt) {
      var regex = [
        "([^%]*)",
        "%",
        "(['\\-+ #0]*?)",
        "([1-9]\\d*)?",
        "(\\.([1-9]\\d*))?",
        "[lhjztL]*?",
        "([diouxXfFeEgGaAcCsSp%jr])"
      ].join("");
      var re = new RegExp(regex);
      var args = Array.prototype.slice.call(arguments, 1);
      var flags, width, precision, conversion;
      var left, pad, sign, arg, match;
      var ret = "";
      var argn = 1;
      mod_assert.equal("string", typeof fmt);
      while ((match = re.exec(fmt)) !== null) {
        ret += match[1];
        fmt = fmt.substring(match[0].length);
        flags = match[2] || "";
        width = match[3] || 0;
        precision = match[4] || "";
        conversion = match[6];
        left = false;
        sign = false;
        pad = " ";
        if (conversion == "%") {
          ret += "%";
          continue;
        }
        if (args.length === 0)
          throw new Error("too few args to sprintf");
        arg = args.shift();
        argn++;
        if (flags.match(/[\' #]/))
          throw new Error("unsupported flags: " + flags);
        if (precision.length > 0)
          throw new Error("non-zero precision not supported");
        if (flags.match(/-/))
          left = true;
        if (flags.match(/0/))
          pad = "0";
        if (flags.match(/\+/))
          sign = true;
        switch (conversion) {
          case "s":
            if (arg === void 0 || arg === null)
              throw new Error("argument " + argn + ": attempted to print undefined or null as a string");
            ret += doPad(pad, width, left, arg.toString());
            break;
          case "d":
            arg = Math.floor(arg);
          case "f":
            sign = sign && arg > 0 ? "+" : "";
            ret += sign + doPad(pad, width, left, arg.toString());
            break;
          case "x":
            ret += doPad(pad, width, left, arg.toString(16));
            break;
          case "j":
            if (width === 0)
              width = 10;
            ret += mod_util.inspect(arg, false, width);
            break;
          case "r":
            ret += dumpException(arg);
            break;
          default:
            throw new Error("unsupported conversion: " + conversion);
        }
      }
      ret += fmt;
      return ret;
    }
    function jsPrintf() {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(process.stdout);
      jsFprintf.apply(null, args);
    }
    function jsFprintf(stream) {
      var args = Array.prototype.slice.call(arguments, 1);
      return stream.write(jsSprintf.apply(this, args));
    }
    function doPad(chr, width, left, str) {
      var ret = str;
      while (ret.length < width) {
        if (left)
          ret += chr;
        else
          ret = chr + ret;
      }
      return ret;
    }
    function dumpException(ex) {
      var ret;
      if (!(ex instanceof Error))
        throw new Error(jsSprintf("invalid type for %%r: %j", ex));
      ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
      if (ex.cause && typeof ex.cause === "function") {
        var cex = ex.cause();
        if (cex) {
          ret += "\nCaused by: " + dumpException(cex);
        }
      }
      return ret;
    }
  }
});

// ../../node_modules/verror/node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf2 = __commonJS({
  "../../node_modules/verror/node_modules/extsprintf/lib/extsprintf.js"(exports2) {
    var mod_assert = require("assert");
    var mod_util = require("util");
    exports2.sprintf = jsSprintf;
    exports2.printf = jsPrintf;
    exports2.fprintf = jsFprintf;
    function jsSprintf(ofmt) {
      var regex = [
        "([^%]*)",
        "%",
        "(['\\-+ #0]*?)",
        "([1-9]\\d*)?",
        "(\\.([1-9]\\d*))?",
        "[lhjztL]*?",
        "([diouxXfFeEgGaAcCsSp%jr])"
      ].join("");
      var re = new RegExp(regex);
      var args = Array.prototype.slice.call(arguments, 1);
      var fmt = ofmt;
      var flags, width, precision, conversion;
      var left, pad, sign, arg, match;
      var ret = "";
      var argn = 1;
      var posn = 0;
      var convposn;
      var curconv;
      mod_assert.equal("string", typeof fmt, "first argument must be a format string");
      while ((match = re.exec(fmt)) !== null) {
        ret += match[1];
        fmt = fmt.substring(match[0].length);
        curconv = match[0].substring(match[1].length);
        convposn = posn + match[1].length + 1;
        posn += match[0].length;
        flags = match[2] || "";
        width = match[3] || 0;
        precision = match[4] || "";
        conversion = match[6];
        left = false;
        sign = false;
        pad = " ";
        if (conversion == "%") {
          ret += "%";
          continue;
        }
        if (args.length === 0) {
          throw jsError(ofmt, convposn, curconv, "has no matching argument (too few arguments passed)");
        }
        arg = args.shift();
        argn++;
        if (flags.match(/[\' #]/)) {
          throw jsError(ofmt, convposn, curconv, "uses unsupported flags");
        }
        if (precision.length > 0) {
          throw jsError(ofmt, convposn, curconv, "uses non-zero precision (not supported)");
        }
        if (flags.match(/-/))
          left = true;
        if (flags.match(/0/))
          pad = "0";
        if (flags.match(/\+/))
          sign = true;
        switch (conversion) {
          case "s":
            if (arg === void 0 || arg === null) {
              throw jsError(ofmt, convposn, curconv, "attempted to print undefined or null as a string (argument " + argn + " to sprintf)");
            }
            ret += doPad(pad, width, left, arg.toString());
            break;
          case "d":
            arg = Math.floor(arg);
          case "f":
            sign = sign && arg > 0 ? "+" : "";
            ret += sign + doPad(pad, width, left, arg.toString());
            break;
          case "x":
            ret += doPad(pad, width, left, arg.toString(16));
            break;
          case "j":
            if (width === 0)
              width = 10;
            ret += mod_util.inspect(arg, false, width);
            break;
          case "r":
            ret += dumpException(arg);
            break;
          default:
            throw jsError(ofmt, convposn, curconv, "is not supported");
        }
      }
      ret += fmt;
      return ret;
    }
    function jsError(fmtstr, convposn, curconv, reason) {
      mod_assert.equal(typeof fmtstr, "string");
      mod_assert.equal(typeof curconv, "string");
      mod_assert.equal(typeof convposn, "number");
      mod_assert.equal(typeof reason, "string");
      return new Error('format string "' + fmtstr + '": conversion specifier "' + curconv + '" at character ' + convposn + " " + reason);
    }
    function jsPrintf() {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(process.stdout);
      jsFprintf.apply(null, args);
    }
    function jsFprintf(stream) {
      var args = Array.prototype.slice.call(arguments, 1);
      return stream.write(jsSprintf.apply(this, args));
    }
    function doPad(chr, width, left, str) {
      var ret = str;
      while (ret.length < width) {
        if (left)
          ret += chr;
        else
          ret = chr + ret;
      }
      return ret;
    }
    function dumpException(ex) {
      var ret;
      if (!(ex instanceof Error))
        throw new Error(jsSprintf("invalid type for %%r: %j", ex));
      ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
      if (ex.cause && typeof ex.cause === "function") {
        var cex = ex.cause();
        if (cex) {
          ret += "\nCaused by: " + dumpException(cex);
        }
      }
      return ret;
    }
  }
});

// ../../node_modules/verror/lib/verror.js
var require_verror = __commonJS({
  "../../node_modules/verror/lib/verror.js"(exports2, module2) {
    var mod_assertplus = require_assert();
    var mod_util = require("util");
    var mod_extsprintf = require_extsprintf2();
    var mod_isError = require_util().isError;
    var sprintf = mod_extsprintf.sprintf;
    module2.exports = VError;
    VError.VError = VError;
    VError.SError = SError;
    VError.WError = WError;
    VError.MultiError = MultiError;
    function parseConstructorArguments(args) {
      var argv, options, sprintf_args, shortmessage, k;
      mod_assertplus.object(args, "args");
      mod_assertplus.bool(args.strict, "args.strict");
      mod_assertplus.array(args.argv, "args.argv");
      argv = args.argv;
      if (argv.length === 0) {
        options = {};
        sprintf_args = [];
      } else if (mod_isError(argv[0])) {
        options = { "cause": argv[0] };
        sprintf_args = argv.slice(1);
      } else if (typeof argv[0] === "object") {
        options = {};
        for (k in argv[0]) {
          options[k] = argv[0][k];
        }
        sprintf_args = argv.slice(1);
      } else {
        mod_assertplus.string(argv[0], "first argument to VError, SError, or WError constructor must be a string, object, or Error");
        options = {};
        sprintf_args = argv;
      }
      mod_assertplus.object(options);
      if (!options.strict && !args.strict) {
        sprintf_args = sprintf_args.map(function(a) {
          return a === null ? "null" : a === void 0 ? "undefined" : a;
        });
      }
      if (sprintf_args.length === 0) {
        shortmessage = "";
      } else {
        shortmessage = sprintf.apply(null, sprintf_args);
      }
      return {
        "options": options,
        "shortmessage": shortmessage
      };
    }
    function VError() {
      var args, obj, parsed, cause, ctor, message, k;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof VError)) {
        obj = Object.create(VError.prototype);
        VError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      if (parsed.options.name) {
        mod_assertplus.string(parsed.options.name, `error's "name" must be a string`);
        this.name = parsed.options.name;
      }
      this.jse_shortmsg = parsed.shortmessage;
      message = parsed.shortmessage;
      cause = parsed.options.cause;
      if (cause) {
        mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
        this.jse_cause = cause;
        if (!parsed.options.skipCauseMessage) {
          message += ": " + cause.message;
        }
      }
      this.jse_info = {};
      if (parsed.options.info) {
        for (k in parsed.options.info) {
          this.jse_info[k] = parsed.options.info[k];
        }
      }
      this.message = message;
      Error.call(this, message);
      if (Error.captureStackTrace) {
        ctor = parsed.options.constructorOpt || this.constructor;
        Error.captureStackTrace(this, ctor);
      }
      return this;
    }
    mod_util.inherits(VError, Error);
    VError.prototype.name = "VError";
    VError.prototype.toString = function ve_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      return str;
    };
    VError.prototype.cause = function ve_cause() {
      var cause = VError.cause(this);
      return cause === null ? void 0 : cause;
    };
    VError.cause = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      return mod_isError(err.jse_cause) ? err.jse_cause : null;
    };
    VError.info = function(err) {
      var rv, cause, k;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      cause = VError.cause(err);
      if (cause !== null) {
        rv = VError.info(cause);
      } else {
        rv = {};
      }
      if (typeof err.jse_info == "object" && err.jse_info !== null) {
        for (k in err.jse_info) {
          rv[k] = err.jse_info[k];
        }
      }
      return rv;
    };
    VError.findCauseByName = function(err, name) {
      var cause;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.string(name, "name");
      mod_assertplus.ok(name.length > 0, "name cannot be empty");
      for (cause = err; cause !== null; cause = VError.cause(cause)) {
        mod_assertplus.ok(mod_isError(cause));
        if (cause.name == name) {
          return cause;
        }
      }
      return null;
    };
    VError.hasCauseWithName = function(err, name) {
      return VError.findCauseByName(err, name) !== null;
    };
    VError.fullStack = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      var cause = VError.cause(err);
      if (cause) {
        return err.stack + "\ncaused by: " + VError.fullStack(cause);
      }
      return err.stack;
    };
    VError.errorFromList = function(errors) {
      mod_assertplus.arrayOfObject(errors, "errors");
      if (errors.length === 0) {
        return null;
      }
      errors.forEach(function(e) {
        mod_assertplus.ok(mod_isError(e));
      });
      if (errors.length == 1) {
        return errors[0];
      }
      return new MultiError(errors);
    };
    VError.errorForEach = function(err, func) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.func(func, "func");
      if (err instanceof MultiError) {
        err.errors().forEach(function iterError(e) {
          func(e);
        });
      } else {
        func(err);
      }
    };
    function SError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof SError)) {
        obj = Object.create(SError.prototype);
        SError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": true
      });
      options = parsed.options;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(SError, VError);
    function MultiError(errors) {
      mod_assertplus.array(errors, "list of errors");
      mod_assertplus.ok(errors.length > 0, "must be at least one error");
      this.ase_errors = errors;
      VError.call(this, {
        "cause": errors[0]
      }, "first of %d error%s", errors.length, errors.length == 1 ? "" : "s");
    }
    mod_util.inherits(MultiError, VError);
    MultiError.prototype.name = "MultiError";
    MultiError.prototype.errors = function me_errors() {
      return this.ase_errors.slice(0);
    };
    function WError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof WError)) {
        obj = Object.create(WError.prototype);
        WError.apply(obj, args);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      options = parsed.options;
      options["skipCauseMessage"] = true;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(WError, VError);
    WError.prototype.name = "WError";
    WError.prototype.toString = function we_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      if (this.jse_cause && this.jse_cause.message)
        str += "; caused by " + this.jse_cause.toString();
      return str;
    };
    WError.prototype.cause = function we_cause(c) {
      if (mod_isError(c))
        this.jse_cause = c;
      return this.jse_cause;
    };
  }
});

// ../../node_modules/json-schema/lib/validate.js
var require_validate = __commonJS({
  "../../node_modules/json-schema/lib/validate.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return factory();
        });
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.jsonSchema = factory();
      }
    })(exports2, function() {
      var exports3 = validate;
      exports3.Integer = { type: "integer" };
      var primitiveConstructors = {
        String,
        Boolean,
        Number,
        Object,
        Array,
        Date
      };
      exports3.validate = validate;
      function validate(instance, schema) {
        return validate(instance, schema, { changing: false });
      }
      ;
      exports3.checkPropertyChange = function(value, schema, property) {
        return validate(value, schema, { changing: property || "property" });
      };
      var validate = exports3._validate = function(instance, schema, options) {
        if (!options)
          options = {};
        var _changing = options.changing;
        function getType(schema2) {
          return schema2.type || primitiveConstructors[schema2.name] == schema2 && schema2.name.toLowerCase();
        }
        var errors = [];
        function checkProp(value, schema2, path2, i) {
          var l;
          path2 += path2 ? typeof i == "number" ? "[" + i + "]" : typeof i == "undefined" ? "" : "." + i : i;
          function addError(message) {
            errors.push({ property: path2, message });
          }
          if ((typeof schema2 != "object" || schema2 instanceof Array) && (path2 || typeof schema2 != "function") && !(schema2 && getType(schema2))) {
            if (typeof schema2 == "function") {
              if (!(value instanceof schema2)) {
                addError("is not an instance of the class/constructor " + schema2.name);
              }
            } else if (schema2) {
              addError("Invalid schema/property definition " + schema2);
            }
            return null;
          }
          if (_changing && schema2.readonly) {
            addError("is a readonly field, it can not be changed");
          }
          if (schema2["extends"]) {
            checkProp(value, schema2["extends"], path2, i);
          }
          function checkType(type, value2) {
            if (type) {
              if (typeof type == "string" && type != "any" && (type == "null" ? value2 !== null : typeof value2 != type) && !(value2 instanceof Array && type == "array") && !(value2 instanceof Date && type == "date") && !(type == "integer" && value2 % 1 === 0)) {
                return [{ property: path2, message: typeof value2 + " value found, but a " + type + " is required" }];
              }
              if (type instanceof Array) {
                var unionErrors = [];
                for (var j2 = 0; j2 < type.length; j2++) {
                  if (!(unionErrors = checkType(type[j2], value2)).length) {
                    break;
                  }
                }
                if (unionErrors.length) {
                  return unionErrors;
                }
              } else if (typeof type == "object") {
                var priorErrors = errors;
                errors = [];
                checkProp(value2, type, path2);
                var theseErrors = errors;
                errors = priorErrors;
                return theseErrors;
              }
            }
            return [];
          }
          if (value === void 0) {
            if (schema2.required) {
              addError("is missing and it is required");
            }
          } else {
            errors = errors.concat(checkType(getType(schema2), value));
            if (schema2.disallow && !checkType(schema2.disallow, value).length) {
              addError(" disallowed value was matched");
            }
            if (value !== null) {
              if (value instanceof Array) {
                if (schema2.items) {
                  var itemsIsArray = schema2.items instanceof Array;
                  var propDef = schema2.items;
                  for (i = 0, l = value.length; i < l; i += 1) {
                    if (itemsIsArray)
                      propDef = schema2.items[i];
                    if (options.coerce)
                      value[i] = options.coerce(value[i], propDef);
                    errors.concat(checkProp(value[i], propDef, path2, i));
                  }
                }
                if (schema2.minItems && value.length < schema2.minItems) {
                  addError("There must be a minimum of " + schema2.minItems + " in the array");
                }
                if (schema2.maxItems && value.length > schema2.maxItems) {
                  addError("There must be a maximum of " + schema2.maxItems + " in the array");
                }
              } else if (schema2.properties || schema2.additionalProperties) {
                errors.concat(checkObj(value, schema2.properties, path2, schema2.additionalProperties));
              }
              if (schema2.pattern && typeof value == "string" && !value.match(schema2.pattern)) {
                addError("does not match the regex pattern " + schema2.pattern);
              }
              if (schema2.maxLength && typeof value == "string" && value.length > schema2.maxLength) {
                addError("may only be " + schema2.maxLength + " characters long");
              }
              if (schema2.minLength && typeof value == "string" && value.length < schema2.minLength) {
                addError("must be at least " + schema2.minLength + " characters long");
              }
              if (typeof schema2.minimum !== void 0 && typeof value == typeof schema2.minimum && schema2.minimum > value) {
                addError("must have a minimum value of " + schema2.minimum);
              }
              if (typeof schema2.maximum !== void 0 && typeof value == typeof schema2.maximum && schema2.maximum < value) {
                addError("must have a maximum value of " + schema2.maximum);
              }
              if (schema2["enum"]) {
                var enumer = schema2["enum"];
                l = enumer.length;
                var found;
                for (var j = 0; j < l; j++) {
                  if (enumer[j] === value) {
                    found = 1;
                    break;
                  }
                }
                if (!found) {
                  addError("does not have a value in the enumeration " + enumer.join(", "));
                }
              }
              if (typeof schema2.maxDecimal == "number" && value.toString().match(new RegExp("\\.[0-9]{" + (schema2.maxDecimal + 1) + ",}"))) {
                addError("may only have " + schema2.maxDecimal + " digits of decimal places");
              }
            }
          }
          return null;
        }
        function checkObj(instance2, objTypeDef, path2, additionalProp) {
          if (typeof objTypeDef == "object") {
            if (typeof instance2 != "object" || instance2 instanceof Array) {
              errors.push({ property: path2, message: "an object is required" });
            }
            for (var i in objTypeDef) {
              if (objTypeDef.hasOwnProperty(i)) {
                var value = instance2[i];
                if (value === void 0 && options.existingOnly)
                  continue;
                var propDef = objTypeDef[i];
                if (value === void 0 && propDef["default"]) {
                  value = instance2[i] = propDef["default"];
                }
                if (options.coerce && i in instance2) {
                  value = instance2[i] = options.coerce(value, propDef);
                }
                checkProp(value, propDef, path2, i);
              }
            }
          }
          for (i in instance2) {
            if (instance2.hasOwnProperty(i) && !(i.charAt(0) == "_" && i.charAt(1) == "_") && objTypeDef && !objTypeDef[i] && additionalProp === false) {
              if (options.filter) {
                delete instance2[i];
                continue;
              } else {
                errors.push({ property: path2, message: typeof value + "The property " + i + " is not defined in the schema and the schema does not allow additional properties" });
              }
            }
            var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
            if (requires && !(requires in instance2)) {
              errors.push({ property: path2, message: "the presence of the property " + i + " requires that " + requires + " also be present" });
            }
            value = instance2[i];
            if (additionalProp && (!(objTypeDef && typeof objTypeDef == "object") || !(i in objTypeDef))) {
              if (options.coerce) {
                value = instance2[i] = options.coerce(value, additionalProp);
              }
              checkProp(value, additionalProp, path2, i);
            }
            if (!_changing && value && value.$schema) {
              errors = errors.concat(checkProp(value, value.$schema, path2, i));
            }
          }
          return errors;
        }
        if (schema) {
          checkProp(instance, schema, "", _changing || "");
        }
        if (!_changing && instance && instance.$schema) {
          checkProp(instance, instance.$schema, "", "");
        }
        return { valid: !errors.length, errors };
      };
      exports3.mustBeValid = function(result) {
        if (!result.valid) {
          throw new TypeError(result.errors.map(function(error) {
            return "for property " + error.property + ": " + error.message;
          }).join(", \n"));
        }
      };
      return exports3;
    });
  }
});

// ../../node_modules/jsprim/lib/jsprim.js
var require_jsprim = __commonJS({
  "../../node_modules/jsprim/lib/jsprim.js"(exports2) {
    var mod_assert = require_assert();
    var mod_util = require("util");
    var mod_extsprintf = require_extsprintf();
    var mod_verror = require_verror();
    var mod_jsonschema = require_validate();
    exports2.deepCopy = deepCopy;
    exports2.deepEqual = deepEqual;
    exports2.isEmpty = isEmpty;
    exports2.hasKey = hasKey;
    exports2.forEachKey = forEachKey;
    exports2.pluck = pluck;
    exports2.flattenObject = flattenObject;
    exports2.flattenIter = flattenIter;
    exports2.validateJsonObject = validateJsonObjectJS;
    exports2.validateJsonObjectJS = validateJsonObjectJS;
    exports2.randElt = randElt;
    exports2.extraProperties = extraProperties;
    exports2.mergeObjects = mergeObjects;
    exports2.startsWith = startsWith;
    exports2.endsWith = endsWith;
    exports2.parseInteger = parseInteger;
    exports2.iso8601 = iso8601;
    exports2.rfc1123 = rfc1123;
    exports2.parseDateTime = parseDateTime;
    exports2.hrtimediff = hrtimeDiff;
    exports2.hrtimeDiff = hrtimeDiff;
    exports2.hrtimeAccum = hrtimeAccum;
    exports2.hrtimeAdd = hrtimeAdd;
    exports2.hrtimeNanosec = hrtimeNanosec;
    exports2.hrtimeMicrosec = hrtimeMicrosec;
    exports2.hrtimeMillisec = hrtimeMillisec;
    function deepCopy(obj) {
      var ret, key;
      var marker = "__deepCopy";
      if (obj && obj[marker])
        throw new Error("attempted deep copy of cyclic object");
      if (obj && obj.constructor == Object) {
        ret = {};
        obj[marker] = true;
        for (key in obj) {
          if (key == marker)
            continue;
          ret[key] = deepCopy(obj[key]);
        }
        delete obj[marker];
        return ret;
      }
      if (obj && obj.constructor == Array) {
        ret = [];
        obj[marker] = true;
        for (key = 0; key < obj.length; key++)
          ret.push(deepCopy(obj[key]));
        delete obj[marker];
        return ret;
      }
      return obj;
    }
    function deepEqual(obj1, obj2) {
      if (typeof obj1 != typeof obj2)
        return false;
      if (obj1 === null || obj2 === null || typeof obj1 != "object")
        return obj1 === obj2;
      if (obj1.constructor != obj2.constructor)
        return false;
      var k;
      for (k in obj1) {
        if (!obj2.hasOwnProperty(k))
          return false;
        if (!deepEqual(obj1[k], obj2[k]))
          return false;
      }
      for (k in obj2) {
        if (!obj1.hasOwnProperty(k))
          return false;
      }
      return true;
    }
    function isEmpty(obj) {
      var key;
      for (key in obj)
        return false;
      return true;
    }
    function hasKey(obj, key) {
      mod_assert.equal(typeof key, "string");
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function forEachKey(obj, callback) {
      for (var key in obj) {
        if (hasKey(obj, key)) {
          callback(key, obj[key]);
        }
      }
    }
    function pluck(obj, key) {
      mod_assert.equal(typeof key, "string");
      return pluckv(obj, key);
    }
    function pluckv(obj, key) {
      if (obj === null || typeof obj !== "object")
        return void 0;
      if (obj.hasOwnProperty(key))
        return obj[key];
      var i = key.indexOf(".");
      if (i == -1)
        return void 0;
      var key1 = key.substr(0, i);
      if (!obj.hasOwnProperty(key1))
        return void 0;
      return pluckv(obj[key1], key.substr(i + 1));
    }
    function flattenIter(data, depth, callback) {
      doFlattenIter(data, depth, [], callback);
    }
    function doFlattenIter(data, depth, accum, callback) {
      var each;
      var key;
      if (depth === 0) {
        each = accum.slice(0);
        each.push(data);
        callback(each);
        return;
      }
      mod_assert.ok(data !== null);
      mod_assert.equal(typeof data, "object");
      mod_assert.equal(typeof depth, "number");
      mod_assert.ok(depth >= 0);
      for (key in data) {
        each = accum.slice(0);
        each.push(key);
        doFlattenIter(data[key], depth - 1, each, callback);
      }
    }
    function flattenObject(data, depth) {
      if (depth === 0)
        return [data];
      mod_assert.ok(data !== null);
      mod_assert.equal(typeof data, "object");
      mod_assert.equal(typeof depth, "number");
      mod_assert.ok(depth >= 0);
      var rv = [];
      var key;
      for (key in data) {
        flattenObject(data[key], depth - 1).forEach(function(p) {
          rv.push([key].concat(p));
        });
      }
      return rv;
    }
    function startsWith(str, prefix) {
      return str.substr(0, prefix.length) == prefix;
    }
    function endsWith(str, suffix) {
      return str.substr(str.length - suffix.length, suffix.length) == suffix;
    }
    function iso8601(d) {
      if (typeof d == "number")
        d = new Date(d);
      mod_assert.ok(d.constructor === Date);
      return mod_extsprintf.sprintf("%4d-%02d-%02dT%02d:%02d:%02d.%03dZ", d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
    }
    var RFC1123_MONTHS = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var RFC1123_DAYS = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    function rfc1123(date) {
      return mod_extsprintf.sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT", RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(), RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
    }
    function parseDateTime(str) {
      var numeric = +str;
      if (!isNaN(numeric)) {
        return new Date(numeric);
      } else {
        return new Date(str);
      }
    }
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var PI_DEFAULTS = {
      base: 10,
      allowSign: true,
      allowPrefix: false,
      allowTrailing: false,
      allowImprecise: false,
      trimWhitespace: false,
      leadingZeroIsOctal: false
    };
    var CP_0 = 48;
    var CP_9 = 57;
    var CP_A = 65;
    var CP_B = 66;
    var CP_O = 79;
    var CP_T = 84;
    var CP_X = 88;
    var CP_Z = 90;
    var CP_a = 97;
    var CP_b = 98;
    var CP_o = 111;
    var CP_t = 116;
    var CP_x = 120;
    var CP_z = 122;
    var PI_CONV_DEC = 48;
    var PI_CONV_UC = 55;
    var PI_CONV_LC = 87;
    function parseInteger(str, uopts) {
      mod_assert.string(str, "str");
      mod_assert.optionalObject(uopts, "options");
      var baseOverride = false;
      var options = PI_DEFAULTS;
      if (uopts) {
        baseOverride = hasKey(uopts, "base");
        options = mergeObjects(options, uopts);
        mod_assert.number(options.base, "options.base");
        mod_assert.ok(options.base >= 2, "options.base >= 2");
        mod_assert.ok(options.base <= 36, "options.base <= 36");
        mod_assert.bool(options.allowSign, "options.allowSign");
        mod_assert.bool(options.allowPrefix, "options.allowPrefix");
        mod_assert.bool(options.allowTrailing, "options.allowTrailing");
        mod_assert.bool(options.allowImprecise, "options.allowImprecise");
        mod_assert.bool(options.trimWhitespace, "options.trimWhitespace");
        mod_assert.bool(options.leadingZeroIsOctal, "options.leadingZeroIsOctal");
        if (options.leadingZeroIsOctal) {
          mod_assert.ok(!baseOverride, '"base" and "leadingZeroIsOctal" are mutually exclusive');
        }
      }
      var c;
      var pbase = -1;
      var base = options.base;
      var start;
      var mult = 1;
      var value = 0;
      var idx = 0;
      var len = str.length;
      if (options.trimWhitespace) {
        while (idx < len && isSpace(str.charCodeAt(idx))) {
          ++idx;
        }
      }
      if (options.allowSign) {
        if (str[idx] === "-") {
          idx += 1;
          mult = -1;
        } else if (str[idx] === "+") {
          idx += 1;
        }
      }
      if (str[idx] === "0") {
        if (options.allowPrefix) {
          pbase = prefixToBase(str.charCodeAt(idx + 1));
          if (pbase !== -1 && (!baseOverride || pbase === base)) {
            base = pbase;
            idx += 2;
          }
        }
        if (pbase === -1 && options.leadingZeroIsOctal) {
          base = 8;
        }
      }
      for (start = idx; idx < len; ++idx) {
        c = translateDigit(str.charCodeAt(idx));
        if (c !== -1 && c < base) {
          value *= base;
          value += c;
        } else {
          break;
        }
      }
      if (start === idx) {
        return new Error("invalid number: " + JSON.stringify(str));
      }
      if (options.trimWhitespace) {
        while (idx < len && isSpace(str.charCodeAt(idx))) {
          ++idx;
        }
      }
      if (idx < len && !options.allowTrailing) {
        return new Error("trailing characters after number: " + JSON.stringify(str.slice(idx)));
      }
      if (value === 0) {
        return 0;
      }
      var result = value * mult;
      if (!options.allowImprecise && (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
        return new Error("number is outside of the supported range: " + JSON.stringify(str.slice(start, idx)));
      }
      return result;
    }
    function translateDigit(d) {
      if (d >= CP_0 && d <= CP_9) {
        return d - PI_CONV_DEC;
      } else if (d >= CP_A && d <= CP_Z) {
        return d - PI_CONV_UC;
      } else if (d >= CP_a && d <= CP_z) {
        return d - PI_CONV_LC;
      } else {
        return -1;
      }
    }
    function isSpace(c) {
      return c === 32 || c >= 9 && c <= 13 || c === 160 || c === 5760 || c === 6158 || c >= 8192 && c <= 8202 || c === 8232 || c === 8233 || c === 8239 || c === 8287 || c === 12288 || c === 65279;
    }
    function prefixToBase(c) {
      if (c === CP_b || c === CP_B) {
        return 2;
      } else if (c === CP_o || c === CP_O) {
        return 8;
      } else if (c === CP_t || c === CP_T) {
        return 10;
      } else if (c === CP_x || c === CP_X) {
        return 16;
      } else {
        return -1;
      }
    }
    function validateJsonObjectJS(schema, input) {
      var report = mod_jsonschema.validate(input, schema);
      if (report.errors.length === 0)
        return null;
      var error = report.errors[0];
      var propname = error["property"];
      var reason = error["message"].toLowerCase();
      var i, j;
      if ((i = reason.indexOf("the property ")) != -1 && (j = reason.indexOf(" is not defined in the schema and the schema does not allow additional properties")) != -1) {
        i += "the property ".length;
        if (propname === "")
          propname = reason.substr(i, j - i);
        else
          propname = propname + "." + reason.substr(i, j - i);
        reason = "unsupported property";
      }
      var rv = new mod_verror.VError('property "%s": %s', propname, reason);
      rv.jsv_details = error;
      return rv;
    }
    function randElt(arr) {
      mod_assert.ok(Array.isArray(arr) && arr.length > 0, "randElt argument must be a non-empty array");
      return arr[Math.floor(Math.random() * arr.length)];
    }
    function assertHrtime(a) {
      mod_assert.ok(a[0] >= 0 && a[1] >= 0, "negative numbers not allowed in hrtimes");
      mod_assert.ok(a[1] < 1e9, "nanoseconds column overflow");
    }
    function hrtimeDiff(a, b) {
      assertHrtime(a);
      assertHrtime(b);
      mod_assert.ok(a[0] > b[0] || a[0] == b[0] && a[1] >= b[1], "negative differences not allowed");
      var rv = [a[0] - b[0], 0];
      if (a[1] >= b[1]) {
        rv[1] = a[1] - b[1];
      } else {
        rv[0]--;
        rv[1] = 1e9 - (b[1] - a[1]);
      }
      return rv;
    }
    function hrtimeNanosec(a) {
      assertHrtime(a);
      return Math.floor(a[0] * 1e9 + a[1]);
    }
    function hrtimeMicrosec(a) {
      assertHrtime(a);
      return Math.floor(a[0] * 1e6 + a[1] / 1e3);
    }
    function hrtimeMillisec(a) {
      assertHrtime(a);
      return Math.floor(a[0] * 1e3 + a[1] / 1e6);
    }
    function hrtimeAccum(a, b) {
      assertHrtime(a);
      assertHrtime(b);
      a[1] += b[1];
      if (a[1] >= 1e9) {
        a[0]++;
        a[1] -= 1e9;
      }
      a[0] += b[0];
      return a;
    }
    function hrtimeAdd(a, b) {
      assertHrtime(a);
      var rv = [a[0], a[1]];
      return hrtimeAccum(rv, b);
    }
    function extraProperties(obj, allowed) {
      mod_assert.ok(typeof obj === "object" && obj !== null, "obj argument must be a non-null object");
      mod_assert.ok(Array.isArray(allowed), "allowed argument must be an array of strings");
      for (var i = 0; i < allowed.length; i++) {
        mod_assert.ok(typeof allowed[i] === "string", "allowed argument must be an array of strings");
      }
      return Object.keys(obj).filter(function(key) {
        return allowed.indexOf(key) === -1;
      });
    }
    function mergeObjects(provided, overrides, defaults) {
      var rv, k;
      rv = {};
      if (defaults) {
        for (k in defaults)
          rv[k] = defaults[k];
      }
      if (provided) {
        for (k in provided)
          rv[k] = provided[k];
      }
      if (overrides) {
        for (k in overrides)
          rv[k] = overrides[k];
      }
      return rv;
    }
  }
});

// ../../node_modules/http-signature/lib/signer.js
var require_signer = __commonJS({
  "../../node_modules/http-signature/lib/signer.js"(exports2, module2) {
    var assert3 = require_assert();
    var crypto = require("crypto");
    var http2 = require("http");
    var util2 = require("util");
    var sshpk = require_lib3();
    var jsprim = require_jsprim();
    var utils = require_utils2();
    var sprintf = require("util").format;
    var HASH_ALGOS = utils.HASH_ALGOS;
    var PK_ALGOS = utils.PK_ALGOS;
    var InvalidAlgorithmError = utils.InvalidAlgorithmError;
    var HttpSignatureError = utils.HttpSignatureError;
    var validateAlgorithm = utils.validateAlgorithm;
    var AUTHZ_FMT = 'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
    function MissingHeaderError(message) {
      HttpSignatureError.call(this, message, MissingHeaderError);
    }
    util2.inherits(MissingHeaderError, HttpSignatureError);
    function StrictParsingError(message) {
      HttpSignatureError.call(this, message, StrictParsingError);
    }
    util2.inherits(StrictParsingError, HttpSignatureError);
    function RequestSigner(options) {
      assert3.object(options, "options");
      var alg = [];
      if (options.algorithm !== void 0) {
        assert3.string(options.algorithm, "options.algorithm");
        alg = validateAlgorithm(options.algorithm);
      }
      this.rs_alg = alg;
      if (options.sign !== void 0) {
        assert3.func(options.sign, "options.sign");
        this.rs_signFunc = options.sign;
      } else if (alg[0] === "hmac" && options.key !== void 0) {
        assert3.string(options.keyId, "options.keyId");
        this.rs_keyId = options.keyId;
        if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
          throw new TypeError("options.key for HMAC must be a string or Buffer");
        this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
        this.rs_signer.sign = function() {
          var digest = this.digest("base64");
          return {
            hashAlgorithm: alg[1],
            toString: function() {
              return digest;
            }
          };
        };
      } else if (options.key !== void 0) {
        var key = options.key;
        if (typeof key === "string" || Buffer.isBuffer(key))
          key = sshpk.parsePrivateKey(key);
        assert3.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), "options.key must be a sshpk.PrivateKey");
        this.rs_key = key;
        assert3.string(options.keyId, "options.keyId");
        this.rs_keyId = options.keyId;
        if (!PK_ALGOS[key.type]) {
          throw new InvalidAlgorithmError(key.type.toUpperCase() + " type keys are not supported");
        }
        if (alg[0] !== void 0 && key.type !== alg[0]) {
          throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
        }
        this.rs_signer = key.createSign(alg[1]);
      } else {
        throw new TypeError("options.sign (func) or options.key is required");
      }
      this.rs_headers = [];
      this.rs_lines = [];
    }
    RequestSigner.prototype.writeHeader = function(header, value) {
      assert3.string(header, "header");
      header = header.toLowerCase();
      assert3.string(value, "value");
      this.rs_headers.push(header);
      if (this.rs_signFunc) {
        this.rs_lines.push(header + ": " + value);
      } else {
        var line = header + ": " + value;
        if (this.rs_headers.length > 0)
          line = "\n" + line;
        this.rs_signer.update(line);
      }
      return value;
    };
    RequestSigner.prototype.writeDateHeader = function() {
      return this.writeHeader("date", jsprim.rfc1123(new Date()));
    };
    RequestSigner.prototype.writeTarget = function(method, path2) {
      assert3.string(method, "method");
      assert3.string(path2, "path");
      method = method.toLowerCase();
      this.writeHeader("(request-target)", method + " " + path2);
    };
    RequestSigner.prototype.sign = function(cb) {
      assert3.func(cb, "callback");
      if (this.rs_headers.length < 1)
        throw new Error("At least one header must be signed");
      var alg, authz;
      if (this.rs_signFunc) {
        var data = this.rs_lines.join("\n");
        var self2 = this;
        this.rs_signFunc(data, function(err, sig) {
          if (err) {
            cb(err);
            return;
          }
          try {
            assert3.object(sig, "signature");
            assert3.string(sig.keyId, "signature.keyId");
            assert3.string(sig.algorithm, "signature.algorithm");
            assert3.string(sig.signature, "signature.signature");
            alg = validateAlgorithm(sig.algorithm);
            authz = sprintf(AUTHZ_FMT, sig.keyId, sig.algorithm, self2.rs_headers.join(" "), sig.signature);
          } catch (e) {
            cb(e);
            return;
          }
          cb(null, authz);
        });
      } else {
        try {
          var sigObj = this.rs_signer.sign();
        } catch (e) {
          cb(e);
          return;
        }
        alg = (this.rs_alg[0] || this.rs_key.type) + "-" + sigObj.hashAlgorithm;
        var signature = sigObj.toString();
        authz = sprintf(AUTHZ_FMT, this.rs_keyId, alg, this.rs_headers.join(" "), signature);
        cb(null, authz);
      }
    };
    module2.exports = {
      isSigner: function(obj) {
        if (typeof obj === "object" && obj instanceof RequestSigner)
          return true;
        return false;
      },
      createSigner: function createSigner(options) {
        return new RequestSigner(options);
      },
      signRequest: function signRequest(request, options) {
        assert3.object(request, "request");
        assert3.object(options, "options");
        assert3.optionalString(options.algorithm, "options.algorithm");
        assert3.string(options.keyId, "options.keyId");
        assert3.optionalArrayOfString(options.headers, "options.headers");
        assert3.optionalString(options.httpVersion, "options.httpVersion");
        if (!request.getHeader("Date"))
          request.setHeader("Date", jsprim.rfc1123(new Date()));
        if (!options.headers)
          options.headers = ["date"];
        if (!options.httpVersion)
          options.httpVersion = "1.1";
        var alg = [];
        if (options.algorithm) {
          options.algorithm = options.algorithm.toLowerCase();
          alg = validateAlgorithm(options.algorithm);
        }
        var i;
        var stringToSign = "";
        for (i = 0; i < options.headers.length; i++) {
          if (typeof options.headers[i] !== "string")
            throw new TypeError("options.headers must be an array of Strings");
          var h = options.headers[i].toLowerCase();
          if (h === "request-line") {
            if (!options.strict) {
              stringToSign += request.method + " " + request.path + " HTTP/" + options.httpVersion;
            } else {
              throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
            }
          } else if (h === "(request-target)") {
            stringToSign += "(request-target): " + request.method.toLowerCase() + " " + request.path;
          } else {
            var value = request.getHeader(h);
            if (value === void 0 || value === "") {
              throw new MissingHeaderError(h + " was not in the request");
            }
            stringToSign += h + ": " + value;
          }
          if (i + 1 < options.headers.length)
            stringToSign += "\n";
        }
        if (request.hasOwnProperty("_stringToSign")) {
          request._stringToSign = stringToSign;
        }
        var signature;
        if (alg[0] === "hmac") {
          if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
            throw new TypeError("options.key must be a string or Buffer");
          var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
          hmac.update(stringToSign);
          signature = hmac.digest("base64");
        } else {
          var key = options.key;
          if (typeof key === "string" || Buffer.isBuffer(key))
            key = sshpk.parsePrivateKey(options.key);
          assert3.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), "options.key must be a sshpk.PrivateKey");
          if (!PK_ALGOS[key.type]) {
            throw new InvalidAlgorithmError(key.type.toUpperCase() + " type keys are not supported");
          }
          if (alg[0] !== void 0 && key.type !== alg[0]) {
            throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
          }
          var signer = key.createSign(alg[1]);
          signer.update(stringToSign);
          var sigObj = signer.sign();
          if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
            throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + " is not a supported hash algorithm");
          }
          options.algorithm = key.type + "-" + sigObj.hashAlgorithm;
          signature = sigObj.toString();
          assert3.notStrictEqual(signature, "", "empty signature produced");
        }
        var authzHeaderName = options.authorizationHeaderName || "Authorization";
        request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT, options.keyId, options.algorithm, options.headers.join(" "), signature));
        return true;
      }
    };
  }
});

// ../../node_modules/http-signature/lib/verify.js
var require_verify = __commonJS({
  "../../node_modules/http-signature/lib/verify.js"(exports2, module2) {
    var assert3 = require_assert();
    var crypto = require("crypto");
    var sshpk = require_lib3();
    var utils = require_utils2();
    var HASH_ALGOS = utils.HASH_ALGOS;
    var PK_ALGOS = utils.PK_ALGOS;
    var InvalidAlgorithmError = utils.InvalidAlgorithmError;
    var HttpSignatureError = utils.HttpSignatureError;
    var validateAlgorithm = utils.validateAlgorithm;
    module2.exports = {
      verifySignature: function verifySignature(parsedSignature, pubkey) {
        assert3.object(parsedSignature, "parsedSignature");
        if (typeof pubkey === "string" || Buffer.isBuffer(pubkey))
          pubkey = sshpk.parseKey(pubkey);
        assert3.ok(sshpk.Key.isKey(pubkey, [1, 1]), "pubkey must be a sshpk.Key");
        var alg = validateAlgorithm(parsedSignature.algorithm);
        if (alg[0] === "hmac" || alg[0] !== pubkey.type)
          return false;
        var v = pubkey.createVerify(alg[1]);
        v.update(parsedSignature.signingString);
        return v.verify(parsedSignature.params.signature, "base64");
      },
      verifyHMAC: function verifyHMAC(parsedSignature, secret) {
        assert3.object(parsedSignature, "parsedHMAC");
        assert3.string(secret, "secret");
        var alg = validateAlgorithm(parsedSignature.algorithm);
        if (alg[0] !== "hmac")
          return false;
        var hashAlg = alg[1].toUpperCase();
        var hmac = crypto.createHmac(hashAlg, secret);
        hmac.update(parsedSignature.signingString);
        var h1 = crypto.createHmac(hashAlg, secret);
        h1.update(hmac.digest());
        h1 = h1.digest();
        var h2 = crypto.createHmac(hashAlg, secret);
        h2.update(new Buffer(parsedSignature.params.signature, "base64"));
        h2 = h2.digest();
        if (typeof h1 === "string")
          return h1 === h2;
        if (Buffer.isBuffer(h1) && !h1.equals)
          return h1.toString("binary") === h2.toString("binary");
        return h1.equals(h2);
      }
    };
  }
});

// ../../node_modules/http-signature/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/http-signature/lib/index.js"(exports2, module2) {
    var parser = require_parser3();
    var signer = require_signer();
    var verify = require_verify();
    var utils = require_utils2();
    module2.exports = {
      parse: parser.parseRequest,
      parseRequest: parser.parseRequest,
      sign: signer.signRequest,
      signRequest: signer.signRequest,
      createSigner: signer.createSigner,
      isSigner: signer.isSigner,
      sshKeyToPEM: utils.sshKeyToPEM,
      sshKeyFingerprint: utils.fingerprint,
      pemToRsaSSHKey: utils.pemToRsaSSHKey,
      verify: verify.verifySignature,
      verifySignature: verify.verifySignature,
      verifyHMAC: verify.verifyHMAC
    };
  }
});

// ../../node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana"
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana"
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana"
      },
      "image/avcs": {
        source: "iana"
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// ../../node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = Object.create(null);
    exports2.lookup = lookup;
    exports2.types = Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// ../../node_modules/caseless/index.js
var require_caseless = __commonJS({
  "../../node_modules/caseless/index.js"(exports2, module2) {
    function Caseless(dict) {
      this.dict = dict || {};
    }
    Caseless.prototype.set = function(name, value, clobber) {
      if (typeof name === "object") {
        for (var i in name) {
          this.set(i, name[i], value);
        }
      } else {
        if (typeof clobber === "undefined")
          clobber = true;
        var has = this.has(name);
        if (!clobber && has)
          this.dict[has] = this.dict[has] + "," + value;
        else
          this.dict[has || name] = value;
        return has;
      }
    };
    Caseless.prototype.has = function(name) {
      var keys = Object.keys(this.dict), name = name.toLowerCase();
      for (var i = 0; i < keys.length; i++) {
        if (keys[i].toLowerCase() === name)
          return keys[i];
      }
      return false;
    };
    Caseless.prototype.get = function(name) {
      name = name.toLowerCase();
      var result, _key;
      var headers = this.dict;
      Object.keys(headers).forEach(function(key) {
        _key = key.toLowerCase();
        if (name === _key)
          result = headers[key];
      });
      return result;
    };
    Caseless.prototype.swap = function(name) {
      var has = this.has(name);
      if (has === name)
        return;
      if (!has)
        throw new Error('There is no header than matches "' + name + '"');
      this.dict[name] = this.dict[has];
      delete this.dict[has];
    };
    Caseless.prototype.del = function(name) {
      var has = this.has(name);
      return delete this.dict[has || name];
    };
    module2.exports = function(dict) {
      return new Caseless(dict);
    };
    module2.exports.httpify = function(resp, headers) {
      var c = new Caseless(headers);
      resp.setHeader = function(key, value, clobber) {
        if (typeof value === "undefined")
          return;
        return c.set(key, value, clobber);
      };
      resp.hasHeader = function(key) {
        return c.has(key);
      };
      resp.getHeader = function(key) {
        return c.get(key);
      };
      resp.removeHeader = function(key) {
        return c.del(key);
      };
      resp.headers = c.dict;
      return c;
    };
  }
});

// ../../node_modules/forever-agent/index.js
var require_forever_agent = __commonJS({
  "../../node_modules/forever-agent/index.js"(exports2, module2) {
    module2.exports = ForeverAgent;
    ForeverAgent.SSL = ForeverAgentSSL;
    var util2 = require("util");
    var Agent = require("http").Agent;
    var net = require("net");
    var tls = require("tls");
    var AgentSSL = require("https").Agent;
    function getConnectionName(host, port) {
      var name = "";
      if (typeof host === "string") {
        name = host + ":" + port;
      } else {
        name = host.host + ":" + host.port + ":" + (host.localAddress ? host.localAddress + ":" : ":");
      }
      return name;
    }
    function ForeverAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.requests = {};
      self2.sockets = {};
      self2.freeSockets = {};
      self2.maxSockets = self2.options.maxSockets || Agent.defaultMaxSockets;
      self2.minSockets = self2.options.minSockets || ForeverAgent.defaultMinSockets;
      self2.on("free", function(socket, host, port) {
        var name = getConnectionName(host, port);
        if (self2.requests[name] && self2.requests[name].length) {
          self2.requests[name].shift().onSocket(socket);
        } else if (self2.sockets[name].length < self2.minSockets) {
          if (!self2.freeSockets[name])
            self2.freeSockets[name] = [];
          self2.freeSockets[name].push(socket);
          var onIdleError = function() {
            socket.destroy();
          };
          socket._onIdleError = onIdleError;
          socket.on("error", onIdleError);
        } else {
          socket.destroy();
        }
      });
    }
    util2.inherits(ForeverAgent, Agent);
    ForeverAgent.defaultMinSockets = 5;
    ForeverAgent.prototype.createConnection = net.createConnection;
    ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;
    ForeverAgent.prototype.addRequest = function(req, host, port) {
      var name = getConnectionName(host, port);
      if (typeof host !== "string") {
        var options = host;
        port = options.port;
        host = options.host;
      }
      if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
        var idleSocket = this.freeSockets[name].pop();
        idleSocket.removeListener("error", idleSocket._onIdleError);
        delete idleSocket._onIdleError;
        req._reusedSocket = true;
        req.onSocket(idleSocket);
      } else {
        this.addRequestNoreuse(req, host, port);
      }
    };
    ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
      if (this.sockets[name]) {
        var index2 = this.sockets[name].indexOf(s);
        if (index2 !== -1) {
          this.sockets[name].splice(index2, 1);
        }
      } else if (this.sockets[name] && this.sockets[name].length === 0) {
        delete this.sockets[name];
        delete this.requests[name];
      }
      if (this.freeSockets[name]) {
        var index2 = this.freeSockets[name].indexOf(s);
        if (index2 !== -1) {
          this.freeSockets[name].splice(index2, 1);
          if (this.freeSockets[name].length === 0) {
            delete this.freeSockets[name];
          }
        }
      }
      if (this.requests[name] && this.requests[name].length) {
        this.createSocket(name, host, port).emit("free");
      }
    };
    function ForeverAgentSSL(options) {
      ForeverAgent.call(this, options);
    }
    util2.inherits(ForeverAgentSSL, ForeverAgent);
    ForeverAgentSSL.prototype.createConnection = createConnectionSSL;
    ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;
    function createConnectionSSL(port, host, options) {
      if (typeof port === "object") {
        options = port;
      } else if (typeof host === "object") {
        options = host;
      } else if (typeof options === "object") {
        options = options;
      } else {
        options = {};
      }
      if (typeof port === "number") {
        options.port = port;
      }
      if (typeof host === "string") {
        options.host = host;
      }
      return tls.connect(options);
    }
  }
});

// ../../node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "../../node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream2 = require("stream").Stream;
    var util2 = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util2.inherits(DelayedStream, Stream2);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream2.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// ../../node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "../../node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util2 = require("util");
    var Stream2 = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util2.inherits(CombinedStream, Stream2);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream2.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// ../../node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "../../node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// ../../node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "../../node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// ../../node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "../../node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// ../../node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "../../node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// ../../node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "../../node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// ../../node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "../../node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// ../../node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "../../node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// ../../node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "../../node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// ../../node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "../../node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// ../../node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "../../node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// ../../node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "../../node_modules/form-data/lib/populate.js"(exports2, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// ../../node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "../../node_modules/form-data/lib/form_data.js"(exports2, module2) {
    var CombinedStream = require_combined_stream();
    var util2 = require("util");
    var path2 = require("path");
    var http2 = require("http");
    var https2 = require("https");
    var parseUrl = require("url").parse;
    var fs3 = require("fs");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData;
    util2.inherits(FormData, CombinedStream);
    function FormData(options) {
      if (!(this instanceof FormData)) {
        return new FormData();
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData.LINE_BREAK = "\r\n";
    FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util2.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion"))) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs3.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
    };
    FormData.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path2.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path2.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path2.basename(value.client._httpMessage.path);
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
    };
    FormData.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https2.request(options);
      } else {
        request = http2.request(options);
      }
      this.getLength(function(err, length) {
        if (err) {
          this._error(err);
          return;
        }
        request.setHeader("Content-Length", length);
        this.pipe(request);
        if (cb) {
          request.on("error", cb);
          request.on("response", cb.bind(this, null));
        }
      }.bind(this));
      return request;
    };
    FormData.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// ../../node_modules/isstream/isstream.js
var require_isstream = __commonJS({
  "../../node_modules/isstream/isstream.js"(exports2, module2) {
    var stream = require("stream");
    function isStream(obj) {
      return obj instanceof stream.Stream;
    }
    function isReadable(obj) {
      return isStream(obj) && typeof obj._read == "function" && typeof obj._readableState == "object";
    }
    function isWritable(obj) {
      return isStream(obj) && typeof obj._write == "function" && typeof obj._writableState == "object";
    }
    function isDuplex(obj) {
      return isReadable(obj) && isWritable(obj);
    }
    module2.exports = isStream;
    module2.exports.isReadable = isReadable;
    module2.exports.isWritable = isWritable;
    module2.exports.isDuplex = isDuplex;
  }
});

// ../../node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "../../node_modules/is-typedarray/index.js"(exports2, module2) {
    module2.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// ../../node_modules/request/lib/getProxyFromURI.js
var require_getProxyFromURI = __commonJS({
  "../../node_modules/request/lib/getProxyFromURI.js"(exports2, module2) {
    "use strict";
    function formatHostname(hostname) {
      return hostname.replace(/^\.*/, ".").toLowerCase();
    }
    function parseNoProxyZone(zone) {
      zone = zone.trim().toLowerCase();
      var zoneParts = zone.split(":", 2);
      var zoneHost = formatHostname(zoneParts[0]);
      var zonePort = zoneParts[1];
      var hasPort = zone.indexOf(":") > -1;
      return { hostname: zoneHost, port: zonePort, hasPort };
    }
    function uriInNoProxy(uri, noProxy) {
      var port = uri.port || (uri.protocol === "https:" ? "443" : "80");
      var hostname = formatHostname(uri.hostname);
      var noProxyList = noProxy.split(",");
      return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
        var isMatchedAt = hostname.indexOf(noProxyZone.hostname);
        var hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
        if (noProxyZone.hasPort) {
          return port === noProxyZone.port && hostnameMatched;
        }
        return hostnameMatched;
      });
    }
    function getProxyFromURI(uri) {
      var noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
      if (noProxy === "*") {
        return null;
      }
      if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
        return null;
      }
      if (uri.protocol === "http:") {
        return process.env.HTTP_PROXY || process.env.http_proxy || null;
      }
      if (uri.protocol === "https:") {
        return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
      }
      return null;
    }
    module2.exports = getProxyFromURI;
  }
});

// ../../node_modules/qs/lib/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      var obj;
      while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];
        if (Array.isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
      return obj;
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (Array.isArray(target)) {
          target.push(source);
        } else if (typeof target === "object") {
          if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            if (target[i] && typeof target[i] === "object") {
              target[i] = merge2(target[i], item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode2 = function(str) {
      try {
        return decodeURIComponent(str.replace(/\+/g, " "));
      } catch (e) {
        return str;
      }
    };
    var encode2 = function encode3(str) {
      if (str.length === 0) {
        return str;
      }
      var string = typeof str === "string" ? str : String(str);
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      return compactQueue(queue);
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer2 = function isBuffer3(obj) {
      if (obj === null || typeof obj === "undefined") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    module2.exports = {
      arrayToObject,
      assign,
      compact,
      decode: decode2,
      encode: encode2,
      isBuffer: isBuffer2,
      isRegExp,
      merge
    };
  }
});

// ../../node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../../node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    module2.exports = {
      "default": "RFC3986",
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return value;
        }
      },
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
  }
});

// ../../node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS({
  "../../node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var formats = require_formats();
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var toISO = Date.prototype.toISOString;
    var defaults = {
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var stringify = function stringify2(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
      var obj = object;
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }
        obj = "";
      }
      if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (Array.isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (skipNulls && obj[key] === null) {
          continue;
        }
        if (Array.isArray(obj)) {
          values = values.concat(stringify2(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
        } else {
          values = values.concat(stringify2(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
        }
      }
      return values;
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = opts ? utils.assign({}, opts) : {};
      if (options.encoder !== null && options.encoder !== void 0 && typeof options.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var delimiter = typeof options.delimiter === "undefined" ? defaults.delimiter : options.delimiter;
      var strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
      var skipNulls = typeof options.skipNulls === "boolean" ? options.skipNulls : defaults.skipNulls;
      var encode2 = typeof options.encode === "boolean" ? options.encode : defaults.encode;
      var encoder = typeof options.encoder === "function" ? options.encoder : defaults.encoder;
      var sort = typeof options.sort === "function" ? options.sort : null;
      var allowDots = typeof options.allowDots === "undefined" ? false : options.allowDots;
      var serializeDate = typeof options.serializeDate === "function" ? options.serializeDate : defaults.serializeDate;
      var encodeValuesOnly = typeof options.encodeValuesOnly === "boolean" ? options.encodeValuesOnly : defaults.encodeValuesOnly;
      if (typeof options.format === "undefined") {
        options.format = formats["default"];
      } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      var formatter = formats.formatters[options.format];
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
      } else if ("indices" in options) {
        arrayFormat = options.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (sort) {
        objKeys.sort(sort);
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (skipNulls && obj[key] === null) {
          continue;
        }
        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode2 ? encoder : null, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
      }
      var joined = keys.join(delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../../node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var has = Object.prototype.hasOwnProperty;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      arrayLimit: 20,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      parameterLimit: 1e3,
      plainObjects: false,
      strictNullHandling: false
    };
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder);
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder);
          val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
          obj[key] = [].concat(obj[key]).concat(val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options) {
      var leaf = val;
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]") {
          obj = [];
          obj = obj.concat(leaf);
        } else {
          obj = options.plainObjects ? Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index2 = parseInt(cleanRoot, 10);
          if (!isNaN(index2) && root !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options);
    };
    module2.exports = function(str, opts) {
      var options = opts ? utils.assign({}, opts) : {};
      if (options.decoder !== null && options.decoder !== void 0 && typeof options.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
      options.delimiter = typeof options.delimiter === "string" || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
      options.depth = typeof options.depth === "number" ? options.depth : defaults.depth;
      options.arrayLimit = typeof options.arrayLimit === "number" ? options.arrayLimit : defaults.arrayLimit;
      options.parseArrays = options.parseArrays !== false;
      options.decoder = typeof options.decoder === "function" ? options.decoder : defaults.decoder;
      options.allowDots = typeof options.allowDots === "boolean" ? options.allowDots : defaults.allowDots;
      options.plainObjects = typeof options.plainObjects === "boolean" ? options.plainObjects : defaults.plainObjects;
      options.allowPrototypes = typeof options.allowPrototypes === "boolean" ? options.allowPrototypes : defaults.allowPrototypes;
      options.parameterLimit = typeof options.parameterLimit === "number" ? options.parameterLimit : defaults.parameterLimit;
      options.strictNullHandling = typeof options.strictNullHandling === "boolean" ? options.strictNullHandling : defaults.strictNullHandling;
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
      }
      return utils.compact(obj);
    };
  }
});

// ../../node_modules/qs/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify2();
    var parse = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// ../../node_modules/request/lib/querystring.js
var require_querystring = __commonJS({
  "../../node_modules/request/lib/querystring.js"(exports2) {
    "use strict";
    var qs = require_lib5();
    var querystring = require("querystring");
    function Querystring(request) {
      this.request = request;
      this.lib = null;
      this.useQuerystring = null;
      this.parseOptions = null;
      this.stringifyOptions = null;
    }
    Querystring.prototype.init = function(options) {
      if (this.lib) {
        return;
      }
      this.useQuerystring = options.useQuerystring;
      this.lib = this.useQuerystring ? querystring : qs;
      this.parseOptions = options.qsParseOptions || {};
      this.stringifyOptions = options.qsStringifyOptions || {};
    };
    Querystring.prototype.stringify = function(obj) {
      return this.useQuerystring ? this.rfc3986(this.lib.stringify(obj, this.stringifyOptions.sep || null, this.stringifyOptions.eq || null, this.stringifyOptions)) : this.lib.stringify(obj, this.stringifyOptions);
    };
    Querystring.prototype.parse = function(str) {
      return this.useQuerystring ? this.lib.parse(str, this.parseOptions.sep || null, this.parseOptions.eq || null, this.parseOptions) : this.lib.parse(str, this.parseOptions);
    };
    Querystring.prototype.rfc3986 = function(str) {
      return str.replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    };
    Querystring.prototype.unescape = querystring.unescape;
    exports2.Querystring = Querystring;
  }
});

// ../../node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "../../node_modules/uri-js/dist/es5/uri.all.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports2, function(exports3) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor2 = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor2(delta / damp) : delta >> 1;
        delta += floor2(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor2(delta / baseMinusTMin);
        }
        return floor2(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode2 = function decode3(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          var oldi = i;
          for (var w = 1, k = base; ; k += base) {
            if (index2 >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base || digit > floor2((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor2(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor2(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor2(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode2 = function encode3(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor2((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q2 = delta;
                for (var k = base; ; k += base) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q2 < t) {
                    break;
                  }
                  var qMinusT = q2 - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q2 = floor2(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q2, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
        });
      };
      var punycode = {
        "version": "2.1.0",
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode2,
        "encode": encode2,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches2 = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches2, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches2 = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches2, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index2) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index2) {
                lastLongest.length++;
              } else {
                acc.push({ index: index2, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches2 = uriString.match(URI_PARSE);
        if (matches2) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches2[1];
            components.userinfo = matches2[3];
            components.host = matches2[4];
            components.port = parseInt(matches2[5], 10);
            components.path = matches2[6] || "";
            components.query = matches2[7];
            components.fragment = matches2[8];
            if (isNaN(components.port)) {
              components.port = matches2[5];
            }
          } else {
            components.scheme = matches2[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches2[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches2[4] : void 0;
            components.port = parseInt(matches2[5], 10);
            components.path = matches2[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches2[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches2[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches2[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse(serialize(base2, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches2 = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches2) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches2[1].toLowerCase();
            var nss = matches2[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports3.SCHEMES = SCHEMES;
      exports3.pctEncChar = pctEncChar;
      exports3.pctDecChars = pctDecChars;
      exports3.parse = parse;
      exports3.removeDotSegments = removeDotSegments;
      exports3.serialize = serialize;
      exports3.resolveComponents = resolveComponents;
      exports3.resolve = resolve;
      exports3.normalize = normalize;
      exports3.equal = equal;
      exports3.escapeComponent = escapeComponent;
      exports3.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// ../../node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS({
  "../../node_modules/ajv/lib/compile/ucs2length.js"(exports2, module2) {
    "use strict";
    module2.exports = function ucs2length(str) {
      var length = 0, len = str.length, pos = 0, value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) == 56320)
            pos++;
        }
      }
      return length;
    };
  }
});

// ../../node_modules/ajv/lib/compile/util.js
var require_util2 = __commonJS({
  "../../node_modules/ajv/lib/compile/util.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copy,
      checkDataType,
      checkDataTypes,
      coerceToTypes,
      toHash,
      getProperty,
      escapeQuotes,
      equal: require_fast_deep_equal(),
      ucs2length: require_ucs2length(),
      varOccurences,
      varReplace,
      schemaHasRules,
      schemaHasRulesExcept,
      schemaUnknownRules,
      toQuotedString,
      getPathExpr,
      getPath,
      getData,
      unescapeFragment,
      unescapeJsonPointer,
      escapeFragment,
      escapeJsonPointer
    };
    function copy(o, to) {
      to = to || {};
      for (var key in o)
        to[key] = o[key];
      return to;
    }
    function checkDataType(dataType, data, strictNumbers, negate) {
      var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
      switch (dataType) {
        case "null":
          return data + EQUAL + "null";
        case "array":
          return OK + "Array.isArray(" + data + ")";
        case "object":
          return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
          return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        case "number":
          return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        default:
          return "typeof " + data + EQUAL + '"' + dataType + '"';
      }
    }
    function checkDataTypes(dataTypes, data, strictNumbers) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
          var code = "";
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? "(" : "(!" + data + " || ";
            code += "typeof " + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number)
            delete types.integer;
          for (var t in types)
            code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, true);
          return code;
      }
    }
    var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t])
            types[types.length] = t;
          else if (optionCoerceTypes === "array" && t === "array")
            types[types.length] = t;
        }
        if (types.length)
          return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === "array" && dataTypes === "array") {
        return ["array"];
      }
    }
    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++)
        hash[arr[i]] = true;
      return hash;
    }
    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
    }
    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
    }
    function varOccurences(str, dataVar) {
      dataVar += "[^0-9]";
      var matches2 = str.match(new RegExp(dataVar, "g"));
      return matches2 ? matches2.length : 0;
    }
    function varReplace(str, dataVar, expr) {
      dataVar += "([^0-9])";
      expr = expr.replace(/\$/g, "$$$$");
      return str.replace(new RegExp(dataVar, "g"), expr + "$1");
    }
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (var key in schema)
        if (rules[key])
          return true;
    }
    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == "boolean")
        return !schema && exceptKeyword != "not";
      for (var key in schema)
        if (key != exceptKeyword && rules[key])
          return true;
    }
    function schemaUnknownRules(schema, rules) {
      if (typeof schema == "boolean")
        return;
      for (var key in schema)
        if (!rules[key])
          return key;
    }
    function toQuotedString(str) {
      return "'" + escapeQuotes(str) + "'";
    }
    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path2 = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
      return joinPaths(currentPath, path2);
    }
    function getPath(currentPath, prop, jsonPointers) {
      var path2 = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path2);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches2;
      if ($data === "")
        return "rootData";
      if ($data[0] == "/") {
        if (!JSON_POINTER.test($data))
          throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
      } else {
        matches2 = $data.match(RELATIVE_JSON_POINTER);
        if (!matches2)
          throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches2[1];
        jsonPointer = matches2[2];
        if (jsonPointer == "#") {
          if (up >= lvl)
            throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
          return paths[lvl - up];
        }
        if (up > lvl)
          throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer)
          return data;
      }
      var expr = data;
      var segments = jsonPointer.split("/");
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += " && " + data;
        }
      }
      return expr;
    }
    function joinPaths(a, b) {
      if (a == '""')
        return b;
      return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
    }
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    function escapeJsonPointer(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
  }
});

// ../../node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS({
  "../../node_modules/ajv/lib/compile/schema_obj.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    module2.exports = SchemaObject;
    function SchemaObject(obj) {
      util2.copy(obj, this);
    }
  }
});

// ../../node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "../../node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// ../../node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS({
  "../../node_modules/ajv/lib/compile/resolve.js"(exports2, module2) {
    "use strict";
    var URI = require_uri_all();
    var equal = require_fast_deep_equal();
    var util2 = require_util2();
    var SchemaObject = require_schema_obj();
    var traverse = require_json_schema_traverse();
    module2.exports = resolve;
    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;
    function resolve(compile, root, ref) {
      var refVal = this._refs[ref];
      if (typeof refVal == "string") {
        if (this._refs[refVal])
          refVal = this._refs[refVal];
        else
          return resolve.call(this, compile, root, refVal);
      }
      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }
      var res = resolveSchema.call(this, root, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
      }
      if (schema instanceof SchemaObject) {
        v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
      } else if (schema !== void 0) {
        v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
      }
      return v;
    }
    function resolveSchema(root, ref) {
      var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
      if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate)
            this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate)
              this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root, baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema)
          return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }
    function resolveRecursive(root, ref, parsedRef) {
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id)
          baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
      }
    }
    var PREVENT_SCOPE_CHANGE = util2.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, baseId, schema, root) {
      parsedRef.fragment = parsedRef.fragment || "";
      if (parsedRef.fragment.slice(0, 1) != "/")
        return;
      var parts = parsedRef.fragment.split("/");
      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util2.unescapeFragment(part);
          schema = schema[part];
          if (schema === void 0)
            break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id)
              baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== void 0 && schema !== root.schema)
        return { schema, root, baseId };
    }
    var SIMPLE_INLINED = util2.toHash([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum"
    ]);
    function inlineRef(schema, limit) {
      if (limit === false)
        return false;
      if (limit === void 0 || limit === true)
        return checkNoRef(schema);
      else if (limit)
        return countKeys(schema) <= limit;
    }
    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return false;
          item = schema[key];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      }
      return true;
    }
    function countKeys(schema) {
      var count = 0, item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object")
            count += countKeys(item);
          if (count == Infinity)
            return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == "object")
              count += countKeys(item) + 1;
            if (count == Infinity)
              return Infinity;
          }
        }
      }
      return count;
    }
    function getFullPath(id, normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      var p = URI.parse(id);
      return _getFullPath(p);
    }
    function _getFullPath(p) {
      return URI.serialize(p).split("#")[0] + "#";
    }
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return URI.resolve(baseId, id);
    }
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { "": schemaId };
      var fullPaths = { "": getFullPath(schemaId, false) };
      var localRefs = {};
      var self2 = this;
      traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "")
          return;
        var id = self2._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== void 0)
          fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util2.escapeFragment(keyIndex));
        if (typeof id == "string") {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
          var refVal = self2._refs[id];
          if (typeof refVal == "string")
            refVal = self2._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == "#") {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self2._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });
      return localRefs;
    }
  }
});

// ../../node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS({
  "../../node_modules/ajv/lib/compile/error_classes.js"(exports2, module2) {
    "use strict";
    var resolve = require_resolve();
    module2.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };
    function ValidationError(errors) {
      this.message = "validation failed";
      this.errors = errors;
      this.ajv = this.validation = true;
    }
    MissingRefError.message = function(baseId, ref) {
      return "can't resolve reference " + ref + " from id " + baseId;
    };
    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }
    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }
});

// ../../node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "../../node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/validate.js
var require_validate2 = __commonJS({
  "../../node_modules/ajv/lib/dotjs/validate.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = "";
      var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
      if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
          var $keywordsMsg = "unknown keyword: " + $unknownKwd;
          if (it.opts.strictKeywords === "log")
            it.logger.warn($keywordsMsg);
          else
            throw new Error($keywordsMsg);
        }
      }
      if (it.isTop) {
        out += " var validate = ";
        if ($async) {
          it.async = true;
          out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += " " + ("/*# sourceURL=" + $id + " */") + " ";
        }
      }
      if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += " var " + $valid + " = false; ";
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'boolean schema is false' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += " return data; ";
            } else {
              out += " validate.errors = null; return true; ";
            }
          } else {
            out += " var " + $valid + " = true; ";
          }
        }
        if (it.isTop) {
          out += " }; return validate; ";
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [""];
        if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
          var $defaultMsg = "default is ignored in the schema root";
          if (it.opts.strictDefaults === "log")
            it.logger.warn($defaultMsg);
          else
            throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
      } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id)
          it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async)
          throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
      }
      var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
      var $errorKeyword;
      var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
      if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
          if ($typeSchema.indexOf("null") == -1)
            $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
          $typeSchema = [$typeSchema, "null"];
          $typeIsArray = true;
        }
      }
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if (it.schema.$comment && it.opts.$comment) {
        out += " " + it.RULES.all.$comment.code(it, "$comment");
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
          out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
          if ($coerceToTypes) {
            var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
            out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
            if (it.opts.coerceTypes == "array") {
              out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
            }
            out += " if (" + $coerced + " !== undefined) ; ";
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($type == "string") {
                  out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                } else if ($type == "number" || $type == "integer") {
                  out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                  if ($type == "integer") {
                    out += " && !(" + $data + " % 1)";
                  }
                  out += ")) " + $coerced + " = +" + $data + "; ";
                } else if ($type == "boolean") {
                  out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                } else if ($type == "null") {
                  out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                } else if (it.opts.coerceTypes == "array" && $type == "array") {
                  out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                }
              }
            }
            out += " else {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } if (" + $coerced + " !== undefined) {  ";
            var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
            out += " " + $data + " = " + $coerced + "; ";
            if (!$dataLvl) {
              out += "if (" + $parentData + " !== undefined)";
            }
            out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          }
          out += " } ";
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
          out += " } if (errors === ";
          if ($top) {
            out += "0";
          } else {
            out += "errs_" + $lvl;
          }
          out += ") { ";
          $closingBraces2 += "}";
        }
      } else {
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
              }
              if (it.opts.useDefaults) {
                if ($rulesGroup.type == "object" && it.schema.properties) {
                  var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== void 0) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch, $i = -1, l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== void 0) {
                        var $passData = $data + "[" + $i + "]";
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1, l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += " " + $code + " ";
                      if ($breakOnError) {
                        $closingBraces1 += "}";
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += " " + $closingBraces1 + " ";
                $closingBraces1 = "";
              }
              if ($rulesGroup.type) {
                out += " } ";
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += " else { ";
                  var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
              }
              if ($breakOnError) {
                out += " if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces2 + " ";
      }
      if ($top) {
        if ($async) {
          out += " if (errors === 0) return data;           ";
          out += " else throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; ";
          out += " return errors === 0;       ";
        }
        out += " }; return validate;";
      } else {
        out += " var " + $valid + " = errors === errs_" + $lvl + ";";
      }
      function $shouldUseGroup($rulesGroup2) {
        var rules = $rulesGroup2.rules;
        for (var i = 0; i < rules.length; i++)
          if ($shouldUseRule(rules[i]))
            return true;
      }
      function $shouldUseRule($rule2) {
        return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
      }
      function $ruleImplementsSomeKeyword($rule2) {
        var impl = $rule2.implements;
        for (var i = 0; i < impl.length; i++)
          if (it.schema[impl[i]] !== void 0)
            return true;
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/compile/index.js
var require_compile2 = __commonJS({
  "../../node_modules/ajv/lib/compile/index.js"(exports2, module2) {
    "use strict";
    var resolve = require_resolve();
    var util2 = require_util2();
    var errorClasses = require_error_classes();
    var stableStringify = require_fast_json_stable_stringify();
    var validateGenerator = require_validate2();
    var ucs2length = util2.ucs2length;
    var equal = require_fast_deep_equal();
    var ValidationError = errorClasses.Validation;
    module2.exports = compile;
    function compile(schema, root, localRefs, baseId) {
      var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
      root = root || { schema, refVal, refs };
      var c = checkCompiling.call(this, schema, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling)
        return compilation.callValidate = callValidate;
      var formats = this._formats;
      var RULES = this.RULES;
      try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode)
            cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root, baseId);
      }
      function callValidate() {
        var validate = compilation.validate;
        var result = validate.apply(this, arguments);
        callValidate.errors = validate.errors;
        return result;
      }
      function localCompile(_schema, _root, localRefs2, baseId2) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema)
          return compile.call(self2, _schema, _root, localRefs2, baseId2);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot,
          baseId: baseId2,
          root: _root,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES,
          validate: validateGenerator,
          util: util2,
          resolve,
          resolveRef,
          usePattern,
          useDefault,
          useCustomRule,
          opts,
          formats,
          logger: self2.logger,
          self: self2
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode)
          sourceCode = opts.processCode(sourceCode, _schema);
        var validate;
        try {
          var makeValidate = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode);
          validate = makeValidate(self2, RULES, formats, root, refVal, defaults, customRules, equal, ucs2length, ValidationError);
          refVal[0] = validate;
        } catch (e) {
          self2.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        }
        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async)
          validate.$async = true;
        if (opts.sourceCode === true) {
          validate.source = {
            code: sourceCode,
            patterns,
            defaults
          };
        }
        return validate;
      }
      function resolveRef(baseId2, ref, isRoot) {
        ref = resolve.url(baseId2, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== void 0) {
          _refVal = refVal[refIndex];
          refCode = "refVal[" + refIndex + "]";
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== void 0) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }
        refCode = addLocalRef(ref);
        var v2 = resolve.call(self2, localCompile, root, ref);
        if (v2 === void 0) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
          }
        }
        if (v2 === void 0) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v2);
          return resolvedRef(v2, refCode);
        }
      }
      function addLocalRef(ref, v2) {
        var refId = refVal.length;
        refVal[refId] = v2;
        refs[ref] = refId;
        return "refVal" + refId;
      }
      function removeLocalRef(ref) {
        delete refs[ref];
      }
      function replaceLocalRef(ref, v2) {
        var refId = refs[ref];
        refVal[refId] = v2;
      }
      function resolvedRef(refVal2, code) {
        return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
      }
      function usePattern(regexStr) {
        var index2 = patternsHash[regexStr];
        if (index2 === void 0) {
          index2 = patternsHash[regexStr] = patterns.length;
          patterns[index2] = regexStr;
        }
        return "pattern" + index2;
      }
      function useDefault(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
            return "" + value;
          case "string":
            return util2.toQuotedString(value);
          case "object":
            if (value === null)
              return "null";
            var valueStr = stableStringify(value);
            var index2 = defaultsHash[valueStr];
            if (index2 === void 0) {
              index2 = defaultsHash[valueStr] = defaults.length;
              defaults[index2] = value;
            }
            return "default" + index2;
        }
      }
      function useCustomRule(rule, schema2, parentSchema, it) {
        if (self2._opts.validateSchema !== false) {
          var deps = rule.definition.dependencies;
          if (deps && !deps.every(function(keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          }))
            throw new Error("parent schema must have all required keywords: " + deps.join(","));
          var validateSchema = rule.definition.validateSchema;
          if (validateSchema) {
            var valid = validateSchema(schema2);
            if (!valid) {
              var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
              if (self2._opts.validateSchema == "log")
                self2.logger.error(message);
              else
                throw new Error(message);
            }
          }
        }
        var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate;
        if (compile2) {
          validate = compile2.call(self2, schema2, parentSchema, it);
        } else if (macro) {
          validate = macro.call(self2, schema2, parentSchema, it);
          if (opts.validateSchema !== false)
            self2.validateSchema(validate, true);
        } else if (inline) {
          validate = inline.call(self2, it, rule.keyword, schema2, parentSchema);
        } else {
          validate = rule.definition.validate;
          if (!validate)
            return;
        }
        if (validate === void 0)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index2 = customRules.length;
        customRules[index2] = validate;
        return {
          code: "customRule" + index2,
          validate
        };
      }
    }
    function checkCompiling(schema, root, baseId) {
      var index2 = compIndex.call(this, schema, root, baseId);
      if (index2 >= 0)
        return { index: index2, compiling: true };
      index2 = this._compilations.length;
      this._compilations[index2] = {
        schema,
        root,
        baseId
      };
      return { index: index2, compiling: false };
    }
    function endCompiling(schema, root, baseId) {
      var i = compIndex.call(this, schema, root, baseId);
      if (i >= 0)
        this._compilations.splice(i, 1);
    }
    function compIndex(schema, root, baseId) {
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId)
          return i;
      }
      return -1;
    }
    function patternCode(i, patterns) {
      return "var pattern" + i + " = new RegExp(" + util2.toQuotedString(patterns[i]) + ");";
    }
    function defaultCode(i) {
      return "var default" + i + " = defaults[" + i + "];";
    }
    function refValCode(i, refVal) {
      return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
    }
    function customRuleCode(i) {
      return "var customRule" + i + " = customRules[" + i + "];";
    }
    function vars(arr, statement) {
      if (!arr.length)
        return "";
      var code = "";
      for (var i = 0; i < arr.length; i++)
        code += statement(i, arr);
      return code;
    }
  }
});

// ../../node_modules/ajv/lib/cache.js
var require_cache = __commonJS({
  "../../node_modules/ajv/lib/cache.js"(exports2, module2) {
    "use strict";
    var Cache = module2.exports = function Cache2() {
      this._cache = {};
    };
    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };
    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };
    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };
    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }
});

// ../../node_modules/ajv/lib/compile/formats.js
var require_formats2 = __commonJS({
  "../../node_modules/ajv/lib/compile/formats.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    module2.exports = formats;
    function formats(mode) {
      mode = mode == "full" ? "full" : "fast";
      return util2.copy(formats[mode]);
    }
    formats.fast = {
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      "uri-template": URITEMPLATE,
      url: URL2,
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    formats.full = {
      date,
      time,
      "date-time": date_time,
      uri,
      "uri-reference": URIREF,
      "uri-template": URITEMPLATE,
      url: URL2,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function date(str) {
      var matches2 = str.match(DATE);
      if (!matches2)
        return false;
      var year = +matches2[1];
      var month = +matches2[2];
      var day = +matches2[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function time(str, full) {
      var matches2 = str.match(TIME);
      if (!matches2)
        return false;
      var hour = matches2[1];
      var minute = matches2[2];
      var second = matches2[3];
      var timeZone = matches2[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// ../../node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS({
  "../../node_modules/ajv/lib/dotjs/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $async, $refCode;
      if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
          $async = it.async;
          $refCode = "validate";
        } else {
          $async = it.root.schema.$async === true;
          $refCode = "root.refVal[0]";
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === void 0) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == "fail") {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            if ($breakOnError) {
              out += " if (false) { ";
            }
          } else if (it.opts.missingRefs == "ignore") {
            it.logger.warn($message);
            if ($breakOnError) {
              out += " if (true) { ";
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = "";
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += " " + $code + " ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
          }
        } else {
          $async = $refVal.$async === true || it.async && $refVal.$async !== false;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) {
          out += " " + $refCode + ".call(this, ";
        } else {
          out += " " + $refCode + "( ";
        }
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async)
            throw new Error("async schema referenced by sync schema");
          if ($breakOnError) {
            out += " var " + $valid + "; ";
          }
          out += " try { await " + __callValidate + "; ";
          if ($breakOnError) {
            out += " " + $valid + " = true; ";
          }
          out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
          if ($breakOnError) {
            out += " " + $valid + " = false; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " if (" + $valid + ") { ";
          }
        } else {
          out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS({
  "../../node_modules/ajv/lib/dotjs/allOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += " if (true) { ";
        } else {
          out += " " + $closingBraces.slice(0, -1) + " ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS({
  "../../node_modules/ajv/lib/dotjs/anyOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $noEmptySchema = $schema.every(function($sch2) {
        return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
            $closingBraces += "}";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match some schema in anyOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS({
  "../../node_modules/ajv/lib/dotjs/comment.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_comment(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $comment = it.util.toQuotedString($schema);
      if (it.opts.$comment === true) {
        out += " console.log(" + $comment + ");";
      } else if (typeof it.opts.$comment == "function") {
        out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS({
  "../../node_modules/ajv/lib/dotjs/const.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_const(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to constant' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS({
  "../../node_modules/ajv/lib/dotjs/contains.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
      } else {
        out += " if (" + $data + ".length == 0) {";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should contain a valid item' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else { ";
      if ($nonEmptySchema) {
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      }
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS({
  "../../node_modules/ajv/lib/dotjs/dependencies.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        if ($property == "__proto__")
          continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += "var " + $errs + " = errors;";
      var $currentErrorPath = it.errorPath;
      out += "var missing" + $lvl + ";";
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          if ($breakOnError) {
            out += " && ( ";
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ")) {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            out += " ) { ";
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1, l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should have ";
                    if ($deps.length == 1) {
                      out += "property " + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += "properties " + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
          out += " }   ";
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          out += ") { ";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
      if ($breakOnError) {
        out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS({
  "../../node_modules/ajv/lib/dotjs/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
      if (!$isData) {
        out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + ";";
      if ($isData) {
        out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
      }
      out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to one of the allowed values' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS({
  "../../node_modules/ajv/lib/dotjs/format.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_format(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) {
          out += " var async" + $lvl + " = " + $format + ".async; ";
        }
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " (";
        if ($unknownFormats != "ignore") {
          out += " (" + $schemaValue + " && !" + $format + " ";
          if ($allowUnknown) {
            out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
          }
          out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) {
          out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        } else {
          out += " " + $format + "(" + $data + ") ";
        }
        out += " : " + $format + ".test(" + $data + "))))) {";
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == "ignore") {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        if ($async) {
          if (!it.async)
            throw new Error("async format in sync schema");
          var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
          out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
          out += " if (! ";
          var $formatRef = "formats" + it.util.getProperty($schema);
          if ($isObject)
            $formatRef += ".validate";
          if (typeof $format == "function") {
            out += " " + $formatRef + "(" + $data + ") ";
          } else {
            out += " " + $formatRef + ".test(" + $data + ") ";
          }
          out += ") { ";
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match format "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS({
  "../../node_modules/ajv/lib/dotjs/if.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_if(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
      if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
          out += " if (" + $nextValid + ") {  ";
          $it.schema = it.schema["then"];
          $it.schemaPath = it.schemaPath + ".then";
          $it.errSchemaPath = it.errSchemaPath + "/then";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'then'; ";
          } else {
            $ifClause = "'then'";
          }
          out += " } ";
          if ($elsePresent) {
            out += " else { ";
          }
        } else {
          out += " if (!" + $nextValid + ") { ";
        }
        if ($elsePresent) {
          $it.schema = it.schema["else"];
          $it.schemaPath = it.schemaPath + ".else";
          $it.errSchemaPath = it.errSchemaPath + "/else";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'else'; ";
          } else {
            $ifClause = "'else'";
          }
          out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " }   ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS({
  "../../node_modules/ajv/lib/dotjs/items.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_items(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have more than " + $schema.length + " items' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
              var $passData = $data + "[" + $i + "]";
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + ".additionalItems";
          $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = " + 0 + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS({
  "../../node_modules/ajv/lib/dotjs/_limit.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
      if (!($isData || typeof $schema == "number" || $schema === void 0)) {
        throw new Error($keyword + " must be number");
      }
      if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
        throw new Error($exclusiveKeyword + " must be number or boolean");
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === void 0) {
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaValueExcl;
          $isData = $isDataExcl;
        }
      } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
          if ($exclIsNumber && $schema === void 0) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += "=";
          } else {
            if ($exclIsNumber)
              $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $notOp += "=";
            } else {
              $exclusive = false;
              $opStr += "=";
            }
          }
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be " + $opStr + " ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS({
  "../../node_modules/ajv/lib/dotjs/_limitItems.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxItems" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxItems") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS({
  "../../node_modules/ajv/lib/dotjs/_limitLength.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxLength" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      if (it.opts.unicode === false) {
        out += " " + $data + ".length ";
      } else {
        out += " ucs2length(" + $data + ") ";
      }
      out += " " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be ";
          if ($keyword == "maxLength") {
            out += "longer";
          } else {
            out += "shorter";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " characters' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS({
  "../../node_modules/ajv/lib/dotjs/_limitProperties.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxProperties" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxProperties") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " properties' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS({
  "../../node_modules/ajv/lib/dotjs/multipleOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      out += "var division" + $lvl + ";if (";
      if ($isData) {
        out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
      }
      out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
      if (it.opts.multipleOfPrecision) {
        out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
      } else {
        out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
      }
      out += " ) ";
      if ($isData) {
        out += "  )  ";
      }
      out += " ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be multiple of ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS({
  "../../node_modules/ajv/lib/dotjs/not.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_not(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption)
          $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        out += "  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) {
          out += " if (false) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS({
  "../../node_modules/ajv/lib/dotjs/oneOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
      out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
          } else {
            out += " var " + $nextValid + " = true; ";
          }
          if ($i) {
            out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
            $closingBraces += "}";
          }
          out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match exactly one schema in oneOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/ajv/lib/dotjs/pattern.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match pattern "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS({
  "../../node_modules/ajv/lib/dotjs/properties.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
      var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
        var $requiredHash = it.util.toHash($required);
      }
      function notProto(p) {
        return p !== "__proto__";
      }
      out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined;";
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        if ($someProperties) {
          out += " var isAdditional" + $lvl + " = !(false ";
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 8) {
              out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
              }
            }
          }
          out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = "' + " + $key + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += " delete " + $data + "[" + $key + "]; ";
            } else {
              out += " " + $nextValid + " = false; ";
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + "/additionalProperties";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is an invalid additional property";
                  } else {
                    out += "should NOT have additional properties";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += " break; ";
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == "failing") {
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += " } ";
        }
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $sch = $schema[$propertyKey];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += " var " + $nextData + " = " + $passData + "; ";
              }
              if ($hasDefault) {
                out += " " + $code + " ";
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = false; ";
                  var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + "/required";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += " } else { ";
                } else {
                  if ($breakOnError) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = true; } else { ";
                  } else {
                    out += " if (" + $useData + " !== undefined ";
                    if ($ownProperties) {
                      out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += " ) { ";
                  }
                }
                out += " " + $code + " } ";
              }
            }
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
          var $pProperty, i4 = -1, l4 = arr4.length - 1;
          while (i4 < l4) {
            $pProperty = arr4[i4 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS({
  "../../node_modules/ajv/lib/dotjs/propertyNames.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      out += "var " + $errs + " = errors;";
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined; ";
        }
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        if ($breakOnError) {
          out += " break; ";
        }
        out += " } }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS({
  "../../node_modules/ajv/lib/dotjs/required.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_required(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = "schema" + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += " var missing" + $lvl + "; ";
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += " var " + $valid + " = true; ";
            if ($isData) {
              out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
            if ($ownProperties) {
              out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += "; if (!" + $valid + ") break; } ";
            if ($isData) {
              out += "  }  ";
            }
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          } else {
            out += " if ( ";
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ") {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) {
              out += "  }  ";
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1, l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += " if (true) {";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS({
  "../../node_modules/ajv/lib/dotjs/uniqueItems.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        }
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
          out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        } else {
          out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
          var $method = "checkDataType" + ($typeIsArray ? "s" : "");
          out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
          if ($typeIsArray) {
            out += ` if (typeof item == 'string') item = '"' + item; `;
          }
          out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS({
  "../../node_modules/ajv/lib/dotjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "$ref": require_ref(),
      allOf: require_allOf(),
      anyOf: require_anyOf(),
      "$comment": require_comment(),
      const: require_const(),
      contains: require_contains(),
      dependencies: require_dependencies(),
      "enum": require_enum(),
      format: require_format(),
      "if": require_if(),
      items: require_items(),
      maximum: require_limit(),
      minimum: require_limit(),
      maxItems: require_limitItems(),
      minItems: require_limitItems(),
      maxLength: require_limitLength(),
      minLength: require_limitLength(),
      maxProperties: require_limitProperties(),
      minProperties: require_limitProperties(),
      multipleOf: require_multipleOf(),
      not: require_not(),
      oneOf: require_oneOf(),
      pattern: require_pattern(),
      properties: require_properties(),
      propertyNames: require_propertyNames(),
      required: require_required(),
      uniqueItems: require_uniqueItems(),
      validate: require_validate2()
    };
  }
});

// ../../node_modules/ajv/lib/compile/rules.js
var require_rules2 = __commonJS({
  "../../node_modules/ajv/lib/compile/rules.js"(exports2, module2) {
    "use strict";
    var ruleModules = require_dotjs();
    var toHash = require_util2().toHash;
    module2.exports = function rules() {
      var RULES = [
        {
          type: "number",
          rules: [
            { "maximum": ["exclusiveMaximum"] },
            { "minimum": ["exclusiveMinimum"] },
            "multipleOf",
            "format"
          ]
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"]
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { "properties": ["additionalProperties", "patternProperties"] }
          ]
        },
        { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
      ];
      var ALL = ["type", "$comment"];
      var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
      ];
      var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);
      RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
          var implKeywords;
          if (typeof keyword == "object") {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function(k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });
        RULES.all.$comment = {
          keyword: "$comment",
          code: ruleModules.$comment
        };
        if (group.type)
          RULES.types[group.type] = group;
      });
      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};
      return RULES;
    };
  }
});

// ../../node_modules/ajv/lib/data.js
var require_data = __commonJS({
  "../../node_modules/ajv/lib/data.js"(exports2, module2) {
    "use strict";
    var KEYWORDS = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const"
    ];
    module2.exports = function(metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];
        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [
                schema,
                { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
        }
      }
      return metaSchema;
    };
  }
});

// ../../node_modules/ajv/lib/compile/async.js
var require_async2 = __commonJS({
  "../../node_modules/ajv/lib/compile/async.js"(exports2, module2) {
    "use strict";
    var MissingRefError = require_error_classes().MissingRef;
    module2.exports = compileAsync;
    function compileAsync(schema, meta, callback) {
      var self2 = this;
      if (typeof this._opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      if (typeof meta == "function") {
        callback = meta;
        meta = void 0;
      }
      var p = loadMetaSchemaOf(schema).then(function() {
        var schemaObj = self2._addSchema(schema, void 0, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });
      if (callback) {
        p.then(function(v) {
          callback(null, v);
        }, callback);
      }
      return p;
      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
      }
      function _compileAsync(schemaObj) {
        try {
          return self2._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError)
            return loadMissingSchema(e);
          throw e;
        }
        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref))
            throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
          var schemaPromise = self2._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }
          return schemaPromise.then(function(sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function() {
                if (!added(ref))
                  self2.addSchema(sch, ref, void 0, meta);
              });
            }
          }).then(function() {
            return _compileAsync(schemaObj);
          });
          function removePromise() {
            delete self2._loadingSchemas[ref];
          }
          function added(ref2) {
            return self2._refs[ref2] || self2._schemas[ref2];
          }
        }
      }
    }
  }
});

// ../../node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS({
  "../../node_modules/ajv/lib/dotjs/custom.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate)
          return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async)
        throw new Error("async keyword in sync schema");
      if (!($inline || $macro)) {
        out += "" + $ruleErrs + " = null;";
      }
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
          $closingBraces += "}";
          out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += " " + $ruleValidate.validate + " ";
        } else {
          out += " " + $valid + " = " + $ruleValidate.validate + "; ";
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) {
          out += "this";
        } else {
          out += "self";
        }
        if ($compile || $rDef.schema === false) {
          out += " , " + $data + " ";
        } else {
          out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        }
        out += " , (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += " " + $valid + " = ";
          if ($asyncKeyword) {
            out += "await ";
          }
          out += "" + def_callRuleValidate + "; ";
        } else {
          if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
          } else {
            out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
          }
        }
      }
      if ($rDef.modifying) {
        out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
      }
      out += "" + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        out += " if ( ";
        if ($rDef.valid === void 0) {
          out += " !";
          if ($macro) {
            out += "" + $nextValid;
          } else {
            out += "" + $valid;
          }
        } else {
          out += " " + !$rDef.valid + " ";
        }
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != "full") {
              out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } ";
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } ";
            }
          }
        } else if ($macro) {
          out += "   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } else { " + def_customError + " } ";
          }
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "../../node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// ../../node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS({
  "../../node_modules/ajv/lib/definition_schema.js"(exports2, module2) {
    "use strict";
    var metaSchema = require_json_schema_draft_07();
    module2.exports = {
      $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
      definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
      },
      type: "object",
      dependencies: {
        schema: ["validate"],
        $data: ["validate"],
        statements: ["inline"],
        valid: { not: { required: ["macro"] } }
      },
      properties: {
        type: metaSchema.properties.type,
        schema: { type: "boolean" },
        statements: { type: "boolean" },
        dependencies: {
          type: "array",
          items: { type: "string" }
        },
        metaSchema: { type: "object" },
        modifying: { type: "boolean" },
        valid: { type: "boolean" },
        $data: { type: "boolean" },
        async: { type: "boolean" },
        errors: {
          anyOf: [
            { type: "boolean" },
            { const: "full" }
          ]
        }
      }
    };
  }
});

// ../../node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/ajv/lib/keyword.js"(exports2, module2) {
    "use strict";
    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require_custom();
    var definitionSchema = require_definition_schema();
    module2.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword,
      validate: validateKeyword
    };
    function addKeyword(keyword, definition) {
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error("Keyword " + keyword + " is already defined");
      if (!IDENTIFIER.test(keyword))
        throw new Error("Keyword " + keyword + " is not a valid identifier");
      if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          for (var i = 0; i < dataType.length; i++)
            _addRule(keyword, dataType[i], definition);
        } else {
          _addRule(keyword, dataType, definition);
        }
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if (definition.$data && this._opts.$data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }
      RULES.keywords[keyword] = RULES.all[keyword] = true;
      function _addRule(keyword2, dataType2, definition2) {
        var ruleGroup;
        for (var i2 = 0; i2 < RULES.length; i2++) {
          var rg = RULES[i2];
          if (rg.type == dataType2) {
            ruleGroup = rg;
            break;
          }
        }
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.push(ruleGroup);
        }
        var rule = {
          keyword: keyword2,
          definition: definition2,
          custom: true,
          code: customRuleCode,
          implements: definition2.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword2] = rule;
      }
      return this;
    }
    function getKeyword(keyword) {
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }
    function removeKeyword(keyword) {
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
    function validateKeyword(definition, throwError) {
      validateKeyword.errors = null;
      var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
      if (v(definition))
        return true;
      validateKeyword.errors = v.errors;
      if (throwError)
        throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
      else
        return false;
    }
  }
});

// ../../node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS({
  "../../node_modules/ajv/lib/refs/data.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON Schema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" }
          ]
        }
      },
      additionalProperties: false
    };
  }
});

// ../../node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS({
  "../../node_modules/ajv/lib/ajv.js"(exports2, module2) {
    "use strict";
    var compileSchema = require_compile2();
    var resolve = require_resolve();
    var Cache = require_cache();
    var SchemaObject = require_schema_obj();
    var stableStringify = require_fast_json_stable_stringify();
    var formats = require_formats2();
    var rules = require_rules2();
    var $dataMetaSchema = require_data();
    var util2 = require_util2();
    module2.exports = Ajv;
    Ajv.prototype.validate = validate;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;
    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;
    Ajv.prototype.compileAsync = require_async2();
    var customKeyword = require_keyword();
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;
    Ajv.prototype.validateKeyword = customKeyword.validate;
    var errorClasses = require_error_classes();
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
    var META_SUPPORT_DATA = ["/properties"];
    function Ajv(opts) {
      if (!(this instanceof Ajv))
        return new Ajv(opts);
      opts = this._opts = util2.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);
      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == "property")
        opts._errorDataPathProperty = true;
      if (opts.serialize === void 0)
        opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);
      if (opts.formats)
        addInitialFormats(this);
      if (opts.keywords)
        addInitialKeywords(this);
      addDefaultMetaSchema(this);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      if (opts.nullable)
        this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
      addInitialSchemas(this);
    }
    function validate(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }
      var valid = v(data);
      if (v.$async !== true)
        this.errors = v.errors;
      return valid;
    }
    function compile(schema, _meta) {
      var schemaObj = this._addSchema(schema, void 0, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++)
          this.addSchema(schema[i], void 0, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== void 0 && typeof id != "string")
        throw new Error("schema id must be string");
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== void 0 && typeof $schema != "string")
        throw new Error("$schema must be a string");
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      var valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    function defaultMeta(self2) {
      var meta = self2._opts.meta;
      self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
      return self2._opts.defaultMeta;
    }
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case "object":
          return schemaObj.validate || this._compile(schemaObj);
        case "string":
          return this.getSchema(schemaObj);
        case "undefined":
          return _getSchemaFragment(this, keyRef);
      }
    }
    function _getSchemaFragment(self2, ref) {
      var res = resolve.schema.call(self2, { schema: {} }, ref);
      if (res) {
        var schema = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self2, schema, root, void 0, baseId);
        self2._fragments[ref] = new SchemaObject({
          ref,
          fragment: true,
          schema,
          root,
          baseId,
          validate: v
        });
        return v;
      }
    }
    function _getSchemaObj(self2, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
    }
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case "string":
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj)
            this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case "object":
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }
    function _removeAllSchemas(self2, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self2._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != "object" && typeof schema != "boolean")
        throw new Error("schema should be object or boolean");
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached)
        return cached;
      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema)
        checkUnique(this, id);
      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
        this.validateSchema(schema, true);
      var localRefs = resolve.ids.call(this, schema);
      var schemaObj = new SchemaObject({
        id,
        schema,
        localRefs,
        cacheKey,
        meta
      });
      if (id[0] != "#" && shouldAddSchema)
        this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);
      if (willValidate && recursiveMeta)
        this.validateSchema(schema, true);
      return schemaObj;
    }
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;
      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }
      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } catch (e) {
        delete schemaObj.validate;
        throw e;
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta)
          this._opts = currentOpts;
      }
      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;
      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }
    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case "auto":
          return _get$IdOrId;
        case "id":
          return _getId;
        default:
          return _get$Id;
      }
    }
    function _getId(schema) {
      if (schema.$id)
        this.logger.warn("schema $id ignored", schema.$id);
      return schema.id;
    }
    function _get$Id(schema) {
      if (schema.id)
        this.logger.warn("schema id ignored", schema.id);
      return schema.$id;
    }
    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id)
        throw new Error("schema $id is different from id");
      return schema.$id || schema.id;
    }
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors)
        return "No errors";
      options = options || {};
      var separator = options.separator === void 0 ? ", " : options.separator;
      var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
      var text = "";
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e)
          text += dataVar + e.dataPath + " " + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }
    function addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }
    function addDefaultMetaSchema(self2) {
      var $dataSchema;
      if (self2._opts.$data) {
        $dataSchema = require_data2();
        self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self2._opts.meta === false)
        return;
      var metaSchema = require_json_schema_draft_07();
      if (self2._opts.$data)
        metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    function addInitialSchemas(self2) {
      var optsSchemas = self2._opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        self2.addSchema(optsSchemas);
      else
        for (var key in optsSchemas)
          self2.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats(self2) {
      for (var name in self2._opts.formats) {
        var format = self2._opts.formats[name];
        self2.addFormat(name, format);
      }
    }
    function addInitialKeywords(self2) {
      for (var name in self2._opts.keywords) {
        var keyword = self2._opts.keywords[name];
        self2.addKeyword(name, keyword);
      }
    }
    function checkUnique(self2, id) {
      if (self2._schemas[id] || self2._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }
    function getMetaSchemaOptions(self2) {
      var metaOpts = util2.copy(self2._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
        delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }
    function setLogger(self2) {
      var logger = self2._opts.logger;
      if (logger === false) {
        self2.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger === void 0)
          logger = console;
        if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
          throw new Error("logger must implement log, warn and error methods");
        self2.logger = logger;
      }
    }
    function noop() {
    }
  }
});

// ../../node_modules/har-validator/lib/error.js
var require_error = __commonJS({
  "../../node_modules/har-validator/lib/error.js"(exports2, module2) {
    function HARError(errors) {
      var message = "validation failed";
      this.name = "HARError";
      this.message = message;
      this.errors = errors;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }
    }
    HARError.prototype = Error.prototype;
    module2.exports = HARError;
  }
});

// ../../node_modules/har-schema/lib/afterRequest.json
var require_afterRequest = __commonJS({
  "../../node_modules/har-schema/lib/afterRequest.json"(exports2, module2) {
    module2.exports = {
      $id: "afterRequest.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "lastAccess",
        "eTag",
        "hitCount"
      ],
      properties: {
        expires: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        lastAccess: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        eTag: {
          type: "string"
        },
        hitCount: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/beforeRequest.json
var require_beforeRequest = __commonJS({
  "../../node_modules/har-schema/lib/beforeRequest.json"(exports2, module2) {
    module2.exports = {
      $id: "beforeRequest.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "lastAccess",
        "eTag",
        "hitCount"
      ],
      properties: {
        expires: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        lastAccess: {
          type: "string",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
        },
        eTag: {
          type: "string"
        },
        hitCount: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/browser.json
var require_browser = __commonJS({
  "../../node_modules/har-schema/lib/browser.json"(exports2, module2) {
    module2.exports = {
      $id: "browser.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "version"
      ],
      properties: {
        name: {
          type: "string"
        },
        version: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/cache.json
var require_cache2 = __commonJS({
  "../../node_modules/har-schema/lib/cache.json"(exports2, module2) {
    module2.exports = {
      $id: "cache.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      properties: {
        beforeRequest: {
          oneOf: [
            { type: "null" },
            { $ref: "beforeRequest.json#" }
          ]
        },
        afterRequest: {
          oneOf: [
            { type: "null" },
            { $ref: "afterRequest.json#" }
          ]
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/content.json
var require_content = __commonJS({
  "../../node_modules/har-schema/lib/content.json"(exports2, module2) {
    module2.exports = {
      $id: "content.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "size",
        "mimeType"
      ],
      properties: {
        size: {
          type: "integer"
        },
        compression: {
          type: "integer"
        },
        mimeType: {
          type: "string"
        },
        text: {
          type: "string"
        },
        encoding: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/cookie.json
var require_cookie2 = __commonJS({
  "../../node_modules/har-schema/lib/cookie.json"(exports2, module2) {
    module2.exports = {
      $id: "cookie.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "value"
      ],
      properties: {
        name: {
          type: "string"
        },
        value: {
          type: "string"
        },
        path: {
          type: "string"
        },
        domain: {
          type: "string"
        },
        expires: {
          type: ["string", "null"],
          format: "date-time"
        },
        httpOnly: {
          type: "boolean"
        },
        secure: {
          type: "boolean"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/creator.json
var require_creator = __commonJS({
  "../../node_modules/har-schema/lib/creator.json"(exports2, module2) {
    module2.exports = {
      $id: "creator.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "version"
      ],
      properties: {
        name: {
          type: "string"
        },
        version: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/entry.json
var require_entry = __commonJS({
  "../../node_modules/har-schema/lib/entry.json"(exports2, module2) {
    module2.exports = {
      $id: "entry.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "startedDateTime",
        "time",
        "request",
        "response",
        "cache",
        "timings"
      ],
      properties: {
        pageref: {
          type: "string"
        },
        startedDateTime: {
          type: "string",
          format: "date-time",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
        },
        time: {
          type: "number",
          min: 0
        },
        request: {
          $ref: "request.json#"
        },
        response: {
          $ref: "response.json#"
        },
        cache: {
          $ref: "cache.json#"
        },
        timings: {
          $ref: "timings.json#"
        },
        serverIPAddress: {
          type: "string",
          oneOf: [
            { format: "ipv4" },
            { format: "ipv6" }
          ]
        },
        connection: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/har.json
var require_har = __commonJS({
  "../../node_modules/har-schema/lib/har.json"(exports2, module2) {
    module2.exports = {
      $id: "har.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "log"
      ],
      properties: {
        log: {
          $ref: "log.json#"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/header.json
var require_header = __commonJS({
  "../../node_modules/har-schema/lib/header.json"(exports2, module2) {
    module2.exports = {
      $id: "header.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "value"
      ],
      properties: {
        name: {
          type: "string"
        },
        value: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/log.json
var require_log = __commonJS({
  "../../node_modules/har-schema/lib/log.json"(exports2, module2) {
    module2.exports = {
      $id: "log.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "version",
        "creator",
        "entries"
      ],
      properties: {
        version: {
          type: "string"
        },
        creator: {
          $ref: "creator.json#"
        },
        browser: {
          $ref: "browser.json#"
        },
        pages: {
          type: "array",
          items: {
            $ref: "page.json#"
          }
        },
        entries: {
          type: "array",
          items: {
            $ref: "entry.json#"
          }
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/page.json
var require_page = __commonJS({
  "../../node_modules/har-schema/lib/page.json"(exports2, module2) {
    module2.exports = {
      $id: "page.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "startedDateTime",
        "id",
        "title",
        "pageTimings"
      ],
      properties: {
        startedDateTime: {
          type: "string",
          format: "date-time",
          pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
        },
        id: {
          type: "string",
          unique: true
        },
        title: {
          type: "string"
        },
        pageTimings: {
          $ref: "pageTimings.json#"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/pageTimings.json
var require_pageTimings = __commonJS({
  "../../node_modules/har-schema/lib/pageTimings.json"(exports2, module2) {
    module2.exports = {
      $id: "pageTimings.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      properties: {
        onContentLoad: {
          type: "number",
          min: -1
        },
        onLoad: {
          type: "number",
          min: -1
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/postData.json
var require_postData = __commonJS({
  "../../node_modules/har-schema/lib/postData.json"(exports2, module2) {
    module2.exports = {
      $id: "postData.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      optional: true,
      required: [
        "mimeType"
      ],
      properties: {
        mimeType: {
          type: "string"
        },
        text: {
          type: "string"
        },
        params: {
          type: "array",
          required: [
            "name"
          ],
          properties: {
            name: {
              type: "string"
            },
            value: {
              type: "string"
            },
            fileName: {
              type: "string"
            },
            contentType: {
              type: "string"
            },
            comment: {
              type: "string"
            }
          }
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/query.json
var require_query = __commonJS({
  "../../node_modules/har-schema/lib/query.json"(exports2, module2) {
    module2.exports = {
      $id: "query.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "name",
        "value"
      ],
      properties: {
        name: {
          type: "string"
        },
        value: {
          type: "string"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/request.json
var require_request = __commonJS({
  "../../node_modules/har-schema/lib/request.json"(exports2, module2) {
    module2.exports = {
      $id: "request.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "method",
        "url",
        "httpVersion",
        "cookies",
        "headers",
        "queryString",
        "headersSize",
        "bodySize"
      ],
      properties: {
        method: {
          type: "string"
        },
        url: {
          type: "string",
          format: "uri"
        },
        httpVersion: {
          type: "string"
        },
        cookies: {
          type: "array",
          items: {
            $ref: "cookie.json#"
          }
        },
        headers: {
          type: "array",
          items: {
            $ref: "header.json#"
          }
        },
        queryString: {
          type: "array",
          items: {
            $ref: "query.json#"
          }
        },
        postData: {
          $ref: "postData.json#"
        },
        headersSize: {
          type: "integer"
        },
        bodySize: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/response.json
var require_response = __commonJS({
  "../../node_modules/har-schema/lib/response.json"(exports2, module2) {
    module2.exports = {
      $id: "response.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      type: "object",
      required: [
        "status",
        "statusText",
        "httpVersion",
        "cookies",
        "headers",
        "content",
        "redirectURL",
        "headersSize",
        "bodySize"
      ],
      properties: {
        status: {
          type: "integer"
        },
        statusText: {
          type: "string"
        },
        httpVersion: {
          type: "string"
        },
        cookies: {
          type: "array",
          items: {
            $ref: "cookie.json#"
          }
        },
        headers: {
          type: "array",
          items: {
            $ref: "header.json#"
          }
        },
        content: {
          $ref: "content.json#"
        },
        redirectURL: {
          type: "string"
        },
        headersSize: {
          type: "integer"
        },
        bodySize: {
          type: "integer"
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/timings.json
var require_timings = __commonJS({
  "../../node_modules/har-schema/lib/timings.json"(exports2, module2) {
    module2.exports = {
      $id: "timings.json#",
      $schema: "http://json-schema.org/draft-06/schema#",
      required: [
        "send",
        "wait",
        "receive"
      ],
      properties: {
        dns: {
          type: "number",
          min: -1
        },
        connect: {
          type: "number",
          min: -1
        },
        blocked: {
          type: "number",
          min: -1
        },
        send: {
          type: "number",
          min: -1
        },
        wait: {
          type: "number",
          min: -1
        },
        receive: {
          type: "number",
          min: -1
        },
        ssl: {
          type: "number",
          min: -1
        },
        comment: {
          type: "string"
        }
      }
    };
  }
});

// ../../node_modules/har-schema/lib/index.js
var require_lib6 = __commonJS({
  "../../node_modules/har-schema/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      afterRequest: require_afterRequest(),
      beforeRequest: require_beforeRequest(),
      browser: require_browser(),
      cache: require_cache2(),
      content: require_content(),
      cookie: require_cookie2(),
      creator: require_creator(),
      entry: require_entry(),
      har: require_har(),
      header: require_header(),
      log: require_log(),
      page: require_page(),
      pageTimings: require_pageTimings(),
      postData: require_postData(),
      query: require_query(),
      request: require_request(),
      response: require_response(),
      timings: require_timings()
    };
  }
});

// ../../node_modules/ajv/lib/refs/json-schema-draft-06.json
var require_json_schema_draft_06 = __commonJS({
  "../../node_modules/ajv/lib/refs/json-schema-draft-06.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-06/schema#",
      $id: "http://json-schema.org/draft-06/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: {},
        examples: {
          type: "array",
          items: {}
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: {}
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: {},
        enum: {
          type: "array",
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: {}
    };
  }
});

// ../../node_modules/har-validator/lib/promise.js
var require_promise = __commonJS({
  "../../node_modules/har-validator/lib/promise.js"(exports2) {
    var Ajv = require_ajv();
    var HARError = require_error();
    var schemas = require_lib6();
    var ajv;
    function createAjvInstance() {
      var ajv2 = new Ajv({
        allErrors: true
      });
      ajv2.addMetaSchema(require_json_schema_draft_06());
      ajv2.addSchema(schemas);
      return ajv2;
    }
    function validate(name, data) {
      data = data || {};
      ajv = ajv || createAjvInstance();
      var validate2 = ajv.getSchema(name + ".json");
      return new Promise(function(resolve, reject) {
        var valid = validate2(data);
        !valid ? reject(new HARError(validate2.errors)) : resolve(data);
      });
    }
    exports2.afterRequest = function(data) {
      return validate("afterRequest", data);
    };
    exports2.beforeRequest = function(data) {
      return validate("beforeRequest", data);
    };
    exports2.browser = function(data) {
      return validate("browser", data);
    };
    exports2.cache = function(data) {
      return validate("cache", data);
    };
    exports2.content = function(data) {
      return validate("content", data);
    };
    exports2.cookie = function(data) {
      return validate("cookie", data);
    };
    exports2.creator = function(data) {
      return validate("creator", data);
    };
    exports2.entry = function(data) {
      return validate("entry", data);
    };
    exports2.har = function(data) {
      return validate("har", data);
    };
    exports2.header = function(data) {
      return validate("header", data);
    };
    exports2.log = function(data) {
      return validate("log", data);
    };
    exports2.page = function(data) {
      return validate("page", data);
    };
    exports2.pageTimings = function(data) {
      return validate("pageTimings", data);
    };
    exports2.postData = function(data) {
      return validate("postData", data);
    };
    exports2.query = function(data) {
      return validate("query", data);
    };
    exports2.request = function(data) {
      return validate("request", data);
    };
    exports2.response = function(data) {
      return validate("response", data);
    };
    exports2.timings = function(data) {
      return validate("timings", data);
    };
  }
});

// ../../node_modules/request/lib/har.js
var require_har2 = __commonJS({
  "../../node_modules/request/lib/har.js"(exports2) {
    "use strict";
    var fs3 = require("fs");
    var qs = require("querystring");
    var validate = require_promise();
    var extend = require_extend();
    function Har(request) {
      this.request = request;
    }
    Har.prototype.reducer = function(obj, pair) {
      if (obj[pair.name] === void 0) {
        obj[pair.name] = pair.value;
        return obj;
      }
      var arr = [
        obj[pair.name],
        pair.value
      ];
      obj[pair.name] = arr;
      return obj;
    };
    Har.prototype.prep = function(data) {
      data.queryObj = {};
      data.headersObj = {};
      data.postData.jsonObj = false;
      data.postData.paramsObj = false;
      if (data.queryString && data.queryString.length) {
        data.queryObj = data.queryString.reduce(this.reducer, {});
      }
      if (data.headers && data.headers.length) {
        data.headersObj = data.headers.reduceRight(function(headers, header) {
          headers[header.name] = header.value;
          return headers;
        }, {});
      }
      if (data.cookies && data.cookies.length) {
        var cookies = data.cookies.map(function(cookie) {
          return cookie.name + "=" + cookie.value;
        });
        if (cookies.length) {
          data.headersObj.cookie = cookies.join("; ");
        }
      }
      function some(arr) {
        return arr.some(function(type) {
          return data.postData.mimeType.indexOf(type) === 0;
        });
      }
      if (some([
        "multipart/mixed",
        "multipart/related",
        "multipart/form-data",
        "multipart/alternative"
      ])) {
        data.postData.mimeType = "multipart/form-data";
      } else if (some([
        "application/x-www-form-urlencoded"
      ])) {
        if (!data.postData.params) {
          data.postData.text = "";
        } else {
          data.postData.paramsObj = data.postData.params.reduce(this.reducer, {});
          data.postData.text = qs.stringify(data.postData.paramsObj);
        }
      } else if (some([
        "text/json",
        "text/x-json",
        "application/json",
        "application/x-json"
      ])) {
        data.postData.mimeType = "application/json";
        if (data.postData.text) {
          try {
            data.postData.jsonObj = JSON.parse(data.postData.text);
          } catch (e) {
            this.request.debug(e);
            data.postData.mimeType = "text/plain";
          }
        }
      }
      return data;
    };
    Har.prototype.options = function(options) {
      if (!options.har) {
        return options;
      }
      var har = {};
      extend(har, options.har);
      if (har.log && har.log.entries) {
        har = har.log.entries[0];
      }
      har.url = har.url || options.url || options.uri || options.baseUrl || "/";
      har.httpVersion = har.httpVersion || "HTTP/1.1";
      har.queryString = har.queryString || [];
      har.headers = har.headers || [];
      har.cookies = har.cookies || [];
      har.postData = har.postData || {};
      har.postData.mimeType = har.postData.mimeType || "application/octet-stream";
      har.bodySize = 0;
      har.headersSize = 0;
      har.postData.size = 0;
      if (!validate.request(har)) {
        return options;
      }
      var req = this.prep(har);
      if (req.url) {
        options.url = req.url;
      }
      if (req.method) {
        options.method = req.method;
      }
      if (Object.keys(req.queryObj).length) {
        options.qs = req.queryObj;
      }
      if (Object.keys(req.headersObj).length) {
        options.headers = req.headersObj;
      }
      function test(type) {
        return req.postData.mimeType.indexOf(type) === 0;
      }
      if (test("application/x-www-form-urlencoded")) {
        options.form = req.postData.paramsObj;
      } else if (test("application/json")) {
        if (req.postData.jsonObj) {
          options.body = req.postData.jsonObj;
          options.json = true;
        }
      } else if (test("multipart/form-data")) {
        options.formData = {};
        req.postData.params.forEach(function(param) {
          var attachment = {};
          if (!param.fileName && !param.contentType) {
            options.formData[param.name] = param.value;
            return;
          }
          if (param.fileName && !param.value) {
            attachment.value = fs3.createReadStream(param.fileName);
          } else if (param.value) {
            attachment.value = param.value;
          }
          if (param.fileName) {
            attachment.options = {
              filename: param.fileName,
              contentType: param.contentType ? param.contentType : null
            };
          }
          options.formData[param.name] = attachment;
        });
      } else {
        if (req.postData.text) {
          options.body = req.postData.text;
        }
      }
      return options;
    };
    exports2.Har = Har;
  }
});

// ../../node_modules/uuid/lib/rng.js
var require_rng = __commonJS({
  "../../node_modules/uuid/lib/rng.js"(exports2, module2) {
    var crypto = require("crypto");
    module2.exports = function nodeRNG() {
      return crypto.randomBytes(16);
    };
  }
});

// ../../node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "../../node_modules/uuid/lib/bytesToUuid.js"(exports2, module2) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module2.exports = bytesToUuid;
  }
});

// ../../node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "../../node_modules/uuid/v4.js"(exports2, module2) {
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module2.exports = v4;
  }
});

// ../../node_modules/request/lib/auth.js
var require_auth = __commonJS({
  "../../node_modules/request/lib/auth.js"(exports2) {
    "use strict";
    var caseless = require_caseless();
    var uuid = require_v4();
    var helpers = require_helpers();
    var md5 = helpers.md5;
    var toBase64 = helpers.toBase64;
    function Auth(request) {
      this.request = request;
      this.hasAuth = false;
      this.sentAuth = false;
      this.bearerToken = null;
      this.user = null;
      this.pass = null;
    }
    Auth.prototype.basic = function(user, pass, sendImmediately) {
      var self2 = this;
      if (typeof user !== "string" || pass !== void 0 && typeof pass !== "string") {
        self2.request.emit("error", new Error("auth() received invalid user or password"));
      }
      self2.user = user;
      self2.pass = pass;
      self2.hasAuth = true;
      var header = user + ":" + (pass || "");
      if (sendImmediately || typeof sendImmediately === "undefined") {
        var authHeader = "Basic " + toBase64(header);
        self2.sentAuth = true;
        return authHeader;
      }
    };
    Auth.prototype.bearer = function(bearer, sendImmediately) {
      var self2 = this;
      self2.bearerToken = bearer;
      self2.hasAuth = true;
      if (sendImmediately || typeof sendImmediately === "undefined") {
        if (typeof bearer === "function") {
          bearer = bearer();
        }
        var authHeader = "Bearer " + (bearer || "");
        self2.sentAuth = true;
        return authHeader;
      }
    };
    Auth.prototype.digest = function(method, path2, authHeader) {
      var self2 = this;
      var challenge = {};
      var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
      while (true) {
        var match = re.exec(authHeader);
        if (!match) {
          break;
        }
        challenge[match[1]] = match[2] || match[3];
      }
      var ha1Compute = function(algorithm, user, realm, pass, nonce, cnonce2) {
        var ha12 = md5(user + ":" + realm + ":" + pass);
        if (algorithm && algorithm.toLowerCase() === "md5-sess") {
          return md5(ha12 + ":" + nonce + ":" + cnonce2);
        } else {
          return ha12;
        }
      };
      var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && "auth";
      var nc = qop && "00000001";
      var cnonce = qop && uuid().replace(/-/g, "");
      var ha1 = ha1Compute(challenge.algorithm, self2.user, challenge.realm, self2.pass, challenge.nonce, cnonce);
      var ha2 = md5(method + ":" + path2);
      var digestResponse = qop ? md5(ha1 + ":" + challenge.nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2) : md5(ha1 + ":" + challenge.nonce + ":" + ha2);
      var authValues = {
        username: self2.user,
        realm: challenge.realm,
        nonce: challenge.nonce,
        uri: path2,
        qop,
        response: digestResponse,
        nc,
        cnonce,
        algorithm: challenge.algorithm,
        opaque: challenge.opaque
      };
      authHeader = [];
      for (var k in authValues) {
        if (authValues[k]) {
          if (k === "qop" || k === "nc" || k === "algorithm") {
            authHeader.push(k + "=" + authValues[k]);
          } else {
            authHeader.push(k + '="' + authValues[k] + '"');
          }
        }
      }
      authHeader = "Digest " + authHeader.join(", ");
      self2.sentAuth = true;
      return authHeader;
    };
    Auth.prototype.onRequest = function(user, pass, sendImmediately, bearer) {
      var self2 = this;
      var request = self2.request;
      var authHeader;
      if (bearer === void 0 && user === void 0) {
        self2.request.emit("error", new Error("no auth mechanism defined"));
      } else if (bearer !== void 0) {
        authHeader = self2.bearer(bearer, sendImmediately);
      } else {
        authHeader = self2.basic(user, pass, sendImmediately);
      }
      if (authHeader) {
        request.setHeader("authorization", authHeader);
      }
    };
    Auth.prototype.onResponse = function(response) {
      var self2 = this;
      var request = self2.request;
      if (!self2.hasAuth || self2.sentAuth) {
        return null;
      }
      var c = caseless(response.headers);
      var authHeader = c.get("www-authenticate");
      var authVerb = authHeader && authHeader.split(" ")[0].toLowerCase();
      request.debug("reauth", authVerb);
      switch (authVerb) {
        case "basic":
          return self2.basic(self2.user, self2.pass, true);
        case "bearer":
          return self2.bearer(self2.bearerToken, true);
        case "digest":
          return self2.digest(request.method, request.path, authHeader);
      }
    };
    exports2.Auth = Auth;
  }
});

// ../../node_modules/oauth-sign/index.js
var require_oauth_sign = __commonJS({
  "../../node_modules/oauth-sign/index.js"(exports2) {
    var crypto = require("crypto");
    function sha(key, body, algorithm) {
      return crypto.createHmac(algorithm, key).update(body).digest("base64");
    }
    function rsa(key, body) {
      return crypto.createSign("RSA-SHA1").update(body).sign(key, "base64");
    }
    function rfc3986(str) {
      return encodeURIComponent(str).replace(/!/g, "%21").replace(/\*/g, "%2A").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/'/g, "%27");
    }
    function map(obj) {
      var key, val, arr = [];
      for (key in obj) {
        val = obj[key];
        if (Array.isArray(val))
          for (var i = 0; i < val.length; i++)
            arr.push([key, val[i]]);
        else if (typeof val === "object")
          for (var prop in val)
            arr.push([key + "[" + prop + "]", val[prop]]);
        else
          arr.push([key, val]);
      }
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    function generateBase(httpMethod, base_uri, params) {
      var normalized = map(params).map(function(p) {
        return [rfc3986(p[0]), rfc3986(p[1] || "")];
      }).sort(function(a, b) {
        return compare(a[0], b[0]) || compare(a[1], b[1]);
      }).map(function(p) {
        return p.join("=");
      }).join("&");
      var base = [
        rfc3986(httpMethod ? httpMethod.toUpperCase() : "GET"),
        rfc3986(base_uri),
        rfc3986(normalized)
      ].join("&");
      return base;
    }
    function hmacsign(httpMethod, base_uri, params, consumer_secret, token_secret) {
      var base = generateBase(httpMethod, base_uri, params);
      var key = [
        consumer_secret || "",
        token_secret || ""
      ].map(rfc3986).join("&");
      return sha(key, base, "sha1");
    }
    function hmacsign256(httpMethod, base_uri, params, consumer_secret, token_secret) {
      var base = generateBase(httpMethod, base_uri, params);
      var key = [
        consumer_secret || "",
        token_secret || ""
      ].map(rfc3986).join("&");
      return sha(key, base, "sha256");
    }
    function rsasign(httpMethod, base_uri, params, private_key, token_secret) {
      var base = generateBase(httpMethod, base_uri, params);
      var key = private_key || "";
      return rsa(key, base);
    }
    function plaintext(consumer_secret, token_secret) {
      var key = [
        consumer_secret || "",
        token_secret || ""
      ].map(rfc3986).join("&");
      return key;
    }
    function sign(signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
      var method;
      var skipArgs = 1;
      switch (signMethod) {
        case "RSA-SHA1":
          method = rsasign;
          break;
        case "HMAC-SHA1":
          method = hmacsign;
          break;
        case "HMAC-SHA256":
          method = hmacsign256;
          break;
        case "PLAINTEXT":
          method = plaintext;
          skipArgs = 4;
          break;
        default:
          throw new Error("Signature method not supported: " + signMethod);
      }
      return method.apply(null, [].slice.call(arguments, skipArgs));
    }
    exports2.hmacsign = hmacsign;
    exports2.hmacsign256 = hmacsign256;
    exports2.rsasign = rsasign;
    exports2.plaintext = plaintext;
    exports2.sign = sign;
    exports2.rfc3986 = rfc3986;
    exports2.generateBase = generateBase;
  }
});

// ../../node_modules/request/lib/oauth.js
var require_oauth = __commonJS({
  "../../node_modules/request/lib/oauth.js"(exports2) {
    "use strict";
    var url = require("url");
    var qs = require_lib5();
    var caseless = require_caseless();
    var uuid = require_v4();
    var oauth = require_oauth_sign();
    var crypto = require("crypto");
    var Buffer2 = require_safe_buffer().Buffer;
    function OAuth(request) {
      this.request = request;
      this.params = null;
    }
    OAuth.prototype.buildParams = function(_oauth, uri, method, query, form, qsLib) {
      var oa = {};
      for (var i in _oauth) {
        oa["oauth_" + i] = _oauth[i];
      }
      if (!oa.oauth_version) {
        oa.oauth_version = "1.0";
      }
      if (!oa.oauth_timestamp) {
        oa.oauth_timestamp = Math.floor(Date.now() / 1e3).toString();
      }
      if (!oa.oauth_nonce) {
        oa.oauth_nonce = uuid().replace(/-/g, "");
      }
      if (!oa.oauth_signature_method) {
        oa.oauth_signature_method = "HMAC-SHA1";
      }
      var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key;
      delete oa.oauth_consumer_secret;
      delete oa.oauth_private_key;
      var token_secret = oa.oauth_token_secret;
      delete oa.oauth_token_secret;
      var realm = oa.oauth_realm;
      delete oa.oauth_realm;
      delete oa.oauth_transport_method;
      var baseurl = uri.protocol + "//" + uri.host + uri.pathname;
      var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join("&"));
      oa.oauth_signature = oauth.sign(oa.oauth_signature_method, method, baseurl, params, consumer_secret_or_private_key, token_secret);
      if (realm) {
        oa.realm = realm;
      }
      return oa;
    };
    OAuth.prototype.buildBodyHash = function(_oauth, body) {
      if (["HMAC-SHA1", "RSA-SHA1"].indexOf(_oauth.signature_method || "HMAC-SHA1") < 0) {
        this.request.emit("error", new Error("oauth: " + _oauth.signature_method + " signature_method not supported with body_hash signing."));
      }
      var shasum = crypto.createHash("sha1");
      shasum.update(body || "");
      var sha1 = shasum.digest("hex");
      return Buffer2.from(sha1, "hex").toString("base64");
    };
    OAuth.prototype.concatParams = function(oa, sep, wrap) {
      wrap = wrap || "";
      var params = Object.keys(oa).filter(function(i) {
        return i !== "realm" && i !== "oauth_signature";
      }).sort();
      if (oa.realm) {
        params.splice(0, 0, "realm");
      }
      params.push("oauth_signature");
      return params.map(function(i) {
        return i + "=" + wrap + oauth.rfc3986(oa[i]) + wrap;
      }).join(sep);
    };
    OAuth.prototype.onRequest = function(_oauth) {
      var self2 = this;
      self2.params = _oauth;
      var uri = self2.request.uri || {};
      var method = self2.request.method || "";
      var headers = caseless(self2.request.headers);
      var body = self2.request.body || "";
      var qsLib = self2.request.qsLib || qs;
      var form;
      var query;
      var contentType = headers.get("content-type") || "";
      var formContentType = "application/x-www-form-urlencoded";
      var transport = _oauth.transport_method || "header";
      if (contentType.slice(0, formContentType.length) === formContentType) {
        contentType = formContentType;
        form = body;
      }
      if (uri.query) {
        query = uri.query;
      }
      if (transport === "body" && (method !== "POST" || contentType !== formContentType)) {
        self2.request.emit("error", new Error("oauth: transport_method of body requires POST and content-type " + formContentType));
      }
      if (!form && typeof _oauth.body_hash === "boolean") {
        _oauth.body_hash = self2.buildBodyHash(_oauth, self2.request.body.toString());
      }
      var oa = self2.buildParams(_oauth, uri, method, query, form, qsLib);
      switch (transport) {
        case "header":
          self2.request.setHeader("Authorization", "OAuth " + self2.concatParams(oa, ",", '"'));
          break;
        case "query":
          var href = self2.request.uri.href += (query ? "&" : "?") + self2.concatParams(oa, "&");
          self2.request.uri = url.parse(href);
          self2.request.path = self2.request.uri.path;
          break;
        case "body":
          self2.request.body = (form ? form + "&" : "") + self2.concatParams(oa, "&");
          break;
        default:
          self2.request.emit("error", new Error("oauth: transport_method invalid"));
      }
    };
    exports2.OAuth = OAuth;
  }
});

// ../../node_modules/request/lib/hawk.js
var require_hawk = __commonJS({
  "../../node_modules/request/lib/hawk.js"(exports2) {
    "use strict";
    var crypto = require("crypto");
    function randomString(size) {
      var bits = (size + 1) * 6;
      var buffer = crypto.randomBytes(Math.ceil(bits / 8));
      var string = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      return string.slice(0, size);
    }
    function calculatePayloadHash(payload, algorithm, contentType) {
      var hash = crypto.createHash(algorithm);
      hash.update("hawk.1.payload\n");
      hash.update((contentType ? contentType.split(";")[0].trim().toLowerCase() : "") + "\n");
      hash.update(payload || "");
      hash.update("\n");
      return hash.digest("base64");
    }
    exports2.calculateMac = function(credentials, opts) {
      var normalized = "hawk.1.header\n" + opts.ts + "\n" + opts.nonce + "\n" + (opts.method || "").toUpperCase() + "\n" + opts.resource + "\n" + opts.host.toLowerCase() + "\n" + opts.port + "\n" + (opts.hash || "") + "\n";
      if (opts.ext) {
        normalized = normalized + opts.ext.replace("\\", "\\\\").replace("\n", "\\n");
      }
      normalized = normalized + "\n";
      if (opts.app) {
        normalized = normalized + opts.app + "\n" + (opts.dlg || "") + "\n";
      }
      var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
      var digest = hmac.digest("base64");
      return digest;
    };
    exports2.header = function(uri, method, opts) {
      var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1e3);
      var credentials = opts.credentials;
      if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
        return "";
      }
      if (["sha1", "sha256"].indexOf(credentials.algorithm) === -1) {
        return "";
      }
      var artifacts = {
        ts: timestamp,
        nonce: opts.nonce || randomString(6),
        method,
        resource: uri.pathname + (uri.search || ""),
        host: uri.hostname,
        port: uri.port || (uri.protocol === "http:" ? 80 : 443),
        hash: opts.hash,
        ext: opts.ext,
        app: opts.app,
        dlg: opts.dlg
      };
      if (!artifacts.hash && (opts.payload || opts.payload === "")) {
        artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType);
      }
      var mac = exports2.calculateMac(credentials, artifacts);
      var hasExt = artifacts.ext !== null && artifacts.ext !== void 0 && artifacts.ext !== "";
      var header = 'Hawk id="' + credentials.id + '", ts="' + artifacts.ts + '", nonce="' + artifacts.nonce + (artifacts.hash ? '", hash="' + artifacts.hash : "") + (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, "\\\\").replace(/"/g, '\\"') : "") + '", mac="' + mac + '"';
      if (artifacts.app) {
        header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : "") + '"';
      }
      return header;
    };
  }
});

// ../../node_modules/request/lib/multipart.js
var require_multipart = __commonJS({
  "../../node_modules/request/lib/multipart.js"(exports2) {
    "use strict";
    var uuid = require_v4();
    var CombinedStream = require_combined_stream();
    var isstream = require_isstream();
    var Buffer2 = require_safe_buffer().Buffer;
    function Multipart(request) {
      this.request = request;
      this.boundary = uuid();
      this.chunked = false;
      this.body = null;
    }
    Multipart.prototype.isChunked = function(options) {
      var self2 = this;
      var chunked = false;
      var parts = options.data || options;
      if (!parts.forEach) {
        self2.request.emit("error", new Error("Argument error, options.multipart."));
      }
      if (options.chunked !== void 0) {
        chunked = options.chunked;
      }
      if (self2.request.getHeader("transfer-encoding") === "chunked") {
        chunked = true;
      }
      if (!chunked) {
        parts.forEach(function(part) {
          if (typeof part.body === "undefined") {
            self2.request.emit("error", new Error("Body attribute missing in multipart."));
          }
          if (isstream(part.body)) {
            chunked = true;
          }
        });
      }
      return chunked;
    };
    Multipart.prototype.setHeaders = function(chunked) {
      var self2 = this;
      if (chunked && !self2.request.hasHeader("transfer-encoding")) {
        self2.request.setHeader("transfer-encoding", "chunked");
      }
      var header = self2.request.getHeader("content-type");
      if (!header || header.indexOf("multipart") === -1) {
        self2.request.setHeader("content-type", "multipart/related; boundary=" + self2.boundary);
      } else {
        if (header.indexOf("boundary") !== -1) {
          self2.boundary = header.replace(/.*boundary=([^\s;]+).*/, "$1");
        } else {
          self2.request.setHeader("content-type", header + "; boundary=" + self2.boundary);
        }
      }
    };
    Multipart.prototype.build = function(parts, chunked) {
      var self2 = this;
      var body = chunked ? new CombinedStream() : [];
      function add(part) {
        if (typeof part === "number") {
          part = part.toString();
        }
        return chunked ? body.append(part) : body.push(Buffer2.from(part));
      }
      if (self2.request.preambleCRLF) {
        add("\r\n");
      }
      parts.forEach(function(part) {
        var preamble = "--" + self2.boundary + "\r\n";
        Object.keys(part).forEach(function(key) {
          if (key === "body") {
            return;
          }
          preamble += key + ": " + part[key] + "\r\n";
        });
        preamble += "\r\n";
        add(preamble);
        add(part.body);
        add("\r\n");
      });
      add("--" + self2.boundary + "--");
      if (self2.request.postambleCRLF) {
        add("\r\n");
      }
      return body;
    };
    Multipart.prototype.onRequest = function(options) {
      var self2 = this;
      var chunked = self2.isChunked(options);
      var parts = options.data || options;
      self2.setHeaders(chunked);
      self2.chunked = chunked;
      self2.body = self2.build(parts, chunked);
    };
    exports2.Multipart = Multipart;
  }
});

// ../../node_modules/request/lib/redirect.js
var require_redirect = __commonJS({
  "../../node_modules/request/lib/redirect.js"(exports2) {
    "use strict";
    var url = require("url");
    var isUrl = /^https?:/;
    function Redirect(request) {
      this.request = request;
      this.followRedirect = true;
      this.followRedirects = true;
      this.followAllRedirects = false;
      this.followOriginalHttpMethod = false;
      this.allowRedirect = function() {
        return true;
      };
      this.maxRedirects = 10;
      this.redirects = [];
      this.redirectsFollowed = 0;
      this.removeRefererHeader = false;
    }
    Redirect.prototype.onRequest = function(options) {
      var self2 = this;
      if (options.maxRedirects !== void 0) {
        self2.maxRedirects = options.maxRedirects;
      }
      if (typeof options.followRedirect === "function") {
        self2.allowRedirect = options.followRedirect;
      }
      if (options.followRedirect !== void 0) {
        self2.followRedirects = !!options.followRedirect;
      }
      if (options.followAllRedirects !== void 0) {
        self2.followAllRedirects = options.followAllRedirects;
      }
      if (self2.followRedirects || self2.followAllRedirects) {
        self2.redirects = self2.redirects || [];
      }
      if (options.removeRefererHeader !== void 0) {
        self2.removeRefererHeader = options.removeRefererHeader;
      }
      if (options.followOriginalHttpMethod !== void 0) {
        self2.followOriginalHttpMethod = options.followOriginalHttpMethod;
      }
    };
    Redirect.prototype.redirectTo = function(response) {
      var self2 = this;
      var request = self2.request;
      var redirectTo = null;
      if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has("location")) {
        var location = response.caseless.get("location");
        request.debug("redirect", location);
        if (self2.followAllRedirects) {
          redirectTo = location;
        } else if (self2.followRedirects) {
          switch (request.method) {
            case "PATCH":
            case "PUT":
            case "POST":
            case "DELETE":
              break;
            default:
              redirectTo = location;
              break;
          }
        }
      } else if (response.statusCode === 401) {
        var authHeader = request._auth.onResponse(response);
        if (authHeader) {
          request.setHeader("authorization", authHeader);
          redirectTo = request.uri;
        }
      }
      return redirectTo;
    };
    Redirect.prototype.onResponse = function(response) {
      var self2 = this;
      var request = self2.request;
      var redirectTo = self2.redirectTo(response);
      if (!redirectTo || !self2.allowRedirect.call(request, response)) {
        return false;
      }
      request.debug("redirect to", redirectTo);
      if (response.resume) {
        response.resume();
      }
      if (self2.redirectsFollowed >= self2.maxRedirects) {
        request.emit("error", new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + request.uri.href));
        return false;
      }
      self2.redirectsFollowed += 1;
      if (!isUrl.test(redirectTo)) {
        redirectTo = url.resolve(request.uri.href, redirectTo);
      }
      var uriPrev = request.uri;
      request.uri = url.parse(redirectTo);
      if (request.uri.protocol !== uriPrev.protocol) {
        delete request.agent;
      }
      self2.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo });
      if (self2.followAllRedirects && request.method !== "HEAD" && response.statusCode !== 401 && response.statusCode !== 307) {
        request.method = self2.followOriginalHttpMethod ? request.method : "GET";
      }
      delete request.src;
      delete request.req;
      delete request._started;
      if (response.statusCode !== 401 && response.statusCode !== 307) {
        delete request.body;
        delete request._form;
        if (request.headers) {
          request.removeHeader("host");
          request.removeHeader("content-type");
          request.removeHeader("content-length");
          if (request.uri.hostname !== request.originalHost.split(":")[0]) {
            request.removeHeader("authorization");
          }
        }
      }
      if (!self2.removeRefererHeader) {
        request.setHeader("referer", uriPrev.href);
      }
      request.emit("redirect");
      request.init();
      return true;
    };
    exports2.Redirect = Redirect;
  }
});

// ../../node_modules/tunnel-agent/index.js
var require_tunnel_agent = __commonJS({
  "../../node_modules/tunnel-agent/index.js"(exports2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http2 = require("http");
    var https2 = require("https");
    var events = require("events");
    var assert3 = require("assert");
    var util2 = require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http2.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http2.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https2.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https2.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http2.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port) {
        for (var i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === host && pending.port === port) {
            self2.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util2.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
      var self2 = this;
      if (typeof options === "string") {
        options = {
          host: options,
          port: arguments[2],
          path: arguments[3]
        };
      }
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push({ host: options.host, port: options.port, request: req });
        return;
      }
      self2.createConnection({ host: options.host, port: options.port, request: req });
    };
    TunnelingAgent.prototype.createConnection = function createConnection(pending) {
      var self2 = this;
      self2.createSocket(pending, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        pending.request.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, pending.host, pending.port);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false
      });
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + Buffer2.from(connectOptions.proxyAuth).toString("base64");
      }
      debug("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode === 200) {
          assert3.equal(head.length, 0);
          debug("tunneling connection has established");
          self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
          cb(socket);
        } else {
          debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
        }
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1)
        return;
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createConnection(pending);
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var secureSocket = tls.connect(0, mergeOptions({}, self2.options, {
          servername: options.host,
          socket
        }));
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.debug = debug;
  }
});

// ../../node_modules/request/lib/tunnel.js
var require_tunnel = __commonJS({
  "../../node_modules/request/lib/tunnel.js"(exports2) {
    "use strict";
    var url = require("url");
    var tunnel = require_tunnel_agent();
    var defaultProxyHeaderWhiteList = [
      "accept",
      "accept-charset",
      "accept-encoding",
      "accept-language",
      "accept-ranges",
      "cache-control",
      "content-encoding",
      "content-language",
      "content-location",
      "content-md5",
      "content-range",
      "content-type",
      "connection",
      "date",
      "expect",
      "max-forwards",
      "pragma",
      "referer",
      "te",
      "user-agent",
      "via"
    ];
    var defaultProxyHeaderExclusiveList = [
      "proxy-authorization"
    ];
    function constructProxyHost(uriObject) {
      var port = uriObject.port;
      var protocol = uriObject.protocol;
      var proxyHost = uriObject.hostname + ":";
      if (port) {
        proxyHost += port;
      } else if (protocol === "https:") {
        proxyHost += "443";
      } else {
        proxyHost += "80";
      }
      return proxyHost;
    }
    function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
      var whiteList = proxyHeaderWhiteList.reduce(function(set, header) {
        set[header.toLowerCase()] = true;
        return set;
      }, {});
      return Object.keys(headers).filter(function(header) {
        return whiteList[header.toLowerCase()];
      }).reduce(function(set, header) {
        set[header] = headers[header];
        return set;
      }, {});
    }
    function constructTunnelOptions(request, proxyHeaders) {
      var proxy = request.proxy;
      var tunnelOptions = {
        proxy: {
          host: proxy.hostname,
          port: +proxy.port,
          proxyAuth: proxy.auth,
          headers: proxyHeaders
        },
        headers: request.headers,
        ca: request.ca,
        cert: request.cert,
        key: request.key,
        passphrase: request.passphrase,
        pfx: request.pfx,
        ciphers: request.ciphers,
        rejectUnauthorized: request.rejectUnauthorized,
        secureOptions: request.secureOptions,
        secureProtocol: request.secureProtocol
      };
      return tunnelOptions;
    }
    function constructTunnelFnName(uri, proxy) {
      var uriProtocol = uri.protocol === "https:" ? "https" : "http";
      var proxyProtocol = proxy.protocol === "https:" ? "Https" : "Http";
      return [uriProtocol, proxyProtocol].join("Over");
    }
    function getTunnelFn(request) {
      var uri = request.uri;
      var proxy = request.proxy;
      var tunnelFnName = constructTunnelFnName(uri, proxy);
      return tunnel[tunnelFnName];
    }
    function Tunnel(request) {
      this.request = request;
      this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;
      this.proxyHeaderExclusiveList = [];
      if (typeof request.tunnel !== "undefined") {
        this.tunnelOverride = request.tunnel;
      }
    }
    Tunnel.prototype.isEnabled = function() {
      var self2 = this;
      var request = self2.request;
      if (typeof self2.tunnelOverride !== "undefined") {
        return self2.tunnelOverride;
      }
      if (request.uri.protocol === "https:") {
        return true;
      }
      return false;
    };
    Tunnel.prototype.setup = function(options) {
      var self2 = this;
      var request = self2.request;
      options = options || {};
      if (typeof request.proxy === "string") {
        request.proxy = url.parse(request.proxy);
      }
      if (!request.proxy || !request.tunnel) {
        return false;
      }
      if (options.proxyHeaderWhiteList) {
        self2.proxyHeaderWhiteList = options.proxyHeaderWhiteList;
      }
      if (options.proxyHeaderExclusiveList) {
        self2.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;
      }
      var proxyHeaderExclusiveList = self2.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList);
      var proxyHeaderWhiteList = self2.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList);
      var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList);
      proxyHeaders.host = constructProxyHost(request.uri);
      proxyHeaderExclusiveList.forEach(request.removeHeader, request);
      var tunnelFn = getTunnelFn(request);
      var tunnelOptions = constructTunnelOptions(request, proxyHeaders);
      request.agent = tunnelFn(tunnelOptions);
      return true;
    };
    Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;
    Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;
    exports2.Tunnel = Tunnel;
  }
});

// ../../node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "../../node_modules/performance-now/lib/performance-now.js"(exports2, module2) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module2.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module2.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module2.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module2.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    }).call(exports2);
  }
});

// ../../node_modules/request/request.js
var require_request2 = __commonJS({
  "../../node_modules/request/request.js"(exports2, module2) {
    "use strict";
    var http2 = require("http");
    var https2 = require("https");
    var url = require("url");
    var util2 = require("util");
    var stream = require("stream");
    var zlib2 = require("zlib");
    var aws2 = require_aws_sign2();
    var aws4 = require_aws4();
    var httpSignature = require_lib4();
    var mime = require_mime_types();
    var caseless = require_caseless();
    var ForeverAgent = require_forever_agent();
    var FormData = require_form_data();
    var extend = require_extend();
    var isstream = require_isstream();
    var isTypedArray = require_is_typedarray().strict;
    var helpers = require_helpers();
    var cookies = require_cookies();
    var getProxyFromURI = require_getProxyFromURI();
    var Querystring = require_querystring().Querystring;
    var Har = require_har2().Har;
    var Auth = require_auth().Auth;
    var OAuth = require_oauth().OAuth;
    var hawk = require_hawk();
    var Multipart = require_multipart().Multipart;
    var Redirect = require_redirect().Redirect;
    var Tunnel = require_tunnel().Tunnel;
    var now = require_performance_now();
    var Buffer2 = require_safe_buffer().Buffer;
    var safeStringify = helpers.safeStringify;
    var isReadStream = helpers.isReadStream;
    var toBase64 = helpers.toBase64;
    var defer = helpers.defer;
    var copy = helpers.copy;
    var version = helpers.version;
    var globalCookieJar = cookies.jar();
    var globalPool = {};
    function filterForNonReserved(reserved, options) {
      var object = {};
      for (var i in options) {
        var notReserved = reserved.indexOf(i) === -1;
        if (notReserved) {
          object[i] = options[i];
        }
      }
      return object;
    }
    function filterOutReservedFunctions(reserved, options) {
      var object = {};
      for (var i in options) {
        var isReserved = !(reserved.indexOf(i) === -1);
        var isFunction2 = typeof options[i] === "function";
        if (!(isReserved && isFunction2)) {
          object[i] = options[i];
        }
      }
      return object;
    }
    function requestToJSON() {
      var self2 = this;
      return {
        uri: self2.uri,
        method: self2.method,
        headers: self2.headers
      };
    }
    function responseToJSON() {
      var self2 = this;
      return {
        statusCode: self2.statusCode,
        body: self2.body,
        headers: self2.headers,
        request: requestToJSON.call(self2.request)
      };
    }
    function Request(options) {
      var self2 = this;
      if (options.har) {
        self2._har = new Har(self2);
        options = self2._har.options(options);
      }
      stream.Stream.call(self2);
      var reserved = Object.keys(Request.prototype);
      var nonReserved = filterForNonReserved(reserved, options);
      extend(self2, nonReserved);
      options = filterOutReservedFunctions(reserved, options);
      self2.readable = true;
      self2.writable = true;
      if (options.method) {
        self2.explicitMethod = true;
      }
      self2._qs = new Querystring(self2);
      self2._auth = new Auth(self2);
      self2._oauth = new OAuth(self2);
      self2._multipart = new Multipart(self2);
      self2._redirect = new Redirect(self2);
      self2._tunnel = new Tunnel(self2);
      self2.init(options);
    }
    util2.inherits(Request, stream.Stream);
    Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG);
    function debug() {
      if (Request.debug) {
        console.error("REQUEST %s", util2.format.apply(util2, arguments));
      }
    }
    Request.prototype.debug = debug;
    Request.prototype.init = function(options) {
      var self2 = this;
      if (!options) {
        options = {};
      }
      self2.headers = self2.headers ? copy(self2.headers) : {};
      for (var headerName in self2.headers) {
        if (typeof self2.headers[headerName] === "undefined") {
          delete self2.headers[headerName];
        }
      }
      caseless.httpify(self2, self2.headers);
      if (!self2.method) {
        self2.method = options.method || "GET";
      }
      if (!self2.localAddress) {
        self2.localAddress = options.localAddress;
      }
      self2._qs.init(options);
      debug(options);
      if (!self2.pool && self2.pool !== false) {
        self2.pool = globalPool;
      }
      self2.dests = self2.dests || [];
      self2.__isRequestRequest = true;
      if (!self2._callback && self2.callback) {
        self2._callback = self2.callback;
        self2.callback = function() {
          if (self2._callbackCalled) {
            return;
          }
          self2._callbackCalled = true;
          self2._callback.apply(self2, arguments);
        };
        self2.on("error", self2.callback.bind());
        self2.on("complete", self2.callback.bind(self2, null));
      }
      if (!self2.uri && self2.url) {
        self2.uri = self2.url;
        delete self2.url;
      }
      if (self2.baseUrl) {
        if (typeof self2.baseUrl !== "string") {
          return self2.emit("error", new Error("options.baseUrl must be a string"));
        }
        if (typeof self2.uri !== "string") {
          return self2.emit("error", new Error("options.uri must be a string when using options.baseUrl"));
        }
        if (self2.uri.indexOf("//") === 0 || self2.uri.indexOf("://") !== -1) {
          return self2.emit("error", new Error("options.uri must be a path when using options.baseUrl"));
        }
        var baseUrlEndsWithSlash = self2.baseUrl.lastIndexOf("/") === self2.baseUrl.length - 1;
        var uriStartsWithSlash = self2.uri.indexOf("/") === 0;
        if (baseUrlEndsWithSlash && uriStartsWithSlash) {
          self2.uri = self2.baseUrl + self2.uri.slice(1);
        } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
          self2.uri = self2.baseUrl + self2.uri;
        } else if (self2.uri === "") {
          self2.uri = self2.baseUrl;
        } else {
          self2.uri = self2.baseUrl + "/" + self2.uri;
        }
        delete self2.baseUrl;
      }
      if (!self2.uri) {
        return self2.emit("error", new Error("options.uri is a required argument"));
      }
      if (typeof self2.uri === "string") {
        self2.uri = url.parse(self2.uri);
      }
      if (!self2.uri.href) {
        self2.uri.href = url.format(self2.uri);
      }
      if (self2.uri.protocol === "unix:") {
        return self2.emit("error", new Error("`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`"));
      }
      if (self2.uri.host === "unix") {
        self2.enableUnixSocket();
      }
      if (self2.strictSSL === false) {
        self2.rejectUnauthorized = false;
      }
      if (!self2.uri.pathname) {
        self2.uri.pathname = "/";
      }
      if (!(self2.uri.host || self2.uri.hostname && self2.uri.port) && !self2.uri.isUnix) {
        var faultyUri = url.format(self2.uri);
        var message = 'Invalid URI "' + faultyUri + '"';
        if (Object.keys(options).length === 0) {
          message += ". This can be caused by a crappy redirection.";
        }
        self2.abort();
        return self2.emit("error", new Error(message));
      }
      if (!self2.hasOwnProperty("proxy")) {
        self2.proxy = getProxyFromURI(self2.uri);
      }
      self2.tunnel = self2._tunnel.isEnabled();
      if (self2.proxy) {
        self2._tunnel.setup(options);
      }
      self2._redirect.onRequest(options);
      self2.setHost = false;
      if (!self2.hasHeader("host")) {
        var hostHeaderName = self2.originalHostHeaderName || "host";
        self2.setHeader(hostHeaderName, self2.uri.host);
        if (self2.uri.port) {
          if (self2.uri.port === "80" && self2.uri.protocol === "http:" || self2.uri.port === "443" && self2.uri.protocol === "https:") {
            self2.setHeader(hostHeaderName, self2.uri.hostname);
          }
        }
        self2.setHost = true;
      }
      self2.jar(self2._jar || options.jar);
      if (!self2.uri.port) {
        if (self2.uri.protocol === "http:") {
          self2.uri.port = 80;
        } else if (self2.uri.protocol === "https:") {
          self2.uri.port = 443;
        }
      }
      if (self2.proxy && !self2.tunnel) {
        self2.port = self2.proxy.port;
        self2.host = self2.proxy.hostname;
      } else {
        self2.port = self2.uri.port;
        self2.host = self2.uri.hostname;
      }
      if (options.form) {
        self2.form(options.form);
      }
      if (options.formData) {
        var formData = options.formData;
        var requestForm = self2.form();
        var appendFormValue = function(key, value) {
          if (value && value.hasOwnProperty("value") && value.hasOwnProperty("options")) {
            requestForm.append(key, value.value, value.options);
          } else {
            requestForm.append(key, value);
          }
        };
        for (var formKey in formData) {
          if (formData.hasOwnProperty(formKey)) {
            var formValue = formData[formKey];
            if (formValue instanceof Array) {
              for (var j = 0; j < formValue.length; j++) {
                appendFormValue(formKey, formValue[j]);
              }
            } else {
              appendFormValue(formKey, formValue);
            }
          }
        }
      }
      if (options.qs) {
        self2.qs(options.qs);
      }
      if (self2.uri.path) {
        self2.path = self2.uri.path;
      } else {
        self2.path = self2.uri.pathname + (self2.uri.search || "");
      }
      if (self2.path.length === 0) {
        self2.path = "/";
      }
      if (options.aws) {
        self2.aws(options.aws);
      }
      if (options.hawk) {
        self2.hawk(options.hawk);
      }
      if (options.httpSignature) {
        self2.httpSignature(options.httpSignature);
      }
      if (options.auth) {
        if (Object.prototype.hasOwnProperty.call(options.auth, "username")) {
          options.auth.user = options.auth.username;
        }
        if (Object.prototype.hasOwnProperty.call(options.auth, "password")) {
          options.auth.pass = options.auth.password;
        }
        self2.auth(options.auth.user, options.auth.pass, options.auth.sendImmediately, options.auth.bearer);
      }
      if (self2.gzip && !self2.hasHeader("accept-encoding")) {
        self2.setHeader("accept-encoding", "gzip, deflate");
      }
      if (self2.uri.auth && !self2.hasHeader("authorization")) {
        var uriAuthPieces = self2.uri.auth.split(":").map(function(item) {
          return self2._qs.unescape(item);
        });
        self2.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(":"), true);
      }
      if (!self2.tunnel && self2.proxy && self2.proxy.auth && !self2.hasHeader("proxy-authorization")) {
        var proxyAuthPieces = self2.proxy.auth.split(":").map(function(item) {
          return self2._qs.unescape(item);
        });
        var authHeader = "Basic " + toBase64(proxyAuthPieces.join(":"));
        self2.setHeader("proxy-authorization", authHeader);
      }
      if (self2.proxy && !self2.tunnel) {
        self2.path = self2.uri.protocol + "//" + self2.uri.host + self2.path;
      }
      if (options.json) {
        self2.json(options.json);
      }
      if (options.multipart) {
        self2.multipart(options.multipart);
      }
      if (options.time) {
        self2.timing = true;
        self2.elapsedTime = self2.elapsedTime || 0;
      }
      function setContentLength() {
        if (isTypedArray(self2.body)) {
          self2.body = Buffer2.from(self2.body);
        }
        if (!self2.hasHeader("content-length")) {
          var length;
          if (typeof self2.body === "string") {
            length = Buffer2.byteLength(self2.body);
          } else if (Array.isArray(self2.body)) {
            length = self2.body.reduce(function(a, b) {
              return a + b.length;
            }, 0);
          } else {
            length = self2.body.length;
          }
          if (length) {
            self2.setHeader("content-length", length);
          } else {
            self2.emit("error", new Error("Argument error, options.body."));
          }
        }
      }
      if (self2.body && !isstream(self2.body)) {
        setContentLength();
      }
      if (options.oauth) {
        self2.oauth(options.oauth);
      } else if (self2._oauth.params && self2.hasHeader("authorization")) {
        self2.oauth(self2._oauth.params);
      }
      var protocol = self2.proxy && !self2.tunnel ? self2.proxy.protocol : self2.uri.protocol;
      var defaultModules = { "http:": http2, "https:": https2 };
      var httpModules = self2.httpModules || {};
      self2.httpModule = httpModules[protocol] || defaultModules[protocol];
      if (!self2.httpModule) {
        return self2.emit("error", new Error("Invalid protocol: " + protocol));
      }
      if (options.ca) {
        self2.ca = options.ca;
      }
      if (!self2.agent) {
        if (options.agentOptions) {
          self2.agentOptions = options.agentOptions;
        }
        if (options.agentClass) {
          self2.agentClass = options.agentClass;
        } else if (options.forever) {
          var v = version();
          if (v.major === 0 && v.minor <= 10) {
            self2.agentClass = protocol === "http:" ? ForeverAgent : ForeverAgent.SSL;
          } else {
            self2.agentClass = self2.httpModule.Agent;
            self2.agentOptions = self2.agentOptions || {};
            self2.agentOptions.keepAlive = true;
          }
        } else {
          self2.agentClass = self2.httpModule.Agent;
        }
      }
      if (self2.pool === false) {
        self2.agent = false;
      } else {
        self2.agent = self2.agent || self2.getNewAgent();
      }
      self2.on("pipe", function(src) {
        if (self2.ntick && self2._started) {
          self2.emit("error", new Error("You cannot pipe to this stream after the outbound request has started."));
        }
        self2.src = src;
        if (isReadStream(src)) {
          if (!self2.hasHeader("content-type")) {
            self2.setHeader("content-type", mime.lookup(src.path));
          }
        } else {
          if (src.headers) {
            for (var i in src.headers) {
              if (!self2.hasHeader(i)) {
                self2.setHeader(i, src.headers[i]);
              }
            }
          }
          if (self2._json && !self2.hasHeader("content-type")) {
            self2.setHeader("content-type", "application/json");
          }
          if (src.method && !self2.explicitMethod) {
            self2.method = src.method;
          }
        }
      });
      defer(function() {
        if (self2._aborted) {
          return;
        }
        var end = function() {
          if (self2._form) {
            if (!self2._auth.hasAuth) {
              self2._form.pipe(self2);
            } else if (self2._auth.hasAuth && self2._auth.sentAuth) {
              self2._form.pipe(self2);
            }
          }
          if (self2._multipart && self2._multipart.chunked) {
            self2._multipart.body.pipe(self2);
          }
          if (self2.body) {
            if (isstream(self2.body)) {
              self2.body.pipe(self2);
            } else {
              setContentLength();
              if (Array.isArray(self2.body)) {
                self2.body.forEach(function(part) {
                  self2.write(part);
                });
              } else {
                self2.write(self2.body);
              }
              self2.end();
            }
          } else if (self2.requestBodyStream) {
            console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.");
            self2.requestBodyStream.pipe(self2);
          } else if (!self2.src) {
            if (self2._auth.hasAuth && !self2._auth.sentAuth) {
              self2.end();
              return;
            }
            if (self2.method !== "GET" && typeof self2.method !== "undefined") {
              self2.setHeader("content-length", 0);
            }
            self2.end();
          }
        };
        if (self2._form && !self2.hasHeader("content-length")) {
          self2.setHeader(self2._form.getHeaders(), true);
          self2._form.getLength(function(err, length) {
            if (!err && !isNaN(length)) {
              self2.setHeader("content-length", length);
            }
            end();
          });
        } else {
          end();
        }
        self2.ntick = true;
      });
    };
    Request.prototype.getNewAgent = function() {
      var self2 = this;
      var Agent = self2.agentClass;
      var options = {};
      if (self2.agentOptions) {
        for (var i in self2.agentOptions) {
          options[i] = self2.agentOptions[i];
        }
      }
      if (self2.ca) {
        options.ca = self2.ca;
      }
      if (self2.ciphers) {
        options.ciphers = self2.ciphers;
      }
      if (self2.secureProtocol) {
        options.secureProtocol = self2.secureProtocol;
      }
      if (self2.secureOptions) {
        options.secureOptions = self2.secureOptions;
      }
      if (typeof self2.rejectUnauthorized !== "undefined") {
        options.rejectUnauthorized = self2.rejectUnauthorized;
      }
      if (self2.cert && self2.key) {
        options.key = self2.key;
        options.cert = self2.cert;
      }
      if (self2.pfx) {
        options.pfx = self2.pfx;
      }
      if (self2.passphrase) {
        options.passphrase = self2.passphrase;
      }
      var poolKey = "";
      if (Agent !== self2.httpModule.Agent) {
        poolKey += Agent.name;
      }
      var proxy = self2.proxy;
      if (typeof proxy === "string") {
        proxy = url.parse(proxy);
      }
      var isHttps = proxy && proxy.protocol === "https:" || this.uri.protocol === "https:";
      if (isHttps) {
        if (options.ca) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.ca;
        }
        if (typeof options.rejectUnauthorized !== "undefined") {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.rejectUnauthorized;
        }
        if (options.cert) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.cert.toString("ascii") + options.key.toString("ascii");
        }
        if (options.pfx) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.pfx.toString("ascii");
        }
        if (options.ciphers) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.ciphers;
        }
        if (options.secureProtocol) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.secureProtocol;
        }
        if (options.secureOptions) {
          if (poolKey) {
            poolKey += ":";
          }
          poolKey += options.secureOptions;
        }
      }
      if (self2.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self2.httpModule.globalAgent) {
        return self2.httpModule.globalAgent;
      }
      poolKey = self2.uri.protocol + poolKey;
      if (!self2.pool[poolKey]) {
        self2.pool[poolKey] = new Agent(options);
        if (self2.pool.maxSockets) {
          self2.pool[poolKey].maxSockets = self2.pool.maxSockets;
        }
      }
      return self2.pool[poolKey];
    };
    Request.prototype.start = function() {
      var self2 = this;
      if (self2.timing) {
        var startTime = new Date().getTime();
        var startTimeNow = now();
      }
      if (self2._aborted) {
        return;
      }
      self2._started = true;
      self2.method = self2.method || "GET";
      self2.href = self2.uri.href;
      if (self2.src && self2.src.stat && self2.src.stat.size && !self2.hasHeader("content-length")) {
        self2.setHeader("content-length", self2.src.stat.size);
      }
      if (self2._aws) {
        self2.aws(self2._aws, true);
      }
      var reqOptions = copy(self2);
      delete reqOptions.auth;
      debug("make request", self2.uri.href);
      delete reqOptions.timeout;
      try {
        self2.req = self2.httpModule.request(reqOptions);
      } catch (err) {
        self2.emit("error", err);
        return;
      }
      if (self2.timing) {
        self2.startTime = startTime;
        self2.startTimeNow = startTimeNow;
        self2.timings = {};
      }
      var timeout;
      if (self2.timeout && !self2.timeoutTimer) {
        if (self2.timeout < 0) {
          timeout = 0;
        } else if (typeof self2.timeout === "number" && isFinite(self2.timeout)) {
          timeout = self2.timeout;
        }
      }
      self2.req.on("response", self2.onRequestResponse.bind(self2));
      self2.req.on("error", self2.onRequestError.bind(self2));
      self2.req.on("drain", function() {
        self2.emit("drain");
      });
      self2.req.on("socket", function(socket) {
        var isConnecting = socket._connecting || socket.connecting;
        if (self2.timing) {
          self2.timings.socket = now() - self2.startTimeNow;
          if (isConnecting) {
            var onLookupTiming = function() {
              self2.timings.lookup = now() - self2.startTimeNow;
            };
            var onConnectTiming = function() {
              self2.timings.connect = now() - self2.startTimeNow;
            };
            socket.once("lookup", onLookupTiming);
            socket.once("connect", onConnectTiming);
            self2.req.once("error", function() {
              socket.removeListener("lookup", onLookupTiming);
              socket.removeListener("connect", onConnectTiming);
            });
          }
        }
        var setReqTimeout = function() {
          self2.req.setTimeout(timeout, function() {
            if (self2.req) {
              self2.abort();
              var e = new Error("ESOCKETTIMEDOUT");
              e.code = "ESOCKETTIMEDOUT";
              e.connect = false;
              self2.emit("error", e);
            }
          });
        };
        if (timeout !== void 0) {
          if (isConnecting) {
            var onReqSockConnect = function() {
              socket.removeListener("connect", onReqSockConnect);
              self2.clearTimeout();
              setReqTimeout();
            };
            socket.on("connect", onReqSockConnect);
            self2.req.on("error", function(err) {
              socket.removeListener("connect", onReqSockConnect);
            });
            self2.timeoutTimer = setTimeout(function() {
              socket.removeListener("connect", onReqSockConnect);
              self2.abort();
              var e = new Error("ETIMEDOUT");
              e.code = "ETIMEDOUT";
              e.connect = true;
              self2.emit("error", e);
            }, timeout);
          } else {
            setReqTimeout();
          }
        }
        self2.emit("socket", socket);
      });
      self2.emit("request", self2.req);
    };
    Request.prototype.onRequestError = function(error) {
      var self2 = this;
      if (self2._aborted) {
        return;
      }
      if (self2.req && self2.req._reusedSocket && error.code === "ECONNRESET" && self2.agent.addRequestNoreuse) {
        self2.agent = { addRequest: self2.agent.addRequestNoreuse.bind(self2.agent) };
        self2.start();
        self2.req.end();
        return;
      }
      self2.clearTimeout();
      self2.emit("error", error);
    };
    Request.prototype.onRequestResponse = function(response) {
      var self2 = this;
      if (self2.timing) {
        self2.timings.response = now() - self2.startTimeNow;
      }
      debug("onRequestResponse", self2.uri.href, response.statusCode, response.headers);
      response.on("end", function() {
        if (self2.timing) {
          self2.timings.end = now() - self2.startTimeNow;
          response.timingStart = self2.startTime;
          if (!self2.timings.socket) {
            self2.timings.socket = 0;
          }
          if (!self2.timings.lookup) {
            self2.timings.lookup = self2.timings.socket;
          }
          if (!self2.timings.connect) {
            self2.timings.connect = self2.timings.lookup;
          }
          if (!self2.timings.response) {
            self2.timings.response = self2.timings.connect;
          }
          debug("elapsed time", self2.timings.end);
          self2.elapsedTime += Math.round(self2.timings.end);
          response.elapsedTime = self2.elapsedTime;
          response.timings = self2.timings;
          response.timingPhases = {
            wait: self2.timings.socket,
            dns: self2.timings.lookup - self2.timings.socket,
            tcp: self2.timings.connect - self2.timings.lookup,
            firstByte: self2.timings.response - self2.timings.connect,
            download: self2.timings.end - self2.timings.response,
            total: self2.timings.end
          };
        }
        debug("response end", self2.uri.href, response.statusCode, response.headers);
      });
      if (self2._aborted) {
        debug("aborted", self2.uri.href);
        response.resume();
        return;
      }
      self2.response = response;
      response.request = self2;
      response.toJSON = responseToJSON;
      if (self2.httpModule === https2 && self2.strictSSL && (!response.hasOwnProperty("socket") || !response.socket.authorized)) {
        debug("strict ssl error", self2.uri.href);
        var sslErr = response.hasOwnProperty("socket") ? response.socket.authorizationError : self2.uri.href + " does not support SSL";
        self2.emit("error", new Error("SSL Error: " + sslErr));
        return;
      }
      self2.originalHost = self2.getHeader("host");
      if (!self2.originalHostHeaderName) {
        self2.originalHostHeaderName = self2.hasHeader("host");
      }
      if (self2.setHost) {
        self2.removeHeader("host");
      }
      self2.clearTimeout();
      var targetCookieJar = self2._jar && self2._jar.setCookie ? self2._jar : globalCookieJar;
      var addCookie = function(cookie) {
        try {
          targetCookieJar.setCookie(cookie, self2.uri.href, { ignoreError: true });
        } catch (e) {
          self2.emit("error", e);
        }
      };
      response.caseless = caseless(response.headers);
      if (response.caseless.has("set-cookie") && !self2._disableCookies) {
        var headerName = response.caseless.has("set-cookie");
        if (Array.isArray(response.headers[headerName])) {
          response.headers[headerName].forEach(addCookie);
        } else {
          addCookie(response.headers[headerName]);
        }
      }
      if (self2._redirect.onResponse(response)) {
        return;
      } else {
        response.on("close", function() {
          if (!self2._ended) {
            self2.response.emit("end");
          }
        });
        response.once("end", function() {
          self2._ended = true;
        });
        var noBody = function(code) {
          return self2.method === "HEAD" || code >= 100 && code < 200 || code === 204 || code === 304;
        };
        var responseContent;
        if (self2.gzip && !noBody(response.statusCode)) {
          var contentEncoding = response.headers["content-encoding"] || "identity";
          contentEncoding = contentEncoding.trim().toLowerCase();
          var zlibOptions = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (contentEncoding === "gzip") {
            responseContent = zlib2.createGunzip(zlibOptions);
            response.pipe(responseContent);
          } else if (contentEncoding === "deflate") {
            responseContent = zlib2.createInflate(zlibOptions);
            response.pipe(responseContent);
          } else {
            if (contentEncoding !== "identity") {
              debug("ignoring unrecognized Content-Encoding " + contentEncoding);
            }
            responseContent = response;
          }
        } else {
          responseContent = response;
        }
        if (self2.encoding) {
          if (self2.dests.length !== 0) {
            console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.");
          } else {
            responseContent.setEncoding(self2.encoding);
          }
        }
        if (self2._paused) {
          responseContent.pause();
        }
        self2.responseContent = responseContent;
        self2.emit("response", response);
        self2.dests.forEach(function(dest) {
          self2.pipeDest(dest);
        });
        responseContent.on("data", function(chunk) {
          if (self2.timing && !self2.responseStarted) {
            self2.responseStartTime = new Date().getTime();
            response.responseStartTime = self2.responseStartTime;
          }
          self2._destdata = true;
          self2.emit("data", chunk);
        });
        responseContent.once("end", function(chunk) {
          self2.emit("end", chunk);
        });
        responseContent.on("error", function(error) {
          self2.emit("error", error);
        });
        responseContent.on("close", function() {
          self2.emit("close");
        });
        if (self2.callback) {
          self2.readResponseBody(response);
        } else {
          self2.on("end", function() {
            if (self2._aborted) {
              debug("aborted", self2.uri.href);
              return;
            }
            self2.emit("complete", response);
          });
        }
      }
      debug("finish init function", self2.uri.href);
    };
    Request.prototype.readResponseBody = function(response) {
      var self2 = this;
      debug("reading response's body");
      var buffers = [];
      var bufferLength = 0;
      var strings = [];
      self2.on("data", function(chunk) {
        if (!Buffer2.isBuffer(chunk)) {
          strings.push(chunk);
        } else if (chunk.length) {
          bufferLength += chunk.length;
          buffers.push(chunk);
        }
      });
      self2.on("end", function() {
        debug("end event", self2.uri.href);
        if (self2._aborted) {
          debug("aborted", self2.uri.href);
          buffers = [];
          bufferLength = 0;
          return;
        }
        if (bufferLength) {
          debug("has body", self2.uri.href, bufferLength);
          response.body = Buffer2.concat(buffers, bufferLength);
          if (self2.encoding !== null) {
            response.body = response.body.toString(self2.encoding);
          }
          buffers = [];
          bufferLength = 0;
        } else if (strings.length) {
          if (self2.encoding === "utf8" && strings[0].length > 0 && strings[0][0] === "\uFEFF") {
            strings[0] = strings[0].substring(1);
          }
          response.body = strings.join("");
        }
        if (self2._json) {
          try {
            response.body = JSON.parse(response.body, self2._jsonReviver);
          } catch (e) {
            debug("invalid JSON received", self2.uri.href);
          }
        }
        debug("emitting complete", self2.uri.href);
        if (typeof response.body === "undefined" && !self2._json) {
          response.body = self2.encoding === null ? Buffer2.alloc(0) : "";
        }
        self2.emit("complete", response, response.body);
      });
    };
    Request.prototype.abort = function() {
      var self2 = this;
      self2._aborted = true;
      if (self2.req) {
        self2.req.abort();
      } else if (self2.response) {
        self2.response.destroy();
      }
      self2.clearTimeout();
      self2.emit("abort");
    };
    Request.prototype.pipeDest = function(dest) {
      var self2 = this;
      var response = self2.response;
      if (dest.headers && !dest.headersSent) {
        if (response.caseless.has("content-type")) {
          var ctname = response.caseless.has("content-type");
          if (dest.setHeader) {
            dest.setHeader(ctname, response.headers[ctname]);
          } else {
            dest.headers[ctname] = response.headers[ctname];
          }
        }
        if (response.caseless.has("content-length")) {
          var clname = response.caseless.has("content-length");
          if (dest.setHeader) {
            dest.setHeader(clname, response.headers[clname]);
          } else {
            dest.headers[clname] = response.headers[clname];
          }
        }
      }
      if (dest.setHeader && !dest.headersSent) {
        for (var i in response.headers) {
          if (!self2.gzip || i !== "content-encoding") {
            dest.setHeader(i, response.headers[i]);
          }
        }
        dest.statusCode = response.statusCode;
      }
      if (self2.pipefilter) {
        self2.pipefilter(response, dest);
      }
    };
    Request.prototype.qs = function(q2, clobber) {
      var self2 = this;
      var base;
      if (!clobber && self2.uri.query) {
        base = self2._qs.parse(self2.uri.query);
      } else {
        base = {};
      }
      for (var i in q2) {
        base[i] = q2[i];
      }
      var qs = self2._qs.stringify(base);
      if (qs === "") {
        return self2;
      }
      self2.uri = url.parse(self2.uri.href.split("?")[0] + "?" + qs);
      self2.url = self2.uri;
      self2.path = self2.uri.path;
      if (self2.uri.host === "unix") {
        self2.enableUnixSocket();
      }
      return self2;
    };
    Request.prototype.form = function(form) {
      var self2 = this;
      if (form) {
        if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
          self2.setHeader("content-type", "application/x-www-form-urlencoded");
        }
        self2.body = typeof form === "string" ? self2._qs.rfc3986(form.toString("utf8")) : self2._qs.stringify(form).toString("utf8");
        return self2;
      }
      self2._form = new FormData();
      self2._form.on("error", function(err) {
        err.message = "form-data: " + err.message;
        self2.emit("error", err);
        self2.abort();
      });
      return self2._form;
    };
    Request.prototype.multipart = function(multipart) {
      var self2 = this;
      self2._multipart.onRequest(multipart);
      if (!self2._multipart.chunked) {
        self2.body = self2._multipart.body;
      }
      return self2;
    };
    Request.prototype.json = function(val) {
      var self2 = this;
      if (!self2.hasHeader("accept")) {
        self2.setHeader("accept", "application/json");
      }
      if (typeof self2.jsonReplacer === "function") {
        self2._jsonReplacer = self2.jsonReplacer;
      }
      self2._json = true;
      if (typeof val === "boolean") {
        if (self2.body !== void 0) {
          if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
            self2.body = safeStringify(self2.body, self2._jsonReplacer);
          } else {
            self2.body = self2._qs.rfc3986(self2.body);
          }
          if (!self2.hasHeader("content-type")) {
            self2.setHeader("content-type", "application/json");
          }
        }
      } else {
        self2.body = safeStringify(val, self2._jsonReplacer);
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
      }
      if (typeof self2.jsonReviver === "function") {
        self2._jsonReviver = self2.jsonReviver;
      }
      return self2;
    };
    Request.prototype.getHeader = function(name, headers) {
      var self2 = this;
      var result, re, match;
      if (!headers) {
        headers = self2.headers;
      }
      Object.keys(headers).forEach(function(key) {
        if (key.length !== name.length) {
          return;
        }
        re = new RegExp(name, "i");
        match = key.match(re);
        if (match) {
          result = headers[key];
        }
      });
      return result;
    };
    Request.prototype.enableUnixSocket = function() {
      var unixParts = this.uri.path.split(":");
      var host = unixParts[0];
      var path2 = unixParts[1];
      this.socketPath = host;
      this.uri.pathname = path2;
      this.uri.path = path2;
      this.uri.host = host;
      this.uri.hostname = host;
      this.uri.isUnix = true;
    };
    Request.prototype.auth = function(user, pass, sendImmediately, bearer) {
      var self2 = this;
      self2._auth.onRequest(user, pass, sendImmediately, bearer);
      return self2;
    };
    Request.prototype.aws = function(opts, now2) {
      var self2 = this;
      if (!now2) {
        self2._aws = opts;
        return self2;
      }
      if (opts.sign_version === 4 || opts.sign_version === "4") {
        var options = {
          host: self2.uri.host,
          path: self2.uri.path,
          method: self2.method,
          headers: self2.headers,
          body: self2.body
        };
        if (opts.service) {
          options.service = opts.service;
        }
        var signRes = aws4.sign(options, {
          accessKeyId: opts.key,
          secretAccessKey: opts.secret,
          sessionToken: opts.session
        });
        self2.setHeader("authorization", signRes.headers.Authorization);
        self2.setHeader("x-amz-date", signRes.headers["X-Amz-Date"]);
        if (signRes.headers["X-Amz-Security-Token"]) {
          self2.setHeader("x-amz-security-token", signRes.headers["X-Amz-Security-Token"]);
        }
      } else {
        var date = new Date();
        self2.setHeader("date", date.toUTCString());
        var auth = {
          key: opts.key,
          secret: opts.secret,
          verb: self2.method.toUpperCase(),
          date,
          contentType: self2.getHeader("content-type") || "",
          md5: self2.getHeader("content-md5") || "",
          amazonHeaders: aws2.canonicalizeHeaders(self2.headers)
        };
        var path2 = self2.uri.path;
        if (opts.bucket && path2) {
          auth.resource = "/" + opts.bucket + path2;
        } else if (opts.bucket && !path2) {
          auth.resource = "/" + opts.bucket;
        } else if (!opts.bucket && path2) {
          auth.resource = path2;
        } else if (!opts.bucket && !path2) {
          auth.resource = "/";
        }
        auth.resource = aws2.canonicalizeResource(auth.resource);
        self2.setHeader("authorization", aws2.authorization(auth));
      }
      return self2;
    };
    Request.prototype.httpSignature = function(opts) {
      var self2 = this;
      httpSignature.signRequest({
        getHeader: function(header) {
          return self2.getHeader(header, self2.headers);
        },
        setHeader: function(header, value) {
          self2.setHeader(header, value);
        },
        method: self2.method,
        path: self2.path
      }, opts);
      debug("httpSignature authorization", self2.getHeader("authorization"));
      return self2;
    };
    Request.prototype.hawk = function(opts) {
      var self2 = this;
      self2.setHeader("Authorization", hawk.header(self2.uri, self2.method, opts));
    };
    Request.prototype.oauth = function(_oauth) {
      var self2 = this;
      self2._oauth.onRequest(_oauth);
      return self2;
    };
    Request.prototype.jar = function(jar) {
      var self2 = this;
      var cookies2;
      if (self2._redirect.redirectsFollowed === 0) {
        self2.originalCookieHeader = self2.getHeader("cookie");
      }
      if (!jar) {
        cookies2 = false;
        self2._disableCookies = true;
      } else {
        var targetCookieJar = jar.getCookieString ? jar : globalCookieJar;
        var urihref = self2.uri.href;
        if (targetCookieJar) {
          cookies2 = targetCookieJar.getCookieString(urihref);
        }
      }
      if (cookies2 && cookies2.length) {
        if (self2.originalCookieHeader) {
          self2.setHeader("cookie", self2.originalCookieHeader + "; " + cookies2);
        } else {
          self2.setHeader("cookie", cookies2);
        }
      }
      self2._jar = jar;
      return self2;
    };
    Request.prototype.pipe = function(dest, opts) {
      var self2 = this;
      if (self2.response) {
        if (self2._destdata) {
          self2.emit("error", new Error("You cannot pipe after data has been emitted from the response."));
        } else if (self2._ended) {
          self2.emit("error", new Error("You cannot pipe after the response has been ended."));
        } else {
          stream.Stream.prototype.pipe.call(self2, dest, opts);
          self2.pipeDest(dest);
          return dest;
        }
      } else {
        self2.dests.push(dest);
        stream.Stream.prototype.pipe.call(self2, dest, opts);
        return dest;
      }
    };
    Request.prototype.write = function() {
      var self2 = this;
      if (self2._aborted) {
        return;
      }
      if (!self2._started) {
        self2.start();
      }
      if (self2.req) {
        return self2.req.write.apply(self2.req, arguments);
      }
    };
    Request.prototype.end = function(chunk) {
      var self2 = this;
      if (self2._aborted) {
        return;
      }
      if (chunk) {
        self2.write(chunk);
      }
      if (!self2._started) {
        self2.start();
      }
      if (self2.req) {
        self2.req.end();
      }
    };
    Request.prototype.pause = function() {
      var self2 = this;
      if (!self2.responseContent) {
        self2._paused = true;
      } else {
        self2.responseContent.pause.apply(self2.responseContent, arguments);
      }
    };
    Request.prototype.resume = function() {
      var self2 = this;
      if (!self2.responseContent) {
        self2._paused = false;
      } else {
        self2.responseContent.resume.apply(self2.responseContent, arguments);
      }
    };
    Request.prototype.destroy = function() {
      var self2 = this;
      this.clearTimeout();
      if (!self2._ended) {
        self2.end();
      } else if (self2.response) {
        self2.response.destroy();
      }
    };
    Request.prototype.clearTimeout = function() {
      if (this.timeoutTimer) {
        clearTimeout(this.timeoutTimer);
        this.timeoutTimer = null;
      }
    };
    Request.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice();
    Request.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice();
    Request.prototype.toJSON = requestToJSON;
    module2.exports = Request;
  }
});

// ../../node_modules/request/index.js
var require_request3 = __commonJS({
  "../../node_modules/request/index.js"(exports2, module2) {
    "use strict";
    var extend = require_extend();
    var cookies = require_cookies();
    var helpers = require_helpers();
    var paramsHaveRequestBody = helpers.paramsHaveRequestBody;
    function initParams(uri, options, callback) {
      if (typeof options === "function") {
        callback = options;
      }
      var params = {};
      if (options !== null && typeof options === "object") {
        extend(params, options, { uri });
      } else if (typeof uri === "string") {
        extend(params, { uri });
      } else {
        extend(params, uri);
      }
      params.callback = callback || params.callback;
      return params;
    }
    function request(uri, options, callback) {
      if (typeof uri === "undefined") {
        throw new Error("undefined is not a valid uri or options object.");
      }
      var params = initParams(uri, options, callback);
      if (params.method === "HEAD" && paramsHaveRequestBody(params)) {
        throw new Error("HTTP HEAD requests MUST NOT include a request body.");
      }
      return new request.Request(params);
    }
    function verbFunc(verb) {
      var method = verb.toUpperCase();
      return function(uri, options, callback) {
        var params = initParams(uri, options, callback);
        params.method = method;
        return request(params, params.callback);
      };
    }
    request.get = verbFunc("get");
    request.head = verbFunc("head");
    request.options = verbFunc("options");
    request.post = verbFunc("post");
    request.put = verbFunc("put");
    request.patch = verbFunc("patch");
    request.del = verbFunc("delete");
    request["delete"] = verbFunc("delete");
    request.jar = function(store) {
      return cookies.jar(store);
    };
    request.cookie = function(str) {
      return cookies.parse(str);
    };
    function wrapRequestMethod(method, options, requester, verb) {
      return function(uri, opts, callback) {
        var params = initParams(uri, opts, callback);
        var target = {};
        extend(true, target, options, params);
        target.pool = params.pool || options.pool;
        if (verb) {
          target.method = verb.toUpperCase();
        }
        if (typeof requester === "function") {
          method = requester;
        }
        return method(target, target.callback);
      };
    }
    request.defaults = function(options, requester) {
      var self2 = this;
      options = options || {};
      if (typeof options === "function") {
        requester = options;
        options = {};
      }
      var defaults = wrapRequestMethod(self2, options, requester);
      var verbs = ["get", "head", "post", "put", "patch", "del", "delete"];
      verbs.forEach(function(verb) {
        defaults[verb] = wrapRequestMethod(self2[verb], options, requester, verb);
      });
      defaults.cookie = wrapRequestMethod(self2.cookie, options, requester);
      defaults.jar = self2.jar;
      defaults.defaults = self2.defaults;
      return defaults;
    };
    request.forever = function(agentOptions, optionsArg) {
      var options = {};
      if (optionsArg) {
        extend(options, optionsArg);
      }
      if (agentOptions) {
        options.agentOptions = agentOptions;
      }
      options.forever = true;
      return request.defaults(options);
    };
    module2.exports = request;
    request.Request = require_request2();
    request.initParams = initParams;
    Object.defineProperty(request, "debug", {
      enumerable: true,
      get: function() {
        return request.Request.debug;
      },
      set: function(debug) {
        request.Request.debug = debug;
      }
    });
  }
});

// ../../node_modules/data-uri-to-buffer/index.js
var require_data_uri_to_buffer = __commonJS({
  "../../node_modules/data-uri-to-buffer/index.js"(exports2, module2) {
    module2.exports = dataUriToBuffer;
    function dataUriToBuffer(uri) {
      if (!/^data\:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
      uri = uri.replace(/\r?\n/g, "");
      var firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4)
        throw new TypeError("malformed data: URI");
      var meta = uri.substring(5, firstComma).split(";");
      var base642 = false;
      var charset = "US-ASCII";
      for (var i = 0; i < meta.length; i++) {
        if (meta[i] == "base64") {
          base642 = true;
        } else if (meta[i].indexOf("charset=") == 0) {
          charset = meta[i].substring(8);
        }
      }
      var data = unescape(uri.substring(firstComma + 1));
      var encoding = base642 ? "base64" : "ascii";
      var buffer = new Buffer(data, encoding);
      buffer.type = meta[0] || "text/plain";
      buffer.charset = charset;
      return buffer;
    }
  }
});

// ../../node_modules/parse-data-uri/index.js
var require_parse_data_uri = __commonJS({
  "../../node_modules/parse-data-uri/index.js"(exports2, module2) {
    var toBuffer = require_data_uri_to_buffer();
    function parseDataUri(dataUri) {
      return {
        mimeType: normalizeMimeType(parseMimeType(dataUri)),
        data: toBuffer(dataUri)
      };
    }
    function parseMimeType(uri) {
      return uri.substring(5, uri.indexOf(";"));
    }
    var prefix = /^(\w+\/)+/;
    function normalizeMimeType(mime) {
      mime = mime.toLowerCase();
      var once = mime.match(prefix);
      if (!once || !(once = once[1])) {
        return mime;
      }
      return mime.replace(prefix, once);
    }
    module2.exports = parseDataUri;
  }
});

// ../../node_modules/get-pixels/node-pixels.js
var require_node_pixels = __commonJS({
  "../../node_modules/get-pixels/node-pixels.js"(exports2, module2) {
    "use strict";
    var ndarray2 = require_ndarray();
    var path2 = require("path");
    var PNG = require_png2().PNG;
    var jpeg = require_jpeg_js2();
    var pack = require_convert();
    var GifReader = require_omggif().GifReader;
    var Bitmap = require_node_bitmap();
    var fs3 = require("fs");
    var request = require_request3();
    var mime = require_mime_types();
    var parseDataURI = require_parse_data_uri();
    function handlePNG(data, cb) {
      var png = new PNG();
      png.parse(data, function(err, img_data) {
        if (err) {
          cb(err);
          return;
        }
        cb(null, ndarray2(new Uint8Array(img_data.data), [img_data.width | 0, img_data.height | 0, 4], [4, 4 * img_data.width | 0, 1], 0));
      });
    }
    function handleJPEG(data, cb) {
      var jpegData;
      try {
        jpegData = jpeg.decode(data);
      } catch (e) {
        cb(e);
        return;
      }
      if (!jpegData) {
        cb(new Error("Error decoding jpeg"));
        return;
      }
      var nshape = [jpegData.height, jpegData.width, 4];
      var result = ndarray2(jpegData.data, nshape);
      cb(null, result.transpose(1, 0));
    }
    function handleGIF(data, cb) {
      var reader;
      try {
        reader = new GifReader(data);
      } catch (err) {
        cb(err);
        return;
      }
      if (reader.numFrames() > 0) {
        var nshape = [reader.numFrames(), reader.height, reader.width, 4];
        try {
          var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3]);
        } catch (err) {
          cb(err);
          return;
        }
        var result = ndarray2(ndata, nshape);
        try {
          for (var i = 0; i < reader.numFrames(); ++i) {
            reader.decodeAndBlitFrameRGBA(i, ndata.subarray(result.index(i, 0, 0, 0), result.index(i + 1, 0, 0, 0)));
          }
        } catch (err) {
          cb(err);
          return;
        }
        cb(null, result.transpose(0, 2, 1));
      } else {
        var nshape = [reader.height, reader.width, 4];
        var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2]);
        var result = ndarray2(ndata, nshape);
        try {
          reader.decodeAndBlitFrameRGBA(0, ndata);
        } catch (err) {
          cb(err);
          return;
        }
        cb(null, result.transpose(1, 0));
      }
    }
    function handleBMP(data, cb) {
      var bmp = new Bitmap(data);
      try {
        bmp.init();
      } catch (e) {
        cb(e);
        return;
      }
      var bmpData = bmp.getData();
      var nshape = [bmpData.getHeight(), bmpData.getWidth(), 4];
      var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2]);
      var result = ndarray2(ndata, nshape);
      pack(bmpData, result);
      cb(null, result.transpose(1, 0));
    }
    function doParse(mimeType, data, cb) {
      switch (mimeType) {
        case "image/png":
          handlePNG(data, cb);
          break;
        case "image/jpg":
        case "image/jpeg":
          handleJPEG(data, cb);
          break;
        case "image/gif":
          handleGIF(data, cb);
          break;
        case "image/bmp":
          handleBMP(data, cb);
          break;
        default:
          cb(new Error("Unsupported file type: " + mimeType));
      }
    }
    module2.exports = function getPixels2(url, type, cb) {
      if (!cb) {
        cb = type;
        type = "";
      }
      if (Buffer.isBuffer(url)) {
        if (!type) {
          cb(new Error("Invalid file type"));
          return;
        }
        doParse(type, url, cb);
      } else if (url.indexOf("data:") === 0) {
        try {
          var buffer = parseDataURI(url);
          if (buffer) {
            process.nextTick(function() {
              doParse(type || buffer.mimeType, buffer.data, cb);
            });
          } else {
            process.nextTick(function() {
              cb(new Error("Error parsing data URI"));
            });
          }
        } catch (err) {
          process.nextTick(function() {
            cb(err);
          });
        }
      } else if (url.indexOf("http://") === 0 || url.indexOf("https://") === 0) {
        request({ url, encoding: null }, function(err, response, body) {
          if (err) {
            cb(err);
            return;
          }
          type = type;
          if (!type) {
            if (response.getHeader !== void 0) {
              type = response.getHeader("content-type");
            } else if (response.headers !== void 0) {
              type = response.headers["content-type"];
            }
          }
          if (!type) {
            cb(new Error("Invalid content-type"));
            return;
          }
          doParse(type, body, cb);
        });
      } else {
        fs3.readFile(url, function(err, data) {
          if (err) {
            cb(err);
            return;
          }
          type = type || mime.lookup(url);
          if (!type) {
            cb(new Error("Invalid file type"));
            return;
          }
          doParse(type, data, cb);
        });
      }
    };
  }
});

// ../../node_modules/web-streams-polyfill/dist/polyfill.js
var require_polyfill = __commonJS({
  "../../node_modules/web-streams-polyfill/dist/polyfill.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports2, function(exports3) {
      "use strict";
      var SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
        return "Symbol(" + description + ")";
      };
      function noop() {
        return void 0;
      }
      function getGlobals() {
        if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      var globals3 = getGlobals();
      function typeIsObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      var rethrowAssertionErrorRejection = noop;
      var originalPromise = Promise;
      var originalPromiseThen = Promise.prototype.then;
      var originalPromiseResolve = Promise.resolve.bind(originalPromise);
      var originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      var queueMicrotask = function() {
        var globalQueueMicrotask = globals3 && globals3.queueMicrotask;
        if (typeof globalQueueMicrotask === "function") {
          return globalQueueMicrotask;
        }
        var resolvedPromise = promiseResolvedWith(void 0);
        return function(fn) {
          return PerformPromiseThen(resolvedPromise, fn);
        };
      }();
      function reflectCall(F, V, args) {
        if (typeof F !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F, V, args);
      }
      function promiseCall(F, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      var QUEUE_MAX_ARRAY_SIZE = 16384;
      var SimpleQueue = function() {
        function SimpleQueue2() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        Object.defineProperty(SimpleQueue2.prototype, "length", {
          get: function() {
            return this._size;
          },
          enumerable: false,
          configurable: true
        });
        SimpleQueue2.prototype.push = function(element) {
          var oldBack = this._back;
          var newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        };
        SimpleQueue2.prototype.shift = function() {
          var oldFront = this._front;
          var newFront = oldFront;
          var oldCursor = this._cursor;
          var newCursor = oldCursor + 1;
          var elements = oldFront._elements;
          var element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        };
        SimpleQueue2.prototype.forEach = function(callback) {
          var i = this._cursor;
          var node = this._front;
          var elements = node._elements;
          while (i !== elements.length || node._next !== void 0) {
            if (i === elements.length) {
              node = node._next;
              elements = node._elements;
              i = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i]);
            ++i;
          }
        };
        SimpleQueue2.prototype.peek = function() {
          var front = this._front;
          var cursor = this._cursor;
          return front._elements[cursor];
        };
        return SimpleQueue2;
      }();
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        var stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        if (reader._ownerReadableStream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        }
        reader._ownerReadableStream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise(function(resolve, reject) {
          reader._closedPromise_resolve = resolve;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      var AbortSteps = SymbolPolyfill("[[AbortSteps]]");
      var ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
      var CancelSteps = SymbolPolyfill("[[CancelSteps]]");
      var PullSteps = SymbolPolyfill("[[PullSteps]]");
      var NumberIsFinite = Number.isFinite || function(x) {
        return typeof x === "number" && isFinite(x);
      };
      var MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x) {
        return typeof x === "object" || typeof x === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(context + " is not an object.");
        }
      }
      function assertFunction(x, context) {
        if (typeof x !== "function") {
          throw new TypeError(context + " is not a function.");
        }
      }
      function isObject2(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      function assertObject(x, context) {
        if (!isObject2(x)) {
          throw new TypeError(context + " is not an object.");
        }
      }
      function assertRequiredArgument(x, position, context) {
        if (x === void 0) {
          throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
        }
      }
      function assertRequiredField(x, field, context) {
        if (x === void 0) {
          throw new TypeError(field + " is required in '" + context + "'.");
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
      }
      function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        var lowerBound = 0;
        var upperBound = Number.MAX_SAFE_INTEGER;
        var x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
          throw new TypeError(context + " is not a finite number");
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
        }
        if (!NumberIsFinite(x) || x === 0) {
          return 0;
        }
        return x;
      }
      function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
          throw new TypeError(context + " is not a ReadableStream.");
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        var reader = stream._reader;
        var readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        var reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      var ReadableStreamDefaultReader = function() {
        function ReadableStreamDefaultReader2(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        Object.defineProperty(ReadableStreamDefaultReader2.prototype, "closed", {
          get: function() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          },
          enumerable: false,
          configurable: true
        });
        ReadableStreamDefaultReader2.prototype.cancel = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        };
        ReadableStreamDefaultReader2.prototype.read = function() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          var resolvePromise;
          var rejectPromise;
          var promise = newPromise(function(resolve, reject) {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          var readRequest = {
            _chunkSteps: function(chunk) {
              return resolvePromise({ value: chunk, done: false });
            },
            _closeSteps: function() {
              return resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: function(e) {
              return rejectPromise(e);
            }
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        };
        ReadableStreamDefaultReader2.prototype.releaseLock = function() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        };
        return ReadableStreamDefaultReader2;
      }();
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
      }
      var _a;
      var AsyncIteratorPrototype;
      if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        AsyncIteratorPrototype = (_a = {}, _a[SymbolPolyfill.asyncIterator] = function() {
          return this;
        }, _a);
        Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
      }
      var ReadableStreamAsyncIteratorImpl = function() {
        function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
          var _this = this;
          var nextSteps = function() {
            return _this._nextSteps();
          };
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        };
        ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
          var _this = this;
          var returnSteps = function() {
            return _this._returnSteps(value);
          };
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        };
        ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
          var _this = this;
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          var reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("iterate"));
          }
          var resolvePromise;
          var rejectPromise;
          var promise = newPromise(function(resolve, reject) {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          var readRequest = {
            _chunkSteps: function(chunk) {
              _this._ongoingPromise = void 0;
              queueMicrotask(function() {
                return resolvePromise({ value: chunk, done: false });
              });
            },
            _closeSteps: function() {
              _this._ongoingPromise = void 0;
              _this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: function(reason) {
              _this._ongoingPromise = void 0;
              _this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        };
        ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          var reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("finish iterating"));
          }
          if (!this._preventCancel) {
            var result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, function() {
              return { value, done: true };
            });
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        };
        return ReadableStreamAsyncIteratorImpl2;
      }();
      var ReadableStreamAsyncIteratorPrototype = {
        next: function() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return: function(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      if (AsyncIteratorPrototype !== void 0) {
        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      }
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
          return false;
        }
        return true;
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
      }
      var NumberIsNaN = Number.isNaN || function(x) {
        return x !== x;
      };
      function IsFiniteNonNegativeNumber(v) {
        if (!IsNonNegativeNumber(v)) {
          return false;
        }
        if (v === Infinity) {
          return false;
        }
        return true;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function DequeueValue(container) {
        var pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        size = Number(size);
        if (!IsFiniteNonNegativeNumber(size)) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        var pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return false;
      }
      var ReadableStreamBYOBRequest = function() {
        function ReadableStreamBYOBRequest2() {
          throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(ReadableStreamBYOBRequest2.prototype, "view", {
          get: function() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          },
          enumerable: false,
          configurable: true
        });
        ReadableStreamBYOBRequest2.prototype.respond = function(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer))
            ;
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        };
        ReadableStreamBYOBRequest2.prototype.respondWithNewView = function(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (view.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (view.buffer.byteLength === 0) {
            throw new TypeError("chunk's buffer must have non-zero byteLength");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        };
        return ReadableStreamBYOBRequest2;
      }();
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      var ReadableByteStreamController = function() {
        function ReadableByteStreamController2() {
          throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(ReadableByteStreamController2.prototype, "byobRequest", {
          get: function() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            if (this._byobRequest === null && this._pendingPullIntos.length > 0) {
              var firstDescriptor = this._pendingPullIntos.peek();
              var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
              var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
              SetUpReadableStreamBYOBRequest(byobRequest, this, view);
              this._byobRequest = byobRequest;
            }
            return this._byobRequest;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ReadableByteStreamController2.prototype, "desiredSize", {
          get: function() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          },
          enumerable: false,
          configurable: true
        });
        ReadableByteStreamController2.prototype.close = function() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          var state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
          }
          ReadableByteStreamControllerClose(this);
        };
        ReadableByteStreamController2.prototype.enqueue = function(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError("chunk's buffer must have non-zero byteLength");
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          var state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        };
        ReadableByteStreamController2.prototype.error = function(e) {
          if (e === void 0) {
            e = void 0;
          }
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e);
        };
        ReadableByteStreamController2.prototype[CancelSteps] = function(reason) {
          if (this._pendingPullIntos.length > 0) {
            var firstDescriptor = this._pendingPullIntos.peek();
            firstDescriptor.bytesFilled = 0;
          }
          ResetQueue(this);
          var result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        };
        ReadableByteStreamController2.prototype[PullSteps] = function(readRequest) {
          var stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            var entry = this._queue.shift();
            this._queueTotalSize -= entry.byteLength;
            ReadableByteStreamControllerHandleQueueDrain(this);
            var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
            readRequest._chunkSteps(view);
            return;
          }
          var autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            var buffer = void 0;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            var pullIntoDescriptor = {
              buffer,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        };
        return ReadableByteStreamController2;
      }();
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
          return false;
        }
        return true;
      }
      function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
          return false;
        }
        return true;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function() {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }, function(e) {
          ReadableByteStreamControllerError(controller, e);
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        var done = false;
        if (stream._state === "closed") {
          done = true;
        }
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        var bytesFilled = pullIntoDescriptor.bytesFilled;
        var elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        var elementSize = pullIntoDescriptor.elementSize;
        var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
        var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
        var totalBytesToCopyRemaining = maxBytesToCopy;
        var ready = false;
        if (maxAlignedBytes > currentAlignedBytes) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        var queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          var headOfQueue = queue.peek();
          var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          var pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        var stream = controller._controlledReadableByteStream;
        var elementSize = 1;
        if (view.constructor !== DataView) {
          elementSize = view.constructor.BYTES_PER_ELEMENT;
        }
        var ctor = view.constructor;
        var buffer = TransferArrayBuffer(view.buffer);
        var pullIntoDescriptor = {
          buffer,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e);
            readIntoRequest._errorSteps(e);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        var stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
          throw new RangeError("bytesWritten out of range");
        }
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
          ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        var descriptor = controller._pendingPullIntos.shift();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        var stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          var firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled > 0) {
            var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e);
            throw e;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        var stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        var buffer = chunk.buffer;
        var byteOffset = chunk.byteOffset;
        var byteLength = chunk.byteLength;
        var transferredBuffer = TransferArrayBuffer(buffer);
        if (ReadableStreamHasDefaultReader(stream)) {
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        bytesWritten = Number(bytesWritten);
        if (!IsFiniteNonNegativeNumber(bytesWritten)) {
          throw new RangeError("bytesWritten must be a finite");
        }
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.byteLength !== view.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        firstDescriptor.buffer = view.buffer;
        ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, function(r) {
          ReadableByteStreamControllerError(controller, r);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        var controller = Object.create(ReadableByteStreamController.prototype);
        var startAlgorithm = function() {
          return void 0;
        };
        var pullAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        var cancelAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = function() {
            return underlyingByteSource.start(controller);
          };
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = function() {
            return underlyingByteSource.pull(controller);
          };
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = function(reason) {
            return underlyingByteSource.cancel(reason);
          };
        }
        var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        var reader = stream._reader;
        var readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        var reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      var ReadableStreamBYOBReader = function() {
        function ReadableStreamBYOBReader2(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        Object.defineProperty(ReadableStreamBYOBReader2.prototype, "closed", {
          get: function() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          },
          enumerable: false,
          configurable: true
        });
        ReadableStreamBYOBReader2.prototype.cancel = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        };
        ReadableStreamBYOBReader2.prototype.read = function(view) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          var resolvePromise;
          var rejectPromise;
          var promise = newPromise(function(resolve, reject) {
            resolvePromise = resolve;
            rejectPromise = reject;
          });
          var readIntoRequest = {
            _chunkSteps: function(chunk) {
              return resolvePromise({ value: chunk, done: false });
            },
            _closeSteps: function(chunk) {
              return resolvePromise({ value: chunk, done: true });
            },
            _errorSteps: function(e) {
              return rejectPromise(e);
            }
          };
          ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
          return promise;
        };
        ReadableStreamBYOBReader2.prototype.releaseLock = function() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readIntoRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        };
        return ReadableStreamBYOBReader2;
      }();
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
          return false;
        }
        return true;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
        }
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        var highWaterMark = strategy.highWaterMark;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        var size = strategy.size;
        if (!size) {
          return function() {
            return 1;
          };
        }
        return size;
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        var size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, context + " has member 'size' that")
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return function(chunk) {
          return convertUnrestrictedDouble(fn(chunk));
        };
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        var abort = original === null || original === void 0 ? void 0 : original.abort;
        var close = original === null || original === void 0 ? void 0 : original.close;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type = original === null || original === void 0 ? void 0 : original.type;
        var write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return function() {
          return promiseCall(fn, original, []);
        };
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
          throw new TypeError(context + " is not a WritableStream.");
        }
      }
      var WritableStream = function() {
        function WritableStream2(rawUnderlyingSink, rawStrategy) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = {};
          }
          if (rawStrategy === void 0) {
            rawStrategy = {};
          }
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          var type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          var highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        Object.defineProperty(WritableStream2.prototype, "locked", {
          get: function() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          },
          enumerable: false,
          configurable: true
        });
        WritableStream2.prototype.abort = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        };
        WritableStream2.prototype.close = function() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        };
        WritableStream2.prototype.getWriter = function() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        };
        return WritableStream2;
      }();
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) {
          highWaterMark = 1;
        }
        if (sizeAlgorithm === void 0) {
          sizeAlgorithm = function() {
            return 1;
          };
        }
        var stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        var controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
          return false;
        }
        return true;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        var wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        var promise = newPromise(function(resolve, reject) {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        var state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
        }
        var promise = newPromise(function(resolve, reject) {
          var closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        var writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        var promise = newPromise(function(resolve, reject) {
          var writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        var state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        var controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        var writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        var storedError = stream._storedError;
        stream._writeRequests.forEach(function(writeRequest) {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        var abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, function() {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, function(reason) {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        var state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        var writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        var writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        var writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      var WritableStreamDefaultWriter = function() {
        function WritableStreamDefaultWriter2(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          var state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            var storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        Object.defineProperty(WritableStreamDefaultWriter2.prototype, "closed", {
          get: function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(WritableStreamDefaultWriter2.prototype, "desiredSize", {
          get: function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(WritableStreamDefaultWriter2.prototype, "ready", {
          get: function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          },
          enumerable: false,
          configurable: true
        });
        WritableStreamDefaultWriter2.prototype.abort = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        };
        WritableStreamDefaultWriter2.prototype.close = function() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          var stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        };
        WritableStreamDefaultWriter2.prototype.releaseLock = function() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          var stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        };
        WritableStreamDefaultWriter2.prototype.write = function(chunk) {
          if (chunk === void 0) {
            chunk = void 0;
          }
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        };
        return WritableStreamDefaultWriter2;
      }();
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
          return false;
        }
        return true;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        var stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        var stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        var stream = writer._ownerWritableStream;
        var state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        var stream = writer._ownerWritableStream;
        var state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        var stream = writer._ownerWritableStream;
        var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        var stream = writer._ownerWritableStream;
        var controller = stream._writableStreamController;
        var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        var state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        var promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      var closeSentinel = {};
      var WritableStreamDefaultController = function() {
        function WritableStreamDefaultController2() {
          throw new TypeError("Illegal constructor");
        }
        WritableStreamDefaultController2.prototype.error = function(e) {
          if (e === void 0) {
            e = void 0;
          }
          if (!IsWritableStreamDefaultController(this)) {
            throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");
          }
          var state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e);
        };
        WritableStreamDefaultController2.prototype[AbortSteps] = function(reason) {
          var result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        };
        WritableStreamDefaultController2.prototype[ErrorSteps] = function() {
          ResetQueue(this);
        };
        return WritableStreamDefaultController2;
      }();
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        error: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
          return false;
        }
        return true;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        var startResult = startAlgorithm();
        var startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, function() {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(r) {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(WritableStreamDefaultController.prototype);
        var startAlgorithm = function() {
          return void 0;
        };
        var writeAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        var closeAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        var abortAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        if (underlyingSink.start !== void 0) {
          startAlgorithm = function() {
            return underlyingSink.start(controller);
          };
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = function(chunk) {
            return underlyingSink.write(chunk, controller);
          };
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = function() {
            return underlyingSink.close();
          };
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = function(reason) {
            return underlyingSink.abort(reason);
          };
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        var stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        var stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        var state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        var value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        var sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, function() {
          WritableStreamFinishInFlightClose(stream);
        }, function(reason) {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        var sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, function() {
          WritableStreamFinishInFlightWrite(stream);
          var state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(reason) {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        var stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise(function(resolve, reject) {
          writer._closedPromise_resolve = resolve;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise(function(resolve, reject) {
          writer._readyPromise_resolve = resolve;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      function isAbortSignal(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a2) {
          return false;
        }
      }
      var NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a2) {
          return false;
        }
      }
      function createDOMExceptionPolyfill() {
        var ctor = function DOMException2(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        var reader = AcquireReadableStreamDefaultReader(source);
        var writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        var shuttingDown = false;
        var currentWrite = promiseResolvedWith(void 0);
        return newPromise(function(resolve, reject) {
          var abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = function() {
              var error = new DOMException$1("Aborted", "AbortError");
              var actions = [];
              if (!preventAbort) {
                actions.push(function() {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(function() {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(function() {
                return Promise.all(actions.map(function(action) {
                  return action();
                }));
              }, true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise(function(resolveLoop, rejectLoop) {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, function() {
              return newPromise(function(resolveRead, rejectRead) {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: function(chunk) {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);
                    resolveRead(false);
                  },
                  _closeSteps: function() {
                    return resolveRead(true);
                  },
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
            if (!preventAbort) {
              shutdownWithAction(function() {
                return WritableStreamAbort(dest, storedError);
              }, true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
            if (!preventCancel) {
              shutdownWithAction(function() {
                return ReadableStreamCancel(source, storedError);
              }, true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesClosed(source, reader._closedPromise, function() {
            if (!preventClose) {
              shutdownWithAction(function() {
                return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
              });
            } else {
              shutdown();
            }
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(function() {
                return ReadableStreamCancel(source, destClosed_1);
              }, true, destClosed_1);
            } else {
              shutdown(true, destClosed_1);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            var oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, function() {
              return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
            });
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), function() {
                return finalize(originalIsError, originalError);
              }, function(newError) {
                return finalize(true, newError);
              });
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), function() {
                return finalize(isError, error);
              });
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve(void 0);
            }
          }
        });
      }
      var ReadableStreamDefaultController = function() {
        function ReadableStreamDefaultController2() {
          throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(ReadableStreamDefaultController2.prototype, "desiredSize", {
          get: function() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          },
          enumerable: false,
          configurable: true
        });
        ReadableStreamDefaultController2.prototype.close = function() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        };
        ReadableStreamDefaultController2.prototype.enqueue = function(chunk) {
          if (chunk === void 0) {
            chunk = void 0;
          }
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        };
        ReadableStreamDefaultController2.prototype.error = function(e) {
          if (e === void 0) {
            e = void 0;
          }
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e);
        };
        ReadableStreamDefaultController2.prototype[CancelSteps] = function(reason) {
          ResetQueue(this);
          var result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        };
        ReadableStreamDefaultController2.prototype[PullSteps] = function(readRequest) {
          var stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            var chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        };
        return ReadableStreamDefaultController2;
      }();
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function() {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
        }, function(e) {
          ReadableStreamDefaultControllerError(controller, e);
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        var stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        var stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          var chunkSize = void 0;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e) {
        var stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        var state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, function(r) {
          ReadableStreamDefaultControllerError(controller, r);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        var startAlgorithm = function() {
          return void 0;
        };
        var pullAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        var cancelAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        if (underlyingSource.start !== void 0) {
          startAlgorithm = function() {
            return underlyingSource.start(controller);
          };
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = function() {
            return underlyingSource.pull(controller);
          };
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = function(reason) {
            return underlyingSource.cancel(reason);
          };
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var reading = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function(resolve) {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading) {
            return promiseResolvedWith(void 0);
          }
          reading = true;
          var readRequest = {
            _chunkSteps: function(value) {
              queueMicrotask(function() {
                reading = false;
                var value1 = value;
                var value2 = value;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);
                }
              });
            },
            _closeSteps: function() {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: function() {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, function(r) {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
        });
        return [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        var original = source;
        var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        var cancel = original === null || original === void 0 ? void 0 : original.cancel;
        var pull = original === null || original === void 0 ? void 0 : original.pull;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, context + " has member 'type' that")
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertReadableStreamType(type, context) {
        type = "" + type;
        if (type !== "bytes") {
          throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
        }
        return type;
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        var mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = "" + mode;
        if (mode !== "byob") {
          throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
        }
        return mode;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        var signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, context + " has member 'signal' that");
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal)) {
          throw new TypeError(context + " is not an AbortSignal.");
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, context + " has member 'readable' that");
        var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, context + " has member 'writable' that");
        return { readable, writable };
      }
      var ReadableStream2 = function() {
        function ReadableStream3(rawUnderlyingSource, rawStrategy) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = {};
          }
          if (rawStrategy === void 0) {
            rawStrategy = {};
          }
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            var highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            var highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        Object.defineProperty(ReadableStream3.prototype, "locked", {
          get: function() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          },
          enumerable: false,
          configurable: true
        });
        ReadableStream3.prototype.cancel = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        };
        ReadableStream3.prototype.getReader = function(rawOptions) {
          if (rawOptions === void 0) {
            rawOptions = void 0;
          }
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          var options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        };
        ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
          if (rawOptions === void 0) {
            rawOptions = {};
          }
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          var transform = convertReadableWritablePair(rawTransform, "First parameter");
          var options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        };
        ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
          if (rawOptions === void 0) {
            rawOptions = {};
          }
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
          }
          var options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e) {
            return promiseRejectedWith(e);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        };
        ReadableStream3.prototype.tee = function() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          var branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        };
        ReadableStream3.prototype.values = function(rawOptions) {
          if (rawOptions === void 0) {
            rawOptions = void 0;
          }
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          var options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        };
        return ReadableStream3;
      }();
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
          value: ReadableStream2.prototype.values,
          writable: true,
          configurable: true
        });
      }
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) {
          highWaterMark = 1;
        }
        if (sizeAlgorithm === void 0) {
          sizeAlgorithm = function() {
            return 1;
          };
        }
        var stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
          return false;
        }
        return true;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        var reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach(function(readRequest) {
            readRequest._closeSteps();
          });
          reader._readRequests = new SimpleQueue();
        }
      }
      function ReadableStreamError(stream, e) {
        stream._state = "errored";
        stream._storedError = e;
        var reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach(function(readRequest) {
            readRequest._errorSteps(e);
          });
          reader._readRequests = new SimpleQueue();
        } else {
          reader._readIntoRequests.forEach(function(readIntoRequest) {
            readIntoRequest._errorSteps(e);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      var byteLengthSizeFunction = function size(chunk) {
        return chunk.byteLength;
      };
      var ByteLengthQueuingStrategy = function() {
        function ByteLengthQueuingStrategy2(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "highWaterMark", {
          get: function() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "size", {
          get: function() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          },
          enumerable: false,
          configurable: true
        });
        return ByteLengthQueuingStrategy2;
      }();
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
      }
      function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return true;
      }
      var countSizeFunction = function size() {
        return 1;
      };
      var CountQueuingStrategy = function() {
        function CountQueuingStrategy2(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        Object.defineProperty(CountQueuingStrategy2.prototype, "highWaterMark", {
          get: function() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(CountQueuingStrategy2.prototype, "size", {
          get: function() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          },
          enumerable: false,
          configurable: true
        });
        return CountQueuingStrategy2;
      }();
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
      }
      function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return true;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        var flush = original === null || original === void 0 ? void 0 : original.flush;
        var readableType = original === null || original === void 0 ? void 0 : original.readableType;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var transform = original === null || original === void 0 ? void 0 : original.transform;
        var writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      var TransformStream = function() {
        function TransformStream2(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
          if (rawTransformer === void 0) {
            rawTransformer = {};
          }
          if (rawWritableStrategy === void 0) {
            rawWritableStrategy = {};
          }
          if (rawReadableStrategy === void 0) {
            rawReadableStrategy = {};
          }
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          var readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          var transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          var startPromise_resolve;
          var startPromise = newPromise(function(resolve) {
            startPromise_resolve = resolve;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        Object.defineProperty(TransformStream2.prototype, "readable", {
          get: function() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TransformStream2.prototype, "writable", {
          get: function() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          },
          enumerable: false,
          configurable: true
        });
        return TransformStream2;
      }();
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          TransformStreamErrorWritableAndUnblockWrite(stream, reason);
          return promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
          return false;
        }
        return true;
      }
      function TransformStreamError(stream, e) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise(function(resolve) {
          stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
      }
      var TransformStreamDefaultController = function() {
        function TransformStreamDefaultController2() {
          throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(TransformStreamDefaultController2.prototype, "desiredSize", {
          get: function() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            var readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          },
          enumerable: false,
          configurable: true
        });
        TransformStreamDefaultController2.prototype.enqueue = function(chunk) {
          if (chunk === void 0) {
            chunk = void 0;
          }
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        };
        TransformStreamDefaultController2.prototype.error = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        };
        TransformStreamDefaultController2.prototype.terminate = function() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        };
        return TransformStreamDefaultController2;
      }();
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
          return false;
        }
        return true;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        var controller = Object.create(TransformStreamDefaultController.prototype);
        var transformAlgorithm = function(chunk) {
          try {
            TransformStreamDefaultControllerEnqueue(controller, chunk);
            return promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        };
        var flushAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        if (transformer.transform !== void 0) {
          transformAlgorithm = function(chunk) {
            return transformer.transform(chunk, controller);
          };
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = function() {
            return transformer.flush(controller);
          };
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        var stream = controller._controlledTransformStream;
        var readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
          throw stream._readable._storedError;
        }
        var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        var transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, function(r) {
          TransformStreamError(controller._controlledTransformStream, r);
          throw r;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        var stream = controller._controlledTransformStream;
        var readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        var error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        var controller = stream._transformStreamController;
        if (stream._backpressure) {
          var backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, function() {
            var writable = stream._writable;
            var state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        TransformStreamError(stream, reason);
        return promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        var readable = stream._readable;
        var controller = stream._transformStreamController;
        var flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        return transformPromiseWith(flushPromise, function() {
          if (readable._state === "errored") {
            throw readable._storedError;
          }
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, function(r) {
          TransformStreamError(stream, r);
          throw readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
      }
      function streamBrandCheckException(name) {
        return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
      }
      var exports$1 = {
        ReadableStream: ReadableStream2,
        ReadableStreamDefaultController,
        ReadableByteStreamController,
        ReadableStreamBYOBRequest,
        ReadableStreamDefaultReader,
        ReadableStreamBYOBReader,
        WritableStream,
        WritableStreamDefaultController,
        WritableStreamDefaultWriter,
        ByteLengthQueuingStrategy,
        CountQueuingStrategy,
        TransformStream,
        TransformStreamDefaultController
      };
      if (typeof globals3 !== "undefined") {
        for (var prop in exports$1) {
          if (Object.prototype.hasOwnProperty.call(exports$1, prop)) {
            Object.defineProperty(globals3, prop, {
              value: exports$1[prop],
              writable: true,
              configurable: true
            });
          }
        }
      }
      exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports3.CountQueuingStrategy = CountQueuingStrategy;
      exports3.ReadableByteStreamController = ReadableByteStreamController;
      exports3.ReadableStream = ReadableStream2;
      exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports3.TransformStream = TransformStream;
      exports3.TransformStreamDefaultController = TransformStreamDefaultController;
      exports3.WritableStream = WritableStream;
      exports3.WritableStreamDefaultController = WritableStreamDefaultController;
      exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../worker-utils/src/lib/env-utils/version.ts
var VERSION = true ? "3.2.9" : DEFAULT_VERSION;
if (false) {
  console.error("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
}

// ../worker-utils/src/lib/env-utils/assert.ts
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "loaders.gl assertion failed.");
  }
}

// ../worker-utils/src/lib/env-utils/globals.ts
var globals = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_ = globals.self || globals.window || globals.global || {};
var window_ = globals.window || globals.self || globals.global || {};
var global_ = globals.global || globals.self || globals.window || {};
var document_ = globals.document || {};
var isBrowser = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
var isWorker = typeof importScripts === "function";
var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;

// ../worker-utils/src/lib/worker-utils/get-transfer-list.ts
function getTransferList(object, recursive = true, transfers) {
  const transfersSet = transfers || new Set();
  if (!object) {
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && typeof object === "object") {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}

// ../worker-utils/src/lib/worker-farm/worker-body.ts
function getParentPort() {
  let parentPort;
  try {
    eval("globalThis.parentPort = require('worker_threads').parentPort");
    parentPort = globalThis.parentPort;
  } catch {
  }
  return parentPort;
}
var onMessageWrapperMap = new Map();
var WorkerBody = class {
  static inWorkerThread() {
    return typeof self !== "undefined" || Boolean(getParentPort());
  }
  static set onmessage(onMessage) {
    function handleMessage(message) {
      const parentPort3 = getParentPort();
      const { type, payload } = parentPort3 ? message : message.data;
      onMessage(type, payload);
    }
    const parentPort2 = getParentPort();
    if (parentPort2) {
      parentPort2.on("message", handleMessage);
      parentPort2.on("exit", () => console.debug("Node worker closing"));
    } else {
      globalThis.onmessage = handleMessage;
    }
  }
  static addEventListener(onMessage) {
    let onMessageWrapper = onMessageWrapperMap.get(onMessage);
    if (!onMessageWrapper) {
      onMessageWrapper = (message) => {
        if (!isKnownMessage(message)) {
          return;
        }
        const parentPort3 = getParentPort();
        const { type, payload } = parentPort3 ? message : message.data;
        onMessage(type, payload);
      };
    }
    const parentPort2 = getParentPort();
    if (parentPort2) {
      console.error("not implemented");
    } else {
      globalThis.addEventListener("message", onMessageWrapper);
    }
  }
  static removeEventListener(onMessage) {
    const onMessageWrapper = onMessageWrapperMap.get(onMessage);
    onMessageWrapperMap.delete(onMessage);
    const parentPort2 = getParentPort();
    if (parentPort2) {
      console.error("not implemented");
    } else {
      globalThis.removeEventListener("message", onMessageWrapper);
    }
  }
  static postMessage(type, payload) {
    const data = { source: "loaders.gl", type, payload };
    const transferList = getTransferList(payload);
    const parentPort2 = getParentPort();
    if (parentPort2) {
      parentPort2.postMessage(data, transferList);
    } else {
      globalThis.postMessage(data, transferList);
    }
  }
};
function isKnownMessage(message) {
  const { type, data } = message;
  return type === "message" && data && typeof data.source === "string" && data.source.startsWith("loaders.gl");
}

// ../worker-utils/src/lib/node/require-utils.node.ts
var require_utils_node_exports = {};
__export(require_utils_node_exports, {
  requireFromFile: () => requireFromFile,
  requireFromString: () => requireFromString
});
var import_module = __toModule(require("module"));
var import_path = __toModule(require("path"));
async function requireFromFile(filename) {
  if (filename.startsWith("http")) {
    const response = await fetch(filename);
    const code = await response.text();
    return requireFromString(code);
  }
  if (!filename.startsWith("/")) {
    filename = `${process.cwd()}/${filename}`;
  }
  return require(filename);
}
function requireFromString(code, filename = "", options) {
  if (typeof filename === "object") {
    options = filename;
    filename = "";
  }
  if (typeof code !== "string") {
    throw new Error(`code must be a string, not ${typeof code}`);
  }
  const paths = import_module.default._nodeModulePaths(import_path.default.dirname(filename));
  const parent = module.parent;
  const newModule = new import_module.default(filename, parent);
  newModule.filename = filename;
  newModule.paths = [].concat((options == null ? void 0 : options.prependPaths) || []).concat(paths).concat((options == null ? void 0 : options.appendPaths) || []);
  newModule._compile(code, filename);
  if (parent && parent.children) {
    parent.children.splice(parent.children.indexOf(newModule), 1);
  }
  return newModule.exports;
}

// ../worker-utils/src/lib/library-utils/library-utils.ts
var LATEST = "latest";
var VERSION2 = typeof VERSION !== "undefined" ? VERSION : LATEST;
var loadLibraryPromises = {};
async function loadLibrary(libraryUrl, moduleName = null, options = {}) {
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
  }
  loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}
function getLibraryUrl(library, moduleName, options) {
  if (library.startsWith("http")) {
    return library;
  }
  const modules = options.modules || {};
  if (modules[library]) {
    return modules[library];
  }
  if (!isBrowser) {
    return `modules/${moduleName}/dist/libs/${library}`;
  }
  if (options.CDN) {
    assert(options.CDN.startsWith("http"));
    return `${options.CDN}/${moduleName}@${VERSION2}/dist/libs/${library}`;
  }
  if (isWorker) {
    return `../src/libs/${library}`;
  }
  return `modules/${moduleName}/src/libs/${library}`;
}
async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith("wasm")) {
    const response2 = await fetch(libraryUrl);
    return await response2.arrayBuffer();
  }
  if (!isBrowser) {
    try {
      return require_utils_node_exports && requireFromFile && await requireFromFile(libraryUrl);
    } catch {
      return null;
    }
  }
  if (isWorker) {
    return importScripts(libraryUrl);
  }
  const response = await fetch(libraryUrl);
  const scriptSource = await response.text();
  return loadLibraryFromString(scriptSource, libraryUrl);
}
function loadLibraryFromString(scriptSource, id) {
  if (!isBrowser) {
    return requireFromString && requireFromString(scriptSource, id);
  }
  if (isWorker) {
    eval.call(global_, scriptSource);
    return null;
  }
  const script = document.createElement("script");
  script.id = id;
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}

// ../polyfills/src/index.ts
var import_xmldom = __toModule(require_lib());

// ../polyfills/src/utils/globals.ts
var isBrowser2 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
var globals2 = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global
};
var global_2 = globals2.global || globals2.self || globals2.window;

// ../polyfills/src/lib/encoding-indexes.ts
var encoding_indexes_default = {
  "ibm866": [1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 9617, 9618, 9619, 9474, 9508, 9569, 9570, 9558, 9557, 9571, 9553, 9559, 9565, 9564, 9563, 9488, 9492, 9524, 9516, 9500, 9472, 9532, 9566, 9567, 9562, 9556, 9577, 9574, 9568, 9552, 9580, 9575, 9576, 9572, 9573, 9561, 9560, 9554, 9555, 9579, 9578, 9496, 9484, 9608, 9604, 9612, 9616, 9600, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1025, 1105, 1028, 1108, 1031, 1111, 1038, 1118, 176, 8729, 183, 8730, 8470, 164, 9632, 160],
  "iso-8859-2": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 728, 321, 164, 317, 346, 167, 168, 352, 350, 356, 377, 173, 381, 379, 176, 261, 731, 322, 180, 318, 347, 711, 184, 353, 351, 357, 378, 733, 382, 380, 340, 193, 194, 258, 196, 313, 262, 199, 268, 201, 280, 203, 282, 205, 206, 270, 272, 323, 327, 211, 212, 336, 214, 215, 344, 366, 218, 368, 220, 221, 354, 223, 341, 225, 226, 259, 228, 314, 263, 231, 269, 233, 281, 235, 283, 237, 238, 271, 273, 324, 328, 243, 244, 337, 246, 247, 345, 367, 250, 369, 252, 253, 355, 729],
  "iso-8859-3": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 294, 728, 163, 164, null, 292, 167, 168, 304, 350, 286, 308, 173, null, 379, 176, 295, 178, 179, 180, 181, 293, 183, 184, 305, 351, 287, 309, 189, null, 380, 192, 193, 194, null, 196, 266, 264, 199, 200, 201, 202, 203, 204, 205, 206, 207, null, 209, 210, 211, 212, 288, 214, 215, 284, 217, 218, 219, 220, 364, 348, 223, 224, 225, 226, null, 228, 267, 265, 231, 232, 233, 234, 235, 236, 237, 238, 239, null, 241, 242, 243, 244, 289, 246, 247, 285, 249, 250, 251, 252, 365, 349, 729],
  "iso-8859-4": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 312, 342, 164, 296, 315, 167, 168, 352, 274, 290, 358, 173, 381, 175, 176, 261, 731, 343, 180, 297, 316, 711, 184, 353, 275, 291, 359, 330, 382, 331, 256, 193, 194, 195, 196, 197, 198, 302, 268, 201, 280, 203, 278, 205, 206, 298, 272, 325, 332, 310, 212, 213, 214, 215, 216, 370, 218, 219, 220, 360, 362, 223, 257, 225, 226, 227, 228, 229, 230, 303, 269, 233, 281, 235, 279, 237, 238, 299, 273, 326, 333, 311, 244, 245, 246, 247, 248, 371, 250, 251, 252, 361, 363, 729],
  "iso-8859-5": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 173, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 8470, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 167, 1118, 1119],
  "iso-8859-6": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, null, null, null, 164, null, null, null, null, null, null, null, 1548, 173, null, null, null, null, null, null, null, null, null, null, null, null, null, 1563, null, null, null, 1567, null, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, null, null, null, null, null, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, null, null, null, null, null, null, null, null, null, null, null, null, null],
  "iso-8859-7": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 8216, 8217, 163, 8364, 8367, 166, 167, 168, 169, 890, 171, 172, 173, null, 8213, 176, 177, 178, 179, 900, 901, 902, 183, 904, 905, 906, 187, 908, 189, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, null, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, null],
  "iso-8859-8": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, null, 162, 163, 164, 165, 166, 167, 168, 169, 215, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 247, 187, 188, 189, 190, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 8215, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, null, null, 8206, 8207, null],
  "iso-8859-10": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 274, 290, 298, 296, 310, 167, 315, 272, 352, 358, 381, 173, 362, 330, 176, 261, 275, 291, 299, 297, 311, 183, 316, 273, 353, 359, 382, 8213, 363, 331, 256, 193, 194, 195, 196, 197, 198, 302, 268, 201, 280, 203, 278, 205, 206, 207, 208, 325, 332, 211, 212, 213, 214, 360, 216, 370, 218, 219, 220, 221, 222, 223, 257, 225, 226, 227, 228, 229, 230, 303, 269, 233, 281, 235, 279, 237, 238, 239, 240, 326, 333, 243, 244, 245, 246, 361, 248, 371, 250, 251, 252, 253, 254, 312],
  "iso-8859-13": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 8221, 162, 163, 164, 8222, 166, 167, 216, 169, 342, 171, 172, 173, 174, 198, 176, 177, 178, 179, 8220, 181, 182, 183, 248, 185, 343, 187, 188, 189, 190, 230, 260, 302, 256, 262, 196, 197, 280, 274, 268, 201, 377, 278, 290, 310, 298, 315, 352, 323, 325, 211, 332, 213, 214, 215, 370, 321, 346, 362, 220, 379, 381, 223, 261, 303, 257, 263, 228, 229, 281, 275, 269, 233, 378, 279, 291, 311, 299, 316, 353, 324, 326, 243, 333, 245, 246, 247, 371, 322, 347, 363, 252, 380, 382, 8217],
  "iso-8859-14": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 7682, 7683, 163, 266, 267, 7690, 167, 7808, 169, 7810, 7691, 7922, 173, 174, 376, 7710, 7711, 288, 289, 7744, 7745, 182, 7766, 7809, 7767, 7811, 7776, 7923, 7812, 7813, 7777, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 372, 209, 210, 211, 212, 213, 214, 7786, 216, 217, 218, 219, 220, 221, 374, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 373, 241, 242, 243, 244, 245, 246, 7787, 248, 249, 250, 251, 252, 253, 375, 255],
  "iso-8859-15": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 8364, 165, 352, 167, 353, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 381, 181, 182, 183, 382, 185, 186, 187, 338, 339, 376, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
  "iso-8859-16": [128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 261, 321, 8364, 8222, 352, 167, 353, 169, 536, 171, 377, 173, 378, 379, 176, 177, 268, 322, 381, 8221, 182, 183, 382, 269, 537, 187, 338, 339, 376, 380, 192, 193, 194, 258, 196, 262, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 272, 323, 210, 211, 212, 336, 214, 346, 368, 217, 218, 219, 220, 280, 538, 223, 224, 225, 226, 259, 228, 263, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 273, 324, 242, 243, 244, 337, 246, 347, 369, 249, 250, 251, 252, 281, 539, 255],
  "koi8-r": [9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 8992, 9632, 8729, 8730, 8776, 8804, 8805, 160, 8993, 176, 178, 183, 247, 9552, 9553, 9554, 1105, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 1025, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 169, 1102, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1103, 1088, 1089, 1090, 1091, 1078, 1074, 1100, 1099, 1079, 1096, 1101, 1097, 1095, 1098, 1070, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1071, 1056, 1057, 1058, 1059, 1046, 1042, 1068, 1067, 1047, 1064, 1069, 1065, 1063, 1066],
  "koi8-u": [9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 8992, 9632, 8729, 8730, 8776, 8804, 8805, 160, 8993, 176, 178, 183, 247, 9552, 9553, 9554, 1105, 1108, 9556, 1110, 1111, 9559, 9560, 9561, 9562, 9563, 1169, 1118, 9566, 9567, 9568, 9569, 1025, 1028, 9571, 1030, 1031, 9574, 9575, 9576, 9577, 9578, 1168, 1038, 169, 1102, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1103, 1088, 1089, 1090, 1091, 1078, 1074, 1100, 1099, 1079, 1096, 1101, 1097, 1095, 1098, 1070, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1071, 1056, 1057, 1058, 1059, 1046, 1042, 1068, 1067, 1047, 1064, 1069, 1065, 1063, 1066],
  "macintosh": [196, 197, 199, 201, 209, 214, 220, 225, 224, 226, 228, 227, 229, 231, 233, 232, 234, 235, 237, 236, 238, 239, 241, 243, 242, 244, 246, 245, 250, 249, 251, 252, 8224, 176, 162, 163, 167, 8226, 182, 223, 174, 169, 8482, 180, 168, 8800, 198, 216, 8734, 177, 8804, 8805, 165, 181, 8706, 8721, 8719, 960, 8747, 170, 186, 937, 230, 248, 191, 161, 172, 8730, 402, 8776, 8710, 171, 187, 8230, 160, 192, 195, 213, 338, 339, 8211, 8212, 8220, 8221, 8216, 8217, 247, 9674, 255, 376, 8260, 8364, 8249, 8250, 64257, 64258, 8225, 183, 8218, 8222, 8240, 194, 202, 193, 203, 200, 205, 206, 207, 204, 211, 212, 63743, 210, 218, 219, 217, 305, 710, 732, 175, 728, 729, 730, 184, 733, 731, 711],
  "windows-874": [8364, 129, 130, 131, 132, 8230, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 153, 154, 155, 156, 157, 158, 159, 160, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, null, null, null, null, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, null, null, null, null],
  "windows-1250": [8364, 129, 8218, 131, 8222, 8230, 8224, 8225, 136, 8240, 352, 8249, 346, 356, 381, 377, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 353, 8250, 347, 357, 382, 378, 160, 711, 728, 321, 164, 260, 166, 167, 168, 169, 350, 171, 172, 173, 174, 379, 176, 177, 731, 322, 180, 181, 182, 183, 184, 261, 351, 187, 317, 733, 318, 380, 340, 193, 194, 258, 196, 313, 262, 199, 268, 201, 280, 203, 282, 205, 206, 270, 272, 323, 327, 211, 212, 336, 214, 215, 344, 366, 218, 368, 220, 221, 354, 223, 341, 225, 226, 259, 228, 314, 263, 231, 269, 233, 281, 235, 283, 237, 238, 271, 273, 324, 328, 243, 244, 337, 246, 247, 345, 367, 250, 369, 252, 253, 355, 729],
  "windows-1251": [1026, 1027, 8218, 1107, 8222, 8230, 8224, 8225, 8364, 8240, 1033, 8249, 1034, 1036, 1035, 1039, 1106, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 1113, 8250, 1114, 1116, 1115, 1119, 160, 1038, 1118, 1032, 164, 1168, 166, 167, 1025, 169, 1028, 171, 172, 173, 174, 1031, 176, 177, 1030, 1110, 1169, 181, 182, 183, 1105, 8470, 1108, 187, 1112, 1029, 1109, 1111, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103],
  "windows-1252": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
  "windows-1253": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 136, 8240, 138, 8249, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 154, 8250, 156, 157, 158, 159, 160, 901, 902, 163, 164, 165, 166, 167, 168, 169, null, 171, 172, 173, 174, 8213, 176, 177, 178, 179, 900, 181, 182, 183, 904, 905, 906, 187, 908, 189, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, null, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, null],
  "windows-1254": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 158, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 286, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 304, 350, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 287, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 305, 351, 255],
  "windows-1255": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 138, 8249, 140, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 154, 8250, 156, 157, 158, 159, 160, 161, 162, 163, 8362, 165, 166, 167, 168, 169, 215, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 247, 187, 188, 189, 190, 191, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1520, 1521, 1522, 1523, 1524, null, null, null, null, null, null, null, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, null, null, 8206, 8207, null],
  "windows-1256": [8364, 1662, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 1657, 8249, 338, 1670, 1688, 1672, 1711, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 1705, 8482, 1681, 8250, 339, 8204, 8205, 1722, 160, 1548, 162, 163, 164, 165, 166, 167, 168, 169, 1726, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 1563, 187, 188, 189, 190, 1567, 1729, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 215, 1591, 1592, 1593, 1594, 1600, 1601, 1602, 1603, 224, 1604, 226, 1605, 1606, 1607, 1608, 231, 232, 233, 234, 235, 1609, 1610, 238, 239, 1611, 1612, 1613, 1614, 244, 1615, 1616, 247, 1617, 249, 1618, 251, 252, 8206, 8207, 1746],
  "windows-1257": [8364, 129, 8218, 131, 8222, 8230, 8224, 8225, 136, 8240, 138, 8249, 140, 168, 711, 184, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 152, 8482, 154, 8250, 156, 175, 731, 159, 160, null, 162, 163, 164, null, 166, 167, 216, 169, 342, 171, 172, 173, 174, 198, 176, 177, 178, 179, 180, 181, 182, 183, 248, 185, 343, 187, 188, 189, 190, 230, 260, 302, 256, 262, 196, 197, 280, 274, 268, 201, 377, 278, 290, 310, 298, 315, 352, 323, 325, 211, 332, 213, 214, 215, 370, 321, 346, 362, 220, 379, 381, 223, 261, 303, 257, 263, 228, 229, 281, 275, 269, 233, 378, 279, 291, 311, 299, 316, 353, 324, 326, 243, 333, 245, 246, 247, 371, 322, 347, 363, 252, 380, 382, 729],
  "windows-1258": [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 138, 8249, 338, 141, 142, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 154, 8250, 339, 157, 158, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 258, 196, 197, 198, 199, 200, 201, 202, 203, 768, 205, 206, 207, 272, 209, 777, 211, 212, 416, 214, 215, 216, 217, 218, 219, 220, 431, 771, 223, 224, 225, 226, 259, 228, 229, 230, 231, 232, 233, 234, 235, 769, 237, 238, 239, 273, 241, 803, 243, 244, 417, 246, 247, 248, 249, 250, 251, 252, 432, 8363, 255],
  "x-mac-cyrillic": [1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 8224, 176, 1168, 163, 167, 8226, 182, 1030, 174, 169, 8482, 1026, 1106, 8800, 1027, 1107, 8734, 177, 8804, 8805, 1110, 181, 1169, 1032, 1028, 1108, 1031, 1111, 1033, 1113, 1034, 1114, 1112, 1029, 172, 8730, 402, 8776, 8710, 171, 187, 8230, 160, 1035, 1115, 1036, 1116, 1109, 8211, 8212, 8220, 8221, 8216, 8217, 247, 8222, 1038, 1118, 1039, 1119, 8470, 1025, 1105, 1103, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 8364]
};

// ../polyfills/src/lib/encoding.ts
global["encoding-indexes"] = encoding_indexes_default || {};
function inRange(a, min, max) {
  return min <= a && a <= max;
}
function includes(array, item) {
  return array.indexOf(item) !== -1;
}
var floor = Math.floor;
function ToDictionary(o) {
  if (o === void 0)
    return {};
  if (o === Object(o))
    return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string) {
  var s = String(string);
  var n = s.length;
  var i = 0;
  var u = [];
  while (i < n) {
    var c = s.charCodeAt(i);
    if (c < 55296 || c > 57343) {
      u.push(c);
    } else if (56320 <= c && c <= 57343) {
      u.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i === n - 1) {
        u.push(65533);
      } else {
        var d = s.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          var a = c & 1023;
          var b = d & 1023;
          u.push(65536 + (a << 10) + b);
          i += 1;
        } else {
          u.push(65533);
        }
      }
    }
    i += 1;
  }
  return u;
}
function codePointsToString(code_points) {
  var s = "";
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
    }
  }
  return s;
}
function isASCIIByte(a) {
  return 0 <= a && a <= 127;
}
var isASCIICodePoint = isASCIIByte;
var end_of_stream = -1;
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
  this.tokens.reverse();
}
Stream.prototype = {
  endOfStream: function() {
    return !this.tokens.length;
  },
  read: function() {
    if (!this.tokens.length)
      return end_of_stream;
    return this.tokens.pop();
  },
  prepend: function(token) {
    if (Array.isArray(token)) {
      var tokens = token;
      while (tokens.length)
        this.tokens.push(tokens.pop());
    } else {
      this.tokens.push(token);
    }
  },
  push: function(token) {
    if (Array.isArray(token)) {
      var tokens = token;
      while (tokens.length)
        this.tokens.unshift(tokens.shift());
    } else {
      this.tokens.unshift(token);
    }
  }
};
var finished = -1;
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
function encoderError(code_point) {
  throw TypeError("The code point " + code_point + " could not be encoded.");
}
function Decoder() {
}
Decoder.prototype = {
  handler: function(stream, bite) {
  }
};
function Encoder() {
}
Encoder.prototype = {
  handler: function(stream, code_point) {
  }
};
function getEncoding(label) {
  label = String(label).trim().toLowerCase();
  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
    return label_to_encoding[label];
  }
  return null;
}
var encodings = [
  {
    encodings: [
      {
        labels: ["unicode-1-1-utf-8", "utf-8", "utf8"],
        name: "UTF-8"
      }
    ],
    heading: "The Encoding"
  },
  {
    encodings: [
      {
        labels: ["866", "cp866", "csibm866", "ibm866"],
        name: "IBM866"
      },
      {
        labels: [
          "csisolatin2",
          "iso-8859-2",
          "iso-ir-101",
          "iso8859-2",
          "iso88592",
          "iso_8859-2",
          "iso_8859-2:1987",
          "l2",
          "latin2"
        ],
        name: "ISO-8859-2"
      },
      {
        labels: [
          "csisolatin3",
          "iso-8859-3",
          "iso-ir-109",
          "iso8859-3",
          "iso88593",
          "iso_8859-3",
          "iso_8859-3:1988",
          "l3",
          "latin3"
        ],
        name: "ISO-8859-3"
      },
      {
        labels: [
          "csisolatin4",
          "iso-8859-4",
          "iso-ir-110",
          "iso8859-4",
          "iso88594",
          "iso_8859-4",
          "iso_8859-4:1988",
          "l4",
          "latin4"
        ],
        name: "ISO-8859-4"
      },
      {
        labels: [
          "csisolatincyrillic",
          "cyrillic",
          "iso-8859-5",
          "iso-ir-144",
          "iso8859-5",
          "iso88595",
          "iso_8859-5",
          "iso_8859-5:1988"
        ],
        name: "ISO-8859-5"
      },
      {
        labels: [
          "arabic",
          "asmo-708",
          "csiso88596e",
          "csiso88596i",
          "csisolatinarabic",
          "ecma-114",
          "iso-8859-6",
          "iso-8859-6-e",
          "iso-8859-6-i",
          "iso-ir-127",
          "iso8859-6",
          "iso88596",
          "iso_8859-6",
          "iso_8859-6:1987"
        ],
        name: "ISO-8859-6"
      },
      {
        labels: [
          "csisolatingreek",
          "ecma-118",
          "elot_928",
          "greek",
          "greek8",
          "iso-8859-7",
          "iso-ir-126",
          "iso8859-7",
          "iso88597",
          "iso_8859-7",
          "iso_8859-7:1987",
          "sun_eu_greek"
        ],
        name: "ISO-8859-7"
      },
      {
        labels: [
          "csiso88598e",
          "csisolatinhebrew",
          "hebrew",
          "iso-8859-8",
          "iso-8859-8-e",
          "iso-ir-138",
          "iso8859-8",
          "iso88598",
          "iso_8859-8",
          "iso_8859-8:1988",
          "visual"
        ],
        name: "ISO-8859-8"
      },
      {
        labels: ["csiso88598i", "iso-8859-8-i", "logical"],
        name: "ISO-8859-8-I"
      },
      {
        labels: [
          "csisolatin6",
          "iso-8859-10",
          "iso-ir-157",
          "iso8859-10",
          "iso885910",
          "l6",
          "latin6"
        ],
        name: "ISO-8859-10"
      },
      {
        labels: ["iso-8859-13", "iso8859-13", "iso885913"],
        name: "ISO-8859-13"
      },
      {
        labels: ["iso-8859-14", "iso8859-14", "iso885914"],
        name: "ISO-8859-14"
      },
      {
        labels: ["csisolatin9", "iso-8859-15", "iso8859-15", "iso885915", "iso_8859-15", "l9"],
        name: "ISO-8859-15"
      },
      {
        labels: ["iso-8859-16"],
        name: "ISO-8859-16"
      },
      {
        labels: ["cskoi8r", "koi", "koi8", "koi8-r", "koi8_r"],
        name: "KOI8-R"
      },
      {
        labels: ["koi8-ru", "koi8-u"],
        name: "KOI8-U"
      },
      {
        labels: ["csmacintosh", "mac", "macintosh", "x-mac-roman"],
        name: "macintosh"
      },
      {
        labels: ["dos-874", "iso-8859-11", "iso8859-11", "iso885911", "tis-620", "windows-874"],
        name: "windows-874"
      },
      {
        labels: ["cp1250", "windows-1250", "x-cp1250"],
        name: "windows-1250"
      },
      {
        labels: ["cp1251", "windows-1251", "x-cp1251"],
        name: "windows-1251"
      },
      {
        labels: [
          "ansi_x3.4-1968",
          "ascii",
          "cp1252",
          "cp819",
          "csisolatin1",
          "ibm819",
          "iso-8859-1",
          "iso-ir-100",
          "iso8859-1",
          "iso88591",
          "iso_8859-1",
          "iso_8859-1:1987",
          "l1",
          "latin1",
          "us-ascii",
          "windows-1252",
          "x-cp1252"
        ],
        name: "windows-1252"
      },
      {
        labels: ["cp1253", "windows-1253", "x-cp1253"],
        name: "windows-1253"
      },
      {
        labels: [
          "cp1254",
          "csisolatin5",
          "iso-8859-9",
          "iso-ir-148",
          "iso8859-9",
          "iso88599",
          "iso_8859-9",
          "iso_8859-9:1989",
          "l5",
          "latin5",
          "windows-1254",
          "x-cp1254"
        ],
        name: "windows-1254"
      },
      {
        labels: ["cp1255", "windows-1255", "x-cp1255"],
        name: "windows-1255"
      },
      {
        labels: ["cp1256", "windows-1256", "x-cp1256"],
        name: "windows-1256"
      },
      {
        labels: ["cp1257", "windows-1257", "x-cp1257"],
        name: "windows-1257"
      },
      {
        labels: ["cp1258", "windows-1258", "x-cp1258"],
        name: "windows-1258"
      },
      {
        labels: ["x-mac-cyrillic", "x-mac-ukrainian"],
        name: "x-mac-cyrillic"
      }
    ],
    heading: "Legacy single-byte encodings"
  },
  {
    encodings: [
      {
        labels: [
          "chinese",
          "csgb2312",
          "csiso58gb231280",
          "gb2312",
          "gb_2312",
          "gb_2312-80",
          "gbk",
          "iso-ir-58",
          "x-gbk"
        ],
        name: "GBK"
      },
      {
        labels: ["gb18030"],
        name: "gb18030"
      }
    ],
    heading: "Legacy multi-byte Chinese (simplified) encodings"
  },
  {
    encodings: [
      {
        labels: ["big5", "big5-hkscs", "cn-big5", "csbig5", "x-x-big5"],
        name: "Big5"
      }
    ],
    heading: "Legacy multi-byte Chinese (traditional) encodings"
  },
  {
    encodings: [
      {
        labels: ["cseucpkdfmtjapanese", "euc-jp", "x-euc-jp"],
        name: "EUC-JP"
      },
      {
        labels: ["csiso2022jp", "iso-2022-jp"],
        name: "ISO-2022-JP"
      },
      {
        labels: [
          "csshiftjis",
          "ms932",
          "ms_kanji",
          "shift-jis",
          "shift_jis",
          "sjis",
          "windows-31j",
          "x-sjis"
        ],
        name: "Shift_JIS"
      }
    ],
    heading: "Legacy multi-byte Japanese encodings"
  },
  {
    encodings: [
      {
        labels: [
          "cseuckr",
          "csksc56011987",
          "euc-kr",
          "iso-ir-149",
          "korean",
          "ks_c_5601-1987",
          "ks_c_5601-1989",
          "ksc5601",
          "ksc_5601",
          "windows-949"
        ],
        name: "EUC-KR"
      }
    ],
    heading: "Legacy multi-byte Korean encodings"
  },
  {
    encodings: [
      {
        labels: ["csiso2022kr", "hz-gb-2312", "iso-2022-cn", "iso-2022-cn-ext", "iso-2022-kr"],
        name: "replacement"
      },
      {
        labels: ["utf-16be"],
        name: "UTF-16BE"
      },
      {
        labels: ["utf-16", "utf-16le"],
        name: "UTF-16LE"
      },
      {
        labels: ["x-user-defined"],
        name: "x-user-defined"
      }
    ],
    heading: "Legacy miscellaneous encodings"
  }
];
var label_to_encoding = {};
encodings.forEach(function(category) {
  category.encodings.forEach(function(encoding) {
    encoding.labels.forEach(function(label) {
      label_to_encoding[label] = encoding;
    });
  });
});
var encoders = {};
var decoders = {};
function indexCodePointFor(pointer, index2) {
  if (!index2)
    return null;
  return index2[pointer] || null;
}
function indexPointerFor(code_point, index2) {
  var pointer = index2.indexOf(code_point);
  return pointer === -1 ? null : pointer;
}
function index(name) {
  if (!("encoding-indexes" in global)) {
    throw Error("Indexes missing. Did you forget to include encoding-indexes.js first?");
  }
  return global["encoding-indexes"][name];
}
function indexGB18030RangesCodePointFor(pointer) {
  if (pointer > 39419 && pointer < 189e3 || pointer > 1237575)
    return null;
  if (pointer === 7457)
    return 59335;
  var offset = 0;
  var code_point_offset = 0;
  var idx = index("gb18030-ranges");
  var i;
  for (i = 0; i < idx.length; ++i) {
    var entry = idx[i];
    if (entry[0] <= pointer) {
      offset = entry[0];
      code_point_offset = entry[1];
    } else {
      break;
    }
  }
  return code_point_offset + pointer - offset;
}
function indexGB18030RangesPointerFor(code_point) {
  if (code_point === 59335)
    return 7457;
  var offset = 0;
  var pointer_offset = 0;
  var idx = index("gb18030-ranges");
  var i;
  for (i = 0; i < idx.length; ++i) {
    var entry = idx[i];
    if (entry[1] <= code_point) {
      offset = entry[1];
      pointer_offset = entry[0];
    } else {
      break;
    }
  }
  return pointer_offset + code_point - offset;
}
function indexShiftJISPointerFor(code_point) {
  shift_jis_index = shift_jis_index || index("jis0208").map(function(code_point2, pointer) {
    return inRange(pointer, 8272, 8835) ? null : code_point2;
  });
  var index_ = shift_jis_index;
  return index_.indexOf(code_point);
}
var shift_jis_index;
function indexBig5PointerFor(code_point) {
  big5_index_no_hkscs = big5_index_no_hkscs || index("big5").map(function(code_point2, pointer) {
    return pointer < (161 - 129) * 157 ? null : code_point2;
  });
  var index_ = big5_index_no_hkscs;
  if (code_point === 9552 || code_point === 9566 || code_point === 9569 || code_point === 9578 || code_point === 21313 || code_point === 21317) {
    return index_.lastIndexOf(code_point);
  }
  return indexPointerFor(code_point, index_);
}
var big5_index_no_hkscs;
var DEFAULT_ENCODING = "utf-8";
function TextDecoder2(label, options) {
  if (!(this instanceof TextDecoder2))
    throw TypeError("Called as a function. Did you forget 'new'?");
  label = label !== void 0 ? String(label) : DEFAULT_ENCODING;
  options = ToDictionary(options);
  this._encoding = null;
  this._decoder = null;
  this._ignoreBOM = false;
  this._BOMseen = false;
  this._error_mode = "replacement";
  this._do_not_flush = false;
  var encoding = getEncoding(label);
  if (encoding === null || encoding.name === "replacement")
    throw RangeError("Unknown encoding: " + label);
  if (!decoders[encoding.name]) {
    throw Error("Decoder not present. Did you forget to include encoding-indexes.js first?");
  }
  var dec = this;
  dec._encoding = encoding;
  if (Boolean(options["fatal"]))
    dec._error_mode = "fatal";
  if (Boolean(options["ignoreBOM"]))
    dec._ignoreBOM = true;
  if (!Object.defineProperty) {
    this.encoding = dec._encoding.name.toLowerCase();
    this.fatal = dec._error_mode === "fatal";
    this.ignoreBOM = dec._ignoreBOM;
  }
  return dec;
}
if (Object.defineProperty) {
  Object.defineProperty(TextDecoder2.prototype, "encoding", {
    get: function() {
      return this._encoding.name.toLowerCase();
    }
  });
  Object.defineProperty(TextDecoder2.prototype, "fatal", {
    get: function() {
      return this._error_mode === "fatal";
    }
  });
  Object.defineProperty(TextDecoder2.prototype, "ignoreBOM", {
    get: function() {
      return this._ignoreBOM;
    }
  });
}
TextDecoder2.prototype.decode = function decode(input, options) {
  var bytes;
  if (typeof input === "object" && input instanceof ArrayBuffer) {
    bytes = new Uint8Array(input);
  } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
    bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
  } else {
    bytes = new Uint8Array(0);
  }
  options = ToDictionary(options);
  if (!this._do_not_flush) {
    this._decoder = decoders[this._encoding.name]({
      fatal: this._error_mode === "fatal"
    });
    this._BOMseen = false;
  }
  this._do_not_flush = Boolean(options["stream"]);
  var input_stream = new Stream(bytes);
  var output = [];
  var result;
  while (true) {
    var token = input_stream.read();
    if (token === end_of_stream)
      break;
    result = this._decoder.handler(input_stream, token);
    if (result === finished)
      break;
    if (result !== null) {
      if (Array.isArray(result))
        output.push.apply(output, result);
      else
        output.push(result);
    }
  }
  if (!this._do_not_flush) {
    do {
      result = this._decoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (result === null)
        continue;
      if (Array.isArray(result))
        output.push.apply(output, result);
      else
        output.push(result);
    } while (!input_stream.endOfStream());
    this._decoder = null;
  }
  function serializeStream(stream) {
    if (includes(["UTF-8", "UTF-16LE", "UTF-16BE"], this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {
      if (stream.length > 0 && stream[0] === 65279) {
        this._BOMseen = true;
        stream.shift();
      } else if (stream.length > 0) {
        this._BOMseen = true;
      } else {
      }
    }
    return codePointsToString(stream);
  }
  return serializeStream.call(this, output);
};
function TextEncoder2(label, options) {
  if (!(this instanceof TextEncoder2))
    throw TypeError("Called as a function. Did you forget 'new'?");
  options = ToDictionary(options);
  this._encoding = null;
  this._encoder = null;
  this._do_not_flush = false;
  this._fatal = Boolean(options["fatal"]) ? "fatal" : "replacement";
  var enc = this;
  if (Boolean(options["NONSTANDARD_allowLegacyEncoding"])) {
    label = label !== void 0 ? String(label) : DEFAULT_ENCODING;
    var encoding = getEncoding(label);
    if (encoding === null || encoding.name === "replacement")
      throw RangeError("Unknown encoding: " + label);
    if (!encoders[encoding.name]) {
      throw Error("Encoder not present. Did you forget to include encoding-indexes.js first?");
    }
    enc._encoding = encoding;
  } else {
    enc._encoding = getEncoding("utf-8");
    if (label !== void 0 && "console" in global) {
      console.warn("TextEncoder constructor called with encoding label, which is ignored.");
    }
  }
  if (!Object.defineProperty)
    this.encoding = enc._encoding.name.toLowerCase();
  return enc;
}
if (Object.defineProperty) {
  Object.defineProperty(TextEncoder2.prototype, "encoding", {
    get: function() {
      return this._encoding.name.toLowerCase();
    }
  });
}
TextEncoder2.prototype.encode = function encode(opt_string, options) {
  opt_string = opt_string === void 0 ? "" : String(opt_string);
  options = ToDictionary(options);
  if (!this._do_not_flush)
    this._encoder = encoders[this._encoding.name]({
      fatal: this._fatal === "fatal"
    });
  this._do_not_flush = Boolean(options["stream"]);
  var input = new Stream(stringToCodePoints(opt_string));
  var output = [];
  var result;
  while (true) {
    var token = input.read();
    if (token === end_of_stream)
      break;
    result = this._encoder.handler(input, token);
    if (result === finished)
      break;
    if (Array.isArray(result))
      output.push.apply(output, result);
    else
      output.push(result);
  }
  if (!this._do_not_flush) {
    while (true) {
      result = this._encoder.handler(input, input.read());
      if (result === finished)
        break;
      if (Array.isArray(result))
        output.push.apply(output, result);
      else
        output.push(result);
    }
    this._encoder = null;
  }
  return new Uint8Array(output);
};
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      } else if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite & 31;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite & 15;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite & 7;
      } else {
        return decoderError(fatal);
      }
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_code_point = utf8_code_point << 6 | bite & 63;
    utf8_bytes_seen += 1;
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (isASCIICodePoint(code_point))
      return code_point;
    var count, offset;
    if (inRange(code_point, 128, 2047)) {
      count = 1;
      offset = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count = 2;
      offset = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count = 3;
      offset = 240;
    }
    var bytes = [(code_point >> 6 * count) + offset];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes.push(128 | temp & 63);
      count -= 1;
    }
    return bytes;
  };
}
encoders["UTF-8"] = function(options) {
  return new UTF8Encoder(options);
};
decoders["UTF-8"] = function(options) {
  return new UTF8Decoder(options);
};
function SingleByteDecoder(index2, options) {
  var fatal = options.fatal;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream)
      return finished;
    if (isASCIIByte(bite))
      return bite;
    var code_point = index2[bite - 128];
    if (code_point === null)
      return decoderError(fatal);
    return code_point;
  };
}
function SingleByteEncoder(index2, options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (isASCIICodePoint(code_point))
      return code_point;
    var pointer = indexPointerFor(code_point, index2);
    if (pointer === null)
      encoderError(code_point);
    return pointer + 128;
  };
}
(function() {
  if (!("encoding-indexes" in global))
    return;
  encodings.forEach(function(category) {
    if (category.heading !== "Legacy single-byte encodings")
      return;
    category.encodings.forEach(function(encoding) {
      var name = encoding.name;
      var idx = index(name.toLowerCase());
      decoders[name] = function(options) {
        return new SingleByteDecoder(idx, options);
      };
      encoders[name] = function(options) {
        return new SingleByteEncoder(idx, options);
      };
    });
  });
})();
decoders["GBK"] = function(options) {
  return new GB18030Decoder(options);
};
encoders["GBK"] = function(options) {
  return new GB18030Encoder(options, true);
};
function GB18030Decoder(options) {
  var fatal = options.fatal;
  var gb18030_first = 0, gb18030_second = 0, gb18030_third = 0;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && gb18030_first === 0 && gb18030_second === 0 && gb18030_third === 0) {
      return finished;
    }
    if (bite === end_of_stream && (gb18030_first !== 0 || gb18030_second !== 0 || gb18030_third !== 0)) {
      gb18030_first = 0;
      gb18030_second = 0;
      gb18030_third = 0;
      decoderError(fatal);
    }
    var code_point;
    if (gb18030_third !== 0) {
      code_point = null;
      if (inRange(bite, 48, 57)) {
        code_point = indexGB18030RangesCodePointFor((((gb18030_first - 129) * 10 + gb18030_second - 48) * 126 + gb18030_third - 129) * 10 + bite - 48);
      }
      var buffer = [gb18030_second, gb18030_third, bite];
      gb18030_first = 0;
      gb18030_second = 0;
      gb18030_third = 0;
      if (code_point === null) {
        stream.prepend(buffer);
        return decoderError(fatal);
      }
      return code_point;
    }
    if (gb18030_second !== 0) {
      if (inRange(bite, 129, 254)) {
        gb18030_third = bite;
        return null;
      }
      stream.prepend([gb18030_second, bite]);
      gb18030_first = 0;
      gb18030_second = 0;
      return decoderError(fatal);
    }
    if (gb18030_first !== 0) {
      if (inRange(bite, 48, 57)) {
        gb18030_second = bite;
        return null;
      }
      var lead = gb18030_first;
      var pointer = null;
      gb18030_first = 0;
      var offset = bite < 127 ? 64 : 65;
      if (inRange(bite, 64, 126) || inRange(bite, 128, 254))
        pointer = (lead - 129) * 190 + (bite - offset);
      code_point = pointer === null ? null : indexCodePointFor(pointer, index("gb18030"));
      if (code_point === null && isASCIIByte(bite))
        stream.prepend(bite);
      if (code_point === null)
        return decoderError(fatal);
      return code_point;
    }
    if (isASCIIByte(bite))
      return bite;
    if (bite === 128)
      return 8364;
    if (inRange(bite, 129, 254)) {
      gb18030_first = bite;
      return null;
    }
    return decoderError(fatal);
  };
}
function GB18030Encoder(options, gbk_flag) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (isASCIICodePoint(code_point))
      return code_point;
    if (code_point === 58853)
      return encoderError(code_point);
    if (gbk_flag && code_point === 8364)
      return 128;
    var pointer = indexPointerFor(code_point, index("gb18030"));
    if (pointer !== null) {
      var lead = floor(pointer / 190) + 129;
      var trail = pointer % 190;
      var offset = trail < 63 ? 64 : 65;
      return [lead, trail + offset];
    }
    if (gbk_flag)
      return encoderError(code_point);
    pointer = indexGB18030RangesPointerFor(code_point);
    var byte1 = floor(pointer / 10 / 126 / 10);
    pointer = pointer - byte1 * 10 * 126 * 10;
    var byte2 = floor(pointer / 10 / 126);
    pointer = pointer - byte2 * 10 * 126;
    var byte3 = floor(pointer / 10);
    var byte4 = pointer - byte3 * 10;
    return [byte1 + 129, byte2 + 48, byte3 + 129, byte4 + 48];
  };
}
encoders["gb18030"] = function(options) {
  return new GB18030Encoder(options);
};
decoders["gb18030"] = function(options) {
  return new GB18030Decoder(options);
};
function Big5Decoder(options) {
  var fatal = options.fatal;
  var Big5_lead = 0;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && Big5_lead !== 0) {
      Big5_lead = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream && Big5_lead === 0)
      return finished;
    if (Big5_lead !== 0) {
      var lead = Big5_lead;
      var pointer = null;
      Big5_lead = 0;
      var offset = bite < 127 ? 64 : 98;
      if (inRange(bite, 64, 126) || inRange(bite, 161, 254))
        pointer = (lead - 129) * 157 + (bite - offset);
      switch (pointer) {
        case 1133:
          return [202, 772];
        case 1135:
          return [202, 780];
        case 1164:
          return [234, 772];
        case 1166:
          return [234, 780];
      }
      var code_point = pointer === null ? null : indexCodePointFor(pointer, index("big5"));
      if (code_point === null && isASCIIByte(bite))
        stream.prepend(bite);
      if (code_point === null)
        return decoderError(fatal);
      return code_point;
    }
    if (isASCIIByte(bite))
      return bite;
    if (inRange(bite, 129, 254)) {
      Big5_lead = bite;
      return null;
    }
    return decoderError(fatal);
  };
}
function Big5Encoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (isASCIICodePoint(code_point))
      return code_point;
    var pointer = indexBig5PointerFor(code_point);
    if (pointer === null)
      return encoderError(code_point);
    var lead = floor(pointer / 157) + 129;
    if (lead < 161)
      return encoderError(code_point);
    var trail = pointer % 157;
    var offset = trail < 63 ? 64 : 98;
    return [lead, trail + offset];
  };
}
encoders["Big5"] = function(options) {
  return new Big5Encoder(options);
};
decoders["Big5"] = function(options) {
  return new Big5Decoder(options);
};
function EUCJPDecoder(options) {
  var fatal = options.fatal;
  var eucjp_jis0212_flag = false, eucjp_lead = 0;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && eucjp_lead !== 0) {
      eucjp_lead = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream && eucjp_lead === 0)
      return finished;
    if (eucjp_lead === 142 && inRange(bite, 161, 223)) {
      eucjp_lead = 0;
      return 65377 - 161 + bite;
    }
    if (eucjp_lead === 143 && inRange(bite, 161, 254)) {
      eucjp_jis0212_flag = true;
      eucjp_lead = bite;
      return null;
    }
    if (eucjp_lead !== 0) {
      var lead = eucjp_lead;
      eucjp_lead = 0;
      var code_point = null;
      if (inRange(lead, 161, 254) && inRange(bite, 161, 254)) {
        code_point = indexCodePointFor((lead - 161) * 94 + (bite - 161), index(!eucjp_jis0212_flag ? "jis0208" : "jis0212"));
      }
      eucjp_jis0212_flag = false;
      if (!inRange(bite, 161, 254))
        stream.prepend(bite);
      if (code_point === null)
        return decoderError(fatal);
      return code_point;
    }
    if (isASCIIByte(bite))
      return bite;
    if (bite === 142 || bite === 143 || inRange(bite, 161, 254)) {
      eucjp_lead = bite;
      return null;
    }
    return decoderError(fatal);
  };
}
function EUCJPEncoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (isASCIICodePoint(code_point))
      return code_point;
    if (code_point === 165)
      return 92;
    if (code_point === 8254)
      return 126;
    if (inRange(code_point, 65377, 65439))
      return [142, code_point - 65377 + 161];
    if (code_point === 8722)
      code_point = 65293;
    var pointer = indexPointerFor(code_point, index("jis0208"));
    if (pointer === null)
      return encoderError(code_point);
    var lead = floor(pointer / 94) + 161;
    var trail = pointer % 94 + 161;
    return [lead, trail];
  };
}
encoders["EUC-JP"] = function(options) {
  return new EUCJPEncoder(options);
};
decoders["EUC-JP"] = function(options) {
  return new EUCJPDecoder(options);
};
function ISO2022JPDecoder(options) {
  var fatal = options.fatal;
  var states = {
    ASCII: 0,
    Roman: 1,
    Katakana: 2,
    LeadByte: 3,
    TrailByte: 4,
    EscapeStart: 5,
    Escape: 6
  };
  var iso2022jp_decoder_state = states.ASCII, iso2022jp_decoder_output_state = states.ASCII, iso2022jp_lead = 0, iso2022jp_output_flag = false;
  this.handler = function(stream, bite) {
    switch (iso2022jp_decoder_state) {
      default:
      case states.ASCII:
        if (bite === 27) {
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }
        if (inRange(bite, 0, 127) && bite !== 14 && bite !== 15 && bite !== 27) {
          iso2022jp_output_flag = false;
          return bite;
        }
        if (bite === end_of_stream) {
          return finished;
        }
        iso2022jp_output_flag = false;
        return decoderError(fatal);
      case states.Roman:
        if (bite === 27) {
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }
        if (bite === 92) {
          iso2022jp_output_flag = false;
          return 165;
        }
        if (bite === 126) {
          iso2022jp_output_flag = false;
          return 8254;
        }
        if (inRange(bite, 0, 127) && bite !== 14 && bite !== 15 && bite !== 27 && bite !== 92 && bite !== 126) {
          iso2022jp_output_flag = false;
          return bite;
        }
        if (bite === end_of_stream) {
          return finished;
        }
        iso2022jp_output_flag = false;
        return decoderError(fatal);
      case states.Katakana:
        if (bite === 27) {
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }
        if (inRange(bite, 33, 95)) {
          iso2022jp_output_flag = false;
          return 65377 - 33 + bite;
        }
        if (bite === end_of_stream) {
          return finished;
        }
        iso2022jp_output_flag = false;
        return decoderError(fatal);
      case states.LeadByte:
        if (bite === 27) {
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }
        if (inRange(bite, 33, 126)) {
          iso2022jp_output_flag = false;
          iso2022jp_lead = bite;
          iso2022jp_decoder_state = states.TrailByte;
          return null;
        }
        if (bite === end_of_stream) {
          return finished;
        }
        iso2022jp_output_flag = false;
        return decoderError(fatal);
      case states.TrailByte:
        if (bite === 27) {
          iso2022jp_decoder_state = states.EscapeStart;
          return decoderError(fatal);
        }
        if (inRange(bite, 33, 126)) {
          iso2022jp_decoder_state = states.LeadByte;
          var pointer = (iso2022jp_lead - 33) * 94 + bite - 33;
          var code_point = indexCodePointFor(pointer, index("jis0208"));
          if (code_point === null)
            return decoderError(fatal);
          return code_point;
        }
        if (bite === end_of_stream) {
          iso2022jp_decoder_state = states.LeadByte;
          stream.prepend(bite);
          return decoderError(fatal);
        }
        iso2022jp_decoder_state = states.LeadByte;
        return decoderError(fatal);
      case states.EscapeStart:
        if (bite === 36 || bite === 40) {
          iso2022jp_lead = bite;
          iso2022jp_decoder_state = states.Escape;
          return null;
        }
        stream.prepend(bite);
        iso2022jp_output_flag = false;
        iso2022jp_decoder_state = iso2022jp_decoder_output_state;
        return decoderError(fatal);
      case states.Escape:
        var lead = iso2022jp_lead;
        iso2022jp_lead = 0;
        var state = null;
        if (lead === 40 && bite === 66)
          state = states.ASCII;
        if (lead === 40 && bite === 74)
          state = states.Roman;
        if (lead === 40 && bite === 73)
          state = states.Katakana;
        if (lead === 36 && (bite === 64 || bite === 66))
          state = states.LeadByte;
        if (state !== null) {
          iso2022jp_decoder_state = iso2022jp_decoder_state = state;
          var output_flag = iso2022jp_output_flag;
          iso2022jp_output_flag = true;
          return !output_flag ? null : decoderError(fatal);
        }
        stream.prepend([lead, bite]);
        iso2022jp_output_flag = false;
        iso2022jp_decoder_state = iso2022jp_decoder_output_state;
        return decoderError(fatal);
    }
  };
}
function ISO2022JPEncoder(options) {
  var fatal = options.fatal;
  var states = {
    ASCII: 0,
    Roman: 1,
    jis0208: 2
  };
  var iso2022jp_state = states.ASCII;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {
      stream.prepend(code_point);
      iso2022jp_state = states.ASCII;
      return [27, 40, 66];
    }
    if (code_point === end_of_stream && iso2022jp_state === states.ASCII)
      return finished;
    if ((iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) && (code_point === 14 || code_point === 15 || code_point === 27)) {
      return encoderError(65533);
    }
    if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point))
      return code_point;
    if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && code_point !== 92 && code_point !== 126 || code_point == 165 || code_point == 8254)) {
      if (isASCIICodePoint(code_point))
        return code_point;
      if (code_point === 165)
        return 92;
      if (code_point === 8254)
        return 126;
    }
    if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {
      stream.prepend(code_point);
      iso2022jp_state = states.ASCII;
      return [27, 40, 66];
    }
    if ((code_point === 165 || code_point === 8254) && iso2022jp_state !== states.Roman) {
      stream.prepend(code_point);
      iso2022jp_state = states.Roman;
      return [27, 40, 74];
    }
    if (code_point === 8722)
      code_point = 65293;
    var pointer = indexPointerFor(code_point, index("jis0208"));
    if (pointer === null)
      return encoderError(code_point);
    if (iso2022jp_state !== states.jis0208) {
      stream.prepend(code_point);
      iso2022jp_state = states.jis0208;
      return [27, 36, 66];
    }
    var lead = floor(pointer / 94) + 33;
    var trail = pointer % 94 + 33;
    return [lead, trail];
  };
}
encoders["ISO-2022-JP"] = function(options) {
  return new ISO2022JPEncoder(options);
};
decoders["ISO-2022-JP"] = function(options) {
  return new ISO2022JPDecoder(options);
};
function ShiftJISDecoder(options) {
  var fatal = options.fatal;
  var Shift_JIS_lead = 0;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && Shift_JIS_lead !== 0) {
      Shift_JIS_lead = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream && Shift_JIS_lead === 0)
      return finished;
    if (Shift_JIS_lead !== 0) {
      var lead = Shift_JIS_lead;
      var pointer = null;
      Shift_JIS_lead = 0;
      var offset = bite < 127 ? 64 : 65;
      var lead_offset = lead < 160 ? 129 : 193;
      if (inRange(bite, 64, 126) || inRange(bite, 128, 252))
        pointer = (lead - lead_offset) * 188 + bite - offset;
      if (inRange(pointer, 8836, 10715))
        return 57344 - 8836 + pointer;
      var code_point = pointer === null ? null : indexCodePointFor(pointer, index("jis0208"));
      if (code_point === null && isASCIIByte(bite))
        stream.prepend(bite);
      if (code_point === null)
        return decoderError(fatal);
      return code_point;
    }
    if (isASCIIByte(bite) || bite === 128)
      return bite;
    if (inRange(bite, 161, 223))
      return 65377 - 161 + bite;
    if (inRange(bite, 129, 159) || inRange(bite, 224, 252)) {
      Shift_JIS_lead = bite;
      return null;
    }
    return decoderError(fatal);
  };
}
function ShiftJISEncoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (isASCIICodePoint(code_point) || code_point === 128)
      return code_point;
    if (code_point === 165)
      return 92;
    if (code_point === 8254)
      return 126;
    if (inRange(code_point, 65377, 65439))
      return code_point - 65377 + 161;
    if (code_point === 8722)
      code_point = 65293;
    var pointer = indexShiftJISPointerFor(code_point);
    if (pointer === null)
      return encoderError(code_point);
    var lead = floor(pointer / 188);
    var lead_offset = lead < 31 ? 129 : 193;
    var trail = pointer % 188;
    var offset = trail < 63 ? 64 : 65;
    return [lead + lead_offset, trail + offset];
  };
}
encoders["Shift_JIS"] = function(options) {
  return new ShiftJISEncoder(options);
};
decoders["Shift_JIS"] = function(options) {
  return new ShiftJISDecoder(options);
};
function EUCKRDecoder(options) {
  var fatal = options.fatal;
  var euckr_lead = 0;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && euckr_lead !== 0) {
      euckr_lead = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream && euckr_lead === 0)
      return finished;
    if (euckr_lead !== 0) {
      var lead = euckr_lead;
      var pointer = null;
      euckr_lead = 0;
      if (inRange(bite, 65, 254))
        pointer = (lead - 129) * 190 + (bite - 65);
      var code_point = pointer === null ? null : indexCodePointFor(pointer, index("euc-kr"));
      if (pointer === null && isASCIIByte(bite))
        stream.prepend(bite);
      if (code_point === null)
        return decoderError(fatal);
      return code_point;
    }
    if (isASCIIByte(bite))
      return bite;
    if (inRange(bite, 129, 254)) {
      euckr_lead = bite;
      return null;
    }
    return decoderError(fatal);
  };
}
function EUCKREncoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (isASCIICodePoint(code_point))
      return code_point;
    var pointer = indexPointerFor(code_point, index("euc-kr"));
    if (pointer === null)
      return encoderError(code_point);
    var lead = floor(pointer / 190) + 129;
    var trail = pointer % 190 + 65;
    return [lead, trail];
  };
}
encoders["EUC-KR"] = function(options) {
  return new EUCKREncoder(options);
};
decoders["EUC-KR"] = function(options) {
  return new EUCKRDecoder(options);
};
function convertCodeUnitToBytes(code_unit, utf16be) {
  var byte1 = code_unit >> 8;
  var byte2 = code_unit & 255;
  if (utf16be)
    return [byte1, byte2];
  return [byte2, byte1];
}
function UTF16Decoder(utf16_be, options) {
  var fatal = options.fatal;
  var utf16_lead_byte = null, utf16_lead_surrogate = null;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {
      return decoderError(fatal);
    }
    if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {
      return finished;
    }
    if (utf16_lead_byte === null) {
      utf16_lead_byte = bite;
      return null;
    }
    var code_unit;
    if (utf16_be) {
      code_unit = (utf16_lead_byte << 8) + bite;
    } else {
      code_unit = (bite << 8) + utf16_lead_byte;
    }
    utf16_lead_byte = null;
    if (utf16_lead_surrogate !== null) {
      var lead_surrogate = utf16_lead_surrogate;
      utf16_lead_surrogate = null;
      if (inRange(code_unit, 56320, 57343)) {
        return 65536 + (lead_surrogate - 55296) * 1024 + (code_unit - 56320);
      }
      stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));
      return decoderError(fatal);
    }
    if (inRange(code_unit, 55296, 56319)) {
      utf16_lead_surrogate = code_unit;
      return null;
    }
    if (inRange(code_unit, 56320, 57343))
      return decoderError(fatal);
    return code_unit;
  };
}
function UTF16Encoder(utf16_be, options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange(code_point, 0, 65535))
      return convertCodeUnitToBytes(code_point, utf16_be);
    var lead = convertCodeUnitToBytes((code_point - 65536 >> 10) + 55296, utf16_be);
    var trail = convertCodeUnitToBytes((code_point - 65536 & 1023) + 56320, utf16_be);
    return lead.concat(trail);
  };
}
encoders["UTF-16BE"] = function(options) {
  return new UTF16Encoder(true, options);
};
decoders["UTF-16BE"] = function(options) {
  return new UTF16Decoder(true, options);
};
encoders["UTF-16LE"] = function(options) {
  return new UTF16Encoder(false, options);
};
decoders["UTF-16LE"] = function(options) {
  return new UTF16Decoder(false, options);
};
function XUserDefinedDecoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream)
      return finished;
    if (isASCIIByte(bite))
      return bite;
    return 63360 + bite - 128;
  };
}
function XUserDefinedEncoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (isASCIICodePoint(code_point))
      return code_point;
    if (inRange(code_point, 63360, 63487))
      return code_point - 63360 + 128;
    return encoderError(code_point);
  };
}
encoders["x-user-defined"] = function(options) {
  return new XUserDefinedEncoder(options);
};
decoders["x-user-defined"] = function(options) {
  return new XUserDefinedDecoder(options);
};

// ../polyfills/src/promise/all-settled.ts
var REJECTED_STATUS = "rejected";
var FULFILLED_STATUS = "fulfilled";
function allSettled(promises) {
  const mappedPromises = promises.map((promise) => {
    return promise.then((value) => {
      return { status: FULFILLED_STATUS, value };
    }).catch((reason) => {
      return { status: REJECTED_STATUS, reason };
    });
  });
  return Promise.all(mappedPromises);
}

// ../polyfills/src/node/buffer/btoa.node.ts
function atob(string) {
  return Buffer.from(string).toString("base64");
}
function btoa(base642) {
  return Buffer.from(base642, "base64").toString("ascii");
}

// ../polyfills/src/node/fetch/headers.node.ts
var Headers = class {
  constructor(headers) {
    this.map = {};
    if (headers instanceof Headers) {
      headers.forEach((value, name) => this.append(name, value));
    } else if (Array.isArray(headers)) {
      headers.forEach((header) => this.append(header[0], header[1]));
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach((name) => this.append(name, headers[name]));
    }
  }
  append(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    const oldValue = this.map[name];
    this.map[name] = oldValue ? `${oldValue}, ${value}` : value;
  }
  delete(name) {
    delete this.map[normalizeName(name)];
  }
  get(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
  }
  has(name) {
    return this.map.hasOwnProperty(normalizeName(name));
  }
  set(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  }
  forEach(visitor, thisArg = null) {
    for (const name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        if (thisArg) {
          visitor.call(thisArg, this.map[name], name, this);
        } else {
          visitor(this.map[name], name, this);
        }
      }
    }
  }
  keys() {
    const items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items);
  }
  values() {
    const items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items);
  }
  entries() {
    const items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items);
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
};
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name) || name === "") {
    throw new TypeError("Invalid character in header field name");
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  const iterator = {
    next() {
      const value = items.shift();
      return { done: value === void 0, value };
    }
  };
  iterator[Symbol.iterator] = function() {
    return iterator;
  };
  return iterator;
}

// ../polyfills/src/utils/assert.ts
function assert2(condition, message) {
  if (!condition) {
    throw new Error(`@loaders.gl/polyfills assertion ${message}`);
  }
}

// ../polyfills/src/node/fetch/utils/stream-utils.node.ts
var import_fs = __toModule(require("fs"));
var import_http = __toModule(require("http"));
var import_https = __toModule(require("https"));
var import_zlib = __toModule(require("zlib"));

// ../polyfills/src/node/fetch/utils/decode-data-uri.node.ts
var isArrayBuffer = (x) => x && x instanceof ArrayBuffer;
var isBuffer = (x) => x && x instanceof Buffer;
function decodeDataUri(uri) {
  const dataIndex = uri.indexOf(",");
  let buffer;
  let mimeType;
  if (uri.slice(dataIndex - 7, dataIndex) === ";base64") {
    buffer = Buffer.from(uri.slice(dataIndex + 1), "base64");
    mimeType = uri.slice(5, dataIndex - 7).trim();
  } else {
    buffer = Buffer.from(decodeURIComponent(uri.slice(dataIndex + 1)));
    mimeType = uri.slice(5, dataIndex).trim();
  }
  if (!mimeType) {
    mimeType = "text/plain;charset=US-ASCII";
  } else if (mimeType.startsWith(";")) {
    mimeType = `text/plain${mimeType}`;
  }
  return { arrayBuffer: toArrayBuffer(buffer), mimeType };
}
function toArrayBuffer(data) {
  if (isArrayBuffer(data)) {
    return data;
  }
  if (isBuffer(data)) {
    const typedArray = new Uint8Array(data);
    return typedArray.buffer;
  }
  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }
  if (typeof data === "string") {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === "object" && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error(`toArrayBuffer(${JSON.stringify(data, null, 2).slice(10)})`);
}

// ../polyfills/src/node/fetch/utils/stream-utils.node.ts
function isRequestURL(url) {
  return url.startsWith("http:") || url.startsWith("https:");
}
async function createReadStream(url, options) {
  if (!isRequestURL(url)) {
    const noqueryUrl = url.split("?")[0];
    return await new Promise((resolve, reject) => {
      const stream = import_fs.default.createReadStream(noqueryUrl, { encoding: null });
      stream.once("readable", () => resolve(stream));
      stream.on("error", (error) => reject(error));
    });
  }
  return await new Promise((resolve, reject) => {
    const requestFunction = url.startsWith("https:") ? import_https.default.request : import_http.default.request;
    const requestOptions = getRequestOptions(url, options);
    const req = requestFunction(requestOptions, (res) => resolve(res));
    req.on("error", (error) => reject(error));
    req.end();
  });
}
function decompressReadStream(readStream, headers) {
  switch (headers.get("content-encoding")) {
    case "br":
      return readStream.pipe(import_zlib.default.createBrotliDecompress());
    case "gzip":
      return readStream.pipe(import_zlib.default.createGunzip());
    case "deflate":
      return readStream.pipe(import_zlib.default.createDeflate());
    default:
      return readStream;
  }
}
async function concatenateReadStream(readStream) {
  const arrayBufferChunks = [];
  return await new Promise((resolve, reject) => {
    readStream.on("error", (error) => reject(error));
    readStream.on("readable", () => readStream.read());
    readStream.on("data", (chunk) => {
      if (typeof chunk === "string") {
        reject(new Error("Read stream not binary"));
      }
      arrayBufferChunks.push(toArrayBuffer(chunk));
    });
    readStream.on("end", () => {
      const arrayBuffer = concatenateArrayBuffers(arrayBufferChunks);
      resolve(arrayBuffer);
    });
  });
}
function getRequestOptions(url, options) {
  const originalHeaders = (options == null ? void 0 : options.headers) || {};
  const headers = {};
  for (const key of Object.keys(originalHeaders)) {
    headers[key.toLowerCase()] = originalHeaders[key];
  }
  headers["accept-encoding"] = headers["accept-encoding"] || "gzip,br,deflate";
  const urlObject = new URL(url);
  return __spreadProps(__spreadValues(__spreadValues({
    hostname: urlObject.hostname,
    path: urlObject.pathname,
    method: "GET"
  }, options), options == null ? void 0 : options.fetch), {
    headers,
    port: urlObject.port
  });
}
function concatenateArrayBuffers(sources) {
  const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}

// ../polyfills/src/node/fetch/response.node.ts
var import_stream = __toModule(require("stream"));
var isBoolean = (x) => typeof x === "boolean";
var isFunction = (x) => typeof x === "function";
var isObject = (x) => x !== null && typeof x === "object";
var isReadableNodeStream = (x) => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
var Response = class {
  constructor(body, options) {
    this.bodyUsed = false;
    const { headers, status = 200, statusText = "OK", url } = options || {};
    this.url = url;
    this.ok = status === 200;
    this.status = status;
    this.statusText = statusText;
    this.headers = new Headers((options == null ? void 0 : options.headers) || {});
    if (isReadableNodeStream(body)) {
      this._body = decompressReadStream(body, headers);
    } else if (typeof body === "string") {
      this._body = import_stream.Readable.from([new TextEncoder().encode(body)]);
    } else {
      this._body = import_stream.Readable.from([body || new ArrayBuffer(0)]);
    }
  }
  get body() {
    assert2(!this.bodyUsed);
    assert2(isReadableNodeStream(this._body));
    this.bodyUsed = true;
    return this._body;
  }
  async arrayBuffer() {
    if (!isReadableNodeStream(this._body)) {
      return this._body || new ArrayBuffer(0);
    }
    const data = await concatenateReadStream(this._body);
    return data;
  }
  async text() {
    const arrayBuffer = await this.arrayBuffer();
    const textDecoder = new TextDecoder();
    return textDecoder.decode(arrayBuffer);
  }
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  async blob() {
    if (typeof Blob === "undefined") {
      throw new Error("Blob polyfill not installed");
    }
    return new Blob([await this.arrayBuffer()]);
  }
};

// ../polyfills/src/node/fetch/fetch.node.ts
var import_fs2 = __toModule(require("fs"));
var isDataURL = (url) => url.startsWith("data:");
var isRequestURL2 = (url) => url.startsWith("http:") || url.startsWith("https:");
async function fetchNode(url, options) {
  try {
    if (isDataURL(url)) {
      const { arrayBuffer, mimeType } = decodeDataUri(url);
      const response = new Response(arrayBuffer, {
        headers: { "content-type": mimeType },
        url
      });
      return response;
    }
    const syntheticResponseHeaders = {};
    const originalUrl = url;
    if (url.endsWith(".gz")) {
      url = url.slice(0, -3);
      syntheticResponseHeaders["content-encoding"] = "gzip";
    }
    const body = await createReadStream(originalUrl, options);
    const headers = getHeaders(url, body, syntheticResponseHeaders);
    const { status, statusText } = getStatus(body);
    const followRedirect = !options || options.followRedirect || options.followRedirect === void 0;
    if (status >= 300 && status < 400 && headers.has("location") && followRedirect) {
      const redirectUrl = generateRedirectUrl(url, headers.get("location"));
      return await fetchNode(redirectUrl, options);
    }
    return new Response(body, { headers, status, statusText, url });
  } catch (error) {
    return new Response(null, { status: 400, statusText: String(error), url });
  }
}
function generateRedirectUrl(originalUrl, location) {
  if (location.startsWith("http")) {
    return location;
  }
  const url = new URL(originalUrl);
  url.pathname = location;
  return url.href;
}
function getStatus(httpResponse) {
  if (httpResponse.statusCode) {
    return { status: httpResponse.statusCode, statusText: httpResponse.statusMessage || "NA" };
  }
  return { status: 200, statusText: "OK" };
}
function getHeaders(url, httpResponse, additionalHeaders = {}) {
  const headers = {};
  if (httpResponse && httpResponse.headers) {
    const httpHeaders = httpResponse.headers;
    for (const key in httpHeaders) {
      const header = httpHeaders[key];
      headers[key.toLowerCase()] = String(header);
    }
  }
  if (!headers["content-length"]) {
    const contentLength = getContentLength(url);
    if (Number.isFinite(contentLength)) {
      headers["content-length"] = contentLength;
    }
  }
  Object.assign(headers, additionalHeaders);
  return new Headers(headers);
}
function getContentLength(url) {
  if (isRequestURL2(url)) {
    return null;
  } else if (isDataURL(url)) {
    return url.length - "data:".length;
  }
  try {
    const noqueryUrl = url.split("?")[0];
    const stats = import_fs2.default.statSync(noqueryUrl);
    return stats.size;
  } catch (error) {
  }
  return null;
}

// ../polyfills/src/node/images/encode-image.node.ts
var import_save_pixels = __toModule(require_save_pixels());
var import_ndarray = __toModule(require_ndarray());

// ../polyfills/src/node/buffer/to-array-buffer.node.ts
function bufferToArrayBuffer(buffer) {
  if (Buffer.isBuffer(buffer)) {
    const typedArray = new Uint8Array(buffer);
    return typedArray.buffer;
  }
  return buffer;
}

// ../polyfills/src/node/images/encode-image.node.ts
function encodeImageToStreamNode(image, options) {
  const type = options.type ? options.type.replace("image/", "") : "jpeg";
  const pixels = (0, import_ndarray.default)(image.data, [image.width, image.height, 4], [4, image.width * 4, 1], 0);
  return (0, import_save_pixels.default)(pixels, type, options);
}
function encodeImageNode(image, options) {
  const imageStream = encodeImageToStreamNode(image, options);
  return new Promise((resolve) => {
    const buffers = [];
    imageStream.on("data", (buffer) => buffers.push(buffer));
    imageStream.on("end", () => {
      const buffer = Buffer.concat(buffers);
      resolve(bufferToArrayBuffer(buffer));
    });
  });
}

// ../polyfills/src/node/images/parse-image.node.ts
var import_get_pixels = __toModule(require_node_pixels());
var import_util = __toModule(require("util"));
async function parseImageNode(arrayBuffer, mimeType) {
  assert2(mimeType, "MIMEType is required to parse image under Node.js");
  const getPixelsAsync = import_util.default.promisify(import_get_pixels.default);
  const buffer = arrayBuffer instanceof Buffer ? arrayBuffer : Buffer.from(arrayBuffer);
  const ndarray2 = await getPixelsAsync(buffer, mimeType);
  const shape = [...ndarray2.shape];
  const layers = ndarray2.shape.length === 4 ? ndarray2.shape.shift() : 1;
  return {
    shape,
    data: ndarray2.data,
    width: ndarray2.shape[0],
    height: ndarray2.shape[1],
    components: ndarray2.shape[2],
    layers
  };
}

// ../polyfills/src/node/file/readable-stream.ts
var import_web_streams_polyfill = __toModule(require_polyfill());
delete global.ReadableStream;
var ReadableStreamPolyfill = class extends import_web_streams_polyfill.ReadableStream {
};

// ../polyfills/src/node/file/blob-stream-controller.ts
var BlobStreamController = class {
  constructor(chunks) {
    this.isWorking = false;
    this.isCancelled = false;
    this.chunks = chunks;
  }
  start(controller) {
    this.work(controller);
  }
  async work(controller) {
    const { chunks } = this;
    this.isWorking = true;
    while (!this.isCancelled && (controller.desiredSize || 0) > 0) {
      let next;
      try {
        next = chunks.next();
      } catch (error) {
        controller.error(error);
        break;
      }
      if (next) {
        if (!next.done && !this.isCancelled) {
          controller.enqueue(next.value);
        } else {
          controller.close();
        }
      }
    }
    this.isWorking = false;
  }
  pull(controller) {
    if (!this.isWorking) {
      this.work(controller);
    }
  }
  cancel() {
    this.isCancelled = true;
  }
};

// ../polyfills/src/node/file/blob-stream.ts
var BlobStream = class extends ReadableStreamPolyfill {
  constructor(chunks) {
    super(new BlobStreamController(chunks.values()), { type: "bytes" });
    this._chunks = chunks;
  }
  async *[Symbol.asyncIterator](_options) {
    const reader = this.getReader();
    yield* this._chunks;
    reader.releaseLock();
  }
};

// ../polyfills/src/node/file/blob.ts
var BlobPolyfill = class {
  constructor(init = [], options = {}) {
    this.parts = [];
    this.size = 0;
    for (const part of init) {
      if (typeof part === "string") {
        const bytes = new TextEncoder().encode(part);
        this.parts.push(bytes);
        this.size += bytes.byteLength;
      } else if (part instanceof BlobPolyfill) {
        this.size += part.size;
        this.parts.push(...part.parts);
      } else if (part instanceof ArrayBuffer) {
        this.parts.push(new Uint8Array(part));
        this.size += part.byteLength;
      } else if (part instanceof Uint8Array) {
        this.parts.push(part);
        this.size += part.byteLength;
      } else if (ArrayBuffer.isView(part)) {
        const { buffer, byteOffset, byteLength } = part;
        this.parts.push(new Uint8Array(buffer, byteOffset, byteLength));
        this.size += byteLength;
      } else {
        const bytes = new TextEncoder().encode(String(part));
        this.parts.push(bytes);
        this.size += bytes.byteLength;
      }
    }
    this.type = readType(options.type);
  }
  slice(start = 0, end = this.size, type = "") {
    const { size, parts } = this;
    let offset = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
    let limit = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(limit - offset, 0);
    const blob = new BlobPolyfill([], { type });
    if (span === 0) {
      return blob;
    }
    let blobSize = 0;
    const blobParts = [];
    for (const part of parts) {
      const { byteLength } = part;
      if (offset > 0 && byteLength <= offset) {
        offset -= byteLength;
        limit -= byteLength;
      } else {
        const chunk = part.subarray(offset, Math.min(byteLength, limit));
        blobParts.push(chunk);
        blobSize += chunk.byteLength;
        offset = 0;
        if (blobSize >= span) {
          break;
        }
      }
    }
    blob.parts = blobParts;
    blob.size = blobSize;
    return blob;
  }
  async arrayBuffer() {
    return this._toArrayBuffer();
  }
  async text() {
    const decoder = new TextDecoder();
    let text = "";
    for (const part of this.parts) {
      text += decoder.decode(part);
    }
    return text;
  }
  stream() {
    return new BlobStream(this.parts);
  }
  toString() {
    return "[object Blob]";
  }
  get [Symbol.toStringTag]() {
    return "Blob";
  }
  _toArrayBuffer() {
    const buffer = new ArrayBuffer(this.size);
    const bytes = new Uint8Array(buffer);
    let offset = 0;
    for (const part of this.parts) {
      bytes.set(part, offset);
      offset += part.byteLength;
    }
    return buffer;
  }
};
function readType(input = "") {
  const type = String(input).toLowerCase();
  return /[^\u0020-\u007E]/.test(type) ? "" : type;
}

// ../polyfills/src/node/file/file.ts
var FilePolyfill = class extends BlobPolyfill {
  constructor(init, name, options = {}) {
    super(init, options);
    this.name = "";
    this.webkitRelativePath = "";
    this.name = String(name).replace(/\//g, ":");
    this.lastModified = (options == null ? void 0 : options.lastModified) || Date.now();
  }
  get [Symbol.toStringTag]() {
    return "File";
  }
};

// ../polyfills/src/index.ts
var installTextEncoder = !isBrowser2 || !("TextEncoder" in global_2);
if (installTextEncoder) {
  global_2["TextEncoder"] = TextEncoder2;
}
var installTextDecoder = !isBrowser2 || !("TextDecoder" in global_2);
if (installTextDecoder) {
  global_2["TextDecoder"] = TextDecoder2;
}
if (!isBrowser2 && !("atob" in global_2) && atob) {
  global_2["atob"] = atob;
}
if (!isBrowser2 && !("btoa" in global_2) && btoa) {
  global_2["btoa"] = btoa;
}
if (!isBrowser2 && !("Headers" in global_2) && Headers) {
  global_2["Headers"] = Headers;
}
if (!isBrowser2 && !("Response" in global_2) && Response) {
  global_2["Response"] = Response;
}
if (!isBrowser2 && !("fetch" in global_2) && fetchNode) {
  global_2["fetch"] = fetchNode;
}
if (!isBrowser2 && !("DOMParser" in global_2) && import_xmldom.DOMParser) {
  global_2["DOMParser"] = import_xmldom.DOMParser;
}
if (!isBrowser2 && !("_encodeImageNode" in global_2) && encodeImageNode) {
  global_2["_encodeImageNode"] = encodeImageNode;
}
if (!isBrowser2 && !("_parseImageNode" in global_2) && parseImageNode) {
  global_2["_parseImageNode"] = parseImageNode;
}
if (!("allSettled" in Promise)) {
  Promise.allSettled = allSettled;
}

// src/lib/utils/version.ts
var VERSION3 = true ? "3.2.9" : "latest";

// src/lib/parsers/basis-module-loader.ts
var VERSION4 = true ? "3.2.9" : "beta";
var BASIS_CDN_ENCODER_WASM = `https://unpkg.com/@loaders.gl/textures@${VERSION4}/dist/libs/basis_encoder.wasm`;
var BASIS_CDN_ENCODER_JS = `https://unpkg.com/@loaders.gl/textures@${VERSION4}/dist/libs/basis_encoder.js`;
var loadBasisEncoderPromise;
async function loadBasisEncoderModule(options) {
  const modules = options.modules || {};
  if (modules.basisEncoder) {
    return modules.basisEncoder;
  }
  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
  return await loadBasisEncoderPromise;
}
async function loadBasisEncoder(options) {
  let BASIS_ENCODER = null;
  let wasmBinary = null;
  [BASIS_ENCODER, wasmBinary] = await Promise.all([
    await loadLibrary(BASIS_CDN_ENCODER_JS, "textures", options),
    await loadLibrary(BASIS_CDN_ENCODER_WASM, "textures", options)
  ]);
  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
}
function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    BasisEncoderModule(options).then((module2) => {
      const { BasisFile, KTX2File, initializeBasis, BasisEncoder } = module2;
      initializeBasis();
      resolve({ BasisFile, KTX2File, BasisEncoder });
    });
  });
}

// src/lib/encoders/encode-ktx2-basis-texture.ts
async function encodeKTX2BasisTexture(image, options = {}) {
  const { useSRGB = false, qualityLevel = 10, encodeUASTC = false, mipmaps = false } = options;
  const { BasisEncoder } = await loadBasisEncoderModule(options);
  const basisEncoder = new BasisEncoder();
  try {
    const basisFileData = new Uint8Array(image.width * image.height * 4);
    basisEncoder.setCreateKTX2File(true);
    basisEncoder.setKTX2UASTCSupercompression(true);
    basisEncoder.setKTX2SRGBTransferFunc(true);
    basisEncoder.setSliceSourceImage(0, image.data, image.width, image.height, false);
    basisEncoder.setPerceptual(useSRGB);
    basisEncoder.setMipSRGB(useSRGB);
    basisEncoder.setQualityLevel(qualityLevel);
    basisEncoder.setUASTC(encodeUASTC);
    basisEncoder.setMipGen(mipmaps);
    const numOutputBytes = basisEncoder.encode(basisFileData);
    const actualKTX2FileData = basisFileData.subarray(0, numOutputBytes).buffer;
    return actualKTX2FileData;
  } catch (error) {
    console.error("Basis Universal Supercompressed GPU Texture encoder Error: ", error);
    throw error;
  } finally {
    basisEncoder.delete();
  }
}

// src/ktx2-basis-writer.ts
var KTX2BasisWriter = {
  name: "Basis Universal Supercompressed GPU Texture",
  id: "ktx2-basis-writer",
  module: "textures",
  version: VERSION3,
  extensions: ["ktx2"],
  options: {
    useSRGB: false,
    qualityLevel: 10,
    encodeUASTC: false,
    mipmaps: false
  },
  encode: encodeKTX2BasisTexture
};

// src/workers/ktx2-basis-writer-nodejs-worker.ts
(() => {
  if (!WorkerBody.inWorkerThread()) {
    return;
  }
  WorkerBody.onmessage = async (type, payload) => {
    switch (type) {
      case "process":
        try {
          const { input, options } = payload;
          const result = await KTX2BasisWriter.encode(input, options);
          WorkerBody.postMessage("done", { result });
        } catch (error) {
          const message = error instanceof Error ? error.message : "";
          WorkerBody.postMessage("error", { error: message });
        }
        break;
      default:
    }
  };
})();
/*!
 *  Copyright 2010 LearnBoost <dev@learnboost.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*!
 * Copyright (c) 2018, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
