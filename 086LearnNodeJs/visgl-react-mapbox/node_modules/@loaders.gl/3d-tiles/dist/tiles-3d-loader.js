"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tiles3DLoader = void 0;
const loader_utils_1 = require("@loaders.gl/loader-utils");
const tiles_1 = require("@loaders.gl/tiles");
const version_1 = require("./lib/utils/version");
const parse_3d_tile_1 = require("./lib/parsers/parse-3d-tile");
const parse_3d_tile_header_1 = require("./lib/parsers/parse-3d-tile-header");
const IMPLICIT_TILING_EXTENSION_NAME = '3DTILES_implicit_tiling';
/**
 * Loader for 3D Tiles
 */
exports.Tiles3DLoader = {
    id: '3d-tiles',
    name: '3D Tiles',
    module: '3d-tiles',
    version: version_1.VERSION,
    extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],
    mimeTypes: ['application/octet-stream'],
    tests: ['cmpt', 'pnts', 'b3dm', 'i3dm'],
    parse,
    options: {
        '3d-tiles': {
            loadGLTF: true,
            decodeQuantizedPositions: false,
            isTileset: 'auto',
            assetGltfUpAxis: null
        }
    }
};
function getBaseUri(tileset) {
    return loader_utils_1.path.dirname(tileset.url);
}
async function parseTile(arrayBuffer, options, context) {
    const tile = {
        content: {
            featureIds: null
        }
    };
    const byteOffset = 0;
    await (0, parse_3d_tile_1.parse3DTile)(arrayBuffer, byteOffset, options, context, tile.content);
    return tile.content;
}
async function parseTileset(data, options, context) {
    const tilesetJson = JSON.parse(new TextDecoder().decode(data));
    // eslint-disable-next-line no-use-before-define
    tilesetJson.loader = options.loader || exports.Tiles3DLoader;
    tilesetJson.url = context.url;
    // base path that non-absolute paths in tileset are relative to.
    tilesetJson.basePath = getBaseUri(tilesetJson);
    tilesetJson.root = hasImplicitTilingExtension(tilesetJson)
        ? await (0, parse_3d_tile_header_1.normalizeImplicitTileHeaders)(tilesetJson)
        : (0, parse_3d_tile_header_1.normalizeTileHeaders)(tilesetJson);
    tilesetJson.type = tiles_1.TILESET_TYPE.TILES3D;
    tilesetJson.lodMetricType = tiles_1.LOD_METRIC_TYPE.GEOMETRIC_ERROR;
    tilesetJson.lodMetricValue = tilesetJson.root?.lodMetricValue || 0;
    return tilesetJson;
}
async function parse(data, options, context) {
    // auto detect file type
    const loaderOptions = options['3d-tiles'] || {};
    let isTileset;
    if (loaderOptions.isTileset === 'auto') {
        isTileset = context.url && context.url.indexOf('.json') !== -1;
    }
    else {
        isTileset = loaderOptions.isTileset;
    }
    if (isTileset) {
        data = await parseTileset(data, options, context);
    }
    else {
        data = await parseTile(data, options, context);
    }
    return data;
}
function hasImplicitTilingExtension(tilesetJson) {
    return (tilesetJson?.extensionsRequired?.includes(IMPLICIT_TILING_EXTENSION_NAME) &&
        tilesetJson?.extensionsUsed?.includes(IMPLICIT_TILING_EXTENSION_NAME));
}
