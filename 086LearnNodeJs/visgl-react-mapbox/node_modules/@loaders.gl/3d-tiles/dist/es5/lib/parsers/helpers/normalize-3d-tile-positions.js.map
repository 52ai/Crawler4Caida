{"version":3,"sources":["../../../../../src/lib/parsers/helpers/normalize-3d-tile-positions.ts"],"names":["normalize3DTilePositionAttribute","tile","positions","options","isQuantized","decodeQuantizedPositions","type","GL","UNSIGNED_SHORT","value","size","normalized","scratchPosition","Vector3","decodedArray","Float32Array","pointCount","i","set","scale","quantizedRange","multiply","quantizedVolumeScale","add","quantizedVolumeOffset","toArray"],"mappings":";;;;;;;AAAA;;AACA;;AAGO,SAASA,gCAAT,CAA0CC,IAA1C,EAAgDC,SAAhD,EAA2DC,OAA3D,EAAoE;AACzE,MAAI,CAACF,IAAI,CAACG,WAAV,EAAuB;AACrB,WAAOF,SAAP;AACD;;AAMD,MAAIC,OAAO,CAAC,UAAD,CAAP,IAAuBA,OAAO,CAAC,UAAD,CAAP,CAAoBE,wBAA/C,EAAyE;AACvEJ,IAAAA,IAAI,CAACG,WAAL,GAAmB,KAAnB;AACA,WAAOC,wBAAwB,CAACJ,IAAD,EAAOC,SAAP,CAA/B;AACD;;AAID,SAAO;AACLI,IAAAA,IAAI,EAAEC,SAAGC,cADJ;AAELC,IAAAA,KAAK,EAAEP,SAFF;AAGLQ,IAAAA,IAAI,EAAE,CAHD;AAILC,IAAAA,UAAU,EAAE;AAJP,GAAP;AAMD;;AAGD,SAASN,wBAAT,CAAkCJ,IAAlC,EAAwCC,SAAxC,EAAmD;AACjD,MAAMU,eAAe,GAAG,IAAIC,aAAJ,EAAxB;AACA,MAAMC,YAAY,GAAG,IAAIC,YAAJ,CAAiBd,IAAI,CAACe,UAAL,GAAkB,CAAnC,CAArB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,IAAI,CAACe,UAAzB,EAAqCC,CAAC,EAAtC,EAA0C;AAExCL,IAAAA,eAAe,CACZM,GADH,CACOhB,SAAS,CAACe,CAAC,GAAG,CAAL,CADhB,EACyBf,SAAS,CAACe,CAAC,GAAG,CAAJ,GAAQ,CAAT,CADlC,EAC+Cf,SAAS,CAACe,CAAC,GAAG,CAAJ,GAAQ,CAAT,CADxD,EAEGE,KAFH,CAES,IAAIlB,IAAI,CAACmB,cAFlB,EAGGC,QAHH,CAGYpB,IAAI,CAACqB,oBAHjB,EAIGC,GAJH,CAIOtB,IAAI,CAACuB,qBAJZ,EAKGC,OALH,CAKWX,YALX,EAKyBG,CAAC,GAAG,CAL7B;AAMD;;AAED,SAAOH,YAAP;AACD","sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {GL} from '@loaders.gl/math';\n\n// Prepare attribute for positions\nexport function normalize3DTilePositionAttribute(tile, positions, options) {\n  if (!tile.isQuantized) {\n    return positions;\n  }\n\n  // For quantized posititions, either expand to Float32Array or return custom accessor\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/TileFormats/Instanced3DModel/README.md#quantized-positions\n\n  // Optionally decodes quantized positions on GPU, for simpler renderers that don't accept normalized attributes\n  if (options['3d-tiles'] && options['3d-tiles'].decodeQuantizedPositions) {\n    tile.isQuantized = false;\n    return decodeQuantizedPositions(tile, positions);\n  }\n\n  // Default: Use normalized shorts directly, no copying/processing.\n  // NOTE: The \"missing\" offset/scaling operations are automatically added to modelMatrix if `tile.isQuantized === true`\n  return {\n    type: GL.UNSIGNED_SHORT,\n    value: positions,\n    size: 3,\n    normalized: true\n  };\n}\n\n// Pre-scale quantized positions on CPU\nfunction decodeQuantizedPositions(tile, positions) {\n  const scratchPosition = new Vector3();\n  const decodedArray = new Float32Array(tile.pointCount * 3);\n\n  for (let i = 0; i < tile.pointCount; i++) {\n    // POSITION = POSITION_QUANTIZED / 65535.0 * QUANTIZED_VOLUME_SCALE + QUANTIZED_VOLUME_OFFSET\n    scratchPosition\n      .set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2])\n      .scale(1 / tile.quantizedRange)\n      .multiply(tile.quantizedVolumeScale)\n      .add(tile.quantizedVolumeOffset)\n      .toArray(decodedArray, i * 3);\n  }\n\n  return decodedArray;\n}\n"],"file":"normalize-3d-tile-positions.js"}