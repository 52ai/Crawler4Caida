"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeImplicitTileData = exports.normalizeImplicitTileHeaders = exports.normalizeTileHeaders = exports.normalizeTileData = void 0;
const tile_3d_subtree_loader_1 = require("../../tile-3d-subtree-loader");
const core_1 = require("@loaders.gl/core");
const tiles_1 = require("@loaders.gl/tiles");
const parse_3d_implicit_tiles_1 = require("./helpers/parse-3d-implicit-tiles");
function getTileType(tile) {
    if (!tile.contentUrl) {
        return tiles_1.TILE_TYPE.EMPTY;
    }
    const contentUrl = tile.contentUrl;
    const fileExtension = contentUrl.split('.').pop();
    switch (fileExtension) {
        case 'pnts':
            return tiles_1.TILE_TYPE.POINTCLOUD;
        case 'i3dm':
        case 'b3dm':
        case 'glb':
        case 'gltf':
            return tiles_1.TILE_TYPE.SCENEGRAPH;
        default:
            return fileExtension;
    }
}
function getRefine(refine) {
    switch (refine) {
        case 'REPLACE':
        case 'replace':
            return tiles_1.TILE_REFINEMENT.REPLACE;
        case 'ADD':
        case 'add':
            return tiles_1.TILE_REFINEMENT.ADD;
        default:
            return refine;
    }
}
function resolveUri(uri, basePath) {
    // url scheme per RFC3986
    const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;
    if (urlSchemeRegex.test(basePath)) {
        const url = new URL(uri, `${basePath}/`);
        return decodeURI(url.toString());
    }
    else if (uri.startsWith('/')) {
        return uri;
    }
    return `${basePath}/${uri}`;
}
function normalizeTileData(tile, options) {
    if (!tile) {
        return null;
    }
    if (tile.content) {
        const contentUri = tile.content.uri || tile.content.url;
        tile.contentUrl = resolveUri(contentUri, options.basePath);
    }
    tile.id = tile.contentUrl;
    tile.lodMetricType = tiles_1.LOD_METRIC_TYPE.GEOMETRIC_ERROR;
    tile.lodMetricValue = tile.geometricError;
    tile.transformMatrix = tile.transform;
    tile.type = getTileType(tile);
    tile.refine = getRefine(tile.refine);
    return tile;
}
exports.normalizeTileData = normalizeTileData;
// normalize tile headers
function normalizeTileHeaders(tileset) {
    const basePath = tileset.basePath;
    const root = normalizeTileData(tileset.root, tileset);
    const stack = [];
    stack.push(root);
    while (stack.length > 0) {
        const tile = stack.pop() || {};
        const children = tile.children || [];
        for (const childHeader of children) {
            normalizeTileData(childHeader, { basePath });
            stack.push(childHeader);
        }
    }
    return root;
}
exports.normalizeTileHeaders = normalizeTileHeaders;
/**
 * Do normalisation of implicit tile headers
 * TODO Check if Tile3D class can be a return type here.
 * @param tileset
 */
async function normalizeImplicitTileHeaders(tileset) {
    if (!tileset.root) {
        return null;
    }
    const basePath = tileset.basePath;
    const implicitTilingExtension = tileset.root.extensions['3DTILES_implicit_tiling'];
    const { subdivisionScheme, maximumLevel, subtreeLevels, subtrees: { uri: subtreesUriTemplate } } = implicitTilingExtension;
    const subtreeUrl = (0, parse_3d_implicit_tiles_1.replaceContentUrlTemplate)(subtreesUriTemplate, 0, 0, 0, 0);
    const rootSubtreeUrl = resolveUri(subtreeUrl, basePath);
    const rootSubtree = await (0, core_1.load)(rootSubtreeUrl, tile_3d_subtree_loader_1.Tile3DSubtreeLoader);
    const contentUrlTemplate = resolveUri(tileset.root.content.uri, basePath);
    const refine = tileset.root.refine;
    // @ts-ignore
    const rootLodMetricValue = tileset.root.geometricError;
    const rootBoundingVolume = tileset.root.boundingVolume;
    const options = {
        contentUrlTemplate,
        subtreesUriTemplate,
        subdivisionScheme,
        subtreeLevels,
        maximumLevel,
        refine,
        basePath,
        lodMetricType: tiles_1.LOD_METRIC_TYPE.GEOMETRIC_ERROR,
        rootLodMetricValue,
        rootBoundingVolume,
        getTileType,
        getRefine
    };
    return await normalizeImplicitTileData(tileset.root, rootSubtree, options);
}
exports.normalizeImplicitTileHeaders = normalizeImplicitTileHeaders;
/**
 * Do implicit data normalisation to create hierarchical tile structure
 * @param tile
 * @param rootSubtree
 * @param options
 * @returns
 */
async function normalizeImplicitTileData(tile, rootSubtree, options) {
    if (!tile) {
        return null;
    }
    tile.lodMetricType = tiles_1.LOD_METRIC_TYPE.GEOMETRIC_ERROR;
    tile.lodMetricValue = tile.geometricError;
    tile.transformMatrix = tile.transform;
    const { children, contentUrl } = await (0, parse_3d_implicit_tiles_1.parseImplicitTiles)({ subtree: rootSubtree, options });
    if (contentUrl) {
        tile.contentUrl = contentUrl;
        tile.content = { uri: contentUrl.replace(`${options.basePath}/`, '') };
    }
    tile.refine = getRefine(tile.refine);
    tile.type = getTileType(tile);
    tile.children = children;
    tile.id = tile.contentUrl;
    return tile;
}
exports.normalizeImplicitTileData = normalizeImplicitTileData;
