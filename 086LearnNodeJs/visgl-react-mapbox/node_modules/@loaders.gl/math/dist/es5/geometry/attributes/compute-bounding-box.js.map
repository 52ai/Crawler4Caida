{"version":3,"sources":["../../../../src/geometry/attributes/compute-bounding-box.ts"],"names":["computeBoundingBox","positions","min","Number","Infinity","max","position","x","y","z","boundingBox","validateBoundingBox","isFinite"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;AAcO,SAASA,kBAAT,GAAiD;AAAA,MAArBC,SAAqB,uEAAJ,EAAI;AACtD,MAAMC,GAAG,GAAG,CAACC,MAAM,CAACC,QAAD,CAAP,EAAmBD,MAAM,CAACC,QAAD,CAAzB,EAAqCD,MAAM,CAACC,QAAD,CAA3C,CAAZ;AACA,MAAMC,GAAG,GAAG,CAAC,CAACD,QAAF,EAAY,CAACA,QAAb,EAAuB,CAACA,QAAxB,CAAZ;;AAFsD,6CAI/B,8CAAsBH,SAAtB,CAJ+B;AAAA;;AAAA;AAItD,wDAAyD;AAAA,UAA9CK,QAA8C;AACvD,UAAMC,CAAC,GAAGD,QAAQ,CAAC,CAAD,CAAlB;AACA,UAAME,CAAC,GAAGF,QAAQ,CAAC,CAAD,CAAlB;AACA,UAAMG,CAAC,GAAGH,QAAQ,CAAC,CAAD,CAAlB;AAEA,UAAIC,CAAC,GAAGL,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASK,CAAT;AAChB,UAAIC,CAAC,GAAGN,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASM,CAAT;AAChB,UAAIC,CAAC,GAAGP,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASO,CAAT;AAEhB,UAAIF,CAAC,GAAGF,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASE,CAAT;AAChB,UAAIC,CAAC,GAAGH,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASG,CAAT;AAChB,UAAIC,CAAC,GAAGJ,GAAG,CAAC,CAAD,CAAX,EAAgBA,GAAG,CAAC,CAAD,CAAH,GAASI,CAAT;AACjB;AAhBqD;AAAA;AAAA;AAAA;AAAA;;AAkBtD,MAAMC,WAAW,GAAG;AAACR,IAAAA,GAAG,EAAHA,GAAD;AAAMG,IAAAA,GAAG,EAAHA;AAAN,GAApB;AACAM,EAAAA,mBAAmB,CAACD,WAAD,CAAnB;AACA,SAAOA,WAAP;AACD;;AAED,SAASC,mBAAT,CAA6BD,WAA7B,EAAuD;AACrD,sBACEP,MAAM,CAACS,QAAP,CAAgBF,WAAW,CAACR,GAAZ,CAAgB,CAAhB,CAAhB,KACEC,MAAM,CAACS,QAAP,CAAgBF,WAAW,CAACR,GAAZ,CAAgB,CAAhB,CAAhB,CADF,IAEEC,MAAM,CAACS,QAAP,CAAgBF,WAAW,CAACR,GAAZ,CAAgB,CAAhB,CAAhB,CAFF,IAGEC,MAAM,CAACS,QAAP,CAAgBF,WAAW,CAACL,GAAZ,CAAgB,CAAhB,CAAhB,CAHF,IAIEF,MAAM,CAACS,QAAP,CAAgBF,WAAW,CAACL,GAAZ,CAAgB,CAAhB,CAAhB,CAJF,IAKEF,MAAM,CAACS,QAAP,CAAgBF,WAAW,CAACL,GAAZ,CAAgB,CAAhB,CAAhB,CANJ;AAQD","sourcesContent":["import {makeAttributeIterator} from '../iterators/attribute-iterator';\nimport {assert} from '../utils/assert';\n\n/**\n * Type for Bounding Box computing\n */\ntype BoundingBox = {\n  min: number[];\n  max: number[];\n};\n/**\n * Getting bounding box geometry according to positions parameters\n * @param positions\n * @returns Bounding Box\n */\nexport function computeBoundingBox(positions: any = []) {\n  const min = [Number(Infinity), Number(Infinity), Number(Infinity)];\n  const max = [-Infinity, -Infinity, -Infinity];\n  // @ts-ignore\n  for (const position of makeAttributeIterator(positions)) {\n    const x = position[0];\n    const y = position[1];\n    const z = position[2];\n\n    if (x < min[0]) min[0] = x;\n    if (y < min[1]) min[1] = y;\n    if (z < min[2]) min[2] = z;\n\n    if (x > max[0]) max[0] = x;\n    if (y > max[1]) max[1] = y;\n    if (z > max[2]) max[2] = z;\n  }\n\n  const boundingBox = {min, max};\n  validateBoundingBox(boundingBox);\n  return boundingBox;\n}\n\nfunction validateBoundingBox(boundingBox: BoundingBox) {\n  assert(\n    Number.isFinite(boundingBox.min[0]) &&\n      Number.isFinite(boundingBox.min[1]) &&\n      Number.isFinite(boundingBox.min[2]) &&\n      Number.isFinite(boundingBox.max[0]) &&\n      Number.isFinite(boundingBox.max[1]) &&\n      Number.isFinite(boundingBox.max[2])\n  );\n}\n"],"file":"compute-bounding-box.js"}