{"version":3,"sources":["../../../../src/lib/worker-api/create-worker.ts"],"names":["AsyncQueue","WorkerBody","requestId","inputBatches","options","createWorker","process","processInBatches","inWorkerThread","context","processOnMainThread","onmessage","type","payload","Error","result","input","postMessage","resultIterator","batch","push","close","error","message","arrayBuffer","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener"],"mappings":"AAOA,OAAOA,UAAP,MAAuB,4BAAvB;AACA,OAAOC,UAAP,MAAuB,4BAAvB;AAIA,IAAIC,SAAS,GAAG,CAAhB;AACA,IAAIC,YAAJ;AACA,IAAIC,OAAJ;AAWA,OAAO,SAASC,YAAT,CAAsBC,OAAtB,EAAwCC,gBAAxC,EAAmF;AACxF,MAAI,CAACN,UAAU,CAACO,cAAX,EAAL,EAAkC;AAChC;AACD;;AAED,QAAMC,OAAsB,GAAG;AAC7BH,IAAAA,OAAO,EAAEI;AADoB,GAA/B;;AAKAT,EAAAA,UAAU,CAACU,SAAX,GAAuB,OAAOC,IAAP,EAAgCC,OAAhC,KAAkE;AACvF,QAAI;AACF,cAAQD,IAAR;AACE,aAAK,SAAL;AACE,cAAI,CAACN,OAAL,EAAc;AACZ,kBAAM,IAAIQ,KAAJ,CAAU,2CAAV,CAAN;AACD;;AACD,gBAAMC,MAAM,GAAG,MAAMT,OAAO,CAACO,OAAO,CAACG,KAAT,EAAgBH,OAAO,CAACT,OAAR,IAAmB,EAAnC,EAAuCK,OAAvC,CAA5B;AACAR,UAAAA,UAAU,CAACgB,WAAX,CAAuB,MAAvB,EAA+B;AAACF,YAAAA;AAAD,WAA/B;AACA;;AAEF,aAAK,oBAAL;AACE,cAAI,CAACR,gBAAL,EAAuB;AACrB,kBAAM,IAAIO,KAAJ,CAAU,4CAAV,CAAN;AACD;;AACDX,UAAAA,YAAY,GAAG,IAAIH,UAAJ,EAAf;AACAI,UAAAA,OAAO,GAAGS,OAAO,CAACT,OAAR,IAAmB,EAA7B;AACA,gBAAMc,cAAc,GAAGX,gBAAgB,CAACJ,YAAD,EAAeC,OAAf,EAAwBK,OAAxB,CAAvC;;AACA,qBAAW,MAAMU,KAAjB,IAA0BD,cAA1B,EAA0C;AACxCjB,YAAAA,UAAU,CAACgB,WAAX,CAAuB,cAAvB,EAAuC;AAACF,cAAAA,MAAM,EAAEI;AAAT,aAAvC;AACD;;AACDlB,UAAAA,UAAU,CAACgB,WAAX,CAAuB,MAAvB,EAA+B,EAA/B;AACA;;AAEF,aAAK,aAAL;AACEd,UAAAA,YAAY,CAACiB,IAAb,CAAkBP,OAAO,CAACG,KAA1B;AACA;;AAEF,aAAK,YAAL;AACEb,UAAAA,YAAY,CAACkB,KAAb;AACA;;AAEF;AA9BF;AAgCD,KAjCD,CAiCE,OAAOC,KAAP,EAAc;AACd,YAAMC,OAAO,GAAGD,KAAK,YAAYR,KAAjB,GAAyBQ,KAAK,CAACC,OAA/B,GAAyC,EAAzD;AACAtB,MAAAA,UAAU,CAACgB,WAAX,CAAuB,OAAvB,EAAgC;AAACK,QAAAA,KAAK,EAAEC;AAAR,OAAhC;AACD;AACF,GAtCD;AAuCD;;AAED,SAASb,mBAAT,CAA6Bc,WAA7B,EAAuDpB,OAAO,GAAG,EAAjE,EAAqE;AACnE,SAAO,IAAIqB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAMC,EAAE,GAAG1B,SAAS,EAApB;;AAIA,UAAM2B,SAAS,GAAG,CAACjB,IAAD,EAAeC,OAAf,KAAiD;AACjE,UAAIA,OAAO,CAACe,EAAR,KAAeA,EAAnB,EAAuB;AAErB;AACD;;AAED,cAAQhB,IAAR;AACE,aAAK,MAAL;AACEX,UAAAA,UAAU,CAAC6B,mBAAX,CAA+BD,SAA/B;AACAH,UAAAA,OAAO,CAACb,OAAO,CAACE,MAAT,CAAP;AACA;;AAEF,aAAK,OAAL;AACEd,UAAAA,UAAU,CAAC6B,mBAAX,CAA+BD,SAA/B;AACAF,UAAAA,MAAM,CAACd,OAAO,CAACS,KAAT,CAAN;AACA;;AAEF;AAXF;AAcD,KApBD;;AAsBArB,IAAAA,UAAU,CAAC8B,gBAAX,CAA4BF,SAA5B;AAGA,UAAMhB,OAAO,GAAG;AAACe,MAAAA,EAAD;AAAKZ,MAAAA,KAAK,EAAEQ,WAAZ;AAAyBpB,MAAAA;AAAzB,KAAhB;AACAH,IAAAA,UAAU,CAACgB,WAAX,CAAuB,SAAvB,EAAkCJ,OAAlC;AACD,GAhCM,CAAP;AAiCD","sourcesContent":["import type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches: AsyncQueue<any>;\nlet options: {[key: string]: any};\n\nexport type ProcessOnMainThread = (\n  data: any,\n  options?: {[key: string]: any},\n  context?: WorkerContext\n) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport function createWorker(process: Process, processInBatches?: ProcessInBatches): void {\n  if (!WorkerBody.inWorkerThread()) {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue<any>();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer: ArrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type: string, payload: WorkerMessagePayload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n"],"file":"create-worker.js"}