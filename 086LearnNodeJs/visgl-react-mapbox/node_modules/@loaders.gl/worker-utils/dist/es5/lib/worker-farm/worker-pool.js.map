{"version":3,"sources":["../../../../src/lib/worker-farm/worker-pool.ts"],"names":["WorkerPool","props","source","url","setProps","idleQueue","forEach","worker","destroy","isDestroyed","name","undefined","maxConcurrency","maxMobileConcurrency","reuseWorkers","onDebug","onMessage","job","type","data","done","onError","error","startPromise","Promise","onStart","jobQueue","push","_startQueuedJob","length","workerThread","_getAvailableWorker","queuedJob","shift","message","backlog","WorkerJob","payload","result","returnWorkerToQueue","shouldDestroyWorker","count","_getMaxConcurrency","toLowerCase","WorkerThread","isMobile","isSupported"],"mappings":"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","sourcesContent":["import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {isMobile} from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\n/** WorkerPool onDebug Callback Parameters */\ntype OnDebugParameters = {\n  message: string;\n  worker: string;\n  name: string;\n  job: string;\n  backlog: number;\n  workerThread: WorkerThread;\n};\n\n/** WorkerPool Properties */\nexport type WorkerPoolProps = {\n  name?: string;\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  onDebug?: (options: OnDebugParameters) => any;\n  reuseWorkers?: boolean;\n};\n\n/** Private helper types */\ntype OnMessage = (job: WorkerJob, type: WorkerMessageType, payload: WorkerMessagePayload) => void;\ntype OnError = (job: WorkerJob, error: Error) => void;\n\ntype QueuedJob = {\n  name: string;\n  onMessage: OnMessage;\n  onError: OnError;\n  onStart: (value: any) => void; // Resolve job start promise\n};\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name: string = 'unnamed';\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency: number = 1;\n  maxMobileConcurrency: number = 1;\n  onDebug: (options: OnDebugParameters) => any = () => {};\n  reuseWorkers: boolean = true;\n\n  private props: WorkerPoolProps = {};\n  private jobQueue: QueuedJob[] = [];\n  private idleQueue: WorkerThread[] = [];\n  private count = 0;\n  private isDestroyed = false;\n\n  /** Checks if workers are supported on this platform */\n  static isSupported(): boolean {\n    return WorkerThread.isSupported();\n  }\n\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props: WorkerPoolProps) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach((worker) => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props: WorkerPoolProps) {\n    this.props = {...this.props, ...props};\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(\n    name: string,\n    onMessage: OnMessage = (job, type, data) => job.done(data),\n    onError: OnError = (job, error) => job.error(error)\n  ): Promise<WorkerJob> {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise<WorkerJob>((onStart) => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({name, onMessage, onError, onStart});\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob(): Promise<void> {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      // Set the worker thread's message handlers\n      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = (error) => queuedJob.onError(job, error);\n\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker: WorkerThread) {\n    const shouldDestroyWorker =\n      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker(): WorkerThread | null {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({name, source: this.source, url: this.url});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n"],"file":"worker-pool.js"}