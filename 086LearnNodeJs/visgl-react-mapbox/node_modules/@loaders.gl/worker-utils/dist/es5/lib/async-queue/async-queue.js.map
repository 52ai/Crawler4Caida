{"version":3,"sources":["../../../../src/lib/async-queue/async-queue.ts"],"names":["Symbol","asyncIterator","AsyncQueue","_values","_settlers","_closed","value","enqueue","Error","length","settler","shift","reject","resolve","push","done","Promise","undefined"],"mappings":";;;;;;;;;;;;;;;;;wBA2BGA,MAAM,CAACC,a;;IAZWC,U;AAKnB,wBAAc;AAAA;AAAA;AAAA;AAAA;AACZ,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,SAAKC,OAAL,GAAe,KAAf;AACD;;;;WAGD,iBAA2C;AACzC,aAAO,IAAP;AACD;;;WAGD,cAAKC,KAAL,EAAqB;AACnB,aAAO,KAAKC,OAAL,CAAaD,KAAb,CAAP;AACD;;;WAMD,iBAAQA,KAAR,EAAgC;AAC9B,UAAI,KAAKD,OAAT,EAAkB;AAChB,cAAM,IAAIG,KAAJ,CAAU,QAAV,CAAN;AACD;;AAED,UAAI,KAAKJ,SAAL,CAAeK,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,YAAI,KAAKN,OAAL,CAAaM,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,gBAAM,IAAID,KAAJ,CAAU,wBAAV,CAAN;AACD;;AACD,YAAME,OAAO,GAAG,KAAKN,SAAL,CAAeO,KAAf,EAAhB;;AACA,YAAIL,KAAK,YAAYE,KAArB,EAA4B;AAC1BE,UAAAA,OAAO,CAACE,MAAR,CAAeN,KAAf;AACD,SAFD,MAEO;AACLI,UAAAA,OAAO,CAACG,OAAR,CAAgB;AAACP,YAAAA,KAAK,EAALA;AAAD,WAAhB;AACD;AACF,OAVD,MAUO;AACL,aAAKH,OAAL,CAAaW,IAAb,CAAkBR,KAAlB;AACD;AACF;;;WAGD,iBAAc;AACZ,aAAO,KAAKF,SAAL,CAAeK,MAAf,GAAwB,CAA/B,EAAkC;AAChC,YAAMC,OAAO,GAAG,KAAKN,SAAL,CAAeO,KAAf,EAAhB;;AACAD,QAAAA,OAAO,CAACG,OAAR,CAAgB;AAACE,UAAAA,IAAI,EAAE;AAAP,SAAhB;AACD;;AACD,WAAKV,OAAL,GAAe,IAAf;AACD;;;WAKD,gBAAwC;AAAA;;AAEtC,UAAI,KAAKF,OAAL,CAAaM,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,YAAMH,KAAK,GAAG,KAAKH,OAAL,CAAaQ,KAAb,EAAd;;AACA,YAAIL,KAAK,YAAYE,KAArB,EAA4B;AAC1B,iBAAOQ,OAAO,CAACJ,MAAR,CAAeN,KAAf,CAAP;AACD;;AACD,eAAOU,OAAO,CAACH,OAAR,CAAgB;AAACE,UAAAA,IAAI,EAAE,KAAP;AAAcT,UAAAA,KAAK,EAALA;AAAd,SAAhB,CAAP;AACD;;AAGD,UAAI,KAAKD,OAAT,EAAkB;AAChB,YAAI,KAAKD,SAAL,CAAeK,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,gBAAM,IAAID,KAAJ,CAAU,wBAAV,CAAN;AACD;;AACD,eAAOQ,OAAO,CAACH,OAAR,CAAgB;AAACE,UAAAA,IAAI,EAAE,IAAP;AAAaT,UAAAA,KAAK,EAAEW;AAApB,SAAhB,CAAP;AACD;;AAGD,aAAO,IAAID,OAAJ,CAAY,UAACH,OAAD,EAAUD,MAAV,EAAqB;AACtC,QAAA,KAAI,CAACR,SAAL,CAAeU,IAAf,CAAoB;AAACD,UAAAA,OAAO,EAAPA,OAAD;AAAUD,UAAAA,MAAM,EAANA;AAAV,SAApB;AACD,OAFM,CAAP;AAGD","sourcesContent":["// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\n/**\n * Async Queue\n * - AsyncIterable: An async iterator can be\n * - Values can be pushed onto the queue\n * @example\n *   const asyncQueue = new AsyncQueue();\n *   setTimeout(() => asyncQueue.enqueue('tick'), 1000);\n *   setTimeout(() => asyncQueue.enqueue(new Error('done')), 10000);\n *   for await (const value of asyncQueue) {\n *     console.log(value); // tick\n *   }\n */\nexport default class AsyncQueue<T> {\n  private _values: any[];\n  private _settlers: any[];\n  private _closed: boolean;\n\n  constructor() {\n    this._values = []; // enqueues > dequeues\n    this._settlers = []; // dequeues > enqueues\n    this._closed = false;\n  }\n\n  /** Return an async iterator for this queue */\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  /** Push a new value - the async iterator will yield a promise resolved to this value */\n  push(value: T): void {\n    return this.enqueue(value);\n  }\n\n  /**\n   * Push a new value - the async iterator will yield a promise resolved to this value\n   * Add an error - the async iterator will yield a promise rejected with this value\n   */\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.shift();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.push(value);\n    }\n  }\n\n  /** Indicate that we not waiting for more values - The async iterator will be done */\n  close(): void {\n    while (this._settlers.length > 0) {\n      const settler = this._settlers.shift();\n      settler.resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  // ITERATOR IMPLEMENTATION\n\n  /** @returns a Promise for an IteratorResult */\n  next(): Promise<IteratorResult<T, any>> {\n    // If values in queue, yield the first value\n    if (this._values.length > 0) {\n      const value = this._values.shift();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({done: false, value});\n    }\n\n    // If queue is closed, the iterator is done\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true, value: undefined});\n    }\n\n    // Yield a promise that waits for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.push({resolve, reject});\n    });\n  }\n}\n"],"file":"async-queue.js"}