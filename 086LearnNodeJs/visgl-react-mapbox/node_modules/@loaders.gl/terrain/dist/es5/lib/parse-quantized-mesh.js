"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadQuantizedMesh;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _schema = require("@loaders.gl/schema");

var _decodeQuantizedMesh = _interopRequireWildcard(require("./decode-quantized-mesh"));

var _skirt = require("./helpers/skirt");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function getMeshAttributes(vertexData, header, bounds) {
  var minHeight = header.minHeight,
      maxHeight = header.maxHeight;

  var _ref = bounds || [0, 0, 1, 1],
      _ref2 = (0, _slicedToArray2.default)(_ref, 4),
      minX = _ref2[0],
      minY = _ref2[1],
      maxX = _ref2[2],
      maxY = _ref2[3];

  var xScale = maxX - minX;
  var yScale = maxY - minY;
  var zScale = maxHeight - minHeight;
  var nCoords = vertexData.length / 3;
  var positions = new Float32Array(nCoords * 3);
  var texCoords = new Float32Array(nCoords * 2);

  for (var i = 0; i < nCoords; i++) {
    var x = vertexData[i] / 32767;
    var y = vertexData[i + nCoords] / 32767;
    var z = vertexData[i + nCoords * 2] / 32767;
    positions[3 * i + 0] = x * xScale + minX;
    positions[3 * i + 1] = y * yScale + minY;
    positions[3 * i + 2] = z * zScale + minHeight;
    texCoords[2 * i + 0] = x;
    texCoords[2 * i + 1] = y;
  }

  return {
    POSITION: {
      value: positions,
      size: 3
    },
    TEXCOORD_0: {
      value: texCoords,
      size: 2
    }
  };
}

function getTileMesh(arrayBuffer, options) {
  if (!arrayBuffer) {
    return null;
  }

  var bounds = options.bounds;

  var _decode = (0, _decodeQuantizedMesh.default)(arrayBuffer, _decodeQuantizedMesh.DECODING_STEPS.triangleIndices),
      header = _decode.header,
      vertexData = _decode.vertexData,
      originalTriangleIndices = _decode.triangleIndices,
      westIndices = _decode.westIndices,
      northIndices = _decode.northIndices,
      eastIndices = _decode.eastIndices,
      southIndices = _decode.southIndices;

  var triangleIndices = originalTriangleIndices;
  var attributes = getMeshAttributes(vertexData, header, bounds);
  var boundingBox = (0, _schema.getMeshBoundingBox)(attributes);

  if (options.skirtHeight) {
    var _addSkirt = (0, _skirt.addSkirt)(attributes, triangleIndices, options.skirtHeight, {
      westIndices: westIndices,
      northIndices: northIndices,
      eastIndices: eastIndices,
      southIndices: southIndices
    }),
        newAttributes = _addSkirt.attributes,
        newTriangles = _addSkirt.triangles;

    attributes = newAttributes;
    triangleIndices = newTriangles;
  }

  return {
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: triangleIndices.length,
      boundingBox: boundingBox
    },
    mode: 4,
    indices: {
      value: triangleIndices,
      size: 1
    },
    attributes: attributes
  };
}

function loadQuantizedMesh(arrayBuffer, options) {
  return getTileMesh(arrayBuffer, options['quantized-mesh']);
}
//# sourceMappingURL=parse-quantized-mesh.js.map