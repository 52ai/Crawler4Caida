{"version":3,"sources":["../../../../../src/lib/extensions/deprecated/KHR_techniques_webgl.ts"],"names":["KHR_TECHNIQUES_WEBGL","name","decode","gltfData","gltfScenegraph","GLTFScenegraph","json","extension","getExtension","techniques","resolveTechniques","materials","material","materialExtension","getObjectExtension","technique","Object","assign","values","resolveValues","removeObjectExtension","removeExtension","encode","options","techniquesExtension","programs","shaders","textDecoder","TextDecoder","forEach","shader","Number","isFinite","bufferView","code","getTypedArrayForBufferView","Error","program","fragmentShader","vertexShader","keys","uniforms","uniform","value","index","undefined","texture","getTexture"],"mappings":"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","sourcesContent":["// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\nexport const name = KHR_TECHNIQUES_WEBGL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n"],"file":"KHR_techniques_webgl.js"}