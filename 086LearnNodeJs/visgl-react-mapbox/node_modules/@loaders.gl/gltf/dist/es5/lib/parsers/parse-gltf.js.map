{"version":3,"sources":["../../../../src/lib/parsers/parse-gltf.ts"],"names":["isGLTF","arrayBuffer","options","byteOffset","parseGLTF","gltf","arrayBufferOrString","context","parseGLTFContainerSync","normalize","promises","loadBuffers","json","buffers","loadImages","promise","push","Promise","all","postProcess","data","uri","baseUri","ArrayBuffer","textDecoder","TextDecoder","decode","glb","type","_glb","Array","length","fill","header","hasBinChunk","binChunks","byteLength","images","i","buffer","fetch","response","imageIndices","getReferencesImageIndices","imageIndex","loadImage","Set","textures","texture","source","undefined","add","from","sort","image","index","parse","Number","isFinite","bufferView","array","ImageLoader","BasisLoader","mimeType","basis","format","parsedImage","compressed","mipmaps","width","height"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {BasisLoader, selectSupportedBasisFormat} from '@loaders.gl/textures';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport type {GLB} from '../types/glb-types';\nimport type {GLTFWithBuffers} from '../types/gltf-types';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {preprocessExtensions, decodeExtensions} from '../api/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  normalize?: boolean;\n  loadImages?: boolean;\n  loadBuffers?: boolean;\n  decompressMeshes?: boolean;\n  postProcess?: boolean;\n  excludeExtensions?: string[];\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf: GLTFWithBuffers,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  preprocessExtensions(gltf, options, context);\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  // TODO\n  const buffers = gltf.json.buffers || [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    } else if (gltf.buffers[i] === null) {\n      gltf.buffers[i] = {\n        arrayBuffer: new ArrayBuffer(buffer.byteLength),\n        byteOffset: 0,\n        byteLength: buffer.byteLength\n      };\n    }\n  }\n}\n\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  const imageIndices = getReferencesImageIndices(gltf);\n\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf: GLTFWithBuffers): number[] {\n  const imageIndices = new Set<number>();\n\n  const textures = gltf.json.textures || [];\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n\n  return Array.from(imageIndices).sort();\n}\n\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(\n  gltf: GLTFWithBuffers,\n  image,\n  index: number,\n  options,\n  context: LoaderContext\n) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  let parsedImage = await parse(\n    arrayBuffer,\n    [ImageLoader, BasisLoader],\n    {mimeType: image.mimeType, basis: options.basis || {format: selectSupportedBasisFormat()}},\n    context\n  );\n\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage[0]\n    };\n  }\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  // Store the loaded image\n  gltf.images = gltf.images || [];\n  gltf.images[index] = parsedImage;\n}\n"],"file":"parse-gltf.js"}