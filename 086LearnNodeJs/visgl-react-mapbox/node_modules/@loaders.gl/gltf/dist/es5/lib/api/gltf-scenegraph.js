"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _images = require("@loaders.gl/images");

var _loaderUtils = require("@loaders.gl/loader-utils");

var _assert = require("../utils/assert");

var _gltfUtils = require("../gltf-utils/gltf-utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_GLTF_JSON = {
  asset: {
    version: '2.0',
    generator: 'loaders.gl'
  },
  buffers: []
};

var GLTFScenegraph = function () {
  function GLTFScenegraph(gltf) {
    (0, _classCallCheck2.default)(this, GLTFScenegraph);
    (0, _defineProperty2.default)(this, "gltf", void 0);
    (0, _defineProperty2.default)(this, "sourceBuffers", void 0);
    (0, _defineProperty2.default)(this, "byteLength", void 0);
    this.gltf = gltf || {
      json: _objectSpread({}, DEFAULT_GLTF_JSON),
      buffers: []
    };
    this.sourceBuffers = [];
    this.byteLength = 0;

    if (this.gltf.buffers && this.gltf.buffers[0]) {
      this.byteLength = this.gltf.buffers[0].byteLength;
      this.sourceBuffers = [this.gltf.buffers[0]];
    }
  }

  (0, _createClass2.default)(GLTFScenegraph, [{
    key: "json",
    get: function get() {
      return this.gltf.json;
    }
  }, {
    key: "getApplicationData",
    value: function getApplicationData(key) {
      var data = this.json[key];
      return data;
    }
  }, {
    key: "getExtraData",
    value: function getExtraData(key) {
      var extras = this.json.extras || {};
      return extras[key];
    }
  }, {
    key: "getExtension",
    value: function getExtension(extensionName) {
      var isExtension = this.getUsedExtensions().find(function (name) {
        return name === extensionName;
      });
      var extensions = this.json.extensions || {};
      return isExtension ? extensions[extensionName] || true : null;
    }
  }, {
    key: "getRequiredExtension",
    value: function getRequiredExtension(extensionName) {
      var isRequired = this.getRequiredExtensions().find(function (name) {
        return name === extensionName;
      });
      return isRequired ? this.getExtension(extensionName) : null;
    }
  }, {
    key: "getRequiredExtensions",
    value: function getRequiredExtensions() {
      return this.json.extensionsRequired || [];
    }
  }, {
    key: "getUsedExtensions",
    value: function getUsedExtensions() {
      return this.json.extensionsUsed || [];
    }
  }, {
    key: "getObjectExtension",
    value: function getObjectExtension(object, extensionName) {
      var extensions = object.extensions || {};
      return extensions[extensionName];
    }
  }, {
    key: "getScene",
    value: function getScene(index) {
      return this.getObject('scenes', index);
    }
  }, {
    key: "getNode",
    value: function getNode(index) {
      return this.getObject('nodes', index);
    }
  }, {
    key: "getSkin",
    value: function getSkin(index) {
      return this.getObject('skins', index);
    }
  }, {
    key: "getMesh",
    value: function getMesh(index) {
      return this.getObject('meshes', index);
    }
  }, {
    key: "getMaterial",
    value: function getMaterial(index) {
      return this.getObject('materials', index);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor(index) {
      return this.getObject('accessors', index);
    }
  }, {
    key: "getTexture",
    value: function getTexture(index) {
      return this.getObject('textures', index);
    }
  }, {
    key: "getSampler",
    value: function getSampler(index) {
      return this.getObject('samplers', index);
    }
  }, {
    key: "getImage",
    value: function getImage(index) {
      return this.getObject('images', index);
    }
  }, {
    key: "getBufferView",
    value: function getBufferView(index) {
      return this.getObject('bufferViews', index);
    }
  }, {
    key: "getBuffer",
    value: function getBuffer(index) {
      return this.getObject('buffers', index);
    }
  }, {
    key: "getObject",
    value: function getObject(array, index) {
      if ((0, _typeof2.default)(index) === 'object') {
        return index;
      }

      var object = this.json[array] && this.json[array][index];

      if (!object) {
        throw new Error("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }

      return object;
    }
  }, {
    key: "getTypedArrayForBufferView",
    value: function getTypedArrayForBufferView(bufferView) {
      bufferView = this.getBufferView(bufferView);
      var bufferIndex = bufferView.buffer;
      var binChunk = this.gltf.buffers[bufferIndex];
      (0, _assert.assert)(binChunk);
      var byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
      return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
    }
  }, {
    key: "getTypedArrayForAccessor",
    value: function getTypedArrayForAccessor(accessor) {
      accessor = this.getAccessor(accessor);
      var bufferView = this.getBufferView(accessor.bufferView);
      var buffer = this.getBuffer(bufferView.buffer);
      var arrayBuffer = buffer.data;

      var _getAccessorArrayType = (0, _gltfUtils.getAccessorArrayTypeAndLength)(accessor, bufferView),
          ArrayType = _getAccessorArrayType.ArrayType,
          length = _getAccessorArrayType.length;

      var byteOffset = bufferView.byteOffset + accessor.byteOffset;
      return new ArrayType(arrayBuffer, byteOffset, length);
    }
  }, {
    key: "getTypedArrayForImageData",
    value: function getTypedArrayForImageData(image) {
      image = this.getAccessor(image);
      var bufferView = this.getBufferView(image.bufferView);
      var buffer = this.getBuffer(bufferView.buffer);
      var arrayBuffer = buffer.data;
      var byteOffset = bufferView.byteOffset || 0;
      return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
    }
  }, {
    key: "addApplicationData",
    value: function addApplicationData(key, data) {
      this.json[key] = data;
      return this;
    }
  }, {
    key: "addExtraData",
    value: function addExtraData(key, data) {
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = data;
      return this;
    }
  }, {
    key: "addObjectExtension",
    value: function addObjectExtension(object, extensionName, data) {
      object.extensions = object.extensions || {};
      object.extensions[extensionName] = data;
      this.registerUsedExtension(extensionName);
      return this;
    }
  }, {
    key: "setObjectExtension",
    value: function setObjectExtension(object, extensionName, data) {
      var extensions = object.extensions || {};
      extensions[extensionName] = data;
    }
  }, {
    key: "removeObjectExtension",
    value: function removeObjectExtension(object, extensionName) {
      var extensions = object.extensions || {};
      var extension = extensions[extensionName];
      delete extensions[extensionName];
      return extension;
    }
  }, {
    key: "addExtension",
    value: function addExtension(extensionName) {
      var extensionData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _assert.assert)(extensionData);
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = extensionData;
      this.registerUsedExtension(extensionName);
      return extensionData;
    }
  }, {
    key: "addRequiredExtension",
    value: function addRequiredExtension(extensionName) {
      var extensionData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _assert.assert)(extensionData);
      this.addExtension(extensionName, extensionData);
      this.registerRequiredExtension(extensionName);
      return extensionData;
    }
  }, {
    key: "registerUsedExtension",
    value: function registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];

      if (!this.json.extensionsUsed.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsUsed.push(extensionName);
      }
    }
  }, {
    key: "registerRequiredExtension",
    value: function registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];

      if (!this.json.extensionsRequired.find(function (ext) {
        return ext === extensionName;
      })) {
        this.json.extensionsRequired.push(extensionName);
      }
    }
  }, {
    key: "removeExtension",
    value: function removeExtension(extensionName) {
      if (this.json.extensionsRequired) {
        this._removeStringFromArray(this.json.extensionsRequired, extensionName);
      }

      if (this.json.extensionsUsed) {
        this._removeStringFromArray(this.json.extensionsUsed, extensionName);
      }

      if (this.json.extensions) {
        delete this.json.extensions[extensionName];
      }
    }
  }, {
    key: "setDefaultScene",
    value: function setDefaultScene(sceneIndex) {
      this.json.scene = sceneIndex;
    }
  }, {
    key: "addScene",
    value: function addScene(scene) {
      var nodeIndices = scene.nodeIndices;
      this.json.scenes = this.json.scenes || [];
      this.json.scenes.push({
        nodes: nodeIndices
      });
      return this.json.scenes.length - 1;
    }
  }, {
    key: "addNode",
    value: function addNode(node) {
      var meshIndex = node.meshIndex,
          matrix = node.matrix;
      this.json.nodes = this.json.nodes || [];
      var nodeData = {
        mesh: meshIndex
      };

      if (matrix) {
        nodeData.matrix = matrix;
      }

      this.json.nodes.push(nodeData);
      return this.json.nodes.length - 1;
    }
  }, {
    key: "addMesh",
    value: function addMesh(mesh) {
      var attributes = mesh.attributes,
          indices = mesh.indices,
          material = mesh.material,
          _mesh$mode = mesh.mode,
          mode = _mesh$mode === void 0 ? 4 : _mesh$mode;

      var accessors = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessors,
          mode: mode
        }]
      };

      if (indices) {
        var indicesAccessor = this._addIndices(indices);

        glTFMesh.primitives[0].indices = indicesAccessor;
      }

      if (Number.isFinite(material)) {
        glTFMesh.primitives[0].material = material;
      }

      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addPointCloud",
    value: function addPointCloud(attributes) {
      var accessorIndices = this._addAttributes(attributes);

      var glTFMesh = {
        primitives: [{
          attributes: accessorIndices,
          mode: 0
        }]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
  }, {
    key: "addImage",
    value: function addImage(imageData, mimeTypeOpt) {
      var metadata = (0, _images.getBinaryImageMetadata)(imageData);
      var mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);
      var bufferViewIndex = this.addBufferView(imageData);
      var glTFImage = {
        bufferView: bufferViewIndex,
        mimeType: mimeType
      };
      this.json.images = this.json.images || [];
      this.json.images.push(glTFImage);
      return this.json.images.length - 1;
    }
  }, {
    key: "addBufferView",
    value: function addBufferView(buffer) {
      var byteLength = buffer.byteLength;
      (0, _assert.assert)(Number.isFinite(byteLength));
      this.sourceBuffers = this.sourceBuffers || [];
      this.sourceBuffers.push(buffer);
      var glTFBufferView = {
        buffer: 0,
        byteOffset: this.byteLength,
        byteLength: byteLength
      };
      this.byteLength += (0, _loaderUtils.padToNBytes)(byteLength, 4);
      this.json.bufferViews = this.json.bufferViews || [];
      this.json.bufferViews.push(glTFBufferView);
      return this.json.bufferViews.length - 1;
    }
  }, {
    key: "addAccessor",
    value: function addAccessor(bufferViewIndex, accessor) {
      var glTFAccessor = {
        bufferView: bufferViewIndex,
        type: (0, _gltfUtils.getAccessorTypeFromSize)(accessor.size),
        componentType: accessor.componentType,
        count: accessor.count,
        max: accessor.max,
        min: accessor.min
      };
      this.json.accessors = this.json.accessors || [];
      this.json.accessors.push(glTFAccessor);
      return this.json.accessors.length - 1;
    }
  }, {
    key: "addBinaryBuffer",
    value: function addBinaryBuffer(sourceBuffer) {
      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        size: 3
      };
      var bufferViewIndex = this.addBufferView(sourceBuffer);
      var minMax = {
        min: accessor.min,
        max: accessor.max
      };

      if (!minMax.min || !minMax.max) {
        minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
      }

      var accessorDefaults = {
        size: accessor.size,
        componentType: (0, _gltfUtils.getComponentTypeFromArray)(sourceBuffer),
        count: Math.round(sourceBuffer.length / accessor.size),
        min: minMax.min,
        max: minMax.max
      };
      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
    }
  }, {
    key: "addTexture",
    value: function addTexture(texture) {
      var imageIndex = texture.imageIndex;
      var glTFTexture = {
        source: imageIndex
      };
      this.json.textures = this.json.textures || [];
      this.json.textures.push(glTFTexture);
      return this.json.textures.length - 1;
    }
  }, {
    key: "addMaterial",
    value: function addMaterial(pbrMaterialInfo) {
      this.json.materials = this.json.materials || [];
      this.json.materials.push(pbrMaterialInfo);
      return this.json.materials.length - 1;
    }
  }, {
    key: "createBinaryChunk",
    value: function createBinaryChunk() {
      var _this$json, _this$json$buffers;

      this.gltf.buffers = [];
      var totalByteLength = this.byteLength;
      var arrayBuffer = new ArrayBuffer(totalByteLength);
      var targetArray = new Uint8Array(arrayBuffer);
      var dstByteOffset = 0;

      var _iterator = _createForOfIteratorHelper(this.sourceBuffers || []),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var sourceBuffer = _step.value;
          dstByteOffset = (0, _loaderUtils.copyToArray)(sourceBuffer, targetArray, dstByteOffset);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {
        this.json.buffers[0].byteLength = totalByteLength;
      } else {
        this.json.buffers = [{
          byteLength: totalByteLength
        }];
      }

      this.gltf.binary = arrayBuffer;
      this.sourceBuffers = [arrayBuffer];
    }
  }, {
    key: "_removeStringFromArray",
    value: function _removeStringFromArray(array, string) {
      var found = true;

      while (found) {
        var index = array.indexOf(string);

        if (index > -1) {
          array.splice(index, 1);
        } else {
          found = false;
        }
      }
    }
  }, {
    key: "_addAttributes",
    value: function _addAttributes() {
      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var result = {};

      for (var attributeKey in attributes) {
        var attributeData = attributes[attributeKey];

        var attrName = this._getGltfAttributeName(attributeKey);

        var accessor = this.addBinaryBuffer(attributeData.value, attributeData);
        result[attrName] = accessor;
      }

      return result;
    }
  }, {
    key: "_addIndices",
    value: function _addIndices(indices) {
      return this.addBinaryBuffer(indices, {
        size: 1
      });
    }
  }, {
    key: "_getGltfAttributeName",
    value: function _getGltfAttributeName(attributeName) {
      switch (attributeName.toLowerCase()) {
        case 'position':
        case 'positions':
        case 'vertices':
          return 'POSITION';

        case 'normal':
        case 'normals':
          return 'NORMAL';

        case 'color':
        case 'colors':
          return 'COLOR_0';

        case 'texcoord':
        case 'texcoords':
          return 'TEXCOORD_0';

        default:
          return attributeName;
      }
    }
  }, {
    key: "_getAccessorMinMax",
    value: function _getAccessorMinMax(buffer, size) {
      var result = {
        min: null,
        max: null
      };

      if (buffer.length < size) {
        return result;
      }

      result.min = [];
      result.max = [];
      var initValues = buffer.subarray(0, size);

      var _iterator2 = _createForOfIteratorHelper(initValues),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var value = _step2.value;
          result.min.push(value);
          result.max.push(value);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      for (var index = size; index < buffer.length; index += size) {
        for (var componentIndex = 0; componentIndex < size; componentIndex++) {
          result.min[0 + componentIndex] = Math.min(result.min[0 + componentIndex], buffer[index + componentIndex]);
          result.max[0 + componentIndex] = Math.max(result.max[0 + componentIndex], buffer[index + componentIndex]);
        }
      }

      return result;
    }
  }]);
  return GLTFScenegraph;
}();

exports.default = GLTFScenegraph;
//# sourceMappingURL=gltf-scenegraph.js.map