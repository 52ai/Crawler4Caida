{"version":3,"sources":["../../../../src/lib/worker-loader-utils/parse-with-worker.ts"],"names":["canParseWithWorker","loader","options","WorkerFarm","isSupported","isBrowser","_nodeWorkers","worker","parseWithWorker","data","context","parseOnMainThread","name","id","url","workerFarm","getWorkerFarm","workerPool","getWorkerPool","JSON","parse","stringify","startJob","onMessage","bind","job","postMessage","input","result","type","payload","done","error","Error","message","console","warn"],"mappings":"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","sourcesContent":["import {\n  WorkerJob,\n  WorkerMessageType,\n  WorkerMessagePayload,\n  isBrowser\n} from '@loaders.gl/worker-utils';\nimport type {Loader, LoaderOptions, LoaderContext} from '../../types';\nimport {WorkerFarm, getWorkerURL} from '@loaders.gl/worker-utils';\n\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canParseWithWorker(loader: Loader, options?: LoaderOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  // Node workers are still experimental\n  if (!isBrowser && !options?._nodeWorkers) {\n    return false;\n  }\n\n  return loader.worker && options?.worker;\n}\n\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.\n */\nexport async function parseWithWorker(\n  loader: Loader,\n  data: any,\n  options?: LoaderOptions,\n  context?: LoaderContext,\n  parseOnMainThread?: (arrayBuffer: ArrayBuffer, options: {[key: string]: any}) => Promise<void>\n) {\n  const name = loader.id; // TODO\n  const url = getWorkerURL(loader, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  // options.log object contains functions which cannot be transferred\n  // context.fetch & context.parse functions cannot be transferred\n  // TODO - decide how to handle logging on workers\n  options = JSON.parse(JSON.stringify(options));\n  context = JSON.parse(JSON.stringify(context || {}));\n\n  const job = await workerPool.startJob(\n    'process-on-worker',\n    // @ts-expect-error\n    onMessage.bind(null, parseOnMainThread) // eslint-disable-line @typescript-eslint/no-misused-promises\n  );\n\n  job.postMessage('process', {\n    // @ts-ignore\n    input: data,\n    options,\n    context\n  });\n\n  const result = await job.result;\n  // TODO - what is going on here?\n  return await result.result;\n}\n\n/**\n * Handle worker's responses to the main thread\n * @param job\n * @param type\n * @param payload\n */\nasync function onMessage(\n  parseOnMainThread: (arrayBuffer: ArrayBuffer, options?: {[key: string]: any}) => Promise<void>,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n\n    case 'process':\n      // Worker is asking for main thread to parseO\n      const {id, input, options} = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`parse-with-worker unknown message ${type}`);\n  }\n}\n"],"file":"parse-with-worker.js"}