{"version":3,"sources":["../../../../src/lib/iterators/text-iterators.ts"],"names":["makeTextDecoderIterator","arrayBufferIterator","options","textDecoder","TextDecoder","undefined","arrayBuffer","decode","stream","makeTextEncoderIterator","textIterator","textEncoder","TextEncoder","text","encode","makeLineIterator","previous","textChunk","eolIndex","indexOf","line","slice","length","makeNumberedLineIterator","lineIterator","counter"],"mappings":"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","sourcesContent":["// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\n\nexport async function* makeTextDecoderIterator(\n  arrayBufferIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options: TextDecoderOptions = {}\n): AsyncIterable<string> {\n  const textDecoder = new TextDecoder(undefined, options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string'\n      ? arrayBuffer\n      : textDecoder.decode(arrayBuffer, {stream: true});\n  }\n}\n\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\n\nexport async function* makeTextEncoderIterator(\n  textIterator: AsyncIterable<string> | Iterable<ArrayBuffer>\n): AsyncIterable<ArrayBuffer> {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\n\nexport async function* makeLineIterator(\n  textIterator: AsyncIterable<string>\n): AsyncIterable<string> {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(\n  lineIterator: AsyncIterable<string>\n): AsyncIterable<{counter: number; line: string}> {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {counter, line};\n    counter++;\n  }\n}\n"],"file":"text-iterators.js"}