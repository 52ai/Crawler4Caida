{"version":3,"sources":["../../../../src/lib/binary-utils/binary-copy-utils.ts"],"names":["copyPaddedArrayBufferToDataView","dataView","byteOffset","sourceBuffer","padding","paddedLength","byteLength","padLength","targetArray","Uint8Array","buffer","sourceArray","set","i","setUint8","copyPaddedStringToDataView","string","textEncoder","TextEncoder","stringBuffer","encode"],"mappings":";;;;;;;;AACA;;AAYO,SAASA,+BAAT,CACLC,QADK,EAELC,UAFK,EAGLC,YAHK,EAILC,OAJK,EAKL;AACA,MAAMC,YAAY,GAAG,kCAAYF,YAAY,CAACG,UAAzB,EAAqCF,OAArC,CAArB;AACA,MAAMG,SAAS,GAAGF,YAAY,GAAGF,YAAY,CAACG,UAA9C;;AAEA,MAAIL,QAAJ,EAAc;AAEZ,QAAMO,WAAW,GAAG,IAAIC,UAAJ,CAClBR,QAAQ,CAACS,MADS,EAElBT,QAAQ,CAACC,UAAT,GAAsBA,UAFJ,EAGlBC,YAAY,CAACG,UAHK,CAApB;AAKA,QAAMK,WAAW,GAAG,IAAIF,UAAJ,CAAeN,YAAf,CAApB;AACAK,IAAAA,WAAW,CAACI,GAAZ,CAAgBD,WAAhB;;AAGA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,SAApB,EAA+B,EAAEM,CAAjC,EAAoC;AAElCZ,MAAAA,QAAQ,CAACa,QAAT,CAAkBZ,UAAU,GAAGC,YAAY,CAACG,UAA1B,GAAuCO,CAAzD,EAA4D,IAA5D;AACD;AACF;;AACDX,EAAAA,UAAU,IAAIG,YAAd;AACA,SAAOH,UAAP;AACD;;AAYM,SAASa,0BAAT,CACLd,QADK,EAELC,UAFK,EAGLc,MAHK,EAILZ,OAJK,EAKG;AACR,MAAMa,WAAW,GAAG,IAAIC,WAAJ,EAApB;AAGA,MAAMC,YAAY,GAAGF,WAAW,CAACG,MAAZ,CAAmBJ,MAAnB,CAArB;AAEAd,EAAAA,UAAU,GAAGF,+BAA+B,CAACC,QAAD,EAAWC,UAAX,EAAuBiB,YAAvB,EAAqCf,OAArC,CAA5C;AAEA,SAAOF,UAAP;AACD","sourcesContent":["import {TypedArray} from '../../types';\nimport {padToNBytes} from './memory-copy-utils';\n\n/**\n * Copy sourceBuffer to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {Array | TypedArray} sourceBuffer - source data buffer\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedArrayBufferToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  sourceBuffer: TypedArray,\n  padding: number\n) {\n  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(\n      dataView.buffer,\n      dataView.byteOffset + byteOffset,\n      sourceBuffer.byteLength\n    );\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n\n/**\n * Copy string to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {string} string - source string\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedStringToDataView(\n  dataView: DataView | null,\n  byteOffset: number,\n  string: string,\n  padding: number\n): number {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n\n  return byteOffset;\n}\n"],"file":"binary-copy-utils.js"}