"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deduceMeshSchema = deduceMeshSchema;
exports.deduceMeshField = deduceMeshField;
exports.makeMeshAttributeMetadata = makeMeshAttributeMetadata;

var _schema = require("../../lib/schema/schema");

var _arrowLikeTypeUtils = require("../../lib/arrow/arrow-like-type-utils");

function deduceMeshSchema(attributes, metadata) {
  var fields = deduceMeshFields(attributes);
  return new _schema.Schema(fields, metadata);
}

function deduceMeshField(attributeName, attribute, optionalMetadata) {
  var type = (0, _arrowLikeTypeUtils.getArrowTypeFromTypedArray)(attribute.value);
  var metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
  var field = new _schema.Field(attributeName, new _schema.FixedSizeList(attribute.size, new _schema.Field('value', type)), false, metadata);
  return field;
}

function deduceMeshFields(attributes) {
  var fields = [];

  for (var attributeName in attributes) {
    var attribute = attributes[attributeName];
    fields.push(deduceMeshField(attributeName, attribute));
  }

  return fields;
}

function makeMeshAttributeMetadata(attribute) {
  var result = new Map();

  if ('byteOffset' in attribute) {
    result.set('byteOffset', attribute.byteOffset.toString(10));
  }

  if ('byteStride' in attribute) {
    result.set('byteStride', attribute.byteStride.toString(10));
  }

  if ('normalized' in attribute) {
    result.set('normalized', attribute.normalized.toString());
  }

  return result;
}
//# sourceMappingURL=deduce-mesh-schema.js.map