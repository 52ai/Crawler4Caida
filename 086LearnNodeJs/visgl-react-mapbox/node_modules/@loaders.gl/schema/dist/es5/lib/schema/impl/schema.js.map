{"version":3,"sources":["../../../../../src/lib/schema/impl/schema.ts"],"names":["Schema","fields","metadata","Array","isArray","checkNames","Map","other","length","i","compareTo","nameMap","Object","create","columnNames","name","selectedFields","filter","field","columnIndices","map","index","Boolean","schemaOrFields","otherSchema","mergeMaps","fieldMap","mergedFields","values","usedNames","console","warn","m1","m2"],"mappings":"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","sourcesContent":["import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields: Field[]): void {\n  const usedNames: Record<string, boolean> = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n"],"file":"schema.js"}