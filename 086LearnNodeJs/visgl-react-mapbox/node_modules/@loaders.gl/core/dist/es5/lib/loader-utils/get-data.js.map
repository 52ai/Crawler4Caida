{"version":3,"sources":["../../../../src/lib/loader-utils/get-data.ts"],"names":["ERR_DATA","getArrayBufferOrStringFromDataSync","data","loader","options","text","buffer","ArrayBuffer","arrayBuffer","binary","textDecoder","TextDecoder","decode","isView","byteLength","length","byteOffset","slice","Error","getArrayBufferOrStringFromData","isArrayBuffer","response","getAsyncIterableFromData","body","Symbol","asyncIterator","getIterableFromData","getReadableStream","oneChunk","iterator"],"mappings":"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","sourcesContent":["import type {\n  DataType,\n  SyncDataType,\n  BatchableDataType,\n  Loader,\n  LoaderOptions\n} from '@loaders.gl/loader-utils';\nimport {concatenateArrayBuffersAsync} from '@loaders.gl/loader-utils';\nimport {\n  isResponse,\n  isReadableStream,\n  isAsyncIterable,\n  isIterable,\n  isIterator,\n  isBlob,\n  isBuffer\n} from '../../javascript-utils/is-type';\nimport {makeIterator} from '../../iterators/make-iterator/make-iterator';\nimport {checkResponse, makeResponse} from '../utils/response-utils';\n\nconst ERR_DATA = 'Cannot convert supplied data type';\n\n// eslint-disable-next-line complexity\nexport function getArrayBufferOrStringFromDataSync(\n  data: SyncDataType,\n  loader: Loader,\n  options: LoaderOptions\n): ArrayBuffer | string {\n  if (loader.text && typeof data === 'string') {\n    return data;\n  }\n\n  if (isBuffer(data)) {\n    // @ts-ignore\n    data = data.buffer;\n  }\n\n  if (data instanceof ArrayBuffer) {\n    const arrayBuffer = data;\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(arrayBuffer);\n    }\n    return arrayBuffer;\n  }\n\n  // We may need to handle offsets\n  if (ArrayBuffer.isView(data)) {\n    // TextDecoder is invoked on typed arrays and will handle offsets\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(data);\n    }\n\n    let arrayBuffer = data.buffer;\n\n    // Since we are returning the underlying arrayBuffer, we must create a new copy\n    // if this typed array / Buffer is a partial view into the ArryayBuffer\n    // TODO - this is a potentially unnecessary copy\n    const byteLength = data.byteLength || data.length;\n    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n      // console.warn(`loaders.gl copying arraybuffer of length ${byteLength}`);\n      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n    }\n    return arrayBuffer;\n  }\n\n  throw new Error(ERR_DATA);\n}\n\n// Convert async iterator to a promise\nexport async function getArrayBufferOrStringFromData(\n  data: DataType,\n  loader: Loader,\n  options: LoaderOptions\n): Promise<ArrayBuffer | string> {\n  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n  if (typeof data === 'string' || isArrayBuffer) {\n    return getArrayBufferOrStringFromDataSync(data as string | ArrayBuffer, loader, options);\n  }\n\n  // Blobs and files are FileReader compatible\n  if (isBlob(data)) {\n    data = await makeResponse(data);\n  }\n\n  if (isResponse(data)) {\n    const response = data as Response;\n    await checkResponse(response);\n    return loader.binary ? await response.arrayBuffer() : await response.text();\n  }\n\n  if (isReadableStream(data)) {\n    // @ts-expect-error TS2559 options type\n    data = makeIterator(data as ReadableStream, options);\n  }\n\n  if (isIterable(data) || isAsyncIterable(data)) {\n    // Assume arrayBuffer iterator - attempt to concatenate\n    return concatenateArrayBuffersAsync(data as AsyncIterable<ArrayBuffer>);\n  }\n\n  throw new Error(ERR_DATA);\n}\n\nexport async function getAsyncIterableFromData(\n  data: BatchableDataType,\n  options: LoaderOptions\n): Promise<AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>> {\n  if (isIterator(data)) {\n    return data as AsyncIterable<ArrayBuffer>;\n  }\n\n  if (isResponse(data)) {\n    const response = data as Response;\n    // Note Since this function is not async, we currently can't load error message, just status\n    await checkResponse(response);\n    // TODO - bug in polyfill, body can be a Promise under Node.js\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const body = await response.body;\n    // TODO - body can be null?\n    return makeIterator(body as ReadableStream<Uint8Array>, options as any);\n  }\n\n  if (isBlob(data) || isReadableStream(data)) {\n    return makeIterator(data as Blob | ReadableStream, options as any);\n  }\n\n  if (isAsyncIterable(data)) {\n    return data[Symbol.asyncIterator]();\n  }\n\n  return getIterableFromData(data);\n}\n\nexport async function getReadableStream(data: BatchableDataType): Promise<ReadableStream> {\n  if (isReadableStream(data)) {\n    return data as ReadableStream;\n  }\n  if (isResponse(data)) {\n    // @ts-ignore\n    return data.body;\n  }\n  const response = await makeResponse(data);\n  // @ts-ignore\n  return response.body;\n}\n\n// HELPERS\n\nfunction getIterableFromData(data) {\n  // generate an iterator that emits a single chunk\n  if (ArrayBuffer.isView(data)) {\n    return (function* oneChunk() {\n      yield data.buffer;\n    })();\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return (function* oneChunk() {\n      yield data;\n    })();\n  }\n\n  if (isIterator(data)) {\n    return data;\n  }\n\n  if (isIterable(data)) {\n    return data[Symbol.iterator]();\n  }\n\n  throw new Error(ERR_DATA);\n}\n"],"file":"get-data.js"}