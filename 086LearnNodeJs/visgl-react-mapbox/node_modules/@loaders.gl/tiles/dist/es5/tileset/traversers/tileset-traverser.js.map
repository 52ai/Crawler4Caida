{"version":3,"sources":["../../../../src/tileset/traversers/tileset-traverser.ts"],"names":["DEFAULT_PROPS","loadSiblings","skipLevelOfDetail","maximumScreenSpaceError","updateTransforms","onTraversalEnd","viewportTraversersMap","basePath","TilesetTraverser","options","Date","getTime","_traversalStack","ManagedArray","_emptyTraversalStack","_frameNumber","root","selectedTiles","requestedTiles","emptyTiles","frameState","reset","updateTile","frameNumber","executeTraversal","stack","_selectionDepth","push","length","tile","pop","shouldRefine","canTraverse","updateChildTiles","updateAndPushChildren","hasRenderContent","parent","parentRefines","Boolean","_shouldRefine","stoppedRefining","id","loadTile","selectTile","refine","TILE_REFINEMENT","ADD","REPLACE","touchTile","newTime","traversalFinished","lastUpdate","updateDebounceTime","children","child","depth","sort","compareDistanceToCamera","bind","checkRefines","hasVisibleChild","refines","isVisibleAndInRequestVolume","find","delete","childRefines","_inRequestVolume","executeEmptyTraversal","contentAvailable","updateTileVisibility","shouldSelectTile","_selectedFrame","shouldLoadTile","_requestedFrame","_priority","_getPriority","tileset","_cache","touch","_touchedFrame","useParentMetric","ignoreVisibility","hasChildren","hasTilesetContent","contentExpired","hasUnloadedContent","screenSpaceError","_screenSpaceError","getScreenSpaceError","viewportIds","key","value","viewport","updateVisibility","b","a","_distanceToCamera","anyVisible","allDescendantsLoaded","traverse"],"mappings":"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","sourcesContent":["import ManagedArray from '../../utils/managed-array';\nimport {TILE_REFINEMENT} from '../../constants';\nimport {FrameState} from '../helpers/frame-state';\n\nexport type TilesetTraverserProps = {\n  loadSiblings?: boolean;\n  skipLevelOfDetail?: boolean;\n  maximumScreenSpaceError?: number;\n  onTraversalEnd?: (frameState) => any;\n  viewportTraversersMap?: {[key: string]: any};\n  basePath?: string;\n};\n\nexport type Props = {\n  loadSiblings: boolean;\n  skipLevelOfDetail: boolean;\n  updateTransforms: boolean;\n  maximumScreenSpaceError: number;\n  onTraversalEnd: (frameState) => any;\n  viewportTraversersMap: {[key: string]: any};\n  basePath: string;\n};\n\nexport const DEFAULT_PROPS: Props = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\n\nexport default class TilesetTraverser {\n  options: Props;\n\n  root: any;\n  requestedTiles: object;\n  selectedTiles: object;\n  emptyTiles: object;\n\n  protected lastUpdate: number = new Date().getTime();\n  protected readonly updateDebounceTime = 1000;\n  protected _traversalStack: ManagedArray;\n  protected _emptyTraversalStack: ManagedArray;\n  protected _frameNumber: number | null;\n\n  protected traversalFinished(frameState: FrameState): boolean {\n    return true;\n  }\n\n  // TODO nested props\n  constructor(options: TilesetTraverserProps) {\n    this.options = {...DEFAULT_PROPS, ...options};\n    // TRAVERSAL\n    // temporary storage to hold the traversed tiles during a traversal\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n\n    // set in every traverse cycle\n    this._frameNumber = null;\n\n    // fulfill in traverse call\n    this.root = null;\n\n    // RESULT\n    // tiles should be rendered\n    this.selectedTiles = {};\n    // tiles should be loaded from server\n    this.requestedTiles = {};\n    // tiles does not have render content\n    this.emptyTiles = {};\n  }\n\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {...this.options, ...options};\n\n    // reset result\n    this.reset();\n\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n\n  // execute traverse\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState: FrameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let shouldRefine = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(\n          tile,\n          frameState,\n          stack,\n          tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth\n        );\n      }\n\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n\n        // replace tiles\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n\n    const newTime = new Date().getTime();\n    if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {\n      this.lastUpdate = newTime;\n      this.options.onTraversalEnd(frameState);\n    }\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {loadSiblings, skipLevelOfDetail} = this.options;\n\n    const children = tile.children;\n\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera.bind(this));\n\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines =\n      tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n\n    let hasVisibleChild = false;\n    let refines = true;\n\n    for (const child of children) {\n      child._selectionDepth = depth;\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n        refines = refines && childRefines;\n\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n    return refines;\n  }\n  /* eslint-enable complexity, max-statements */\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  // Decide if tile LoD (level of detail) is not sufficient under current viewport\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    const viewportIds: string[] = [];\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n    tile.updateVisibility(frameState, viewportIds);\n  }\n\n  // UTILITIES\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n\n    stack.push(root);\n\n    while (stack.length > 0 && allDescendantsLoaded) {\n      const tile = stack.pop();\n\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        // Load tiles that aren't visible since they are still needed for the parent to refine\n        this.loadTile(tile, frameState);\n      }\n\n      this.touchTile(tile, frameState);\n\n      // Only traverse if the tile is empty - traversal stop at descendants with content\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      if (traverse) {\n        const children = tile.children;\n        for (const child of children) {\n          // eslint-disable-next-line max-depth\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n          stack.push(child);\n        }\n      } else if (!tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n}\n\n// TODO\n// enable expiration\n// enable optimization hint\n"],"file":"tileset-traverser.js"}