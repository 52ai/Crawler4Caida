"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDracoSchema = void 0;
const schema_1 = require("@loaders.gl/schema");
const schema_2 = require("@loaders.gl/schema");
/** Extract an arrow-like schema from a Draco mesh */
function getDracoSchema(attributes, loaderData, indices) {
    const metadataMap = makeMetadata(loaderData.metadata);
    const fields = [];
    const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
    for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
        fields.push(field);
    }
    if (indices) {
        const indicesField = getArrowFieldFromAttribute('indices', indices);
        fields.push(indicesField);
    }
    return new schema_2.Schema(fields, metadataMap);
}
exports.getDracoSchema = getDracoSchema;
function transformAttributesLoaderData(loaderData) {
    const result = {};
    for (const key in loaderData) {
        const dracoAttribute = loaderData[key];
        result[dracoAttribute.name || 'undefined'] = dracoAttribute;
    }
    return result;
}
function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
    const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;
    const field = (0, schema_1.deduceMeshField)(attributeName, attribute, metadataMap);
    return field;
}
function makeMetadata(metadata) {
    const metadataMap = new Map();
    for (const key in metadata) {
        metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));
    }
    return metadataMap;
}
