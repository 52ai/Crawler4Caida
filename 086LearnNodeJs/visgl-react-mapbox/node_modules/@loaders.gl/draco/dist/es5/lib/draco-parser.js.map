{"version":3,"sources":["../../../src/lib/draco-parser.ts"],"names":["GEOMETRY_TYPE","TRIANGULAR_MESH","POINT_CLOUD","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","INDEX_ITEM_SIZE","DracoParser","draco","decoder","Decoder","metadataQuerier","MetadataQuerier","destroy","arrayBuffer","options","buffer","DecoderBuffer","Init","byteLength","_disableAttributeTransforms","geometry_type","GetEncodedGeometryType","dracoGeometry","Mesh","PointCloud","dracoStatus","DecodeBufferToMesh","DecodeBufferToPointCloud","Error","ok","ptr","message","error_msg","loaderData","_getDracoLoaderData","geometry","_getMeshData","boundingBox","attributes","schema","indices","data","loader","header","vertexCount","num_points","metadata","_getTopLevelMetadata","_getDracoAttributes","num_attributes","num_faces","dracoAttributes","attributeId","dracoAttribute","GetAttribute","_getAttributeMetadata","unique_id","attribute_type","data_type","num_components","byte_offset","byte_stride","normalized","attribute_index","quantization","_getQuantizationTransform","quantization_transform","octahedron","_getOctahedronTransform","octahedron_transform","_getMeshAttributes","positionAttribute","topology","mode","value","_getTriangleStripIndices","size","_getTriangleListIndices","Object","values","loaderAttribute","attributeName","_deduceAttributeName","name","_getAttributeValues","byteOffset","byteStride","numFaces","numIndices","_malloc","GetTrianglesUInt32Array","HEAPF32","slice","_free","dracoArray","DracoInt32Array","GetTriangleStripsFromMesh","getUint32Array","attribute","TypedArrayCtor","numComponents","numPoints","numValues","BYTES_PER_ELEMENT","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","uniqueId","entries","extraAttributes","attributeUniqueId","thisAttributeType","dracoAttributeConstant","attributeType","entryName","attributeNameEntry","string","dracoMetadata","GetMetadata","_getDracoMetadata","GetAttributeMetadata","result","numEntries","NumEntries","entryIndex","GetEntryName","_getDracoMetadataField","GetIntEntryArray","intArray","getInt32Array","int","GetIntEntry","GetStringEntry","double","GetDoubleEntry","quantizedAttributes","octahedronAttributes","skipAttributes","dracoAttributeName","SkipAttributeTransform","skip","map","type","includes","transform","AttributeQuantizationTransform","InitFromAttribute","quantization_bits","range","min_values","i","min_value","DT_FLOAT32","DT_INT8","DT_INT16","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","DT_INVALID","GetValue"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\n\nimport type {TypedArray, MeshAttribute, MeshGeometry} from '@loaders.gl/schema';\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  DracoMesh,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {getDracoSchema} from './utils/get-draco-schema';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMesh {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMesh = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshGeometry {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n"],"file":"draco-parser.js"}