{"version":3,"sources":["../../../src/helpers/binary-util-functions.ts"],"names":["classifyRings","geom","len","indices","length","type","data","areas","polygons","ringAreas","polygon","ccw","offset","endIndex","i","startIndex","shape","slice","area","before","after","concat","undefined","push","project","x0","y0","size","j","jl","y2","Math","PI","atan","exp","readFeature","tag","feature","pbf","id","readVarint","readTag","_geometry","pos","end","key","_keys","value","_values","properties"],"mappings":"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","sourcesContent":["import Protobuf from 'pbf';\nimport {getPolygonSignedArea} from '@math.gl/polygon';\nimport {FlatIndexedGeometry, FlatPolygon} from '@loaders.gl/schema';\nimport VectorTileFeature from '../lib/binary-vector-tile/vector-tile-feature';\n\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * The function also detects holes which have zero area and\n * removes them. In doing so it modifies the input\n * `geom.data` array to remove the unneeded data\n *\n * @param geometry\n * @returns object\n */\n// eslint-disable-next-line max-statements\nexport function classifyRings(geom: FlatIndexedGeometry): FlatPolygon {\n  const len = geom.indices.length;\n  const type = 'Polygon';\n\n  if (len <= 1) {\n    return {\n      type,\n      data: geom.data,\n      areas: [[getPolygonSignedArea(geom.data)]],\n      indices: [geom.indices]\n    };\n  }\n\n  const areas: any[] = [];\n  const polygons: any[] = [];\n  let ringAreas: number[] = [];\n  let polygon: number[] = [];\n  let ccw: boolean | undefined;\n  let offset = 0;\n\n  for (let endIndex: number, i = 0, startIndex: number; i < len; i++) {\n    startIndex = geom.indices[i] - offset;\n\n    endIndex = geom.indices[i + 1] - offset || geom.data.length;\n    const shape = geom.data.slice(startIndex, endIndex);\n    const area = getPolygonSignedArea(shape);\n\n    if (area === 0) {\n      // This polygon has no area, so remove it from the shape\n      // Remove the section from the data array\n      const before = geom.data.slice(0, startIndex);\n      const after = geom.data.slice(endIndex);\n      geom.data = before.concat(after);\n\n      // Need to offset any remaining indices as we have\n      // modified the data buffer\n      offset += endIndex - startIndex;\n\n      // Do not add this index to the output and process next shape\n      continue; // eslint-disable-line no-continue\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon.length) {\n        areas.push(ringAreas);\n        polygons.push(polygon);\n      }\n      polygon = [startIndex];\n      ringAreas = [area];\n    } else {\n      ringAreas.push(area);\n      polygon.push(startIndex);\n    }\n  }\n  if (ringAreas) areas.push(ringAreas);\n  if (polygon.length) polygons.push(polygon);\n\n  return {type, areas, indices: polygons, data: geom.data};\n}\n\n/**\n *\n * @param data\n * @param x0\n * @param y0\n * @param size\n */\nexport function project(data: number[], x0: number, y0: number, size: number): void {\n  for (let j = 0, jl = data.length; j < jl; j += 2) {\n    data[j] = ((data[j] + x0) * 360) / size - 180;\n    const y2 = 180 - ((data[j + 1] + y0) * 360) / size;\n    data[j + 1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n  }\n}\n\n/**\n * All code below is unchanged from the original Mapbox implemenation\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nexport function readFeature(tag: number, feature?: VectorTileFeature, pbf?: Protobuf): void {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();\n    else if (tag === 2) readTag(pbf, feature);\n    else if (tag === 3) feature.type = pbf.readVarint();\n    else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\n\n/**\n * @param pbf\n * @param feature\n */\nexport function readTag(pbf: Protobuf, feature: VectorTileFeature): void {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n    const value = feature._values[pbf.readVarint()];\n    feature.properties[key] = value;\n  }\n}\n"],"file":"binary-util-functions.js"}